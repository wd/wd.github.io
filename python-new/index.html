<!doctype html><html lang=en><head><meta http-equiv=X-Clacks-Overhead content="GNU Terry Pratchett"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=https://wdicc.com/favicon.ico><title>Python __new__ | wd and cc</title><meta name=title content="Python __new__"><meta name=description content="翻译一点 https://www.python.org/download/releases/2.2/descrintro/#__new__ 有些感觉还是挺生硬的，方便自己理解吧。
__new__ 的一些规则:

__new__ 是一个静态方法。定义它的时候并不需要执行 __new__ = staticmethod(__new__)，因为它的名字就包含了这个含义（这个对于类构造方法来说是个特殊的函数）
__new__ 的第一个参数，必须是一个类，其余的参数是留给构造方法的。
覆盖了基类的 __new__ 方法的类有可能会调用基类的 __new__ 方法。传递给基类的 __new__ 方法的第一个参数，应该是覆盖基类的 __new__ 方法的类，而不是基类，如果传递了基类，你得到的将是基类的示例。
除非你想要按照后面两条描述的方法来使用，否则 __new__ 方法必须要调用基类的 __new__ 方法，这个是创建你的对象的实例的唯一方法。子类的 __new__ 方法可以从两个方面影响产生的实例：传递不同的参数给基类的 __new__，以及修改基类产生的对象（例如初始化一些实例变量）
__new__ 方法必须返回一个对象。并不一定必须返回一个新的对象，虽然通常都那么做。如果你返回一个已经存在的对象，依然会有对于 __init__ 构造函数的调用。如果你返回一个其他函数的对象，那个对象的 __init__ 也会被调用。如果忘记返回，python 会给你返回 None，你程序的调用方也许会觉得很奇怪。
对于不可变对象，__new__ 可以返回一个之前缓存的对象。对于一些比较小的 int, str, tuple 类型就是这么做的。这也是为什么他们的 __init__ 什么都没做：否则之前缓存的对象会被 init 很多次。（另外一个原因是本身页没有东西可以给 __init__ 初始化的了，__new__ 返回的就是一个已经初始化的对象）。
如果你想要给一个内置的不可变类型增加一些可变的状态（例如给 string 类型增加一个默认的转换方法），最好是在 __init__ 方法里面初始化可变状态，而不要在 __new__ 里面。
如果你想要修改构造方法的签名，一般需要覆盖 __new__ 和 __init__ 方法来接受心的签名。然而，大部分内置类型都会忽视自己不用的参数，尤其是不可变类型（int，long，float，complex，str，unicode，tuple）都有一个假的 __init__，而可变类型（dict，list，file，super，classmethod，staticmethd，property）有一个假的 __new__。内置类型 object 有假的 __init__ 和 __new__ （给其他对象继承）。内置类型 type 在很多方面都很特别，请参考 metaclasses。
（这条和 __new__ 没关系，但是页应该了解一下）如果新建一个 type 的子类，实例会自动给 __dict__ 和 __weakrefs__ 预留空间（ __dict__ 在你使用前不会初始化，所以你不需要担心创建的所有实例被一个空的字典所占用的空间）。如果不需要这个多余的空间，可以给你的类设置 __slots__ = []（更多信息可以参考 __slots__。
Factoid: __new__ 是一个静态方法，不是类方法。我开始的时候觉得他应该是一个类方法，and that&rsquo;s why I added the classmethod primitive。不幸的是，对于一个类方法，在这种情况下面 upcalls 不工作，所以我只好把他设计成一个第一个参数是一个 class 的静态方法。讽刺的是，there are now no known uses for class methods in the Python distribution (other than in the test suite). I might even get rid of classmethod in a future release if no good use for it can be found!
"><meta name=keywords content="python,"><meta property="og:url" content="https://wdicc.com/python-new/"><meta property="og:site_name" content="wd and cc"><meta property="og:title" content="Python __new__"><meta property="og:description" content="翻译一点 https://www.python.org/download/releases/2.2/descrintro/#__new__ 有些感觉还是挺生硬的，方便自己理解吧。
__new__ 的一些规则:
__new__ 是一个静态方法。定义它的时候并不需要执行 __new__ = staticmethod(__new__)，因为它的名字就包含了这个含义（这个对于类构造方法来说是个特殊的函数） __new__ 的第一个参数，必须是一个类，其余的参数是留给构造方法的。 覆盖了基类的 __new__ 方法的类有可能会调用基类的 __new__ 方法。传递给基类的 __new__ 方法的第一个参数，应该是覆盖基类的 __new__ 方法的类，而不是基类，如果传递了基类，你得到的将是基类的示例。 除非你想要按照后面两条描述的方法来使用，否则 __new__ 方法必须要调用基类的 __new__ 方法，这个是创建你的对象的实例的唯一方法。子类的 __new__ 方法可以从两个方面影响产生的实例：传递不同的参数给基类的 __new__，以及修改基类产生的对象（例如初始化一些实例变量） __new__ 方法必须返回一个对象。并不一定必须返回一个新的对象，虽然通常都那么做。如果你返回一个已经存在的对象，依然会有对于 __init__ 构造函数的调用。如果你返回一个其他函数的对象，那个对象的 __init__ 也会被调用。如果忘记返回，python 会给你返回 None，你程序的调用方也许会觉得很奇怪。 对于不可变对象，__new__ 可以返回一个之前缓存的对象。对于一些比较小的 int, str, tuple 类型就是这么做的。这也是为什么他们的 __init__ 什么都没做：否则之前缓存的对象会被 init 很多次。（另外一个原因是本身页没有东西可以给 __init__ 初始化的了，__new__ 返回的就是一个已经初始化的对象）。 如果你想要给一个内置的不可变类型增加一些可变的状态（例如给 string 类型增加一个默认的转换方法），最好是在 __init__ 方法里面初始化可变状态，而不要在 __new__ 里面。 如果你想要修改构造方法的签名，一般需要覆盖 __new__ 和 __init__ 方法来接受心的签名。然而，大部分内置类型都会忽视自己不用的参数，尤其是不可变类型（int，long，float，complex，str，unicode，tuple）都有一个假的 __init__，而可变类型（dict，list，file，super，classmethod，staticmethd，property）有一个假的 __new__。内置类型 object 有假的 __init__ 和 __new__ （给其他对象继承）。内置类型 type 在很多方面都很特别，请参考 metaclasses。 （这条和 __new__ 没关系，但是页应该了解一下）如果新建一个 type 的子类，实例会自动给 __dict__ 和 __weakrefs__ 预留空间（ __dict__ 在你使用前不会初始化，所以你不需要担心创建的所有实例被一个空的字典所占用的空间）。如果不需要这个多余的空间，可以给你的类设置 __slots__ = []（更多信息可以参考 __slots__。 Factoid: __new__ 是一个静态方法，不是类方法。我开始的时候觉得他应该是一个类方法，and that’s why I added the classmethod primitive。不幸的是，对于一个类方法，在这种情况下面 upcalls 不工作，所以我只好把他设计成一个第一个参数是一个 class 的静态方法。讽刺的是，there are now no known uses for class methods in the Python distribution (other than in the test suite). I might even get rid of classmethod in a future release if no good use for it can be found!"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-01-16T15:47:59+08:00"><meta property="article:modified_time" content="2017-01-16T15:47:59+08:00"><meta property="article:tag" content="Python"><meta name=twitter:card content="summary"><meta name=twitter:title content="Python __new__"><meta name=twitter:description content="翻译一点 https://www.python.org/download/releases/2.2/descrintro/#__new__ 有些感觉还是挺生硬的，方便自己理解吧。
__new__ 的一些规则:
__new__ 是一个静态方法。定义它的时候并不需要执行 __new__ = staticmethod(__new__)，因为它的名字就包含了这个含义（这个对于类构造方法来说是个特殊的函数） __new__ 的第一个参数，必须是一个类，其余的参数是留给构造方法的。 覆盖了基类的 __new__ 方法的类有可能会调用基类的 __new__ 方法。传递给基类的 __new__ 方法的第一个参数，应该是覆盖基类的 __new__ 方法的类，而不是基类，如果传递了基类，你得到的将是基类的示例。 除非你想要按照后面两条描述的方法来使用，否则 __new__ 方法必须要调用基类的 __new__ 方法，这个是创建你的对象的实例的唯一方法。子类的 __new__ 方法可以从两个方面影响产生的实例：传递不同的参数给基类的 __new__，以及修改基类产生的对象（例如初始化一些实例变量） __new__ 方法必须返回一个对象。并不一定必须返回一个新的对象，虽然通常都那么做。如果你返回一个已经存在的对象，依然会有对于 __init__ 构造函数的调用。如果你返回一个其他函数的对象，那个对象的 __init__ 也会被调用。如果忘记返回，python 会给你返回 None，你程序的调用方也许会觉得很奇怪。 对于不可变对象，__new__ 可以返回一个之前缓存的对象。对于一些比较小的 int, str, tuple 类型就是这么做的。这也是为什么他们的 __init__ 什么都没做：否则之前缓存的对象会被 init 很多次。（另外一个原因是本身页没有东西可以给 __init__ 初始化的了，__new__ 返回的就是一个已经初始化的对象）。 如果你想要给一个内置的不可变类型增加一些可变的状态（例如给 string 类型增加一个默认的转换方法），最好是在 __init__ 方法里面初始化可变状态，而不要在 __new__ 里面。 如果你想要修改构造方法的签名，一般需要覆盖 __new__ 和 __init__ 方法来接受心的签名。然而，大部分内置类型都会忽视自己不用的参数，尤其是不可变类型（int，long，float，complex，str，unicode，tuple）都有一个假的 __init__，而可变类型（dict，list，file，super，classmethod，staticmethd，property）有一个假的 __new__。内置类型 object 有假的 __init__ 和 __new__ （给其他对象继承）。内置类型 type 在很多方面都很特别，请参考 metaclasses。 （这条和 __new__ 没关系，但是页应该了解一下）如果新建一个 type 的子类，实例会自动给 __dict__ 和 __weakrefs__ 预留空间（ __dict__ 在你使用前不会初始化，所以你不需要担心创建的所有实例被一个空的字典所占用的空间）。如果不需要这个多余的空间，可以给你的类设置 __slots__ = []（更多信息可以参考 __slots__。 Factoid: __new__ 是一个静态方法，不是类方法。我开始的时候觉得他应该是一个类方法，and that’s why I added the classmethod primitive。不幸的是，对于一个类方法，在这种情况下面 upcalls 不工作，所以我只好把他设计成一个第一个参数是一个 class 的静态方法。讽刺的是，there are now no known uses for class methods in the Python distribution (other than in the test suite). I might even get rid of classmethod in a future release if no good use for it can be found!"><meta itemprop=name content="Python __new__"><meta itemprop=description content="翻译一点 https://www.python.org/download/releases/2.2/descrintro/#__new__ 有些感觉还是挺生硬的，方便自己理解吧。
__new__ 的一些规则:
__new__ 是一个静态方法。定义它的时候并不需要执行 __new__ = staticmethod(__new__)，因为它的名字就包含了这个含义（这个对于类构造方法来说是个特殊的函数） __new__ 的第一个参数，必须是一个类，其余的参数是留给构造方法的。 覆盖了基类的 __new__ 方法的类有可能会调用基类的 __new__ 方法。传递给基类的 __new__ 方法的第一个参数，应该是覆盖基类的 __new__ 方法的类，而不是基类，如果传递了基类，你得到的将是基类的示例。 除非你想要按照后面两条描述的方法来使用，否则 __new__ 方法必须要调用基类的 __new__ 方法，这个是创建你的对象的实例的唯一方法。子类的 __new__ 方法可以从两个方面影响产生的实例：传递不同的参数给基类的 __new__，以及修改基类产生的对象（例如初始化一些实例变量） __new__ 方法必须返回一个对象。并不一定必须返回一个新的对象，虽然通常都那么做。如果你返回一个已经存在的对象，依然会有对于 __init__ 构造函数的调用。如果你返回一个其他函数的对象，那个对象的 __init__ 也会被调用。如果忘记返回，python 会给你返回 None，你程序的调用方也许会觉得很奇怪。 对于不可变对象，__new__ 可以返回一个之前缓存的对象。对于一些比较小的 int, str, tuple 类型就是这么做的。这也是为什么他们的 __init__ 什么都没做：否则之前缓存的对象会被 init 很多次。（另外一个原因是本身页没有东西可以给 __init__ 初始化的了，__new__ 返回的就是一个已经初始化的对象）。 如果你想要给一个内置的不可变类型增加一些可变的状态（例如给 string 类型增加一个默认的转换方法），最好是在 __init__ 方法里面初始化可变状态，而不要在 __new__ 里面。 如果你想要修改构造方法的签名，一般需要覆盖 __new__ 和 __init__ 方法来接受心的签名。然而，大部分内置类型都会忽视自己不用的参数，尤其是不可变类型（int，long，float，complex，str，unicode，tuple）都有一个假的 __init__，而可变类型（dict，list，file，super，classmethod，staticmethd，property）有一个假的 __new__。内置类型 object 有假的 __init__ 和 __new__ （给其他对象继承）。内置类型 type 在很多方面都很特别，请参考 metaclasses。 （这条和 __new__ 没关系，但是页应该了解一下）如果新建一个 type 的子类，实例会自动给 __dict__ 和 __weakrefs__ 预留空间（ __dict__ 在你使用前不会初始化，所以你不需要担心创建的所有实例被一个空的字典所占用的空间）。如果不需要这个多余的空间，可以给你的类设置 __slots__ = []（更多信息可以参考 __slots__。 Factoid: __new__ 是一个静态方法，不是类方法。我开始的时候觉得他应该是一个类方法，and that’s why I added the classmethod primitive。不幸的是，对于一个类方法，在这种情况下面 upcalls 不工作，所以我只好把他设计成一个第一个参数是一个 class 的静态方法。讽刺的是，there are now no known uses for class methods in the Python distribution (other than in the test suite). I might even get rid of classmethod in a future release if no good use for it can be found!"><meta itemprop=datePublished content="2017-01-16T15:47:59+08:00"><meta itemprop=dateModified content="2017-01-16T15:47:59+08:00"><meta itemprop=wordCount content="1198"><meta itemprop=keywords content="Python"><meta name=referrer content="no-referrer-when-downgrade"><style>:root{--width:720px;--font-main:Verdana, sans-serif;--font-secondary:Verdana, sans-serif;--font-scale:1em;--background-color:#fff;--heading-color:#222;--text-color:#444;--link-color:#3273dc;--visited-color:#8b6fcb;--code-background-color:#f2f2f2;--code-color:#222;--blockquote-color:#222}@media(prefers-color-scheme:dark){:root{--background-color:#01242e;--heading-color:#eee;--text-color:#ddd;--link-color:#8cc2dd;--visited-color:#8b6fcb;--code-background-color:#000;--code-color:#ddd;--blockquote-color:#ccc}}body{font-family:var(--font-secondary);font-size:var(--font-scale);margin:auto;padding:20px;max-width:var(--width);text-align:left;background-color:var(--background-color);word-wrap:break-word;overflow-wrap:break-word;line-height:1.5;color:var(--text-color)}h1,h2,h3,h4,h5,h6{font-family:var(--font-main);color:var(--heading-color)}a{color:var(--link-color);cursor:pointer;text-decoration:none}a:hover{text-decoration:underline}nav a{margin-right:8px}strong,b{color:var(--heading-color)}button{margin:0;cursor:pointer}time{font-family:monospace;font-style:normal;font-size:15px}main{line-height:1.6}table{width:100%}hr{border:0;border-top:1px dashed}img{max-width:100%}code{font-family:monospace;padding:2px;background-color:var(--code-background-color);color:var(--code-color);border-radius:3px}blockquote{border-left:1px solid #999;color:var(--code-color);padding-left:20px;font-style:italic}footer{padding:25px 0;text-align:center}.title:hover{text-decoration:none}.title h1{font-size:1.5em}.inline{width:auto !important}.highlight,.code{padding:1px 15px;background-color:var(--code-background-color);color:var(--code-color);border-radius:3px;margin-block-start:1em;margin-block-end:1em;overflow-x:auto}ul.blog-posts{list-style-type:none;padding:unset}ul.blog-posts li{display:flex}ul.blog-posts li span{flex:0 0 130px}ul.blog-posts li a:visited{color:var(--visited-color)}</style></head><body><header><a href=/ class=title><h2>wd and cc</h2></a><p>-- Good good study, day day up!</p><nav><a href=/>Home</a>
<a href=/posts/>Posts</a>
<a href="https://www.google.com.hk/search?sitesearch=https%3A%2F%2Fwdicc.com%2F&amp;q=">Search</a>
<a href=/tags/>Tags</a>
<a href=/atom.xml>subscribe</a></nav></header><main><h1>Python __new__</h1><p><i><time datetime=2017-01-16>16 Jan, 2017
</time></i><a href=https://wdicc.com/tags/python/>#Python</a></p><content><p>翻译一点 <a href=https://www.python.org/download/releases/2.2/descrintro/#__new>https://www.python.org/download/releases/2.2/descrintro/#__new</a>__ 有些感觉还是挺生硬的，方便自己理解吧。</p><p><code>__new__</code> 的一些规则:</p><ul><li><code>__new__</code> 是一个静态方法。定义它的时候并不需要执行 <code>__new__ = staticmethod(__new__)</code>，因为它的名字就包含了这个含义（这个对于类构造方法来说是个特殊的函数）</li><li><code>__new__</code> 的第一个参数，必须是一个类，其余的参数是留给构造方法的。</li><li>覆盖了基类的 <code>__new__</code> 方法的类有可能会调用基类的 <code>__new__</code> 方法。传递给基类的 <code>__new__</code> 方法的第一个参数，应该是覆盖基类的 <code>__new__</code> 方法的类，而不是基类，如果传递了基类，你得到的将是基类的示例。</li><li>除非你想要按照后面两条描述的方法来使用，否则 <code>__new__</code> 方法必须要调用基类的 <code>__new__</code> 方法，这个是创建你的对象的实例的唯一方法。子类的 <code>__new__</code> 方法可以从两个方面影响产生的实例：传递不同的参数给基类的 <code>__new__</code>，以及修改基类产生的对象（例如初始化一些实例变量）</li><li><code>__new__</code> 方法必须返回一个对象。并不一定必须返回一个新的对象，虽然通常都那么做。如果你返回一个已经存在的对象，依然会有对于 <code>__init__</code> 构造函数的调用。如果你返回一个其他函数的对象，那个对象的 <code>__init__</code> 也会被调用。如果忘记返回，python 会给你返回 None，你程序的调用方也许会觉得很奇怪。</li><li>对于不可变对象，<code>__new__</code> 可以返回一个之前缓存的对象。对于一些比较小的 int, str, tuple 类型就是这么做的。这也是为什么他们的 <code>__init__</code> 什么都没做：否则之前缓存的对象会被 init 很多次。（另外一个原因是本身页没有东西可以给 <code>__init__</code> 初始化的了，<code>__new__</code> 返回的就是一个已经初始化的对象）。</li><li>如果你想要给一个内置的不可变类型增加一些可变的状态（例如给 string 类型增加一个默认的转换方法），最好是在 <code>__init__</code> 方法里面初始化可变状态，而不要在 <code>__new__</code> 里面。</li><li>如果你想要修改构造方法的签名，一般需要覆盖 <code>__new__</code> 和 <code>__init__</code> 方法来接受心的签名。然而，大部分内置类型都会忽视自己不用的参数，尤其是不可变类型（int，long，float，complex，str，unicode，tuple）都有一个假的 <code>__init__</code>，而可变类型（dict，list，file，super，classmethod，staticmethd，property）有一个假的 <code>__new__</code>。内置类型 <code>object</code> 有假的 <code>__init__</code> 和 <code>__new__</code> （给其他对象继承）。内置类型 <code>type</code> 在很多方面都很特别，请参考 metaclasses。</li><li>（这条和 <code>__new__</code> 没关系，但是页应该了解一下）如果新建一个 <code>type</code> 的子类，实例会自动给 <code>__dict__</code> 和 <code>__weakrefs__</code> 预留空间（ <code>__dict__</code> 在你使用前不会初始化，所以你不需要担心创建的所有实例被一个空的字典所占用的空间）。如果不需要这个多余的空间，可以给你的类设置 <code>__slots__ = []</code>（更多信息可以参考 <code>__slots__</code>。</li><li>Factoid: <code>__new__</code> 是一个静态方法，不是类方法。我开始的时候觉得他应该是一个类方法，and that&rsquo;s why I added the classmethod primitive。不幸的是，对于一个类方法，在这种情况下面 upcalls 不工作，所以我只好把他设计成一个第一个参数是一个 class 的静态方法。讽刺的是，there are now no known uses for class methods in the Python distribution (other than in the test suite). I might even get rid of classmethod in a future release if no good use for it can be found!</li></ul></content></main><footer>Made with <a href=https://github.com/janraasch/hugo-bearblog/>Hugo ʕ•ᴥ•ʔ Bear</a></footer></body></html>