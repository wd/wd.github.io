<!DOCTYPE HTML>
<html>
<head>
	<meta name="generator" content="Hugo 0.19" />
	<meta charset="utf-8">
    
    
    <title>wd and cc</title>
    <meta name="author" content="wd">
    <meta name="description" content="">
    <meta name="keywords" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <link href="https://wdicc.com/index.xml" rel="alternate" title="wd and cc" type="application/atom+xml">
	<link href="/favicon.ico" rel="shortcut icon">
    <link href="/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
    <link href="/css/custom.css" media="screen, projection" rel="stylesheet" type="text/css">

    <link href='//fonts.googleapis.com/css?family=Slackey' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Fjalla+One' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Amethysta' rel='stylesheet' type='text/css'>
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
    

    <script type="text/javascript" src="/js/jquery-tapir.js"></script>

    

    <link rel="stylesheet" href="/css/hljs.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
</head>


<body>
    <div id="wrapper">
        <header id="header" class="inner">
<h1 class="animated bounceInDown">
    <div id="headerbg">
        wd and cc
    </div>
</h1>

<span class="subtitle">happy every day</span>
<br>

<ul id="social-links" style="text-align:center; clear:both;">
    
    
    <li>
    <a href="https://github.com/wd" class="github" title="Github"></a>
    </li>
    
    
    
    
    
    <li>
    <a href="http://www.twitter.com/wd" class="twitter" title="Twitter"></a>
    </li>
    
    
    
    
    
</ul>


<ul id="nav">
	<li id="ajax"><a href="/index.html">Home</a></li>
	<li id="ajax"><a href="/archives/index.html">Archives</a></li>
	<li id="ajax"><a href="/tags/index.html">Tags</a></li>
    <li><a href="/atom.xml">RSS</a></li>
    <li>
    <div id="dark">
        <form action="//www.google.com.hk/search" method="get" accept-charset="UTF-8" id="search">
            <input type="hidden" name="sitesearch" value="https://wdicc.com/" />
            <input type="text" name="q" results="0" placeholder="Search..." x-webkit-speech />
        </form>
    </div>
    </li>
</ul>

</header>

<div id="toload">

    <div id="content" class="inner">
        




    
    <script id="dsq-count-scr" src="//wdicc.disqus.com/count.js" async></script>
    




  <article class="post">
    <h2 class="title"> 
        <a href="/postgresql-explain/">PostgreSQL Explain</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2013-02-03T17:40:00.000&#43;08:00' itemprop="datePublished">2013-02-03</time>
</div>
        <div class="tags">Tags: 
</div>
    </div>
        <div id="table-of-contents"><br />
<h2>Table of Contents</h2><br />
<div id="text-table-of-contents"><br />
<ul><br />
<li><a href="#sec-1">1 notice</a></li><br />
<li><a href="#sec-2">2 explain basics</a></li><br />
<li><a href="#sec-3">3 explain analyse</a></li><br />
<li><a href="#sec-4">4 Caveats 注意事项</a></li><br />
</ul><br />
</div><br />
</div><br />

<div id="outline-container-1" class="outline-3"><br />
<h3 id="sec-1"><span class="section-number-3">1</span> notice</h3><br />
<div class="outline-text-3" id="text-1"><br />


<p><br />
简单翻译了一下 <a href="http://www.postgresql.org/docs/9.2/static/using-explain.html">http://www.postgresql.org/docs/9.2/static/using-explain.html</a> ，里面有些内容没翻译。<br />
</p><br />
</div><br />

</div><br />

<div id="outline-container-2" class="outline-3"><br />
<h3 id="sec-2"><span class="section-number-3">2</span> explain basics</h3><br />
<div class="outline-text-3" id="text-2"><br />





<pre class="example">EXPLAIN SELECT * FROM tenk1;

                         QUERY PLAN
-------------------------------------------------------------
 Seq Scan on tenk1  (cost=0.00..458.00 rows=10000 width=244)
</pre><br />


<ul><br />
<li>第一行输出需要的消耗。<br />
</li><br />
<li>最后一行输出需要的消耗。<br />
</li><br />
<li>返回的行数，假定全部返回。并非扫描处理的行数。<br />
</li><br />
<li>每行的平均数据量，字节<br />
</li><br />
</ul><br />


<p><br />
消耗是使用设置的规划器的一些 cost常量<sup><a class="footref" name="fnr.1" href="#fn.1">1</a></sup> 来计算出来的，上一级的 node 的 消耗包括了所有子 node 的消耗，消耗不包括传输结果花的时间。<br />
</p><br />



<pre class="example">SELECT relpages, reltuples FROM pg_class WHERE relname = 'tenk1';
</pre><br />


<p><br />
从上面这个语句可以看到，tenk1 有 358 磁盘页和 10000 行。这个查询的消耗计算公式如下<br />
</p><br />
<pre class="example">
 (disk pages read * seq_page_cost) + (rows scanned * cpu_tuple_cost)
</pre><br />


<p><br />
默认情况下 <code>seq_page_cost = 1.0, cpu_tuple_cost = 0.01</code>, 所以最总消耗是 <code>(358 * 1.0) + (10000 * 0.01) = 458</code> 。<br />
</p><br />



<pre class="example">EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 7000;

                         QUERY PLAN
------------------------------------------------------------
 Seq Scan on tenk1  (cost=0.00..483.00 rows=7001 width=244)
   Filter: (unique1 &lt; 7000)
</pre><br />


<p><br />
再看这个，加了一个 where 条件，多了一个 filter 操作，返回结果变少，但是消耗变多了。因为总体需要处理的数据没有变少，并且还多了<br />
</p><br />
<pre class="example">
 10000 * cpu_operator_cost
</pre><br />


<p><br />
需要的消耗。<br />
</p><br />
<p><br />
这些计算方法得到的数值可能和你系统的会稍有区别，使用 analyse 命令可能会改变计算结果，因为它会根据一些随机的样本重新收集表的状态信息。<br />
</p><br />



<pre class="example">EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 100;

                                  QUERY PLAN
------------------------------------------------------------------------------
 Bitmap Heap Scan on tenk1  (cost=5.03..229.17 rows=101 width=244)
   Recheck Cond: (unique1 &lt; 100)
   -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..5.01 rows=101 width=0)
         Index Cond: (unique1 &lt; 100)
</pre><br />


<p><br />
再来看一个。子执行计划节点会先扫描索引，上一级的执行计划节点会根据索引返回的位置来获取数据。获取散列数据比获取全部数据消耗要大，不过因为毕竟是少量数据，可以看到消耗还是小于全表扫描。上级的节点会在获取散列数据之前做一个磁盘排序，好减少获取的消耗，而 Bitmap 字样表示索引返回的结果是按照存储位置排好序的，这就是使用索引的一个原因。<br />
</p><br />



<pre class="example">EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 100 AND stringu1 = 'xxx';

                                  QUERY PLAN
------------------------------------------------------------------------------
 Bitmap Heap Scan on tenk1  (cost=5.01..229.40 rows=1 width=244)
   Recheck Cond: (unique1 &lt; 100)
   Filter: (stringu1 = 'xxx'::name)
   -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..5.01 rows=101 width=0)
         Index Cond: (unique1 &lt; 100)
</pre><br />


<p><br />
stringu1 = 'xxx' 减少了输出的行数，因为还需要扫描同样的行数，所以没有减少执行计划的消耗，而且还有稍微的增加，<br />
</p><br />



<pre class="example">EXPLAIN SELECT * FROM tenk1 WHERE unique1 = 42;

                                 QUERY PLAN
-----------------------------------------------------------------------------
 Index Scan using tenk1_unique1 on tenk1  (cost=0.00..8.27 rows=1 width=244)
   Index Cond: (unique1 = 42)
</pre><br />


<p><br />
数据根据索引排序来获取，不需要额外的排序。<br />
</p><br />



<pre class="example">EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 100 AND unique2 &gt; 9000;

                                     QUERY PLAN
-------------------------------------------------------------------------------------
 Bitmap Heap Scan on tenk1  (cost=25.01..60.14 rows=10 width=244)
   Recheck Cond: ((unique1 &lt; 100) AND (unique2 &gt; 9000))
   -&gt;  BitmapAnd  (cost=25.01..25.01 rows=10 width=0)
         -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..5.01 rows=101 width=0)
               Index Cond: (unique1 &lt; 100)
         -&gt;  Bitmap Index Scan on tenk1_unique2  (cost=0.00..19.74 rows=999 width=0)
               Index Cond: (unique2 &gt; 9000)

EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 100 AND unique2 &gt; 9000 LIMIT 2;

                                     QUERY PLAN
-------------------------------------------------------------------------------------
 Limit  (cost=0.00..14.25 rows=2 width=244)
   -&gt;  Index Scan using tenk1_unique2 on tenk1  (cost=0.00..71.23 rows=10 width=244)
         Index Cond: (unique2 &gt; 9000)
         Filter: (unique1 &lt; 100)
</pre><br />


<p><br />
这两个查询，第一个分别查两个索引，然后做 BitmapAnd 得到结果。第二个只查了其中一个索引，然后使用 filter 方式来做过滤，可以看到第二个查询里面的消耗 71.23 表示的是返回所有数据需要的消耗，Limit 节点在得到需要的结果厚，会终止执行，所以最终没有返回那么多，最终消耗小一点，比第一个查询小。<br />
</p><br />




<pre class="example">EXPLAIN SELECT *
FROM tenk1 t1, tenk2 t2
WHERE t1.unique1 &lt; 10 AND t1.unique2 = t2.unique2;

                                      QUERY PLAN
--------------------------------------------------------------------------------------
 Nested Loop  (cost=4.33..118.25 rows=10 width=488)
   -&gt;  Bitmap Heap Scan on tenk1 t1  (cost=4.33..39.44 rows=10 width=244)
         Recheck Cond: (unique1 &lt; 10)
         -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..4.33 rows=10 width=0)
               Index Cond: (unique1 &lt; 10)
   -&gt;  Index Scan using tenk2_unique2 on tenk2 t2  (cost=0.00..7.87 rows=1 width=244)
         Index Cond: (unique2 = t1.unique2)
</pre><br />


<p><br />
这个是两表 join，最后通过嵌套循环节点来做的 join。先查询外层 <code>Bitmap heap scan</code> 这个节点，这个节点还有个子节点。这个节点的查询和 <code>select ... where unique1 &lt; 10</code> 的查询类似。然后执行内层 <code>Index scan using</code> 这个节点，外层查询获取到的数据会插入进来，这个时候 t1.unique2 的值已经有了，所以这层的查询和 <code>select ... where t2.unique2 = 常量</code> 的查询类似，消耗比前面的小是因为第一次查询有了 cache，这次就会稍微快了一点。这层查询的消耗是 <code>外层行数*内层的消耗=10 * 7.87</code> 加上一些 cpu 消耗。<br />
</p><br />



<pre class="example">EXPLAIN SELECT *
FROM tenk1 t1, tenk2 t2
WHERE t1.unique1 &lt; 10 AND t1.unique2 = t2.unique2 AND t1.hundred &lt; t2.hundred;

                                      QUERY PLAN
--------------------------------------------------------------------------------------
 Nested Loop  (cost=4.33..118.28 rows=3 width=488)
   Join Filter: (t1.hundred &lt; t2.hundred)
   -&gt;  Bitmap Heap Scan on tenk1 t1  (cost=4.33..39.44 rows=10 width=244)
         Recheck Cond: (unique1 &lt; 10)
         -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..4.33 rows=10 width=0)
               Index Cond: (unique1 &lt; 10)
   -&gt;  Index Scan using tenk2_unique2 on tenk2 t2  (cost=0.00..7.87 rows=1 width=244)
         Index Cond: (unique2 = t1.unique2)
</pre><br />


<p><br />
如果有条件无法在两个子节点上面执行，那就只能在 join 节点来做 filter，类似上面这个。实际执行时间和前面那个没有 t1.hundred &lt; t2.hundred 条件的差不多。<br />
</p><br />
<p><br />
outer join 的时候，还可能会有 Join Filter 和 Filter 同时出现的情况，join filter 出现在外表的 on 语句里面，不匹配的数据依然会返回 null。而 filter 这个时候是用来过滤 join 结果的。<br />
</p><br />
<p><br />
对于 inner join，Join Filter 和 Filter 两个没有区别。<br />
</p><br />



<pre class="example">EXPLAIN SELECT *
FROM tenk1 t1, tenk2 t2
WHERE t1.unique1 &lt; 100 AND t1.unique2 = t2.unique2;

                                        QUERY PLAN
------------------------------------------------------------------------------------------
 Hash Join  (cost=230.43..713.94 rows=101 width=488)
   Hash Cond: (t2.unique2 = t1.unique2)
   -&gt;  Seq Scan on tenk2 t2  (cost=0.00..445.00 rows=10000 width=244)
   -&gt;  Hash  (cost=229.17..229.17 rows=101 width=244)
         -&gt;  Bitmap Heap Scan on tenk1 t1  (cost=5.03..229.17 rows=101 width=244)
               Recheck Cond: (unique1 &lt; 100)
               -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..5.01 rows=101 width=0)
                     Index Cond: (unique1 &lt; 100)
</pre><br />


<p><br />
改变一些条件，会看到执行计划变了，选择了 hash join。一个表的结果会在内层里面记录一个 hash 表，查另一个表的时候会查这个 hash 表来查看匹配的数据。<br />
</p><br />



<pre class="example">EXPLAIN SELECT *
FROM tenk1 t1, onek t2
WHERE t1.unique1 &lt; 100 AND t1.unique2 = t2.unique2;

                                        QUERY PLAN
------------------------------------------------------------------------------------------
 Merge Join  (cost=197.83..267.93 rows=10 width=488)
   Merge Cond: (t1.unique2 = t2.unique2)
   -&gt;  Index Scan using tenk1_unique2 on tenk1 t1  (cost=0.00..656.25 rows=101 width=244)
         Filter: (unique1 &lt; 100)
   -&gt;  Sort  (cost=197.83..200.33 rows=1000 width=244)
         Sort Key: t2.unique2
         -&gt;  Seq Scan on onek t2  (cost=0.00..148.00 rows=1000 width=244)
</pre><br />


<p><br />
这是一个 merge jion 操作。merge join 需要输入的表都按照 join 字段先进行排序。从 t1 直接通过索引进行了查询，得到的结果就是顺序的。因为 t2 需要返回的数据量大，从 t2 做了全表扫描，然后进行了排序。通常全表扫描+排序比走索引消耗小。<br />
</p><br />
<p><br />
出同样的结果有很多路可以走，如果想看看其他执行计划是否更实惠，可以通过打开关闭一些标志<sup><a class="footref" name="fnr.2" href="#fn.2">2</a></sup>来做到。<br />
</p><br />



<pre class="example">SET enable_sort = off;

EXPLAIN SELECT *
FROM tenk1 t1, onek t2
WHERE t1.unique1 &lt; 100 AND t1.unique2 = t2.unique2;

                                        QUERY PLAN
------------------------------------------------------------------------------------------
 Merge Join  (cost=0.00..292.36 rows=10 width=488)
   Merge Cond: (t1.unique2 = t2.unique2)
   -&gt;  Index Scan using tenk1_unique2 on tenk1 t1  (cost=0.00..656.25 rows=101 width=244)
         Filter: (unique1 &lt; 100)
   -&gt;  Index Scan using onek_unique2 on onek t2  (cost=0.00..224.76 rows=1000 width=244)
</pre><br />


<p><br />
可以看到走索引比全表扫描消耗更大。<br />
</p><br />

</div><br />

</div><br />

<div id="outline-container-3" class="outline-3"><br />
<h3 id="sec-3"><span class="section-number-3">3</span> explain analyse</h3><br />
<div class="outline-text-3" id="text-3"><br />


<p><br />
explain 的 analyse 选项可以看看规划器执行 sql 所用的真实时间。<br />
</p><br />



<pre class="example">EXPLAIN ANALYZE SELECT *
FROM tenk1 t1, tenk2 t2
WHERE t1.unique1 &lt; 10 AND t1.unique2 = t2.unique2;

                                                           QUERY PLAN
---------------------------------------------------------------------------------------------------------------------------------
 Nested Loop  (cost=4.33..118.25 rows=10 width=488) (actual time=0.370..1.126 rows=10 loops=1)
   -&gt;  Bitmap Heap Scan on tenk1 t1  (cost=4.33..39.44 rows=10 width=244) (actual time=0.254..0.380 rows=10 loops=1)
         Recheck Cond: (unique1 &lt; 10)
         -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..4.33 rows=10 width=0) (actual time=0.164..0.164 rows=10 loops=1)
               Index Cond: (unique1 &lt; 10)
   -&gt;  Index Scan using tenk2_unique2 on tenk2 t2  (cost=0.00..7.87 rows=1 width=244) (actual time=0.041..0.048 rows=1 loops=10)
         Index Cond: (unique2 = t1.unique2)
 Total runtime: 2.414 ms
</pre><br />


<p><br />
如上所示，会显示出来真实的执行时间（毫秒），返回的行数等其他信息。为了和 explain 里面消耗的取值能匹配上，loop 大于 1 的节点显示的是单次执行的时间，需要乘以循环次数。<br />
</p><br />



<pre class="example">EXPLAIN ANALYZE SELECT *
FROM tenk1 t1, tenk2 t2
WHERE t1.unique1 &lt; 100 AND t1.unique2 = t2.unique2 ORDER BY t1.fivethous;

                                                                 QUERY PLAN
--------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=717.30..717.56 rows=101 width=488) (actual time=104.950..105.327 rows=100 loops=1)
   Sort Key: t1.fivethous
   Sort Method: quicksort  Memory: 68kB
   -&gt;  Hash Join  (cost=230.43..713.94 rows=101 width=488) (actual time=3.680..102.396 rows=100 loops=1)
         Hash Cond: (t2.unique2 = t1.unique2)
         -&gt;  Seq Scan on tenk2 t2  (cost=0.00..445.00 rows=10000 width=244) (actual time=0.046..46.219 rows=10000 loops=1)
         -&gt;  Hash  (cost=229.17..229.17 rows=101 width=244) (actual time=3.184..3.184 rows=100 loops=1)
               Buckets: 1024  Batches: 1  Memory Usage: 27kB
               -&gt;  Bitmap Heap Scan on tenk1 t1  (cost=5.03..229.17 rows=101 width=244) (actual time=0.612..1.959 rows=100 loops=1)
                     Recheck Cond: (unique1 &lt; 100)
                     -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..5.01 rows=101 width=0) (actual time=0.390..0.390 rows=100 loops=1)
                           Index Cond: (unique1 &lt; 100)
 Total runtime: 107.392 ms
</pre><br />


<p><br />
有时候还会显示更多的一些信息，比如 sort 和 hash 节点。sort 节点会显示排序的方法，内存磁盘的占用。hash 节点会显示桶（buckets）和批次（batches），如果 batches 大于 1 会使用磁盘空间。<br />
</p><br />



<pre class="example">EXPLAIN ANALYZE SELECT * FROM tenk1 WHERE ten &lt; 7;

                                                QUERY PLAN
----------------------------------------------------------------------------------------------------------
 Seq Scan on tenk1  (cost=0.00..483.00 rows=7000 width=244) (actual time=0.111..59.249 rows=7000 loops=1)
   Filter: (ten &lt; 7)
   Rows Removed by Filter: 3000
 Total runtime: 85.340 ms
</pre><br />


<p><br />
上面这个执行计划显示了 filter 移除了多少行结果。<br />
</p><br />
<p><br />
explain 还提供了一个 buffers 选项。能得到 query 的哪部分 io 最密集。<br />
</p><br />



<pre class="example">EXPLAIN (ANALYZE, BUFFERS) SELECT * FROM tenk1 WHERE unique1 &lt; 100 AND unique2 &gt; 9000;

                                                            QUERY PLAN
-----------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on tenk1  (cost=25.07..60.23 rows=10 width=244) (actual time=3.069..3.213 rows=10 loops=1)
   Recheck Cond: ((unique1 &lt; 100) AND (unique2 &gt; 9000))
   Buffers: shared hit=16
   -&gt;  BitmapAnd  (cost=25.07..25.07 rows=10 width=0) (actual time=2.967..2.967 rows=0 loops=1)
         Buffers: shared hit=7
         -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..5.02 rows=102 width=0) (actual time=0.732..0.732 rows=200 loops=1)
               Index Cond: (unique1 &lt; 100)
               Buffers: shared hit=2
         -&gt;  Bitmap Index Scan on tenk1_unique2  (cost=0.00..19.80 rows=1007 width=0) (actual time=2.015..2.015 rows=1009 loops=1)
               Index Cond: (unique2 &gt; 9000)
               Buffers: shared hit=5
 Total runtime: 3.917 ms
</pre><br />


<p><br />
要注意的是，explain analyse 会真的执行 sql，所以对于 update，insert，delete 等的 sql 操作，最好在执行的时候启用事务，执行完 explain 之后 rollback。<br />
</p><br />
</div><br />

</div><br />

<div id="outline-container-4" class="outline-3"><br />
<h3 id="sec-4"><span class="section-number-3">4</span> Caveats 注意事项</h3><br />
<div class="outline-text-3" id="text-4"><br />


<p><br />
有两个情况可能会影响 explain analyse 和实际执行的差别<br />
1 因为没有任何输出，所以 I/O 和网络网络传输消耗没有体现。<br />
2 因为要输出执行时间，而有些系统里面 gettimeofday() 这个系统调用很慢，所以会导致消耗增加。<br />
</p><br />
<p><br />
在衡量 explain 执行结果的时候，最好是在情况类似的 db 上面，否则可能没有任何参考价值。比如在一个小表上面的执行计划可能和大表就会很不一样。<br />
</p><br />
<div id="footnotes"><br />
<h2 class="footnotes">Footnotes: </h2><br />
<div id="text-footnotes"><br />
<p class="footnote"><sup><a class="footnum" name="fn.1" href="#fnr.1">1</a></sup> : http://www.postgresql.org/docs/9.2/static/runtime-config-query.html#RUNTIME-CONFIG-QUERY-CONSTANTS<br />
</p><br />


<p class="footnote"><sup><a class="footnum" name="fn.2" href="#fnr.2">2</a></sup> : http://www.postgresql.org/docs/9.2/static/runtime-config-query.html#RUNTIME-CONFIG-QUERY-ENABLE<br />
</p></div><br />
</div><br />

</div><br />
</div><br />

<div id="postamble"><br />
<p class="date">Date: 2013-02-03 18:27:03 CST</p><br />
<p class="author">Author: Wang Dong</p><br />
<p class="creator">Org version 7.8.11 with Emacs version 24</p><br />
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a><br />
</div><br />

    </div>

<div class="meta">
    
    <span class="comments"><a href="/postgresql-explain/#disqus_thread">Comments</a></span>
    
</div>
</article>

  <article class="post">
    <h2 class="title"> 
        <a href="/redmine-a-good-project-tracker/">redmine-a-good-project-tracker</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2012-12-11T14:53:00.000&#43;08:00' itemprop="datePublished">2012-12-11</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/linux">linux</a>


</div>
    </div>
        

<p>其实很早，大概2，3年前就听说了 redmine 了，不过他环境是 ruby 的，一直没有勇气去搭一个环境。现在项目人多了，bug 阿 feature 阿，就需要记录一下了，因为有些事情不记录下来总是会忘记。之前是尝试通过 wiki ＋ bugfree 来记录的，bugfree 记录在提测之后的一些问题，wiki 记录一些 feature request 什么的。bugfree 我们没权限管理，wiki 记录又不方便，然后我就又想起来 redmine 了。</p>

<p>哦对，其实公司还提供了一个 jira 给大家用，我用了几次我觉得那玩意太难用了，和那个 confluence 的 wiki 一样难用。</p>

<p>本身搭建没什么难度，编译一个 ruby，然后 gem 安装几个包，下载 redmine，使用 rake 命令操作就好了。启动他的 server 之后，就可以访问了。下面几个东西是我花了一些时间配置的。</p>

<h2 id="和-ldap-集成">和 ldap 集成</h2>

<p>在 redmine 的设置里面，本身是有一项和 redmine 集成的功能的，设置 basedn，和下面的 attributes 内容（sAMAccountName,givenName,sN,mail)就可以了。点测试，得能通过。</p>

<p>在我这里，光设置这个还不行，还需要 hack 一段代码。注意下面的那个 <code>@xxxx.com</code>，这个对应你自己的。</p>

<pre><code class="language-diff">ndex: app/models/auth_source_ldap.rb
===================================================================
--- app/models/auth_source_ldap.rb	(版本 10947)
+++ app/models/auth_source_ldap.rb	(工作副本)
@@ -135,11 +135,12 @@
   # Get the user's dn and any attributes for them, given their login
   def get_user_dn(login, password)
     ldap_con = nil
-    if self.account &amp;&amp; self.account.include?(&quot;$login&quot;)
-      ldap_con = initialize_ldap_con(self.account.sub(&quot;$login&quot;, Net::LDAP::DN.escape(login)), password)
-    else
-      ldap_con = initialize_ldap_con(self.account, self.account_password)
-    end
+    ldap_con = initialize_ldap_con(login + '@xxxxx.com', password)
+    #if self.account &amp;&amp; self.account.include?(&quot;$login&quot;)
+    #  ldap_con = initialize_ldap_con(self.account.sub(&quot;$login&quot;, Net::LDAP::DN.escape(login)), password)
+    #else
+    #  ldap_con = initialize_ldap_con(self.account, self.account_password)
+    #end
     login_filter = Net::LDAP::Filter.eq( self.attr_login, login )
     object_filter = Net::LDAP::Filter.eq( &quot;objectClass&quot;, &quot;*&quot; )
     attrs = {}
@@ -149,6 +150,8 @@
       search_filter = search_filter &amp; f
     end
 
+    logger.debug &quot;------------get_user_dn #{login} #{self.base_dn} #{search_filter} #{search_attributes}&quot; if logger &amp;&amp; logger.debug?
+
     ldap_con.search( :base =&gt; self.base_dn,
                      :filter =&gt; search_filter,
                      :attributes=&gt; search_attributes) do |entry|
</code></pre>

<p>总之登陆验证的代码关键就在这里了，可以自己做尝试，建议先写最简单的代码测试。比如</p>

<pre><code class="language-ruby">require 'rubygems'
require 'net/ldap'

ldap = Net::LDAP.new :host =&gt; 'qunarldap.corp.qunar.com',
     :port =&gt; 389,
     :auth =&gt; {
           :method =&gt; :simple,
           :username =&gt; &quot;wd@xxxx.com&quot;,
           :password =&gt; &quot;pwd&quot;
     }

filter = Net::LDAP::Filter.eq(&quot;sAMAccountName&quot;,&quot;wd*&quot;)
object_filter = Net::LDAP::Filter.eq( &quot;objectClass&quot;, &quot;*&quot; )
search_filter = filter &amp; object_filter

treebase = &quot;你的 basedn&quot; #

attr = [&quot;dn&quot;, &quot;givenName&quot;, &quot;sN&quot;, &quot;mail&quot;]

ldap.search(:base =&gt; treebase, :filter =&gt; search_filter, :attributes =&gt; attr ) do |entry|
  puts &quot;DN: #{entry.dn}&quot;
  entry.each do |attribute, values|
    puts &quot;   #{attribute}:&quot;
    values.each do |value|
      puts &quot;      ---&gt;#{value}&quot;
    end
  end
end

p ldap.get_operation_result
</code></pre>

<p>搞定这块，就可以通过 ldap 用户直接登陆了，登陆会自动创建用户。</p>

<h2 id="通过回复邮件自动创建和更新-issue">通过回复邮件自动创建和更新 issue</h2>

<p>用过 bugzilla 的都知道，可以通过邮件回复的方式来 comment issue。redmine 也提供了这个功能。我这种对 mail 服务器无权的用户，只能申请一个邮箱专门做这个事情了。公司邮箱是 exchange 的，没有打开 imap。redmine 只提供了 imap，pop 之类的方式。好在还有 davmail。先配置好一个 davmail，然后通过 imap 来做这个事情，imap 比 pop 好处多很多，比如可以指定 inbox，可以 move 到 read 之类，就不多说了。</p>

<p>crontab 指令大概如下。</p>

<pre><code class="language-bash">#!/bin/bash

LOG=/export/redmine/log/mail_recieve.log

echo &quot;start $(date)&quot; &gt;&gt; $LOG

/usr/local/ruby/bin/rake --silent -f /export/redmine/Rakefile redmine:email:receive_imap RAILS_ENV=&quot;production&quot; host=localhost username=abc password=def port=1143 move_on_success=read move_on_failure=failed unknown_user=accept &gt;&gt; $LOG 2&gt;&amp;1

echo &quot;end $(date)&quot; &gt;&gt; $LOG
</code></pre>

<p>不过如果 redmine 就这么简单就搞定的话，那我也没必要单独拿出来掰了。关键是，通过 imap 死活就是不行。只好又看了一下代码。</p>

<pre><code class="language-diff">Index: lib/redmine/imap.rb
===================================================================
--- lib/redmine/imap.rb	(版本 10947)
+++ lib/redmine/imap.rb	(工作副本)
@@ -30,8 +30,9 @@
         imap.login(imap_options[:username], imap_options[:password]) unless imap_options[:username].nil?
         imap.select(folder)
         imap.search(['NOT', 'SEEN']).each do |message_id|
-          msg = imap.fetch(message_id,'RFC822')[0].attr['RFC822']
-          logger.debug &quot;Receiving message #{message_id}&quot; if logger &amp;&amp; logger.debug?
+          #msg = imap.fetch(message_id,'RFC822')[0].attr['RFC822']
+          msg = imap.fetch(message_id,'BODY[]')[0].attr['BODY[]']
+          logger.debug &quot;Receiving message #{message_id}, msg:\n#{msg}&quot; if logger &amp;&amp; logger.debug?
           if MailHandler.receive(msg, options)
             logger.debug &quot;Message #{message_id} successfully received&quot; if logger &amp;&amp; logger.debug?
             if imap_options[:move_on_success]
</code></pre>

<p>这里把那个 RFC822 改成 BODY[] 就好了，入丝般润滑。。。</p>

<h2 id="过滤掉邮件回复的垃圾内容">过滤掉邮件回复的垃圾内容</h2>

<p>邮件回复 ok 之后，紧跟着问题就是，他会把整封邮件都作为回复记录进去，这个太恶心了。还好他提供了设置，在 email notification 选项里面，配置一个 email header <code>--Reply above this line--</code>，在 incoming mail 里面配置一个 Truncate emails after one of these lines <code>--Reply above this line--</code>，他就会截取这个字符前面的内容了。</p>

<p>不过还有问题就是，一般邮件回复都开头都是个 <code>On xxxx xxx wrote:</code>，这个他不会截掉，那就再 hack 一下。。</p>

<pre><code class="language-diff">--- app/models/mail_handler.rb	(版本 10947)
+++ app/models/mail_handler.rb	(工作副本)
@@ -463,9 +464,12 @@
 
   # Removes the email body of text after the truncation configurations.
   def cleanup_body(body)
-    delimiters = Setting.mail_handler_body_delimiters.to_s.split(/[\r\n]+/).reject(&amp;:blank?).map {|s| Regexp.escape(s)}
+    #delimiters = Setting.mail_handler_body_delimiters.to_s.split(/[\r\n]+/).reject(&amp;:blank?).map {|s| Regexp.escape(s)}
+    delimiters = Setting.mail_handler_body_delimiters.to_s.split(/[\r\n]+/).reject(&amp;:blank?).map {|s| s}
+
     unless delimiters.empty?
       regex = Regexp.new(&quot;^[&gt; ]*(#{ delimiters.join('|') })\s*[\r\n].*&quot;, Regexp::MULTILINE)
+      #regex = Regexp.new(&quot;(^[&gt; ]*(#{ delimiters.join('|') })\s*[\r\n].*)|(On (.*)wrote:[\r\n].*)&quot;, Regexp::MULTILINE)
       body = body.gsub(regex, '')
     end
     body.strip
</code></pre>

<p>这里搞定之后，在那个 Truncate emails after one of these lines 里面就可以写正则了，增加一行 <code>On (.*)wrote:</code>，然后就可以了。</p>

<h2 id="code-review">code review</h2>

<p>增加了一个 code review 插件，已有项目需要在项目的模块里面启用。并且需要 admin 在角色配置里面，给相应角色增加 code review 的权限。不过貌似这插件不太好用，只能一行一行来。</p>

    </div>

<div class="meta">
    
    <span class="comments"><a href="/redmine-a-good-project-tracker/#disqus_thread">Comments</a></span>
    
</div>
</article>

  <article class="post">
    <h2 class="title"> 
        <a href="/some-tips-on-bash-scripting/">Some tips for bash scripting</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2012-12-02T19:43:00.000&#43;08:00' itemprop="datePublished">2012-12-02</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/web">web</a>


</div>
    </div>
        

<p>最近几天写了一些 bash 脚本，又有些心得，记录一下。</p>

<h2 id="获取当前路径的绝对路径">获取当前路径的绝对路径</h2>

<p>比较常见的需求可能是获取相对路径，这样方便程序复制到其他目录也可以运行。使用 <code>$(dirname $0)</code> 就可以获取相对路径，不过这里说的是绝对路径。</p>

<p>其实也简单，相对路径加上当前目录，那不就是绝对路径么。不过是，有时候 <code>$(dirname $0)</code> 取到的也可能是绝对路径（一般期望相对路径的程序也能跑通，所以不大关心）。</p>

<p>可以用下面的做法，大意是先判断一下获取到的路径是不是 <code>/</code> 开头，如果是，那就不处理，如果不是，那就把当前的路径附加上去得到一个绝对路径。</p>

<pre><code class="language-bash">PG_DIR=&quot;$(dirname $0)/../&quot;

echo &quot;$PG_DIR&quot; | grep -q ^/

if [ $? -ne 0 ];then
        PG_DIR=&quot;$(pwd)/$PG_DIR&quot;
fi
</code></pre>

<h2 id="使用-getopt-获取命令行参数">使用 getopt 获取命令行参数</h2>

<p>获取参数比较常见的做法是取 <code>$1</code> <code>$2</code> 这些，不过不太专业，这里说的是类似于 <code>--prefix=/path/to/install -v</code> 这种。</p>

<p>bash 本身提供了一个内部命令 <code>getopts</code> 来做这个事情，不过那个只能支持 short_opts，就是类似 <code>-v</code> 这种，不支持长的。</p>

<p>getopt 是一个 GNU 程序，他支持 long_opts。下面是个例子。代码基本来自网上。</p>

<pre><code class="language-bash">ARGS=$(getopt -a -o h -l initdb::,help -- &quot;$@&quot;)
[ $? -ne 0 ] &amp;&amp; usage

eval set -- &quot;${ARGS}&quot; 

while true
do
        case $1 in
                --initdb)
                        initdb $2
                        ;;
                -h|--help)
                        usage;
                        ;;
                --)
                        shift
                        break
                        ;;
        esac
        shift
done
</code></pre>

<p>解释一下上面的参数的含义:
* <code>-o</code> 参数指定的就是短参数，我试过，貌似还得指定至少一个短参数。
* <code>-l</code> 参数指定的就是长参数。
* 多个参数用逗号 <code>,</code> 分隔。
* 参数后面跟一个冒号 <code>:</code> 表示这个参数(option)必须要给一个参数(argument)，类似上面的 <code>--prefix=/path/to/install</code> 这种。
* 参数后面跟2个冒号 <code>::</code> 表示这个参数后面的参数可有可无。比如例子里面的 <code>--initdb</code></p>

<h2 id="find-exec-提示-no-such-file-or-directory">find exec 提示 No such file or directory</h2>

<p>这个是之前用来日志删除的一个程序，大概命令类似 <code>find ./ -name '2012*' -exec rm -r {} \;</code>，后来总发现报 <code>No such file or directory</code> 这个错误，可是去看的时候，发现那些目录也被删掉了。开始觉得可能是有其他人的程序也在删除这个目录，问了一圈结果没人删。</p>

<p>后来经过测试琢磨找到原因了，在于这个命令的执行思路大概是先去找那个名字的文件或者目录，然后挨个执行后面的命令。那么，如果找到的既有上级目录，也有下级文件的时候，如果目录先被删掉了，那删文件的时候可不就是 <code>No such file or directory</code> 么。</p>

<p>好在 find 提供了一个参数 <code>-prune</code></p>

<pre><code>       -prune True; if the file is a directory, do not descend into it. If -depth is given, false; no effect.  Because -delete implies -depth, you can-
              not usefully use -prune and -delete together.
</code></pre>

    </div>

<div class="meta">
    
    <span class="comments"><a href="/some-tips-on-bash-scripting/#disqus_thread">Comments</a></span>
    
</div>
</article>

  <article class="post">
    <h2 class="title"> 
        <a href="/hello-world/">Hello world</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2012-11-28T18:38:00.000&#43;08:00' itemprop="datePublished">2012-11-28</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/heart">heart</a>


</div>
    </div>
        <p>Just a test.</p>

<p>Hello world from github :D</p>

    </div>

<div class="meta">
    
    <span class="comments"><a href="/hello-world/#disqus_thread">Comments</a></span>
    
</div>
</article>

  <article class="post">
    <h2 class="title"> 
        <a href="/two-table-after-join/">Join 后面跟两个表</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2012-08-05T00:00:00.000&#43;00:00' itemprop="datePublished">2012-08-05</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/linux">linux</a>

<a href="/tags/mysql">mysql</a>

<a href="/tags/sql">sql</a>


</div>
    </div>
        <p>发现 sql 的写法真是千奇百怪，经常遇到没见过的写法。前几天就遇到了一个 sql 在 join 后写两个表，用逗号分隔。类似下面。</p>

<pre class="prettyprint lang-sql">
select a.a, b.f from t1 a left join ( b, c ) on ( b.id = c.id and b.a = a.a )
</pre>

<p>看到 sql 的这些用法我一般都是去 pgsql 的文档里面去查，因为 pg 的文档里面一般会指明一种用法是否标准 sql，多写标准 sql 可以避免知识不能转移。不过去查了发现 pg 不支持这种写法，也去 pg 里面执行了，确实不支持。</p>

<p>然后就去看 mysql 的文档，里面有对于这种写法的<a href="http://dev.mysql.com/doc/refman/5.1/en/join.html">支持</a>。</p>

<pre class="prettyprint lang-text">
 The syntax of table_factor is extended in comparison with the SQL Standard. The latter accepts only table_reference, not a list of them inside a pair of parentheses.

This is a conservative extension if we consider each comma in a list of table_reference items as equivalent to an inner join. For example:

SELECT * FROM t1 LEFT JOIN (t2, t3, t4)
                 ON (t2.a=t1.a AND t3.b=t1.b AND t4.c=t1.c)

is equivalent to:

SELECT * FROM t1 LEFT JOIN (t2 CROSS JOIN t3 CROSS JOIN t4)
                 ON (t2.a=t1.a AND t3.b=t1.b AND t4.c=t1.c)

In MySQL, JOIN, CROSS JOIN, and INNER JOIN are syntactic equivalents (they can replace each other). In standard SQL, they are not equivalent. INNER JOIN is used with an ON clause, CROSS JOIN is used otherwise. 
</pre>

<p>可以看到，这种写法就是等于是让括号里面的 b,c 使用 inner join 的方式连接，当然如果 on 里面没有指定 join 方式，最后就是个笛卡尔集。然后<a href="http://dev.mysql.com/doc/refman/5.1/en/nested-join-optimization.html">这里</a> 有更多的一些说明，还有下面这种写法。</p>

<pre class="prettyprint lang-sql">
t1 LEFT JOIN t2 ON t1.a=t2.a, t3
</pre>

<p>这些写法都有各自的含义。</p>

<p>其实这么看来，这个方式好像是比较方便的，不过是对于不明白的人如果乱用，这玩意出的错也是很诡异很难排查的。</p>

<p>另外注意上面的语句里面写了，mysql 里面的 join, inner join, cross join 是完全同样的东西。</p>

    </div>

<div class="meta">
    
    <span class="comments"><a href="/two-table-after-join/#disqus_thread">Comments</a></span>
    
</div>
</article>

  <article class="post">
    <h2 class="title"> 
        <a href="/fdw-in-postgresql/">Postgresql 里面连接其他数据库</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2012-05-06T00:00:00.000&#43;00:00' itemprop="datePublished">2012-05-06</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/dbi">dbi</a>

<a href="/tags/fdw">fdw</a>

<a href="/tags/linux">linux</a>

<a href="/tags/postgresql">postgresql</a>


</div>
    </div>
        <p>PG 9.x 引入了 fdw，可以通过 pg 去连接其他 db，不仅限于其他 pg，还可以是 mysql，oracle，文件等。按照设计，fdw 还应该提供给查询规划器一些对方 db 的索引等信息，这样在查询过程中可以提升查询速度。<br />
</p><br />

<div id="outline-container-1" class="outline-3"><br />
<h3 id="sec-1">dbi_link</h3><br />
<div class="outline-text-3" id="text-1"><br />


<p><br />
dbi 就是 perl 的 dbi，总的思想就是通过 plperl 写一些 function（所以也给了调试修改的便利），通过 dbi 去连接其他数据库，可以连接的 db 和 dbi 的支持一样。<br />
</p><br />
<p><br />
测试了一下，第一次连接的时候会 cache 对方 db 的信息，对于复杂库没测试成功，只有一个表的库连接成功，并且可以查询。查询的时候就和查询本地库没有区别。<br />
</p><br />
<p><br />
效率上面看，不是很高，每次查询都必然需要获取对方全部数据。就算是有 where 条件，也不会试用到对方 db 的索引。所以综合来看，只是提供了一个简单的方法来获取数据，最好是一次性的。<br />
</p><br />
</div><br />

</div><br />

<div id="outline-container-2" class="outline-3"><br />
<h3 id="sec-2">db_link</h3><br />
<div class="outline-text-3" id="text-2"><br />


<p><br />
db_link 本身是 pg 自带的，contrib 里面的。db_link 只支持 pg，建立连接之后，后续查询可以只指定使用哪个连接即可。<br />
</p><br />
<p><br />
相对 dbi_link，使用起来稍微复杂一点，需要特定的格式。效率上面看，查全表数据比 dbi_link 快。<br />
</p><br />
<p><br />
他有个优势是每次查询对方库的时候都需要指定一个 sql，而如果只需要少量数据的时候，可以在 sql 里面直接使用 where 来过滤数据，这样就能使用对方 db 的索引了，速度快很多。不过就是稍微有点繁琐。<br />
</p><br />
</div><br />

</div><br />

<div id="outline-container-3" class="outline-3"><br />
<h3 id="sec-3">fdw</h3><br />
<div class="outline-text-3" id="text-3"><br />


<p><br />
<a href="http://www.postgresonline.com/journal/archives/250-File-FDW-Family-Part-1-file_fdw.html">http://www.postgresonline.com/journal/archives/250-File-FDW-Family-Part-1-file\_fdw.html</a> 这里有个链接，讲了 file fdw。其他 fdw 还没有试过。我理解 fdw 是否能使用对方 db 的索引，还需要看 fdw 的实现。file fdw 提供了类似 oracle 外部表一样的东西。实际上早年间 yahoo 的兄弟写过一个外部表的 pg 扩展的，不知道是不是这个 file fdw 就是从那来的。<br />
</p></div><br />
</div><br />

    </div>

<div class="meta">
    
    <span class="comments"><a href="/fdw-in-postgresql/#disqus_thread">Comments</a></span>
    
</div>
</article>

  <article class="post">
    <h2 class="title"> 
        <a href="/controlmaster-in-ssh/">有跳板机的 ssh 登陆</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2012-05-06T00:00:00.000&#43;00:00' itemprop="datePublished">2012-05-06</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/linux">linux</a>

<a href="/tags/ssh">ssh</a>


</div>
    </div>
        <p>我厂登陆服务器需要先走一个跳板机，不能直接登陆，很是蛋疼。实际上 ssh 早就解决了这个问题。<br />
</p><br />
<p><br />
大意是通过设置 proxycommand 来实现，我也写过一个 <a href="http://wdicc.com/cow-ssh-proxycommand/">http://wdicc.com/cow-ssh-proxycommand/</a> 。配置如下<br />
</p><br />


<pre class="prettyprint lang-conf">
# gateways
Host abc
     Hostname abc.com

# servers
Host *.xxx
     ProxyCommand ssh abc exec nc %h %p 2>/dev/null
</pre><br />

<p><br />
这样所有 .xxx 结尾的机器，都会使用 abc 这个机器来跳了。要注意的是，首先需要你机器和 abc 之间的 ssh 验证，这个使用使用的是你机器的 id_rsa 和 abc.com 的 authorized_keys。然后会是 proxy 起作用，需要你的机器和 .xxx 机器的验证，使用的是你的机器的 id_rsa 和 .xxx 的 authorized_keys，注意并不是 abc.com 和 .xxx 之间。<br />
</p><br />
<p><br />
倒霉的是，我厂有些 gateway 机器还需要使用 token，并不能使用 key 验证。虽然有了上面设置，如果从某个机器 cp 数据的时候，还得来回输入哪个 token，真他妈的 2b。<br />
</p><br />
<p><br />
还好 ssh 还提供了一个 controlmaster，很好的解决了这个问题。<br />
</p><br />


<pre class="prettyprint lang-conf">
Host *
     User dong.wang
     ServerAliveInterval 30
     ControlMaster auto
     ControlPath /tmp/ssh/master-%r@%h:%p
     ControlPersist yes
</pre><br />

<p><br />
上面这个设置是所有服务器启用 controlmaster，哪个 /tmp/ssh 目录可以自己设置，没有就创建一个。哪个 ControlPersist 可以是个时间。<br />
</p><br />
<p><br />
这样设置之后，第一次连接的时候，会启动一个 master。后续连接都会走这个，连接速度很快不说，还完全不需要输入什么 token。并且因为只有 gateway 需要输入 token，所以一个 gateway 只需要输入一次。实在是爽大了，真是居家旅行必备啊。就冲着连接速度快这一点也值了。<br />
</p><br />

    </div>

<div class="meta">
    
    <span class="comments"><a href="/controlmaster-in-ssh/#disqus_thread">Comments</a></span>
    
</div>
</article>

  <article class="post">
    <h2 class="title"> 
        <a href="/auto-archive-task-for-org-mode/">org-mode 里面自动归档任务</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2012-04-08T00:00:00.000&#43;00:00' itemprop="datePublished">2012-04-08</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/emacs">emacs</a>

<a href="/tags/linux">linux</a>

<a href="/tags/org-mode">org-mode</a>


</div>
    </div>
        <p>我想应该有不少人在使用 emacs 的 org-mode 来做笔记，任务管理等。我使用 org-mode 比较多的情况是使用他做一些提纲，类似思维导图一样，以及用它来管理 todo list。<br />
</p><br />
<p><br />
org-mode 本身提供了 remember 来创建 todo list。<br />
</p><br />
<p><br />
新建一个 org 文件 ~/org/todo.org，包含两行内容如下<br />
</p><br />


<pre class="prettyprint lang-text">
* Tasks
* Done
</pre><br />

<p><br />
然后设置下面的内容<br />
</p><br />


<pre class="prettyprint lang-lisp">
(define-key global-map "\C-ca" 'org-agenda)
(global-set-key (kbd "C-c m r") 'org-capture)
(setq org-capture-templates
      '(("t" "Todo" entry (file+headline "~/org/todo.org" "Tasks")
         "* TODO %?\nCREATED: %U")
        ("j" "Journal" entry (file+datetree "~/org/journal.org")
         "* %?\nEntered on %U\n  %i\n  %a")))
(defun wd-move-done-task-to-done-cats ( task-pos )
  "move done task to *DONE cats"
  (let* ((entry (org-get-entry))
        (title (org-get-heading))
        (task (format "** %s\n%s\n" title entry))
        )
    (goto-char (point-min))
    (when (search-forward-regexp "^* Tasks$latex ")
      (goto-char (point-min))
      (when (search-forward-regexp "^* Done$")
        (goto-char (match-beginning 0))
        (forward-line)      
        (insert task)
        (goto-char task-pos)
        (delete-region (org-entry-beginning-position) (org-entry-end-position))      
        )
      )
    )
  )

(defun wd-track-task-status ( changes-plist )
   "Track task status, and move it to '* Done' cats if it is stats change from to to done
1 TODO 文件至少需要包含两个标题 * Tasks 和 * Done
2 * Tasks 里面的 TODO 内容变成 DONE 的时候，会自动把这个条目移动到 * Done
3 org-todo-keywords 的设置里面不能包含自动增加时间等的设置，否则增加的内容不能正确加到这个条目
"
   ;; (interactive)
   (let ((type (plist-get change-plist :type))
          (pos (plist-get change-plist :position))
          (from (plist-get change-plist :from))
          (to (plist-get change-plist :to))
          )
     (when (and (string= from "TODO")
                (string= to "DONE"))
       ;; (let ((answer (read-char "Move this entry to *DONE ? Y/N (Y)")))
       ;;   (when (or (= answer (string-to-char "y"))
       ;;             (= answer (string-to-char "Y"))
       ;;             (= answer (string-to-char "
"))
       ;;             )
           (wd-move-done-task-to-done-cats pos)
         ;; ))
       )
     )
   )

(add-hook 'org-trigger-hook 'wd-track-task-status)

;; (setq org-todo-keywords
;;       '((sequence "TODO(t)" "WAIT(w@/!)" "|" "DONE(d!)" "CANCELED(c@)")))
(setq org-todo-keywords
      '((sequence "TODO(t)" "WAIT(w)" "|" "DONE(d)" "CANCELED(c)")))
</pre><br />

<p><br />
在任何地方按一下 C-c m r，会出来一个 window 让你选择要创建 todo 还是 journal。选 t，然后输入内容就会自动插入到 ~/org/todo.org 的 * Tasks 里面。<br />
</p><br />
<p><br />
此后，如果任务完成的时候，打开 todo.org，然后在任务上面 C-c C-t，会提示输入状态。如果是从 TODO 变成了 DONE，那这条任务会被转移到 * Done 里面。<br />
</p><br />
<p><br />
因为里面都有时间，所以在 agenda list 里面，可以用 L 看到任务完成时间等。也将就用了。<br />
</p><br />

    </div>

<div class="meta">
    
    <span class="comments"><a href="/auto-archive-task-for-org-mode/#disqus_thread">Comments</a></span>
    
</div>
</article>

  <article class="post">
    <h2 class="title"> 
        <a href="/about-interview/">关于面试的一点经验</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2012-04-08T00:00:00.000&#43;00:00' itemprop="datePublished">2012-04-08</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/heart">heart</a>

<a href="/tags/interview">interview</a>


</div>
    </div>
        <p>最近面试了不少，也算有点经验了，阶段总结一下。本文也基本是针对刚毕业的或者毕业没两年的，大牛就别看了，浪费时间。<br />
</p><br />

<div id="outline-container-1" class="outline-2"><br />
<h2 id="sec-1">简历</h2><br />
<div class="outline-text-2" id="text-1"><br />


<p><br />
其实写简历的时候，为了能获得更多的面试机会，通常都会有些夸大，尤其是刚毕业没多久，经验不多的，这个情况更严重。把只看过两次的东西，说成熟悉，把用过几次的说成熟练。<br />
</p><br />
<p><br />
对于新人来说，这么做似乎会增加面试机会。但实际上，没有目的的面试，只会浪费双方的时间。很多次看到简历觉得似乎这个是我们需要的人，叫来问两句明白水平之后，基本就只能让对方走人了。不管怎么样，这对双方都是一个损失。<br />
</p><br />
<p><br />
与其夸大简历寻求面试机会，有时候还不如花点时间上个培训班。我见到过不少上培训班的，可能花 3 个月半年的，来了之后你问问题，答得也还算靠谱。不过上培训班能学到的水平大家也清楚，基本是比较初级的，对于高级职位没有帮助。<br />
</p><br />
<p><br />
总之吧，简历不好夸大，提到的东西至少得是你有自己见解的，否则还不如不提。<br />
</p><br />
</div><br />

</div><br />

<div id="outline-container-2" class="outline-2"><br />
<h2 id="sec-2">面试题</h2><br />
<div class="outline-text-2" id="text-2"><br />


<p><br />
对于技术工程师，很多公司都有面试题。有些求职者可能觉得这个东西挺讨厌的，浪费时间。想知道水平直接聊聊不就完了。<br />
</p><br />
<p><br />
其实面试通常时间都不会很长，在这么短的时间内要决定时不时要一个人，也不是个简单的事情，要了解各方面。通常找工程师的时候，动手能力也是一项。从面试题能看出来动手能力。<br />
</p><br />
<p><br />
看你写 for 循环也能看出来你的基础扎实不扎实。我还真见过不少人使用他熟悉的语言，这些都写错的。<br />
</p><br />
<p><br />
当然，面试题不是一切，也不是不允许有笔误，毕竟现在那么多编辑工具都有提示，真没记住还不行么？错是可以错的，可是别人指出错误的时候你一要能看出来错误在哪里，二要虚心接受错误。别牛逼哄哄的还说什么从来不手写，都在编辑器写之类，那种态度要不得，哪个公司哪个领导都不愿意找一个大爷回来养着，伺候不起的。<br />
</p><br />
</div><br />

</div><br />

<div id="outline-container-3" class="outline-2"><br />
<h2 id="sec-3">面试过程</h2><br />
<div class="outline-text-2" id="text-3"><br />


<p><br />
面试聊天期间大可不必紧张，你的主要目的是表达出来你会的东西。大可不必管对方需要什么样子的人，你合适不合适由对方做判断就好了。<br />
</p><br />
<p><br />
而同时其实面试官也会努力帮你，让你表达出你会的东西。<br />
</p><br />
<p><br />
至于说不会的东西怎么办？如实说就可以了。可以类比，但是千万不要狡辩，你要明白的是对方的水平肯定不会比你差，你的任何狡辩只能让对方觉得你这个人很无知自大。<br />
</p><br />
</div><br />

</div><br />

<div id="outline-container-4" class="outline-2"><br />
<h2 id="sec-4">将来的团队</h2><br />
<div class="outline-text-2" id="text-4"><br />


<p><br />
面试不要只关注工资。一个好的工作环境，一个靠谱的团队，带给你的隐性收入远比眼前的工资来的多。不过说实话，这些收入恐怕1，2年就挖空了，那个时候如果一个公司不能按照行情给一个靠谱的价格，那就比较难能继续留住人了。也是个博弈吧，这些事情不是很懂。<br />
</p><br />
<p><br />
同时，找一个自己喜欢的愿意专研的工作也比较重要。<br />
</p><br />
<p><br />
当然，如果你就是想涨工资，那就另说。<br />
</p><br />
</div><br />

</div><br />

<div id="outline-container-5" class="outline-2"><br />
<h2 id="sec-5">薪资</h2><br />
<div class="outline-text-2" id="text-5"><br />


<p><br />
不要尝试讨价还价。<br />
</p><br />
<p><br />
现在的 IT 公司薪资基本都是不透明的，普通员工通常都只知道自己的工资。<br />
</p><br />
<p><br />
如果你不想让自己觉得被坑，那最好在来面试之前就通过各个渠道去获取一下这个公司的薪资水平，并且确定自己能接受的最低工资是多少，可以通过朋友你自己等对你的评价来判断，不要依赖面试官。另外你工作的前一家公司给你的工资也是一个参考，觉得自己屈才的话，大可以往上提。<br />
</p><br />
<p><br />
综合考虑自己的能力，公司能给你带来的隐性收入，到时候直接报你能接受的最低工资就好了。如果是对方真的觉得你的水平不到那个工资，那也没办法的事情。重要的是自己能接受的最低限度是多少，就不要和对方讨价了，否则就算入职了回头也会郁闷的。<br />
</p><br />
</div><br />

</div><br />

<div id="outline-container-6" class="outline-2"><br />
<h2 id="sec-6">跳槽</h2><br />
<div class="outline-text-2" id="text-6"><br />


<p><br />
如果是跳槽过来的，一般都会问一下为什么从原单位离职。建议如实交代，就算是因为工资不高等觉得好像放不到台面上面的原因。没关系的，诚信是个基本要求。<br />
</p><br />
<p><br />
跳槽也不建议太频繁。虽然现在通过跳槽涨工资是个普遍现象，但是也没有刚那边工作半年就来这边面试，并且要求工资涨 2k 的吧？那你再牛逼也没公司敢要，刚培养到能干活，跑了？<br />
</p></div><br />
</div><br />

    </div>

<div class="meta">
    
    <span class="comments"><a href="/about-interview/#disqus_thread">Comments</a></span>
    
</div>
</article>

  <article class="post">
    <h2 class="title"> 
        <a href="/emacs-settings-in-mac/">mac 里面的 emacs 的几个设置</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2012-03-06T00:00:00.000&#43;00:00' itemprop="datePublished">2012-03-06</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/emacs">emacs</a>

<a href="/tags/linux">linux</a>

<a href="/tags/macos">macos</a>


</div>
    </div>
        <p>刚开始在 mac 里面使用 emacs 简直就是自虐，因为那个反人类的 command 按键。一般 pc 上面的 alt 是在 space 旁边的，macbook 的 space 旁边是 command，对于一个需要经常在 mac 里面按的键，不是一般的郁闷。这个问题有两个方法解决。<br />
</p><br />

<div id="outline-container-1" class="outline-2"><br />
<h2 id="sec-1">mac 自带的解决方法</h2><br />
<div class="outline-text-2" id="text-1"><br />


<p><br />
就是在键盘设置里面，把修饰键里面的 command 和 alt 替换一下。这个方法会很不爽，因为 mac 里面的复制粘贴是 command + c/v，以后要按 alt + c/v 的话，距离有点远。<br />
</p><br />
</div><br />

</div><br />

<div id="outline-container-2" class="outline-2"><br />
<h2 id="sec-2">KeyRemap4MacBook</h2><br />
<div class="outline-text-2" id="text-2"><br />


<p><br />
这个是个 mac 上面的软件，地址在 <a href="http://pqrs.org/macosx/keyremap4macbook/document.html">这里</a> 。里面的设置实在太多了，这里要用到的一个就是只在 emacs 里面把 command 和 alt 替换一下，这样就解决了上面提到的问题，还算完美。可是这个时候会发现，在 emacs 界面激活的情况下，command 开头的系统级别的快捷键都不好用了，比如 command + tab，这也很郁闷。<br />
</p><br />
</div><br />

</div><br />

<div id="outline-container-3" class="outline-2"><br />
<h2 id="sec-3">emacs 自带的完美解决方法</h2><br />
<div class="outline-text-2" id="text-3"><br />


<p><br />
只说 emacs23，emacs24。早期的好像有 mac-pass-command-to-system 之类的设置，可我在 emacs24 里面没看到这个变量。<br />
</p><br />
<p><br />
具体设置参考<a href="http://www.emacswiki.org/emacs/EmacsForMacOS#toc23">这里</a> ，主要是下面这些设置。<br />
</p><br />


<pre class="prettyprint lang-lisp">
;; key bindings
(when (eq system-type 'darwin) ;; mac specific settings
  (setq mac-option-modifier 'alt)
  (setq mac-command-modifier 'meta)
  (global-set-key [kp-delete] 'delete-char) ;; sets fn-delete to be right-delete
  )
</pre><br />

<p><br />
现在就很爽了，按 command + x 和 alt + x 效果一样，按 command + tab 也能切换窗口。算是完美了。<br />
</p></div><br />
</div><br />

    </div>

<div class="meta">
    
    <span class="comments"><a href="/emacs-settings-in-mac/#disqus_thread">Comments</a></span>
    
</div>
</article>



  <nav id="pagenavi">
    
        <a href="/page/4/" class="prev">Prev</a>
    
    
        <a href="/page/6/" class="next">Next</a>
    
  <div class="center"><a href="/archives/index.html">Blog Archives</a></div>
  </nav>


    </div>
    <footer id="footer">
    <div style="display:inline">
    Copyright &copy; 2017
    
    wd
    . Powered by <a href="http://gohugo.io" target="_blank">Hugo</a> |
    Theme is <a href="https://github.com/wd/hugo-fabric">hugo-fabric</a>, fork from <a href="https://github.com/wd/hexo-fabric">hexo-fabric</a> by <a href="https://wdicc.com">me</a>
</div>

    </footer>
    <script src="/js/fabric.js"></script>


</div>
</div>
<script src="/js/jquery.ui.totop.js" type="text/javascript"></script>
<script type="text/javascript">
 
;(function($){$().UItoTop({easingType:'easeOutCirc'});})(jQuery);
 
</script>
</body>
</html>
