<!DOCTYPE HTML>
<html>
<head>
	<meta name="generator" content="Hugo 0.19" />
	<meta charset="utf-8">
    
    
    <title>wd and cc</title>
    <meta name="author" content="wd">
    <meta name="description" content="">
    <meta name="keywords" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <link href="https://wdicc.com/index.xml" rel="alternate" title="wd and cc" type="application/atom+xml">
	<link href="/favicon.ico" rel="shortcut icon">
    <link href="/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
    <link href="/css/custom.css" media="screen, projection" rel="stylesheet" type="text/css">

    <link href='//fonts.googleapis.com/css?family=Slackey' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Fjalla+One' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Amethysta' rel='stylesheet' type='text/css'>
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
    

    <script type="text/javascript" src="/js/jquery-tapir.js"></script>

    

    <link rel="stylesheet" href="/css/hljs.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
</head>


<body>
    <div id="wrapper">
        <header id="header" class="inner">
<h1 class="animated bounceInDown">
    <div id="headerbg">
        wd and cc
    </div>
</h1>

<span class="subtitle">happy every day</span>
<br>

<ul id="social-links" style="text-align:center; clear:both;">
    
    
    <li>
    <a href="https://github.com/wd" class="github" title="Github"></a>
    </li>
    
    
    
    
    
    <li>
    <a href="http://www.twitter.com/wd" class="twitter" title="Twitter"></a>
    </li>
    
    
    
    
    
</ul>


<ul id="nav">
	<li id="ajax"><a href="/index.html">Home</a></li>
	<li id="ajax"><a href="/archives/index.html">Archives</a></li>
	<li id="ajax"><a href="/tags/index.html">Tags</a></li>
    <li><a href="/atom.xml">RSS</a></li>
    <li>
    <div id="dark">
        <form action="//www.google.com.hk/search" method="get" accept-charset="UTF-8" id="search">
            <input type="hidden" name="sitesearch" value="https://wdicc.com/" />
            <input type="text" name="q" results="0" placeholder="Search..." x-webkit-speech />
        </form>
    </div>
    </li>
</ul>

</header>

<div id="toload">

    <div id="content" class="inner">
        




    
    <script id="dsq-count-scr" src="//wdicc.disqus.com/count.js" async></script>
    




  <article class="post">
    <h2 class="title"> 
        <a href="/release-some-staff-at-github/">Release some staff at github</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2016-12-13T17:00:31.000&#43;08:00' itemprop="datePublished">2016-12-13</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/hexo">hexo</a>

<a href="/tags/lua">lua</a>

<a href="/tags/ngx_lua">ngx_lua</a>

<a href="/tags/mcrypt">mcrypt</a>


</div>
    </div>
        <p>把 blog 用到的模板整理了一下，放到了 <a href="https://github.com/wd/hexo-fabric">https://github.com/wd/hexo-fabric</a> ，这个最开始是 fork 别人的代码改的，后来发现原来那个人已经不用了，就整理一下，增加了一个 tag 支持，修改了一下字体和背景色，还有代码颜色等，都是一些小修改。同时也提交到了官方的 theme 库，不过 pull request 还没有通过。。</p>

<p>另外，还把之前写的一个给 ngx-lua 用的一个使用 mcrypt 加密解密的库 <a href="https://github.com/wd/lua-resty-mcrypt">https://github.com/wd/lua-resty-mcrypt</a> ，整理出来单独弄了一个模块。代码其实非常简单，这个也能看出来 ngx_lua 里面使用 ffi 调用 C 模块开发多舒服，不过因为 C 知识有限，可能还是会有一些问题，不过至少自己测试是 ok 的，也在线上跑了好久，只能遇到有问题的再说了。这个同时也提交到了春哥的 opm 仓库，那个倒没有审核，提交就被索引了，使用的话应该可以用 opm 命令直接安装。</p>

    </div>

<div class="meta">
    
    <span class="comments"><a href="/release-some-staff-at-github/#disqus_thread">Comments</a></span>
    
</div>
</article>

  <article class="post">
    <h2 class="title"> 
        <a href="/Bloat-and-Query-Speed-in-PostgreSQL/">Bloat and Query Speed in PostgreSQL</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2016-12-09T12:12:21.000&#43;08:00' itemprop="datePublished">2016-12-09</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/postgresql">postgresql</a>


</div>
    </div>
        <p>内容反义自 <a href="https://www.citusdata.com/blog/2016/11/04/autovacuum-not-the-enemy/">https://www.citusdata.com/blog/2016/11/04/autovacuum-not-the-enemy/</a></p>

<p>pg 的 mvcc 会导致表索引的 bloat 就不多说了。说一下不合理处理这种 bloat 害处是啥。</p>

<p>首先肯定是会浪费空间。然后也会影响查询速度。表和索引存储的时候都是 8kB 一个 page，如果一个查询一些行，数据库会加载这些 pages 到内存。一个 page 里面的 dead rows 越多，在加载的时候就越浪费 I/O。例如全表扫描会加载所有的 dead rows。</p>

<p>Bloat 还会导致热门的查询会一下塞满内存。会导致相同的 live rows 需要更多 pages。This causes swapping and makes certain query plans and algorithms ineligible for execution.</p>

<p>还有一个影响是，pg 的系统表也会有可能 bloat，因为他们也是表。导致这个的一种情况是频繁的创建和删除临时表。这个进一步会导致一些管理命令执行变慢，甚至比如 <code>\d</code> 这种命令。</p>

<p>索引也有可能会 bloat。索引是 tuple 标识和数据之间的一个映射。这些标识指向的是某个 page 里面的 offset。每个 tuple 都是一个独立的对象，需要自己的索引条目。更新一行的时候总是会创建这行的新的索引条目。</p>

<p>索引的 bloat 的影响比 table 小一点。索引里面指向 dead tuple 的可以直接标记为 dead. 这会使得索引膨胀，但是不会导致不必要的堆查找。同时更新堆中的 tuples 不影响已经索引的列，使用一种叫做 HOT 的技术来把指向 dead tuples 的指针指向新的。这允许查询可以通过这些指针复用旧的索引条目。(Also updates to tuples in the heap that do not affect the indexed column(s) use a technique called HOT to provide pointers from the dead tuple to its replacement. This allows queries to reuses old index entries by following pointers across the heap.) (没太看明白.)</p>

<p>索引 bloat 的问题还是应该需要重视。例如 btree 索引是由二叉树组成()。叶子节点包含值和 tuple 标识（应该是指在 data file 的 offset）。随机更新因为会重用 page，所以可以保持 btree 维持一个良好的形状。但是，如果是单侧更新，会导致大量的空页。</p>

<p>The size considerations of index bloat are still significant. For instance a btree index consists of binary tree of pages (the same sized pages as you find holding tuples in the heap). The leaf node pages contain values and tuple identifiers. Uniform random table updates tend to keep a btree index in pretty good shape because it can reuse pages. However lopsided inserts/updates affecting one side of the tree while preserving a few straggling entries can lead to lots of mostly empty pages.</p>

    </div>

<div class="meta">
    
    <span class="comments"><a href="/Bloat-and-Query-Speed-in-PostgreSQL/#disqus_thread">Comments</a></span>
    
</div>
</article>

  <article class="post">
    <h2 class="title"> 
        <a href="/Full-page-write-in-PostgreSQL/">Full page write in PostgreSQL</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2016-12-08T18:02:14.000&#43;08:00' itemprop="datePublished">2016-12-08</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/postgresql">postgresql</a>


</div>
    </div>
        

<p>读了一篇<a href="http://blog.2ndquadrant.com/on-the-impact-of-full-page-writes/">文章</a>，简单翻译总结下。</p>

<h2 id="partial-writes-torn-pages">Partial Writes / Torn Pages</h2>

<p>pg 默认是 8kB 一个 page。linux 文件系统一般是 4kB（x86 里面最大是 4kB)，老设备驱动一般是 512B 一个扇区，新的设备有些支持 4kB 或者 8kB。</p>

<p>当 pg 写入一个 page 8kB 的时候，系统的底层会拆分小一点块，这里涉及到写入的原子性。8kB 的 pg page，会被文件系统拆分成 4kB 的块，然后拆分成 512B 扇区大小。这个时候如果系统崩溃（比如停电，内核 bug）会发生什么？</p>

<p>即使系统的存储有针对这种情况的设计（比如 SSD 自带电容器，RAID 控制器自带电池），内核那块也是会拆分成 4kB 的 page，所以还是有一定可能性，pg 写了 8kB，但是只有部分写入成功。</p>

<p>这个时候你可能意识到这就是为啥我们要有事务日志（WAL）。所以当系统崩溃重启之后，数据库会读取 WAL（从最后一次 checkpoint），然后重新写入一遍，以保证数据文件是完整的。</p>

<p>恢复的时候，在修改一个 page 之前，还是会读取一下。</p>

<p>在 checkpoint 之后第一次修改一个 page 的时候，会把整个 page 写入 WAL。这是为了保证在恢复的时候，能保证这些被修改的 page 能完全恢复到他原有的样子。</p>

<h2 id="写放大">写放大</h2>

<p>如果打开 Full page write，很显然会导致 WAL 文件增加，因为就算修改一个字节，也会导致 8kB page 的写入。因为 Full page write 只发生在 checkpoint 之后的第一次写入，所以减少 checkpoint 的发生频率是可以减少写入的。</p>

<h2 id="uuid-vs-bigserial-主键">UUID vs BIGSERIAL 主键</h2>

<p>比较了一下使用 UUID 或者 bigserial 做主键对写入的影响。可以看原链接的图，会发现在 INSERT 语句的情况下 UUID 产生的 WAL 文件量比较多。主要原因是 Btree 索引的情况下，bigserial 是顺序的维护这个索引，UUID 是无顺序的，会导致维护索引产生的数据量不同。</p>

<p>如果是使用 UPDATE 随机修改，那么会发现产生的 WAL 数量就差不多了。</p>

<h2 id="8kb-and-4kb-pages">8kB and 4kB pages</h2>

<p>如果减小 pg 的 page 的大小，可以减小 WAL 数量。从 8kB 减小到 4kB，上面 UUID 那个例子，可以减少大概 35% 的量。</p>

<h2 id="需要-full-page-write-吗">需要 full-page write 吗？</h2>

<p>首先，这个参数是 2005 年 pg 8.1 引入的，那么现代的文件系统是不是已经不用操心部分写入的情况了？作者尝试了一些测试没有测试出来部分写入的情况，当然这不表示不会存在。但是就算是存在，数据的一致性校验也会是有效的保护（虽然并不能修复这个问题，但是至少能让你知道有坏的 page）</p>

<p>其次，现在很多系统都依赖于流式同步，并不会等着有问题的服务器在有硬件问题的时候重启，并且花费很多时间恢复，一般都直接切换到热备服务器上面了。这个时候部分写就不是什么问题了。但是如果我们都推荐这么做，那么「我也不知道为啥数据损坏了，我只是设置了 full_page_writes=off」这种会是 DBA 死前最常见的言论了。(类似于「这种蛇我之前在 reddit 看见过，无毒的」)</p>

<h2 id="总结">总结</h2>

<p>对于 full-page write 你没法直接优化。大部分情况下，full-page write 都是发生在 checkpoint 之后，直到下一次 checkpoint。所以调整 checkpoint 的发生频率不要太频繁很重要。</p>

<p>有些应用层的操作，可能会导致对表或者索引的随机写入的增加，例如上面的 UUID 的值就是随机的，会让简单的 INSERT 也会导致索引的随机 update。使用 Bigserial 做主键(让 UUID 做替代键)可以减少写放大。</p>

    </div>

<div class="meta">
    
    <span class="comments"><a href="/Full-page-write-in-PostgreSQL/#disqus_thread">Comments</a></span>
    
</div>
</article>

  <article class="post">
    <h2 class="title"> 
        <a href="/use-pgrepup-to-upgrade-your-postgres/">使用 pgrepup 跨版本升级 pg</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2016-12-08T11:55:33.000&#43;08:00' itemprop="datePublished">2016-12-08</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/postgres">postgres</a>


</div>
    </div>
        

<p><a href="http://gasparin.net/2016/11/pgrepup-upgrade-postgresql-using-logical-replication/">pgrepup</a> 其实是一个支持 pg 跨版本复制的工具。而 pg 大版本升级需要停机是个比较郁闷的事情，如果能通过这个解决就实在太好了。下面测试了一下。</p>

<h2 id="安装">安装</h2>

<p>需要安装 <code>pgrepup</code> 和 <code>pglogical</code>。</p>

<h3 id="安装-pgrepup">安装 pgrepup</h3>

<p>pgrepup 官方说是支持 python &gt;= 2.7 的版本，我自己测试的结果，python 3.5 里面执行有点问题，需要修改几个地方。但是在 python 2.7 里面，不需要做任何修改，所以建议使用 python 2.7。安装很简单，执行 <code>pip install pgprepup</code> 就可以了。</p>

<h3 id="安装-pglogical">安装 pglogical</h3>

<p>需要给你的 pg 安装这个扩展。高版本的和低版本的都需要安装。</p>

<p>安装也很简单，下载源码，执行 <code>PATH=/opt/pg96/bin:$PATH make USE_PGXS=1 install</code> 就好了。如果是给 pg95 装，那就把路径改成 pg95。</p>

<p>可以参考<a href="https://2ndquadrant.com/it/resources/pglogical/pglogical-installation-instructions/">这里</a>。</p>

<h2 id="配置">配置</h2>

<h3 id="配置-db">配置 db</h3>

<p>先给几个 db 定义一下角色。db1 假设为 9.5 版本，db2 假设为 9.6 版本。</p>

<p>pgrepup 允许 db1, db2 和执行 pgrepup 所在的机器分别在不同的机器，也可以在相同的机器，看机器情况。</p>

<p>对于 db，最小配置的 postgres.conf 修改如下，我测试的时候两个 db 在一台机器上面，只需要修改 port 不一样就可以了。</p>

<pre><code>listen_addresses = '*'          # what IP address(es) to listen on;
port = 5495
wal_level = logical # minimal, archive, hot_standby, or logical
max_wal_senders = 3             # max number of walsender processes
max_replication_slots = 3       # max number of replication slots
shared_preload_libraries = 'pglogical'          # (change requires restart)

## 下面几个参数不是必须设置的
logging_collector = on          # Enable capturing of stderr and csvlog
log_filename = 'postgresql-%Y-%m-%d.log'        # log file name pattern,
</code></pre>

<p>pg_hba.conf 如下，修改其中的 client_ip 和 db_ip 为对应的真实 ip。</p>

<pre><code>host all all client_ip/32 md5
host replication pgrepup_replication db_ip/32 md5
host all pgrepup_replication db_ip/32 md5
</code></pre>

<p>配置好之后，启动 db1 和 db2 看看是不是可以正常连接。</p>

<p>还需要建立用户。如果已经存在一个 super 的用户，那也可以直接用那个用户，没有的话，就建一个。db1 和 db2 都需要建立，可以是不同的用户。</p>

<h4 id="hint">hint</h4>

<p>当然，如果我们在生产环境里面做这个事情，那肯定会是 db1 已经是一个存在的 db，只需要增加原来没有的配置就好了。db2 会是一个全新的 db，使用 initdb 初始化，之后配置上面的配置项（当然，如果是将来要给生产用，那应该是复制 db1 的配置文件过来，修改端口就可以了，其他都一样）。</p>

<h3 id="配置-pgrepup">配置 pgrepup</h3>

<p>执行一下 <code>pgrepup config</code></p>

<pre><code>❯❯❯ pgrepup config
Pgrepup 0.3.7
Create a new pgrepup config
Configuration filename [~/.pgrepup] ./pgrepup.config
Security
Do you want to encrypt database credentials using a password? [Y/n] n
Folder where pgrepup store temporary dumps and pgpass file [/tmp] ./tmp
Source Database configuration
Ip address or Dns name: db_ip
Port: 5495
Connect Database: [template1]
Username: wd
Password:
Destination Database configuration
Ip address or Dns name: db_ip
Port: 5496
Connect Database: [template1]
Username: wd
Password:
Configuration saved to ./pgrepup.config.
You can now use the check command to verify setup of source and destination databases
</code></pre>

<p>之后会产生一个配置文件 pgrepup.config，有修改的话，可以打开再次编辑。</p>

<p>之后，可以执行一下 <code>pgrepup check</code> 来检查一下</p>

<pre><code>❯❯❯ pgrepup -c pgrepup.config check
Pgrepup 0.3.7
Global checkings...
 &gt;  Folder ./tmp exists and is writable ..........................................OK
Checking Source...
 &gt;  Connection PostgreSQL connection to db_ip:5495 with user wd OK
 &gt;  pglogical installation .......................................................KO

    Hint: Install docs at https://2ndquadrant.com/it/resources/pglogical/pglogical-installation-instructions/

 &gt;  Needed wal_level setting .....................................................OK
 &gt;  Needed max_worker_processes setting ..........................................OK
 &gt;  Needed max_replication_slots setting .........................................OK
 &gt;  Needed max_wal_senders setting ...............................................OK
 &gt;  pg_hba.conf settings .........................................................KO
    Hint: Add the following lines to /home/wd/data95/pg_hba.conf:
        host replication pgrepup_replication db_ip/32 md5
        host all pgrepup_replication db_ip/32 md5
    After adding the lines, remember to reload postgreSQL
 &gt;  Local pg_dumpall version .....................................................OK
 &gt;  Source cluster tables without primary keys
 &gt;      template1 ................................................................OK
 &gt;      testdb
 &gt;          public.t1 ............................................................OK
 &gt;      postgres .................................................................OK
Checking Destination...
 &gt;  Connection PostgreSQL connection to db_ip:5496 with user wd OK
 &gt;  pglogical installation .......................................................KO

    Hint: Install docs at https://2ndquadrant.com/it/resources/pglogical/pglogical-installation-instructions/

 &gt;  Needed wal_level setting .....................................................KO
    Hint: Set wal_level to logical
 &gt;  Needed max_worker_processes setting ..........................................OK
 &gt;  Needed max_replication_slots setting .........................................KO
    Hint: Increase max_replication_slots to 3
 &gt;  Needed max_wal_senders setting ...............................................OK
 &gt;  pg_hba.conf settings .........................................................KO
    Hint: Add the following lines to /home/wd/data96/pg_hba.conf:
        host replication pgrepup_replication db_ip/32 md5
        host all pgrepup_replication db_ip/32 md5
    After adding the lines, remember to reload postgreSQL
 &gt;  Local pg_dumpall version .....................................................OK
</code></pre>

<p>上面是我第一次执行 check 的结果，可以看到很多红色的 <code>KO</code>，有些下面还有 hint 提示告诉你怎么修复，针对红色的信息进行修复就好了。</p>

<pre><code>❯❯❯ pgrepup -c pgrepup.config check
Pgrepup 0.3.7
Global checkings...
 &gt;  Folder ./tmp exists and is writable ..........................................OK
Checking Source...
 &gt;  Connection PostgreSQL connection to db_ip:5495 with user wd ...OK
 &gt;  pglogical installation .......................................................OK
 &gt;  Needed wal_level setting .....................................................OK
 &gt;  Needed max_worker_processes setting ..........................................OK
 &gt;  Needed max_replication_slots setting .........................................OK
 &gt;  Needed max_wal_senders setting ...............................................OK
 &gt;  pg_hba.conf settings .........................................................OK
 &gt;  Local pg_dumpall version .....................................................OK
 &gt;  Source cluster tables without primary keys
 &gt;      template1 ................................................................OK
 &gt;      testdb
 &gt;          public.t1 ............................................................OK
 &gt;      postgres .................................................................OK
Checking Destination...
 &gt;  Connection PostgreSQL connection to db_ip:5496 with user wd ...OK
 &gt;  pglogical installation .......................................................OK
 &gt;  Needed wal_level setting .....................................................OK
 &gt;  Needed max_worker_processes setting ..........................................OK
 &gt;  Needed max_replication_slots setting .........................................OK
 &gt;  Needed max_wal_senders setting ...............................................OK
 &gt;  pg_hba.conf settings .........................................................OK
 &gt;  Local pg_dumpall version .....................................................OK
</code></pre>

<p>上面是我修复之后执行的结果。其中会提示会被同步的 db（上面是 template1, testdb, postgres）。之后执行 setup</p>

<pre><code>❯❯❯ pgrepup -c pgrepup.config setup
Pgrepup 0.3.7
Check if there are active subscriptions in Destination nodes .....................OK
Global tasks
 &gt;  Remove nodes from Destination cluster
 &gt;      postgres .................................................................OK
 &gt;      template1 ................................................................OK
 &gt;      testdb ...................................................................OK
 &gt;  Create temp pgpass file ......................................................OK
 &gt;  Drop pg_logical extension in all databases of Source cluster
 &gt;      template1 ................................................................OK
 &gt;      postgres .................................................................OK
 &gt;      testdb ...................................................................OK
 &gt;  Drop pg_logical extension in all databases of Destination cluster
 &gt;      postgres .................................................................OK
 &gt;      template1 ................................................................OK
 &gt;      testdb ...................................................................OK
Setup Source
 &gt;  Create user for replication ..................................................OK
 &gt;  Dump globals and schema of all databases .....................................OK
 &gt;  Setup pglogical replication sets on Source node name
 &gt;      template1 ................................................................OK
 &gt;      postgres .................................................................OK
 &gt;      testdb ...................................................................OK
Setup Destination
 &gt;  Create and import source globals and schema ..................................OK
 &gt;  Setup pglogical Destination node name
 &gt;      postgres .................................................................OK
 &gt;      testdb ...................................................................OK
 &gt;      template1 ................................................................OK
Cleaning up
 &gt;  Remove temporary pgpass file .................................................OK
 &gt;  Remove other temporary files .................................................OK
</code></pre>

<p>然后执行 start</p>

<pre><code>❯❯❯ pgrepup -c pgrepup.config start
Pgrepup 0.3.7
Start replication and upgrade
 &gt;  postgres .................................................................OK
 &gt;  template1 ................................................................OK
 &gt;  testdb ...................................................................OK
</code></pre>

<p>可以通过 status 看同步状态</p>

<pre><code>❯❯❯ pgrepup -c pgrepup.config status
Pgrepup 0.3.7
Configuration
 &gt;  Source database cluster ......................................................OK
 &gt;  Destination database cluster .................................................OK
Pglogical setup
 &gt;  Source database cluster
 &gt;      template1 ................................................................OK
 &gt;      postgres .................................................................OK
 &gt;      testdb ...................................................................OK
 &gt;  Destination database cluster
 &gt;      postgres .................................................................OK
 &gt;      testdb ...................................................................OK
 &gt;      template1 ................................................................OK
Replication status
 &gt;  Database postgres
 &gt;      Replication status ..............................................replicating
 &gt;  Database testdb
 &gt;      Replication status ..............................................replicating
 &gt;  Database template1
 &gt;      Replication status ..............................................replicating
 &gt;  Xlog difference (bytes) ...................................................57816
</code></pre>

<p>可以看到三个 db 都在同步。这个时候在 db1 上面插入数据，能在 db2 上面看到会同步过去。</p>

<p>状态有三种情况
* initializing: pglogical 正在 copy 数据
* replication: 同步状态
* down: 同步断开了，需要检查日志修复</p>

<h2 id="需要注意的问题">需要注意的问题</h2>

<h3 id="db-里面的表都需要有主键">db 里面的表都需要有主键</h3>

<p>如果存在没有主键的表，执行 check 的时候会看到下面的信息</p>

<pre><code> &gt;  Source cluster tables without primary keys
 &gt;      template1 ................................................................OK
 &gt;      testdb
 &gt;          public.t2 ............................................................KO
    Hint: Add a primary key or unique index or use the pgrepup fix command
 &gt;          public.t1 ............................................................OK
 &gt;      postgres .................................................................OK
</code></pre>

<p>如果不解决就执行 setup，会提示下面的信息</p>

<pre><code>Setup Source ........................................Skipped, configuration problems
Setup Destination
 &gt;  Create and import source globals and schema .............................Skipped
 &gt;  Setup pglogical Destination node name
 &gt;      postgres .................................................................OK
 &gt;      template1 ................................................................OK
 &gt;      testdb ...................................................................OK
</code></pre>

<p>可以自己创建一个主键重新 check，也可以执行 fix 来修复，然后再次执行 setup。</p>

<pre><code> ❯❯❯ pgrepup -c pgrepup.config fix
Pgrepup 0.3.7
Find Source cluster's databases with tables without primary key/unique index...
 &gt;  template1 ....................................................................OK
 &gt;  postgres .....................................................................OK
 &gt;  testdb
 &gt;      Found public.t2 without primary key ................Added __pgrepup_id field
</code></pre>

<p>通过 fix 加的主键，在 uninstall 的时候会被删除。</p>

<h3 id="replication-status-down">Replication status .. down</h3>

<p>有时候会遇到有的 db 的状态是好的，有的 db 是 down 的情况</p>

<pre><code>Replication status
 &gt;  Database postgres
 &gt;      Replication status ..............................................replicating
 &gt;  Database testdb
 &gt;      Replication status .....................................................down
 &gt;  Database template1
 &gt;      Replication status ..............................................replicating
 &gt;  Xlog difference (bytes) ..................................................614096
</code></pre>

<p>在同步状态下面，如果给某个 db 加一个没有主键的表，就会导致同步断掉。修复方法是先 stop，然后执行 check，按照提示修复，然后执行 setup，然后 start 就可以了。</p>

<h3 id="官方列出来的几个问题">官方列出来的几个问题</h3>

<ul>
<li>DDL 命令。不会同步 DDL 命令，可以在 db1 试试看 <code>pglogical.replicate_ddl_command</code>。</li>
<li>seq 序列。执行 stop 命令的时候，会在目标 db 的 seq 上面加 1000。</li>
<li>有大量的 db。执行 start 命令之后，pglogical 会每个 db 启动一个 worker 来同步数据，要是 db 比较多会导致比较高的负载。</li>
</ul>

<p>因为这个是基于 pglogical 的，所以还需要关注 pglogical 列出来的一些<a href="https://2ndquadrant.com/it/resources/pglogical/pglogical-docs/">限制</a> 第 4 部分 Limitations and Restrictions。
* 4.1 Superuser is required
* 4.2 UNLOGGED and TEMPORARY not replicated
* 4.3 One database at a time
* 4.4 PRIMARY KEY or REPLICA IDENTITY required
* 4.5 Only one unique index/constraint/PK
* 4.6 DDL
* 4.7 No replication queue flush
* 4.8 FOREIGN KEYS
* 4.9 TRUNCATE
* 4.10 Sequences
* 4.11 Triggers
* 4.12 PostgreSQL Version differences
* 4.13 Doesn&rsquo;t replicate DDL</p>

<h3 id="pgrepup-uninstall">pgrepup uninstall</h3>

<p>uninstall 会清理 pgrepup 创建的一些信息，比如安装的 pglogical 扩展，创建用来同步的用户，和通过 fix 命令添加的 seq。</p>

<pre><code>❯❯❯ pgrepup -c pgrepup.config uninstall
Pgrepup 0.3.7
Check active subscriptions in Destination nodes
 &gt;  template1 ...............................................................Stopped
 &gt;  testdb ..................................................................Stopped
 &gt;  postgres ................................................................Stopped
Uninstall operations
 &gt;  Remove nodes from Destination cluster
 &gt;      postgres .................................................................OK
 &gt;      testdb ...................................................................OK
 &gt;      template1 ................................................................OK
 &gt;  Drop pg_logical extension in all databases
 &gt;      Source
 &gt;          template1 ............................................................OK
 &gt;          postgres .............................................................OK
 &gt;          testdb ...............................................................OK
 &gt;      Destination
 &gt;          postgres .............................................................OK
 &gt;          testdb ...............................................................OK
 &gt;          template1 ............................................................OK
 &gt;  Drop user for replication ....................................................OK
 &gt;  Drop unique fields added by fix command
 &gt;          template1
 &gt;          postgres
 &gt;          testdb
 &gt;              public.t1 ........................................................OK
 &gt;              public.t2 ........................................................OK
</code></pre>

<h2 id="升级">升级</h2>

<p>如果前面配置好了同步状态，那剩下的事情就简单了。
* 停止应用链接 db1
* 确保 db1 已经没有任何链接
* 使用 <code>pgrepup stop</code> 停止 replication
* 修改应用链接到 db2
* 启动应用
* 剩下的就是处理掉停止的 db1</p>

<h2 id="参考文档">参考文档</h2>

<p><a href="http://qiita.com/yteraoka/items/e82e4d28f6a23915d190">http://qiita.com/yteraoka/items/e82e4d28f6a23915d190</a></p>

    </div>

<div class="meta">
    
    <span class="comments"><a href="/use-pgrepup-to-upgrade-your-postgres/#disqus_thread">Comments</a></span>
    
</div>
</article>

  <article class="post">
    <h2 class="title"> 
        <a href="/Built-in-sharding-in-PostgreSQL/">Built in sharding in PostgreSQL</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2016-12-07T16:54:59.000&#43;08:00' itemprop="datePublished">2016-12-07</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/postgresql">postgresql</a>


</div>
    </div>
        

<p>PostgreSQL 内建 sharding 支持，粗略翻译自 <a href="https://wiki.postgresql.org/wiki/Built-in_Sharding">https://wiki.postgresql.org/wiki/Built-in_Sharding</a></p>

<h2 id="introduction">Introduction</h2>

<p>内建支持 sharding 最大的挑战是，如何用最小的代码修改实现。大部分社区的 sharding 修改支持都修改了很多 PostgreSQL 的代码，这也导致这些不能被 Postgres 社区那些不需要 sharding 的人接受。有了 FDW 之后，就有了在有限代码修改情况下实现内建 sharding 支持的可能。</p>

<p>基于 FDW 的这种 sharding 设计，是基于 NTT 开发的 Postgres-XC，大概已经有 10 年了。Postgres-XL 是基于这个设计的一种更加灵活的实现。</p>

<h2 id="enhance-existing-features">Enhance Existing Features</h2>

<ul>
<li>已完成？提升 FDW 的基础设计和 postgres_fdw。特别的，好的性能要求合理的把一些操作推送到子节点(foreign shards)。在 Postgres 9.6 中，join, sort, update, delete 都可以推送到字节点了。聚合的 pushdown 将在 Postgres 10 中支持。FDW 表已经可以作为继承表出现。</li>
<li>提升分区支持有效提升 existence of shards。幸运的是，单节点的分区支持也需要重构才能提升性能和更多优化。例如，executor-based partition pruning.</li>
<li>给 FDW 请求增加并行支持。这样能允许节点并行执行，这个可能会通过多个异步的链接来实现。</li>
</ul>

<h2 id="new-subsystems">New Subsystems</h2>

<p>还需要开发一些子系统：
* 允许表可以复制到所有节点，以允许更多的 join pushdown。这个可以通过 trigger 或者逻辑复制来完成。
* 实现一个子模块，以使用新的分区系统表来提交符合提交的查询的 FDW 查询。
* 实现一个子模块收集 FDW 查询的结果返回给用户。
* 实现全局事务管理器以便更加高效的允许子节点原子的提交事务。这个可能会通过 prepared 的事务来实现，还有某种在 crash 之后清理那些 preapared 的事务的事务管理器。例如 XA。
* 实现全局快照管理器，以允许子节点可以看到一致性的快照。（是不是 serialisable 事务模式会避免跨节点快照冲突？pg_export_snapshot() 或者 hot_standby_feedback 是不是会有帮助？) 多节点的备份的一致性也需要这个支持。
* 实现支持 create, manage, report on shards 这些用户 API。</p>

<h2 id="use-cases">Use Cases</h2>

<p>有四种可能的用户案例和不同的需求:
* 跨节点在只读节点上面执行只读聚合查询，例如数据仓库
  这种是最简单的场景，不需要全局事务管理，全局快照管理，并且因为聚合，所以子节点返回的数据量也是最小的。
* 跨节点在只读节点上面执行只读非聚合查询
  这种会给调度节点压力，需要收集和处理很多子节点返回的数据。这种也能看到 FDW 传输机制等级。
* 跨节点在可读写节点执行只读查询
  这个需要全局快照管理来保证子节点返回数据的一致性
* 跨节点执行读写查询
  这个需要全局快照管理器和全局事务管理器</p>

    </div>

<div class="meta">
    
    <span class="comments"><a href="/Built-in-sharding-in-PostgreSQL/#disqus_thread">Comments</a></span>
    
</div>
</article>

  <article class="post">
    <h2 class="title"> 
        <a href="/registration-about-google-voice/">申请 google voice</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2016-11-14T16:02:30.000&#43;08:00' itemprop="datePublished">2016-11-14</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/google">google</a>


</div>
    </div>
        <p>昨天晚上突然想申请一个 google voice 帐号。有了之后就可以作为国外的号码使用了，可以打电话收短信，想想好像还有点用。比如我就可以用他注册一个微博帐号用来关联一些无聊的服务了。。。</p>

<p>申请的过程网上很多，不细说了。主要注意下面几点。</p>

<ol>
<li>需要美国 ip 打开 <a href="https://www.google.com/voice">https://www.google.com/voice</a> ，否则会跳转到一个帮助页面。这个从网上搜一些免费的代理就可以了。我是搜索到了一些 ss 帐号，然后配合 surge 来做的。</li>
<li>需要一个能接电话的美国号码来接受 google voice 的验证电话。这个我是通过 <a href="http://textnow.com">http://textnow.com</a> 来做的。登录 textnow.com 注册一个免费的帐号，其中有一步是需要输入一个美国区号，这个要注意，我第一次注册的时候，输入的是 213 (洛杉矶地区的)，然后就不行，后来又申请了一个 517 的就可以。所以最好搜索一下别人申请成功的区号有哪些，另外还好就是只要有不同的邮箱，就可以多次注册来换号码，如果遇到不行的，可以换个邮箱重新注册一下。</li>
<li>在 google voice 里面填入电话之后。google voice 会打电话给那个号码。我用 textnow 的 ios 客户端接的电话（建议不要用他们的 web，他们的 web 必须要你的浏览器支持 flash 才行，很恶心），我遇到的情况下，前几次接到的电话没有对方的声音，自己尝试直接输入号码也不行。后来多试几次就好了。</li>
<li>后面就是选号了。选好号码之后，点提交一般都会遇到一个错误，「There was an error with your request. Please try again」, 遇到这个是正常的。需要你多次点击那个按钮提交，有人用按键精灵点了几个小时搞定了。我这是打开 chrome 的 dev tools，然后看 network 里面发的请求，每次点击都会有一个 post 请求，在上面按右键，选择 「copy as curl」，然后在命令行写一个简单的程序，<code>while true; do 这里把复制的内容贴过来 ;sleep 1.5s; done</code>，复制到命令行，不停的重试就可以了，直到收到邮件说你的号码开通了。要注意的是命令行也得设置代理，一般是通过 export。</li>
</ol>

    </div>

<div class="meta">
    
    <span class="comments"><a href="/registration-about-google-voice/#disqus_thread">Comments</a></span>
    
</div>
</article>

  <article class="post">
    <h2 class="title"> 
        <a href="/new-and-old/">新与旧</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2016-11-13T13:39:18.000&#43;08:00' itemprop="datePublished">2016-11-13</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/heart">heart</a>


</div>
    </div>
        <p>北京有个古北水镇，运营上据说是杭州乌镇的那拨人。乌镇没去过，去过古北水镇。在一片山里面，长城下面，一群建筑。里面还开了一些模仿古代的商店，比如酒家，染坊这些可以参观。</p>

<p>这个地方离北京大概是 2 个多小时的车程（全程高速不怎么堵车的情况下）。周末过去之后会发现停车场停满了车，还有好多旅游车，水镇上面也人山人海。</p>

<p>这里面的建筑都是后期开发商人工开辟的。景区里面的酒店基本都是1k起，并且还得提前预约。据说夜景很漂亮，不过我没看过。</p>

<p>北京是个古老的城市，如果城区里面的历史建筑都留着，现在可够你转几个月的，光就绕着北京城墙走一圈，估计一天都不一定可以。曾经在西安的城墙上面走过一圈，感觉还不错，我记得还收了门票的。</p>

<p>北京有个南锣鼓巷，过去转你会发现并没有什么能让你理解回味京味的东西，卖的也是羊肉串奶茶这些，排好长的队买一串拿着边吃边走完了，其实可能也挺没意思的。</p>

<p>都说台湾是中华传统保持比较好的地方。去了台北第一印象就是，破房子挺多的。那边房子是私产，所以拆迁很难。然后个人又不一定有能力翻盖，所以就有破烂的房子。给我们开车的台湾人还说去过北京，说羡慕那边的高楼大厦，到处都很新，很时髦的样子。</p>

<p>台湾有很多夜市，去过几个，有的比较商业化的，你会发现周边也都是高楼了。有的就是普通的，真的是一条路白天行车，晚上就堵起来开始摆摊。我记得某个夜市里面有个摊位，说是开了好多年了，现在物价高，不得已只好比早年涨了几毛钱。看着都震惊了，涨几毛钱还废什么话，况且本身人家卖的也不贵，都是良心价。</p>

<p>地价涨没那么快，可能各种基础花费都会比较稳定，否则地价涨了房租涨了，那物价必定会涨。所以10年前我在北京长椿街那上班的时候，一份盖饭，大概是 7，8 块钱。到了现在，估计是翻一倍。另外这种店还越来越少，因为卫生条件，房租这些要求导致价格底了不好赚钱。</p>

<p>台湾夜市里面也经常能碰见那种几十年的老店，那真的是几十年一直在做那个生意。几十年价格也没有变化太多。想起来前门的那个面馆前段时间关门了，没有办法，涨价没法涨，收入基本不变的情况下，地价变化太大，只好关门了。</p>

<p>就目前这个房地产的情况，北京还能有多少真正的老字号，有多少真正的老街，估计基本不会有了。后面估计会有更加多人工的景区了，费用估计还不能便宜了。</p>

<p>想起来凤凰古城了，大家不愿意拆，那就某天一把火烧了，这下都同意了吧，这可是天意。</p>

    </div>

<div class="meta">
    
    <span class="comments"><a href="/new-and-old/#disqus_thread">Comments</a></span>
    
</div>
</article>

  <article class="post">
    <h2 class="title"> 
        <a href="/decorator-in-python/">python 的 decorator 学习</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2016-10-21T18:50:59.000&#43;08:00' itemprop="datePublished">2016-10-21</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/python">python</a>

<a href="/tags/decorator">decorator</a>


</div>
    </div>
        <p>最近学习了一下 python 的 decorator（装饰器），看的是这篇，<a href="http://coolshell.cn/articles/11265.html">Python修饰器的函数式编程</a>， 觉得挺有意思的，写点东西记录一下。</p>

<p>装饰器简单讲就是返回一个函数的函数/类。看个简单的例子。</p>

<pre><code class="language-python">#!/usr/bin/python
# -*- coding: utf-8 -*-


def dec1(fn):
    print('inside dec1')

    def wrapper():
        print('inside wrapper')
        return fn()
    return wrapper


@dec1
def f1():
    print('inside f1')

if __name__ == '__main__':
    print('begin exec')
    f1()
    print('end exec')

# 执行结果:
# inside dec1
# begin exec
# inside wrapper
# inside f1
# end exec
</code></pre>

<p>看上面例子能看到，装饰器生效有 2 个步骤，第一个是装饰，第二个是执行。上面装饰器的效果，和下面的代码的效果是一样。</p>

<pre><code class="language-python">#!/usr/bin/python
# -*- coding: utf-8 -*-


def dec1(fn):
    print('inside dec1')

    def wrapper():
        print('inside wrapper')
        return fn()
    return wrapper


# @dec1
def f1():
    print('inside f1')

if __name__ == '__main__':
    print('begin exec')
    dec1(f1)()
    print('end exec')

# 执行结果:
# begin exec
# inside dec1
# inside wrapper
# inside f1
# end exec
</code></pre>

<p>可以看到除了 「begin/end exec」，其他部分执行结果是一样的。所以理解装饰器，就把 <code>@dec1</code> 换成 <code>dec1(fn)()</code> 这么理解就可以了。</p>

<p>有时候会看到类也可以作为装饰器使用。其实理解起来也类似。举个例子。</p>

<pre><code class="language-python">#!/usr/bin/python
# -*- coding: utf-8 -*-


class dec1(object):
    def __init__(self, fn):
        print('inside dec1')
        self.fn = fn

    def __call__(self):
        print('inside wrapper')
        return self.fn()


@dec1
def f1():
    print('inside f1')

if __name__ == '__main__':
    print('begin exec')
    f1()
    print('end exec')

# 执行结果:
# inside dec1
# begin exec
# inside wrapper
# inside f1
# end exec
</code></pre>

<p>这里和上面类似，把 <code>@dec1</code> 理解成 <code>dec1(fn)()</code>，不过是这里的 <code>dec1</code> 是个类，那么 <code>dec1(fn)</code> 其实是调用的 <code>dec1.__init__(fn)</code>，那么后续的 <code>dec1(fn)()</code> 就是调用产生的对象的 <code>dec1.__call__()</code> 了。</p>

<p>有时候还能看到加了参数的装饰器。加了参数的是怎么回事呢。再看下面的例子。</p>

<pre><code class="language-python">#!/usr/bin/python
# -*- coding: utf-8 -*-


def dec1(name):
    print('inside dec1')

    def real_dec1(fn):
        def wrapper():
            print('inside wrapper')
            return fn()
        return wrapper
    return real_dec1


@dec1(name='1')
def f1():
    print('inside f1')

if __name__ == '__main__':
    print('begin exec')
    f1()
    print('end exec')

# 执行结果:
# inside dec1
# begin exec
# inside wrapper
# inside f1
# end exec
</code></pre>

<p>看懂了没有，就是多了个嵌套而已。遇到加了参数的，那就是把之前的没有参数的部分返回回来就可以了。等价的例子就不贴了，这个等价于 <code>dec1(name='1')(fn)()</code>。</p>

<p>如果是类装饰器，并且有参数，那等价于 <code>dec1(name='1')(fn)()</code>，其中 <code>__init__(self, name)</code> 先处理第一层参数，然后 <code>__call__(fn)</code> 处理第二层，然后需要在 <code>__call__</code> 里面再定义一个 wrapper 返回。</p>

<p>说明白没有？呵呵。</p>

    </div>

<div class="meta">
    
    <span class="comments"><a href="/decorator-in-python/#disqus_thread">Comments</a></span>
    
</div>
</article>

  <article class="post">
    <h2 class="title"> 
        <a href="/about-http-cookie/">cookie 的一点研究</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2016-09-16T08:59:09.000&#43;08:00' itemprop="datePublished">2016-09-16</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/http">http</a>

<a href="/tags/cookie">cookie</a>


</div>
    </div>
        <p>这几天搞了一下 python 里面 cookie 相关的东西。我的目的是想要尝试用 python 登录某个网站，并且保持登录状态直到过期。因为 http 协议是无状态的，所以一般来讲，网站想要用户保持登录，那么网站在用户登录之后，必须要和用户端协商好怎么来证明这个用户已经登录过了。</p>

<p>用户端如果使用浏览器，那么网站就可以利用浏览器对 cookie 的支持来让用户在不知情的情况下，让网站在用户登录后发的一个 token 在用户后续的请求里面都包含上。</p>

<p>用户端如果不是浏览器，比如是个 python 程序，那么网站可以和用户协商每次请求里面都包含某个下发的 token（当然，甚至要求客户端每次请求都带着用户名密码也是可行的）。</p>

<p>但是如果网站本身只是给浏览器用户准备的，那么通过用程序来「模拟」浏览器行为，把必要的 token 保存并在后续的请求里面都带上，也是可行的。</p>

<p>python 里面，发送 http 请求可以简单的使用 <code>urllib.request.urlopen(url)</code>，但是如果想要定制一下请求，比如修改一些 header 信息，那么就得使用 <code>urllib.request.Request</code> 这个 class 先构造一个 Request 对象，然后传递给 urlopen 了。</p>

<p>如果要处理 cookie，那就需要使用 <code>http.cookiejar.CookieJar</code> 了，有了 Cookiejar 对象，就可以把网站下发的 cookie 保存到这个变量里面，然后在必要的时候，可以返回给服务器端了。如果想要保存到文件，那么可以使用 <code>http.cookiejar.LWPCookieJar</code> 或者 <code>http.cookiejar.MozillaCookieJar</code>，也可以基于 <code>http.cookiejar.FileCookieJar</code> 自己实现一个子类，来用自己的办法保存和加载 cookie，比如保存到数据库什么的，这样就可以多台机器之间共享 cookie 了。</p>

<p><code>urlopen</code> 本身不支持自定义 cookiejar 逻辑，得使用 <code>opener = build_opener(HTTPCookieProcessor(cookiejar=Cookiejar对象))</code> 来先构造一个自定义的 openner, 然后使用 <code>opener(Request对象)</code> 来发送请求。</p>

<p>如果不定义自己的 cookie policy，那么会使用默认的 <code>http.cookiejar.DefaultCookiePolicy</code>，也可以自己基于 <code>http.cookiejar.CookiePolicy</code> 实现自己的逻辑。只需要 override <code>set_ok</code> 和 <code>return_ok</code> 这两个方法就可以。</p>

<p>http cookie 其实有很多属性，比如 domain, expire, path 等常见属性，也有 httponly, secure 等几个不常见的。这些属性都是浏览器处理的。就是说，浏览器把 cookie 返回给服务器端的时候，如果 domain 不匹配，或者已经过了 expire 时间等等一些不符合浏览器制定的 cookie 逻辑的时候，浏览器就不会把 cookie 发送给服务器端。就比如，服务器产生 cookie 的时候，声明了 domain=a.com，那么如果是来自于 b.com 的请求，浏览器是根本不会给他发送这个 cookie。再比如，服务器端产生 cookie 的时候，声明了 1 天后过期，那么 1 天之后，浏览器也不会再给服务器端发这个 cookie 了。</p>

<p>但是如果是我们自己实现客户端模拟浏览器的时候，其实我们是可以耍流氓的，可以制定自己的 cookie 逻辑，也就是上面提到的 cookie policy。比如我可以简单的在 <code>return_ok</code> 这个方法里面 <code>return True</code>，在任何情况下都把所有的 cookie 返回给服务器，这样服务器端如果不提前想明白，它是一点都不知道的。</p>

<p>所谓提前想明白就是想明白是不是需要针对这种情况做处理。如果本身我们系统也没有那么严格要求，那么不处理也可以。但是如果是某个比如金融系统，那么是必须要考虑的。否则如果完全依赖 cookie 的话，如果我通过某些手段弄到了用户的 cookie，那么我就可以骗过服务器端，让他认为我就是那个用户。</p>

<p>我想了一下，貌似被盗窃 cookie 这种事情服务器端不太好防范，但是可以做的是防止浏览器耍流氓。比如我们把 cookie 加密，并里面增加一个发送 cookie 的时间。收到客户端发过来的 cookie 之后，我们解密看看时间有没有过期，这样就可以在服务器端让 cookie 失效了。</p>

<p>另外，也可以考虑使用 session。session 是把一些用户的状态保存在服务器端。但是 session 实际上也是依赖 cookie 的，因为前面说了 http 协议无状态，就算可以把用户状态保存在服务器端，但是总还是得识别用户才可以。那个识别的 cookie 就是所谓的 session cookie，其实就是某个用户的唯一标识。</p>

<p>对于 session cookie 被窃，好像也没有太好的办法，无非也是想办法比对之前用户的一些状态信息，比如 ip 和现在的信息是不是一致，不一致可以认为有被窃的怀疑，这个时候让用户再次验证用户信息，这都不能 100% 保证，但是至少会增加窃贼的成本。</p>

<p>上面说到这些，都可以自己测试一下，测试也并不一定需要搭一个服务器端配合，以及使用复杂的抓包专鉴，其实使用 <code>nc</code> 就可以。</p>

<p>使用 <code>nc -l 9999</code> 就可以启动一个监听在 9999 端口的 socket 服务器。之后使用 python 或者 curl 之类的程序请求，就能立刻看到请求发送过来的 http 信息，这个对于学习 http 协议其实也很方便。</p>

<pre><code>$ nc -l 9999
GET / HTTP/1.1
Accept-Encoding: identity
Connection: close
Cookie: QN2=test; QN1=ClbaCVfZF5lfszBALzTIAg==
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6)  AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36
Host: localhost:9999

</code></pre>

<p>收到的上面这个请求，可以看到发送过来了 2 个 cookie。</p>

<p>如果还想测试数据返回的情况，那么可以写一个 <code>test.resp</code> 文件，内容如下</p>

<pre><code>$ cat test.resp
HTTP/1.1 200 OK
Date: Sun, 18 Oct 2009 08:56:53 GMT
Server: Apache/2.2.14 (Win32)
Last-Modified: Sat, 20 Nov 2004 07:16:26 GMT
ETag: &quot;10000000565a5-2c-3e94b66c2e680&quot;
Set-Cookie: QN1=ClbaCVfZF5lfszBALzTIAg==; expires=Thu, 31-Dec-37 23:55:55 GMT; path=/
Set-Cookie: QN2=test; expires=Thu, 31-Dec-37 23:55:55 GMT; path=/; secure; httponly
Accept-Ranges: bytes
Content-Length: 44
Connection: close
Content-Type: text/html
X-Pad: avoid browser bug

&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;
</code></pre>

<p>然后使用 <code>nc -l 9999 &lt; test.resp</code> 命令启动服务，客户端来请求的时候，就会返回上面 <code>test.resp</code> 里面的内容。</p>

    </div>

<div class="meta">
    
    <span class="comments"><a href="/about-http-cookie/#disqus_thread">Comments</a></span>
    
</div>
</article>

  <article class="post">
    <h2 class="title"> 
        <a href="/double-pinyin/">从双拼讲输入法</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2016-08-20T10:00:51.000&#43;08:00' itemprop="datePublished">2016-08-20</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/input">input</a>


</div>
    </div>
        <p>上高中的时候，就流行五笔打字，不过那会家里都没有电脑，都是去网吧（或者叫打字社）去学习的，不过那会学习这个貌似唯一的用途就是录入用。</p>

<p>当时也背过五笔的码表，王旁青头兼五一，估计很多人都很熟悉。上了大学在有更多机会接触电脑的时候，上网什么的，自然就开始使用拼音输入法，因为基本不需要练习，会盲打知道键盘按键键位就可以使用。当时用的比较多的是智能 ABC，后来 2000 年左右写书的时候，用的是紫光拼音，紫光的词库比智能 ABC 好一点，所以用起来也好用很多。此后一直使用拼音输入法。</p>

<p>直到应该是大概 2008 年左右，ssslang 在使用二笔，就开始想尝试一下码表输入法。因为本身使用了这么多年的电脑输入和拼音输入法之后，对字形其实已经失去了概念，如果学五笔的话，肯定会是很痛苦的。</p>

<p>而二笔输入法一个字 4 个码，第一个码还是拼音的第一个字母，但是大部分常用字都是 2 个码就可以出，所以这样等于每个字都至少知道了一半的编码，这个还是很赞的。</p>

<p>二笔输入法也有很多编码方案，当时选的是哲豆二笔，这个方案只用了 26 个字母键，所以也可以在手机上面使用（其他方案用了一些符号键，比如 [ ]，当时手机还都是流行硬键盘，一般都没有单独的符号键，而且貌似现在的软键盘也没有单独的符号键）。我当时用的 palm treo 650，输入还是蛮爽的。后来自己把一些词库导入了进去，用起来就更加舒服了。</p>

<p>但是后来的问题是慢慢的一些流行的智能机没有那么好的输入法自定义支持，就没法用了，慢慢切回来了拼音输入法。</p>

<p>二笔是码表输入法，就是每个字有自己的编码，联系的过程就是熟悉码表的过程，如果某个字不熟悉，那么其实你是需要轻微的思考的，想一下那个字怎么写，是哪个码。所以输入的速度取决于对这些字的熟悉程度，遇到不熟悉的会有卡顿。</p>

<p>最近看到了不少双拼的讨论，就想尝试一下双拼。因为如果反正都是用拼音输入法，那么对于 ing, eng 这些，如果可以按一个按键就输入进去，那么岂不是可以节省很多时间？并且这个还是基于拼音的，和那些需要记住字形的输入法不是一个套路，看着还不错。</p>

<p>我是这周一开始尝试的。mac 上面用的是鼠须管，ios 用的 touchpal。双拼也有很多方案，我选的方案是小鹤双拼，也没啥特别的原因，就是看用的人挺多的。</p>

<p>尝试的结果就是，输入了 4 天之后，周五我又换回了拼音输入法。。。。</p>

<p>因为我越用越发现，双拼也是个码表输入法。开始想得是节省拼音的输入时间，但是打字的时候，比如输入 hao 的时候，想到的不是输入 h 然后输入 ao 对应的字母 c，而是熟悉之后自然而然的按照 hc 来输入，下次需要输入 lao 的时候，还是需要想一下 ao 在字母 c，需要输入 lc。</p>

<p>这么看的话，和前面说的码表输入法有啥区别呢？所以我感觉双拼也是个码表输入法。既然是码表输入法，双拼的区分度那么差，何必折腾他呢，不如去用二笔呢。而且我用的时候最郁闷的是，二笔训练出来的键位记忆居然总会出来捣乱，这其实也更加说明这个就是码表输入法。。。</p>

<p>而且还有就是，普通拼音输入法里面，尤其是手机上面，容易按错键，比如 hao 输入成了 hso 的时候，手机上面会纠错，把「好」这个选项放在第一个。但是如果是双拼就没那么好搞了，如果也增加纠错，那会增加很多重码，体验不好。</p>

<p>另外还有个问题就是对于 sh, s, en, eng 这些不太清楚的人来讲，更加是个挑战，当然拼音可以用模糊音，按说双拼也可以想办法自定义模糊音。但是可能就失去了双拼的一些优势。</p>

    </div>

<div class="meta">
    
    <span class="comments"><a href="/double-pinyin/#disqus_thread">Comments</a></span>
    
</div>
</article>



  <nav id="pagenavi">
    
        <a href="/" class="prev">Prev</a>
    
    
        <a href="/page/3/" class="next">Next</a>
    
  <div class="center"><a href="/archives/index.html">Blog Archives</a></div>
  </nav>


    </div>
    <footer id="footer">
    <div style="display:inline">
    Copyright &copy; 2017
    
    wd
    . Powered by <a href="http://gohugo.io" target="_blank">Hugo</a> |
    Theme is <a href="https://github.com/wd/hugo-fabric">hugo-fabric</a>, fork from <a href="https://github.com/wd/hexo-fabric">hexo-fabric</a> by <a href="https://wdicc.com">me</a>
</div>

    </footer>
    <script src="/js/fabric.js"></script>


</div>
</div>
<script src="/js/jquery.ui.totop.js" type="text/javascript"></script>
<script type="text/javascript">
 
;(function($){$().UItoTop({easingType:'easeOutCirc'});})(jQuery);
 
</script>
</body>
</html>
