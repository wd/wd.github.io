<!DOCTYPE HTML>
<html>
<head>
	<meta name="generator" content="Hugo 0.19" />
	<meta charset="utf-8">
    
    
    <title>wd and cc</title>
    <meta name="author" content="wd">
    <meta name="description" content="">
    <meta name="keywords" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <link href="https://wdicc.com/index.xml" rel="alternate" title="wd and cc" type="application/atom+xml">
	<link href="/favicon.ico" rel="shortcut icon">
    <link href="/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
    <link href="/css/custom.css" media="screen, projection" rel="stylesheet" type="text/css">

    <link href='//fonts.googleapis.com/css?family=Slackey' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Fjalla+One' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Amethysta' rel='stylesheet' type='text/css'>
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
    

    <script type="text/javascript" src="/js/jquery-tapir.js"></script>

    

    <link rel="stylesheet" href="/css/hljs.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
</head>


<body>
    <div id="wrapper">
        <header id="header" class="inner">
<h1 class="animated bounceInDown">
    <div id="headerbg">
        wd and cc
    </div>
</h1>

<span class="subtitle">happy every day</span>
<br>

<ul id="social-links" style="text-align:center; clear:both;">
    
    
    <li>
    <a href="https://github.com/wd" class="github" title="Github"></a>
    </li>
    
    
    
    
    
    <li>
    <a href="http://www.twitter.com/wd" class="twitter" title="Twitter"></a>
    </li>
    
    
    
    
    
</ul>


<ul id="nav">
	<li id="ajax"><a href="/index.html">Home</a></li>
	<li id="ajax"><a href="/archives/index.html">Archives</a></li>
	<li id="ajax"><a href="/tags/index.html">Tags</a></li>
    <li><a href="/atom.xml">RSS</a></li>
    <li>
    <div id="dark">
        <form action="//www.google.com.hk/search" method="get" accept-charset="UTF-8" id="search">
            <input type="hidden" name="sitesearch" value="https://wdicc.com/" />
            <input type="text" name="q" results="0" placeholder="Search..." x-webkit-speech />
        </form>
    </div>
    </li>
</ul>

</header>

<div id="toload">

    <div id="content" class="inner">
        




    
    <script id="dsq-count-scr" src="//wdicc.disqus.com/count.js" async></script>
    




  <article class="post">
    <h2 class="title"> 
        <a href="/evolution/">进化论</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2016-08-20T09:55:17.000&#43;08:00' itemprop="datePublished">2016-08-20</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/tech">tech</a>


</div>
    </div>
        

<h2 id="回忆一些没用的">回忆一些没用的</h2>

<p>我是 1998 年上的大学。小的时候就对各种电子产品比较感兴趣，当然其实没有什么机会的，当时主要就是游戏机，但是我家里是没有的。高中的时候曾经借同学的回家玩过，和我弟弟一起玩的挺嗨，但是对于增长知识应该是没啥用的。</p>

<p>高考完毕之后，其实最想要报的还是计算机系，记得暑假的时候在电视里面看电脑相关的讲座，讲的最多的好像就是五笔，那会 windows 用户也不多，都是用的 dos。ucdos 是最常用的。那会电脑最大的用途感觉就是打字输入，然后打印。</p>

<p>当时没有报计算机，因为闭塞的农村人认为计算机会和财经一样（当时财经类专业曾经火过一些时间，但是介于毕业的人都没啥靠谱工作，所以就认为一般了），过段时间就不行了，所以没有报这块，报的是应用物理专业（当然了，这个专业更屎）。</p>

<p>那个假期去我舅舅的办公室去玩玩电脑。我舅舅是微机专业毕业的，毕业后回我们那边做类似一个打字的工作（其实我也不知道具体做什么&hellip;.）。我当时去那边就是熟悉各种 dos 命令，学习一下 foxbase。</p>

<p>当时我记得有一本 foxbase 的书，看里面东西看不懂，没有现在的论坛和方便的网络，没有人可以交流。我记得印象最深的是有一道题需要算 1+2+3+&hellip;+100 等于多少，不懂编程完全不知道怎么做这个事情，但是看了答案看不懂，因为不懂 i=i+1 是什么意思，那会不明白为什么 i 还可以在右边。现在看来，生在那个年代那个地方真的很悲哀。</p>

<p>进入大学之后，选修了一门 word 之类的课，开始接触 windows。然后宿舍同学熟悉之后，就计划一起买了一台电脑，每个人 1200，我们总共 6 个人，7200 一台电脑，包括音箱电脑桌。当时要上网只能是拨号，56k 猫，开始是用不起的，大概到了大2，3 才开始拨号。然后 6 个人轮流用。那是我们班的地一台电脑，当时辅导员要求大家写保证书，保证不玩游戏才允许买。当然，你们懂得，保证书有个卵用，所以后来某天被发现玩游戏之后，给我们把电脑格式化了。但是之后大家还是会玩。</p>

<p>上了大学之后，就有网络中心，第一次去网络中心的时候，有点懵逼，和 xh 两个人对着电脑不知道该干啥。旁边的人都在玩 mud，当时不懂，就是看着一个绿窗口觉得很神奇。当然后来我们玩 mud 到昏天黑地就不多说了。玩 mud 玩的多了，慢慢了解到了 mud 的机制，有时候自己搭一个开始研究里面的编程，不过还比较粗浅。当时学的也就是 fortrun，c 语言这些。</p>

<p>那会的搜索引擎是目录式的，就和黄页一样，除了去看一些门户，就是翻这些东西，希望发现一些有意思的东西。那会学习也基本是靠买书和看自带的文档（不如 msdn），和通过网络靠一些小论坛里面的一些交流。那会写的比较多的是 vc vb 这些，php 之类学的人不多，java 我记得好像也不多。我的毕业论文是一个 vb 的程序，现在看写的比较烂，也就是能用。</p>

<h2 id="开始讲网站开发">开始讲网站开发</h2>

<p>前面废话太多，又不太舍得删掉，就分一下块吧，下面讲讲网站开发技术的进化。</p>

<h3 id="dreamwaver-frontpage-时代">dreamwaver &amp; frontpage 时代</h3>

<p>那会做网页比较多的应该是 asp，用 frontpage 写，用 iis 发布，都是图形界面的，linux 没有什么人会用。linux 下面那会各种问题，驱动输入法这些都得花费很大的精力去解决。我装的第一个 linux 应该是 xterm linux，11 张光盘，因为他把一些软件也刻录到光盘了。第一次装 linux 就把宿舍的电脑搞挂了，没选对直接重新分区了。不过也就当年折腾这些弄明白了分区表 mbr 这些东西。</p>

<p>那会还攒了一些书，有一本就是讲怎么用 dreamwaver 的，当时觉得这个东西真牛逼，抛弃了 frontpage。我还记得我用 frontpage 做的第一个自我感觉良好的网页给别人看的时候，人家的那个表情，基本就是想吐的那种。我现在想，典型的那些花背景底色，大字体，图片按钮，来回滚动的一些内容等等，都是很烂的。</p>

<p>基于对 dreamwaver 的熟悉，当时还去联想实习了一段时间，给他们解决了一些问题。</p>

<p>那会做网页一般也就是收个表单，存到数据库什么的，不会有太复杂的东西。做个论坛是最常见的了。那个年代 javascript 是忌讳的东西，一般也就是用来滚动个页面标题什么的，没人拿他做特牛逼的东西。</p>

<p>毕业之后，就进了出版社。那个时代桌面程序很流行，因为大部分电脑都不能上网的，我到了出版社凭着自己的兴趣，用 vb 做了一个库存管理的软件，其实就是入库多少，出库多少登记一下，简单的很。</p>

<p>后来也是自己的兴趣，找了一台没人用的电脑，windows 上面跑起了 java web 服务，那会还流行搞一些 java applet 跑。出版社最早的网站就是这么跑起来的。</p>

<p>在后来装了一个 linux，开始在上面跑 qmail，跑 apache，开始熟悉 linux。同时也有了 php 的网站，不是我开发的，跑在我那个 linux 机器上面。</p>

<h3 id="ajax-mvc">ajax &amp; mvc</h3>

<p>后来大概有几年没有接触这些了，大概 08 年左右接触到了 ajax，javascript 算是就那几年走上神坛。当时老何演示了一个跑在本地浏览器里面的留言本程序，服务器端不用提供任何 html 相关的服务，只需要保存数据返回数据就好，逻辑都跑在本地浏览器里面。</p>

<p>不过那个时候我写的比较多的还是那种古老的表单方式，自己没去仔细了解这种新技术。后来大概 09 年左右有机会开始写 javascript 的时候了解了一些机制，感觉这种方式很有意思，渲染逻辑跑在浏览器，这样节省了一些服务器端的压力，并不是什么操作都需要提交到服务器让服务器去判断下一步怎么办。那会用到了 jquery，感觉真的好方便，并且他还提供一些 css 的效果，让不太熟悉的人也可以很方便的搞起来。而服务器端那会用 php 比较多。</p>

<p>php 当时也接触了一些框架，名字是不记得的。我这种野路子程序员，根本不明白人家的一些设计思路，代码和模板分离，mvc 这些都不懂，不过代码看多了也能明白一些。</p>

<p>我记得 09 年写这些的时候，一个遗留的 php 网站，需要增加一点功能，发现需要我一个人在 n 个文件里面修改，楞要把一个功能分散个 n 个文件让我很不理解，不是蛋疼么。当然后来明白这么做是为了分工合作为了灵活扩展，那么如果就一个人写的时候，我们是不是也需要这么做呢？</p>

<h3 id="emberjs-angular-react-django-spring">emberjs &amp; angular &amp; react &amp; django &amp; spring</h3>

<p>后来大概 10 年左右的时候，我写代码还是用 jquery 的方式来做，因为当时觉得很好用。再后来接触了一些 emberjs angular 的一些知识。学习到了 emberjs 里面的命名惯例，比如一个路由叫 posts 那么就有对应的 PostsController，不用你显式的去让他们产生关系。学习 angular 学到了双向绑定的概念，你在定义了一个模型之后，在模板里面用到变量的地方会自动跟着这个模型的数据变化而变化，这就比用 jquery 的时候需要你自己去替换 dom 里面的内容方便多了。然后到了现在的 react 又提出了 virtual dom 的概念，让你不需要关心 dom 结构，你只需要操作你的虚拟 view 就好了。</p>

<p>当然前端其实还有好多的进步，比如 coffee script 来解决 javascript 这个语言本身的一些问题，哪里不严谨，一些最佳实践什么的就不用你操心了，只需要写 coffee script 就好了，编译成 javascript 之后，会自动处理好。</p>

<p>还有比如 css 不能 include，import，很多方案来解决这个问题。</p>

<p>后端这块，最近接触了 django，spring 这些。程序员要分 2 类的话，那就是 java 的和非 java 的，要分三类的话，就是 java ，javascript 和其他，呵呵。看过之后感觉 spring 真是不错的东西。难怪 java 程序员不去了解其他的，入了 java 坑就不用搞其他的了，库类很方便。并且类似 spring 这种东西，好多年前就有了，可以极大的方便 web 开发（不止 web 开发可以用）。如果能很好的驾驭 java，驾驭 tomcat jvm 这些东西，那么使用 java 其实是很不错的方案。通过 java 的 oo 特性，比如继承，重载 interface abstract 这些，可以很方便的定义好一些规范，也可以很好的把大家的工作划分开，架构，定义模型定义接口的人大家协同工作。</p>

<p>以前文件路径就是网页路径，现在有了 route 的概念（这个概念在 angular, emberjs 里面也有)，做了 route mapping 之后，可以很方便的把不同的 route 映射到相同的方法上面，可以很方便复用代码逻辑。</p>

<h2 id="总结下">总结下</h2>

<p>上面讲了很多，整个就是个进化史。以前弄个网站出来需要花不少时间，还很难看。现在基于 bootstrap 还有这些开发框架，做一个出来很快外观还好看。这就是进步。</p>

<p>计算机技术的颠覆是很快的，如果打算一直从事这块工作，建议还是得保持一颗持续学习的心态，也得扩展自己学习的广度，这样可以吸收到各种技术的长处。</p>

<p>现在学习的手段也多了很多，我看视频直播网站都有开始讲课的了（不一定靠谱），还有各种学习视频，更别说各种可参考的学习文档了。实在是太方便了，只要愿意花时间，进步速度绝对很快。</p>

    </div>

<div class="meta">
    
    <span class="comments"><a href="/evolution/#disqus_thread">Comments</a></span>
    
</div>
</article>

  <article class="post">
    <h2 class="title"> 
        <a href="/LLD-in-zabbix/">LLD in zabbix</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2016-07-30T14:09:58.000&#43;08:00' itemprop="datePublished">2016-07-30</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/zabbix">zabbix</a>

<a href="/tags/monitor">monitor</a>


</div>
    </div>
        

<p>如果需要监控的内容比较多的时候，手动管理报警信息就已经不使用了，加一批机器就需要忙活一阵子。也不能体现我们充满智慧的大脑的作用。</p>

<p>zabbix 支持 LLD(low level discovery) 方式来自动产生监控项目，包括 item, trigger 这些都可以自动添加。大概讲解一下可以利用这个东西做什么事情。</p>

<h2 id="zabbix-收集数据的方式">zabbix 收集数据的方式</h2>

<p>zabbix 有很多收集数据的方法，这里重点讲 2 个，一个是 <code>zabbix agent</code>，一个是 <code>zabbix traper</code>。这两个方式可以和 nagios 里面的 active 和 passive 方式做类比。traaper 方式对应的就是 passive，就是 client 主动发送数据给 server。</p>

<p>对于 zabbix agent 方式，我们可以自己定义一些 <code>userParameter</code> 来添加自定义监控，这些网上很多例子。如果使用 trapper 方式，那么原则上面可以不用做任何自定义，就可以通过 zabbix-sender 或者自己模拟 sender 的协议，通过比如 python，java 等发送自己的监控信息。通过 python 发送的例子网上也有。</p>

<h2 id="lld">LLD</h2>

<p>参考<a href="https://www.zabbix.com/documentation/3.2/manual/discovery/low_level_discovery">这里</a>，LLD 主要的思路就是给服务器端发送一个 json 数据格式。例如下面这个。</p>

<pre><code>{
  &quot;data&quot;:[
  
  { &quot;{#FSNAME}&quot;:&quot;/&quot;,                           &quot;{#FSTYPE}&quot;:&quot;rootfs&quot;   },
  { &quot;{#FSNAME}&quot;:&quot;/sys&quot;,                        &quot;{#FSTYPE}&quot;:&quot;sysfs&quot;    },
  { &quot;{#FSNAME}&quot;:&quot;/proc&quot;,                       &quot;{#FSTYPE}&quot;:&quot;proc&quot;     },
  { &quot;{#FSNAME}&quot;:&quot;/dev&quot;,                        &quot;{#FSTYPE}&quot;:&quot;devtmpfs&quot; },
  { &quot;{#FSNAME}&quot;:&quot;/dev/pts&quot;,                    &quot;{#FSTYPE}&quot;:&quot;devpts&quot;   },
  { &quot;{#FSNAME}&quot;:&quot;/lib/init/rw&quot;,                &quot;{#FSTYPE}&quot;:&quot;tmpfs&quot;    },
  { &quot;{#FSNAME}&quot;:&quot;/dev/shm&quot;,                    &quot;{#FSTYPE}&quot;:&quot;tmpfs&quot;    },
  { &quot;{#FSNAME}&quot;:&quot;/home&quot;,                       &quot;{#FSTYPE}&quot;:&quot;ext3&quot;     },
  { &quot;{#FSNAME}&quot;:&quot;/tmp&quot;,                        &quot;{#FSTYPE}&quot;:&quot;ext3&quot;     },
  { &quot;{#FSNAME}&quot;:&quot;/usr&quot;,                        &quot;{#FSTYPE}&quot;:&quot;ext3&quot;     },
  { &quot;{#FSNAME}&quot;:&quot;/var&quot;,                        &quot;{#FSTYPE}&quot;:&quot;ext3&quot;     },
  { &quot;{#FSNAME}&quot;:&quot;/sys/fs/fuse/connections&quot;,    &quot;{#FSTYPE}&quot;:&quot;fusectl&quot;  }
  
  ]
}
</code></pre>

<p>这个数据里面，data 是必须的，里面包含里面发现的可监控数据，这可以是任何数据。例子里面是发现了可以用来监控的磁盘分区。data 是个数组，每个可监控项是一个数组元素。还有类似下面这样的数据。</p>

<pre><code>{
    &quot;data&quot;: [
        {
            &quot;{#HOST}&quot;: &quot;Japan 1&quot;,
            &quot;{#COUNT}&quot;: &quot;5&quot;
        },
        {
            &quot;{#HOST}&quot;: &quot;Japan 2&quot;,
            &quot;{#COUNT}&quot;: &quot;12&quot;
        },
        {
            &quot;{#HOST}&quot;: &quot;Latvia&quot;,
            &quot;{#COUNT}&quot;: &quot;3&quot;
        }
    ]
}
</code></pre>

<p>这个是发现了一些可监控的 host。</p>

<p>理解没有？发现是发现可监控的服务，并不是发现监控项。比如我们可以通过发现这机器上面有没有启动 ssh，发现有启动之后，我们就可以通过服务器端配置 discovery 自动添加一些监控规则。</p>

<pre><code>{
    &quot;data&quot;: [
        { &quot;{#SSH_PORT}&quot;: &quot;22&quot; },
        { &quot;{#SSH_PORT}&quot;: &quot;8022&quot; }
    ]
}
</code></pre>

<p>比如上面这个，我们发现了 2 个 ssh 进程，一个是 22 端口，一个是 8022 端口。</p>

<p>所以重点是发现有什么可监控的服务，并不是发现监控项。</p>

<p>BUT，其实并不是不能发现监控项，也是可以的。不过是，这种被发现的监控项，除非对应的 trigger 也都是一样的，否则你会发现无法分别添加不同的 trigger 规则。</p>

<h2 id="发现监控项">发现监控项</h2>

<p>有了发现服务之后，就肯定需要对相应的服务的一些监控项做监控了。这个给 discovery 规则配置 item prototype 就可以了，不过这个里面有点坑需要填，后面会说，这里先不讲。</p>

<p>那么比如对于 ssh 服务，可以监控
* 当前链接人数，conn.cnt
* 配置文件的 md5，conf.md5（配合 zabbix trigger 可以用来监控文件是不是被修改了）</p>

<p>那监控数据就如下面</p>

<pre><code>{
    &quot;22.conn.cnt&quot;: 4,
    &quot;22.conf.md5&quot;: &quot;18492113fb263c9d0a33c9fea403eea1&quot;,
    &quot;8022.conn.cnt&quot;: 9,
    &quot;8022.conf.md5&quot;: &quot;6cab272daa07202ccb57c4064c0dcfb8&quot;
}
</code></pre>

<p>上面就是一个 discovery 项目，filter 是 {% raw %}{#SSH_PORT}{% endraw %}，和 2 个 item prototype，分别是 {% raw %}{#SSH_PORT}.cnn.cnt{% endraw %} 和 {% raw %}{#SSH_PORT}.conf.md5{% endraw %}。</p>

<h2 id="复杂一点的-lld">复杂一点的 LLD</h2>

<p>一个 LLD 还可以发现多个服务。比如下面这种。</p>

<pre><code>{
    &quot;data&quot;: [
        { &quot;{#SSH_PORT}&quot;: &quot;22&quot; },
        { &quot;{#SSH_PORT}&quot;: &quot;8022&quot; },
        { &quot;{#PG_PORT}&quot;: 5432 },
        { &quot;{#PG_PORT}&quot;: 6432 }
    ]
}
</code></pre>

<p>这个除了我们前面讲的 ssh 服务，还发现了两个 pg 的服务。在服务器端，只需要添加两个 discovery 规则就可以了，分别使用 {% raw %}{#SSH_PORT}{% endraw %} 和 {% raw %}{#PG_PORT}{% endraw %} 这两个宏来过滤数据。</p>

<pre><code>{
    &quot;data&quot;: [
        { &quot;{#SSH_PORT}&quot;: &quot;22&quot; },
        { &quot;{#SSH_PORT}&quot;: &quot;8022&quot; },
        { &quot;{#PG_PORT}&quot;: 5432 },
        { &quot;{#PG_PORT}&quot;: 6432 }
        { &quot;{#MASTER_DB_PORT}&quot;: 5432, &quot;{#SLAVE_DB}&quot;: &quot;host1&quot; },
        { &quot;{#MASTER_DB_PORT}&quot;: 5432, &quot;{#SLAVE_DB}&quot;: &quot;host2&quot; },
    ]
}
</code></pre>

<p>上面这个，除了有 2 个 db 之外，还有一个 db 是个 master，能看到他对应的 slave 有哪些。要注意，我们在新增加的这个发现项里面，不能再使用 {% raw %}{#PG_PORT}{% endraw %} 这个宏了，因为如果使用了这个宏，就会和第3，4个项目无法区分了。所以我们改了一下名字。</p>

<p>到此为止，只是我们的构思，想要告诉 zabbix 我们想要监控什么。真正使用还需要走一些路。</p>

<h2 id="如何发送数据">如何发送数据</h2>

<p>不管是 discovery 数据，还是 item 的监控数据，都可以通过 agent 和 trapper 方式发送。</p>

<p>对于 discovery 数据，使用 agent 发送就是上面讲的格式。</p>

<pre><code>{
    &quot;data&quot;: [
        { &quot;{#PG.OTHER}&quot;: &quot;0&quot; },
     ]
}
</code></pre>

<p>如果使用 trapper 方式发送，格式如下</p>

<pre><code>{
    &quot;data&quot;: [
        {
            &quot;host&quot;: &quot;HOST1&quot;,
            &quot;value&quot;: &quot;{\&quot;data\&quot;: [{\&quot;{#PG.OTHER}\&quot;: \&quot;0\&quot;}]}&quot;,
            &quot;key&quot;: &quot;pg.discover&quot;
        }
    ],
    &quot;request&quot;: &quot;sender data&quot;
}
</code></pre>

<p>上面这个数据里面，data 和 request 是 zabbix sender 的固定格式。data 里面，包含了 host, value, key 三个字段。host 是被监控的 host，和将来服务器端的 host 对应。value 是发送的监控内容，可以看到也就是我们使用 agent 发送的内容。key 就是对应的监控项，这个监控项也就是 agent 方式发送对应的那个 userParameter。</p>

<p>使用 trapper 方式发送里面，是可以伪造被监控的 host 的，所以 trapper 方式并不要求一定要在被监控机器上面执行。</p>

<p>对于 item 监控数据，使用 agent 发送是下面这种格式。</p>

<pre><code>{
    &quot;key1&quot;: 2,
    &quot;key2&quot;: &quot;ok&quot;
}
</code></pre>

<p>使用 trapper 方式发送，是下面的这种格式。</p>

<pre><code>{
    &quot;data&quot;: [
        {
            &quot;host&quot;: &quot;HOST1&quot;,
            &quot;value&quot;: 1,
            &quot;key&quot;: &quot;key1&quot;
        },
        {
            &quot;host&quot;: &quot;HOST1&quot;,
            &quot;value&quot;: &quot;ok&quot;,
            &quot;key&quot;: &quot;key2&quot;
        }
    ],
    &quot;request&quot;: &quot;sender data&quot;
}
</code></pre>

<h2 id="zabbix-里面的限制">zabbix 里面的限制</h2>

<p>上面的例子很完美，但实际上 zabbix 是有一些限制的。比如 item 定义。</p>

<p>假如对于发现的 pg 服务，有一个监控项是连接数，比如 {% raw %}{#PG_PORT}.conn.cnt{% endraw %}，此时你会发现在 zabbix 新建 item 的 <code>Key</code> 那个设置里面，这么写无法提交。需要使用假装类似 userParameter 的方式来写，比如 {% raw %}pg.[{#PG.PORT}.conn.cnt]{% endraw %}，假装那个 <code>pg.</code> 是个 userParameter 命令，{% raw %}[{#PG.PORT}.conn.cnt]{% endraw %} 里面的内容是他的参数。当然，这个 pg. 可以基本可以是任何字符串，比如 abc，你自己觉得有意义就好了。</p>

<p>那么这个时候对于发现那块，我们基本不用动，需要动的是被发送的服务的监控项的命名上面。</p>

<p>比如以那个 ssh 的监控为例，原来发送的数据如下</p>

<pre><code>{
    &quot;22.conn.cnt&quot;: 4,
    &quot;22.conf.md5&quot;: &quot;18492113fb263c9d0a33c9fea403eea1&quot;,
    &quot;8022.conn.cnt&quot;: 9,
    &quot;8022.conf.md5&quot;: &quot;6cab272daa07202ccb57c4064c0dcfb8&quot;
}
</code></pre>

<p>我们只需要修改成这样</p>

<pre><code>{
    &quot;ssh[22.conn.cnt]&quot;: 4,
    &quot;ssh[22.conf.md5]&quot;: &quot;18492113fb263c9d0a33c9fea403eea1&quot;,
    &quot;ssh[8022.conn.cnt]&quot;: 9,
    &quot;ssh[8022.conf.md5]&quot;: &quot;6cab272daa07202ccb57c4064c0dcfb8&quot;
}
</code></pre>

<p>对应的 2 个 item prototype，key 分别修改为 {% raw %}ssh[{#SSH_PORT}.cnn.cnt]{% endraw %} 和 {% raw %}ssh[{#SSH_PORT}.conf.md5]{% endraw %}。那个 ssh 可以随意起。并且其实并不一定就得是这种模式，比如叫做 {% raw %}ssh.conf.md5[{#SSH_PORT}]{% endraw %} 应该也可以，当然需要你发送的数据也做对应修改。</p>

<h2 id="如何发送监控数据">如何发送监控数据</h2>

<p>咦？好像说过一次了？这次和上面不一样，呵呵。</p>

<p>设计好并写好监控之后，选择什么方式发送监控数据呢。我选择的是 discovery 数据通过 agent 方式获取，也就是在各服务器上面定义相同的一个 key，然后执行这个 key 的时候发送发现的服务信息。</p>

<p>而对于监控项数据则通过 trapper 方式发送。通过 trapper 方式发送，需要定时执行，可以通过 crontab 发送。我选择的是建立了一个 agent 类型的 item，执行这个 item 的时候发送监控数据。这样一方面可以针对这个发送动作建立一个监控，另外一方面调整很方便，zabbix 界面修改就可以。并且我把这个 item 建立到了模板上面，只要修改应用模板就可以了。</p>

<p>监控数据也可以用 agent 方式发送，如果用 agent 方式发送，对于上面的 ssh 服务，就需要真的建立那个 ssh 的 userParameter 了，然后接受比如 <code>22.conf.md5</code> 这样的参数，去返回对应的监控数据。我没有用这种方式，是因为这样做等于有多少个 item 就需要在监控周期内执行多少次那个命令，给服务器增加负担（虽然没多少）。而使用 trapper 方式的话，就可以一次把所有的监控数据都发过去了，命令只需要执行一次。</p>

<h2 id="如何应对不同的部分">如何应对不同的部分</h2>

<p>到此为止，应该可以很完美的发现服务，并且监控了。但是会发现其实并不是所有服务器的服务都是一样的，比如对于 pgsql，slow query 的界定对于不同的业务可能不一样。而因为 trigger 也是自动发现添加的，这样也有可能需要不同的机器上面的服务有不同的阈值，怎么解决呢？</p>

<p>先说监控项的阈值。因为我的监控数据其实是通过建立一个 agent 类型的 item 定期发送 trapper 数据来实现的，所以只需要在调用那个 item 的时候传送不同的阈值就可以了。实际上面我的 itme key 定义是这样的 <code>pg.sendtrap[{$PG.DISCOVER.SETTINGS}]</code> 。那个 pg.sendtrap 是对应到一个 userParameter 的 <code>UserParameter=pg.sendtrap[*],/etc/zabbix/bin/zabbix_pg.py --check --sendtrap --settings $1</code>，在 zabbix_pg.py 里面，会处理 settings 参数。如果有阈值，那就定义好 <code>{$PG.DISCOVER.SETTINGS}</code> 这个宏就可以了。template 上面可以定义默认的阈值，当然默认阈值在程序里面定义也可以。然后不同 host 可以定义 host 的阈值，会覆盖模板的配置。</p>

<p>其实 trigger 的阈值和这个思路类似，也是 template 里面定义一个宏，trigger 里面使用这个宏就可以了。如果 host 有不同的阈值，那就定义一个 host 的宏覆盖他就可以了。</p>

<h2 id="目前的情况">目前的情况</h2>

<p>配合 zabbix 的 auto registration 这个 action，可以做到新机器只需要执行一个 saltstack state，安装好我们的 zabbix agent，就可以自动注册 host，自动添加监控报警。</p>

<p>相当完美。</p>

    </div>

<div class="meta">
    
    <span class="comments"><a href="/LLD-in-zabbix/#disqus_thread">Comments</a></span>
    
</div>
</article>

  <article class="post">
    <h2 class="title"> 
        <a href="/all-about-lazy/">能不能成功取决于什么</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2016-07-09T14:21:10.000&#43;08:00' itemprop="datePublished">2016-07-09</time>
</div>
        <div class="tags">Tags: 
</div>
    </div>
        

<p>随着年龄的增长，自己对一些事情的认识在改变，一直想总结一个给年轻同学的帖子，但是总是不能总结太好怎么讲，大概从想讲到现在，已经几个月了，我感觉不讲的话可能就讲不出来了，所以乱谈一下。</p>

<h2 id="从全栈讲起">从全栈讲起</h2>

<p>什么是全栈？我感觉肯定不是普通人，我觉得全栈至少得是绝顶聪明的人才可以做到，对于他们来讲，有很扎实的 CS 功底，并且知识面非常广泛，还有很多产出，并且这些产出是各个方面的。</p>

<p><img src="https://pic2.zhimg.com/3c8fbae345f5a480ee55174852f392a1_b.png" alt="某种观点" /></p>

<p>上面是李笑来老师对于全栈的看法，<a href="https://www.zhihu.com/question/47359997">这里</a> 有知乎用户对这个的讨论。</p>

<p>我只是关注到了他那句话里面的「不太笨」，如果他的意思是很聪明的意思，那观点就和我一致了，呵呵。</p>

<p>不得不承认，智商和你能掌握的内容是有关系的，智商不够再怎么努力也很难达到某种顶峰。当然这并不是说，智商不够的就没戏了，换句话说，如果智商不够还不努力，你还是就想想老婆孩子热炕头就算了。</p>

<h2 id="学习别人">学习别人</h2>

<p>学习别人的成功经验，似乎是一种很好的办法，至少人家那条路是走通了。</p>

<p>这几年流行健身，是吧。看着别人一个一个健身房也好，路边跑步也好，还有奥森跑步的，是不是看着眼红但是又觉得自己周边不具备环境？健身房贵，路边有觉得没有好环境，奥森还有点远，所以我得找一个满足条件的才能去进行这个事情。</p>

<p>还有比如看到有人拿 kindle 看书，是不是觉得我要是有个 kindle 带着方便，肯定可以看好多书，比如一直想学习的 iOS 开发，还有 Java 编程思想，哎呀呀，编程能力大幅增长啊。所以一定要买个 kindle。</p>

<p>等等类似的事情吧，别的不多讲了。就是我想要干什么事情，但是呢最好满足个什么条件，会让我干的更好更有动力。</p>

<p>最后通常的结果呢？步顶多跑几次就会觉得没意思了，kindle 在家里吃灰，然后开始有其他的想法，比如看着人家的 iphone 不错唉，我要是有个，看个 pdf 什么的，比 kindle 方便啊，手机可是一直带着的，所以。。。。</p>

<h2 id="听别人讲">听别人讲</h2>

<p>欧洲人在放难民进来的时候，想的可是我们可怜你们让你们进来，你们应该很满足，不要闹事老实呆着。所以实际上呢？</p>

<p>父母亲戚常见的「我都是为了你好」这种说法，大家估计都听腻了吧。有用么？</p>

<p>微信朋友圈网上各种鸡汤文，比尔盖兹为什么成功，雷军马云的奋斗，这些文章看的时候让人激动人心，看完了貌似就忘记了，是不是？。。</p>

<h2 id="关键在哪里">关键在哪里？</h2>

<p>我感觉关键就是一个字「懒」。</p>

<p><img src="http://ww1.sinaimg.cn/mw690/69a2b902jw1f1nn2v6ld1j20go0aswgl.jpg" alt="懒" /></p>

<p>2004 年左右在 irc 玩的时候，就有一个网站 <a href="http://lmgtfy.com/?q=%E6%87%92">let me google that for you</a>。这个网站就是鄙视那些连 google 都懒得用的，稍微有点问题就问别人。知识都是别人的，把别人当 google 用。</p>

<p>很多人都有类似习惯。我们学习的时候，别人都是引进大门，如果自己不能养成自己知识持续更新的习惯，等到自己连年轻人都跟不上的时候，就很悲哀了。</p>

<p>这个都无关智商，所谓活到老学到老，别人都给你总结好了，懒字一上来，就混吃等死吧。</p>

<p>想要客服懒字，得自己给自己洗脑，让自己能坚持的下去。<a href="http://v.youku.com/v_show/id_XMTY5NTc2MzMy.html">老罗的奋斗</a> 里面，老罗讲自己决定要去新东方当老师之前，学习英语的时候，隔段时间就会学不下去，学不下去的时候，看看成功学的书，给自己打打鸡血，就又活蹦乱跳了。</p>

<p>我大概总结几项提升的方向，遇事情想想，应该有好处
* 主动思考解决问题的最佳思路
* 主动发现问题，改进承担
* 主动推进事情进展
* 不要限定自己的范围，不停挑战难点
* 积极参与到别人的有激情的项目里面
* 对技术保持强烈的好奇心</p>

    </div>

<div class="meta">
    
    <span class="comments"><a href="/all-about-lazy/#disqus_thread">Comments</a></span>
    
</div>
</article>

  <article class="post">
    <h2 class="title"> 
        <a href="/how-to-create-a-blog-with-https-for-free/">如何不花钱建立一个支持 https 的 blog</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2016-04-10T10:18:28.000&#43;08:00' itemprop="datePublished">2016-04-10</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/blog">blog</a>


</div>
    </div>
        <p>早年的时候要搞 blog 还得弄一个空间，现在，免费的东西越来越多了，感觉共产主义的实现还要靠资本家啊，不过羊毛出在羊身上。。。</p>

<p>要想弄一个免费的 blog，首先你的 blog 内容最好是纯静态网页，如果是类似 php 什么的，那就难找了。使用 jeklly, hexo 这些都可以把 markdown 文件渲染成 html。</p>

<p>然后注册一个 github 或者 gitcafe 等等支持 pages 服务的空间，搞定之后就能得到一个类似于 <a href="http://wd.github.io">http://wd.github.io</a> 这样的地址。</p>

<p>然后你注册一个域名（发现标题没起好，这个还是要收费的。。），然后注册 cloudflare，把你的域名的 dns 使用 cloudflare 的，然后在 cloudflare 配置一个 cname 到 wd.github.io。然后建立一个 page rule，强制你的域名使用 ssl。</p>

<p>ok 拉，整个过程就是域名花钱了。可以访问下 <a href="http://wdicc.com">http://wdicc.com</a> 看看效果，会自动跳转到 <a href="https://wdicc.com">https://wdicc.com</a> :D</p>

    </div>

<div class="meta">
    
    <span class="comments"><a href="/how-to-create-a-blog-with-https-for-free/#disqus_thread">Comments</a></span>
    
</div>
</article>

  <article class="post">
    <h2 class="title"> 
        <a href="/Custom-Netgear-r6300v2-wireless-router/">Custom Netgear r6300v2 wireless router</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2016-03-27T11:50:38.000&#43;08:00' itemprop="datePublished">2016-03-27</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/linux">linux</a>

<a href="/tags/router">router</a>

<a href="/tags/gfw">gfw</a>


</div>
    </div>
        <p>接 <a href="/Across-the-Great-Wall-we-can-reach-every-corner-in-the-world">科学上网</a>。买了群晖之后，一直通过群晖上面跑一个 haproxy 来做转发。不过心里总觉得有点不爽，毕竟一方面多转发了一次，另外群晖在不使用的时候，还会休眠，又或多或少担心影响休眠（经过测试应该是不影响的，但是..）。所以买了 r6300v2 之后，就琢磨通过路由器做这个事情。</p>

<p>路由器上面搞就有两个选择，一是从 iptables 入手，直接转发出去，另外一个是从软件层面做。</p>

<p>开始搞了几天的 iptables，发现原有系统 iptables 条目还是挺多的，加上路由器翻墙的功能也需要加一些条目，导致尝试了好几天之后总算能够转发过去链接了，但是数据包过不去，为了调试就开始打算在路由器安装 tcpdump。然后找到了 <a href="https://github.com/Entware/entware">https://github.com/Entware/entware</a> ，配置好之后可以使用 opkg 来安装包。包列表可以参考这里 <a href="http://pkg.entware.net/binaries/armv7/Packages.html">http://pkg.entware.net/binaries/armv7/Packages.html</a> ，这个路由器是 armv7 版本的 cpu。</p>

<p>安装 opkg 之前先得了解下，梅林固件分两部分存储，一部分是系统区，一部分是自定义区。系统区应该是你刷的固件所在的地方，是不能修改的，自定义区是可以存放一些自己定义的脚本的。每次系统启动的时候，你的一些自定义的东西都是存在自定义区加载的。自定义区就是 /jffs 分区。想要使用，得在 系统管理 -&gt; 系统设置 里面，打开 JFFS 的配置，允许执行上面的脚本。</p>

<p>因为系统自带的 /jffs 分区只有 60M 左右，而我们装包的时候很容易就超过这个限制了，我现在已经用了 8xM 空间。所以最好还是用一个 u 盘来做这个事情。每次想要自动加载 u 盘，启动 u 盘里面的程序的话，还需要一些自定义的脚本来做这个事情。</p>

<p>先把 opkg 配置好，需要先准备好 /opt 目录。</p>

<pre><code>mkdir -p /tmp/opt
mount -t ext4 -o rw,noatime /dev/sda1 /opt
</code></pre>

<p>上面的 /dev/sda1 是 u 盘，ext4 是文件系统类型，按照自己的修改一下。一般 u 盘插上去就会自动挂载，df 看一下就知道是哪个名字了。系统配置里面有个 dlna 的配置记得关掉，否则他会读 u 盘导致你不能 umount 之类，或者 kill 掉一个叫做 minidlna 的进程也可以。</p>

<p>然后参考 <a href="https://github.com/Entware/entware">https://github.com/Entware/entware</a> 操作就可以了，可以看到他会在 /opt 给你安装一陀东西。因为这个是 u 盘，所以东西重启也不会丢失。</p>

<p>然后参考<a href="https://github.com/RMerl/asuswrt-merlin/wiki/User-scripts">梅林的 wiki</a>，它允许用户在 <code>/jffs/scripts</code> 自定义一些启动脚本，来支持我们自动挂载和启动 u 盘上面的程序。</p>

<p>post-mount 内容如下，前面几个注释的是调试用的。最后一个 if 里面内容是执行一些 opkg 安装的程序的启动脚本，这个后面说。</p>

<pre><code>#!/bin/sh

#echo $(date) &gt; /tmp/000service-start
#echo &quot;$1&quot; &gt;&gt; /tmp/000service-start
#ls /dev/sda* &gt;&gt; /tmp/000service-start

if [ -b /dev/sda1 ];then
        mkdir -p /tmp/opt
        mount -t ext4 -o rw,noatime /dev/sda1 /opt
fi

if [ -x /opt/bin/opkg ];then
        /opt/etc/init.d/rc.unslung start
fi
</code></pre>

<p>要记得 <code>sudo chmod +x post-mount</code>，然后可以重启路由器看看是不是启动之后就能看到 /opt 有了你上次安装的程序了。</p>

<p>上面一阶段搞定之后，就可以装一些软件了，比如我装了 vim, tcpdump，bind-dig, haproxy。opkg 的命令使用可以参考这里 <a href="https://wiki.openwrt.org/doc/techref/opkg">https://wiki.openwrt.org/doc/techref/opkg</a> 。</p>

<p>接着上面的话题，本来打算装好 tcpdump 来调试的，然后发现可以比较方便的启动 haproxy 之后，就打算用 haproxy 弄了，路由表太多，分析比较麻烦，还是走简单的吧。。</p>

<p><code>/opt/etc/haproxy.cfg</code> 如下，把 IP 和 PORT 改成你自己的。</p>

<pre><code>global
        ulimit-n  331071

defaults
        log global
        mode    tcp
        option  dontlognull
        timeout connect 1000
        timeout client 150000
        timeout server 150000

frontend ss-in
        bind *:本机PORT
        default_backend ss-out

backend ss-out
        server server1 IP:远端PORT maxconn 20480
</code></pre>

<p><code>/opt/etc/init.d/S001haproxy.sh</code> 如下，<code>sudo chmod +x /etc/init.d/S001haproxy.sh</code></p>

<pre><code>#!/bin/sh

haproxy_bin=/opt/sbin/haproxy
haproxy_cfg=/opt/etc/haproxy.cfg
pid=/opt/var/run/haproxy.pid

action=$1

if [ -z &quot;$action&quot; ];then
        printf &quot;Usage: $0 {start|stop|restart}\n&quot; &gt;&amp;2
        exit 1
fi

case &quot;$action&quot; in
        start)
                $haproxy_bin -f $haproxy_cfg -p $pid -D
                ;;
        stop)
                kill $(cat $pid)
                ;;
        restart)
                kill $(cat $pid)
                $haproxy_bin -f $haproxy_cfg -p $pid -D
                ;;
esac
</code></pre>

<p>因为前面在 post-mount 最后一个 if 里面的语句，这样启动路由器就会自动启动 haproxy 了。</p>

<p>想使用这个端口转发，还需要在路由器配置界面里面增加一个到路由器 ip 的映射，然后还需要一个 <code>/jffs/scripts/firewall-start</code> 如下</p>

<pre><code>#!/bin/sh

iptables -I INPUT -i ppp0 -p tcp --destination-port PORT -j ACCEPT
</code></pre>

<p>我使用的过程中还发现一个问题，pkg.entware.net 貌似被墙了。。虽然配置了翻墙但是不太明白为什么路由器上面时好时坏，而我局域网内的 mac 访问总是 ok 的，很奇怪。路由器上面不能访问有个办法是通过 mac 代理一下。</p>

<p>mac 上面启动一个 ngx，配置如下，使用 nginx -p ./ -c nginx.conf 启动。</p>

<pre><code>events {
  worker_connections 1024;
}


http {
  server {
      listen 0.0.0.0:8000;
      location / {
           proxy_pass http://pkg.entware.net;
      }
  }
}
</code></pre>

<p>然后修改路由器上面 /opt/etc/opkg.conf <code>src/gz packages http://MAC_IP:8000/binaries/armv7</code>，然后就可以了。</p>

<p>写完自己看发现这不是一份操作指南，只能算是一些提示，如果有人照着做能不能成功可能还是得看自己。。。</p>

    </div>

<div class="meta">
    
    <span class="comments"><a href="/Custom-Netgear-r6300v2-wireless-router/#disqus_thread">Comments</a></span>
    
</div>
</article>

  <article class="post">
    <h2 class="title"> 
        <a href="/lua-metatable/">lua metatable</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2016-03-27T10:48:26.000&#43;08:00' itemprop="datePublished">2016-03-27</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/lua">lua</a>


</div>
    </div>
        <pre><code>t = setmetatable({ bar = 4, foo = 7 }, { __index = { foo = 3 } })

print(t.foo)  -- 7
print(t.bar)  -- 4

t = setmetatable({  }, { __index = { foo = 3} })

print(t.foo)  -- 3
print(t.bar)  -- nil

fuc = function (t,k)
    if k == 'foo' then
        return rawget(t, 'bar')
    else
        return 0
    end
end

t = setmetatable({   }, { __index = fuc })

print(t.foo)  -- 3
print(t.bar)  -- nil
print(t.ff)
</code></pre>

    </div>

<div class="meta">
    
    <span class="comments"><a href="/lua-metatable/#disqus_thread">Comments</a></span>
    
</div>
</article>

  <article class="post">
    <h2 class="title"> 
        <a href="/Across-the-Great-Wall-we-can-reach-every-corner-in-the-world/">Across the Great Wall, we can reach every corner in the world</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2016-03-20T20:39:53.000&#43;08:00' itemprop="datePublished">2016-03-20</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/gfw">gfw</a>


</div>
    </div>
        

<p>科学上网估计是每个搞 IT 的人必须要掌握的知识了。简单讲讲我目前使用的一些方法。</p>

<h2 id="国外服务">国外服务</h2>

<p>首先肯定需要先有个国外的资源，比如买专业的 vpn ss 服务等。数据经过第三方都不一定那么可靠，我的主力邮箱在 gmail，可不想被攻破，所以我选择了自己购买和搭建服务。</p>

<p>我买的是 linode 的服务，最便宜的是 10$ 一个月。也可以买一些美国的 kvm 或者 zen 的虚拟机，有比较便宜的一个月可能才不到 1$，当然这种便宜的一般很快就会卖没，得看运气。我的 linode 是和 3 个基友一起合租的，这样大家每个人一年也就 300 来块钱，也就一顿海底捞（我这两年非常喜欢用饭钱来衡量消费，吃饭可是天天都有的，但是有些消费，比如买软件，买服务这些一般都是一年或者几年才一次，比起吃饭真的便宜多了），一般都能承担的吧。</p>

<p>早期我买过一些 ssh 服务，速度不稳定，因为很难限制超售。后来还买过云梯，他们提供的节点比较多速度还不错。</p>

<p>有了 vps 搭一个 ssserver 就是很简单的了，就不多说了。服务器上面我还配置了 ocserv 这个支持 cisco 客户端的 vpn 服务。当然并不是所有 vps 都支持，有的 vps 没有 tun 设备，跑不起来，买的时候要注意。</p>

<h2 id="ssh-方式">ssh 方式</h2>

<p>使用 ssh 方式的时候，最早是直接 ssh 链接弄一个 socks 端口给本地，然后本地使用 pac 配合。</p>

<p>后来有段时间被断的不行，就试了 stunnel，可以把 ssh 转为 https 服务，这样就可以跑在 443 端口了，和其他 https 服务比较难区分。可以起点作用。</p>

<p>这个方式没法支持手机。</p>

<h2 id="使用-ngx">使用 ngx</h2>

<p>有段时间还使用 hosts 文件加 ngx 反向代理还翻墙。ngx 上面配置 google.com 和 twitter.com 的反向代理，然后手机或者电脑上面配置 hosts 指向 ngx。就可以实现翻墙了。不过因为都是 https 的网站，所以服务器上面得配置 https 的服务，证书得弄到电脑或者手机上面信任才行。</p>

<p>这个手机想要支持的话，ios 比较麻烦，必须得越狱。</p>

<h2 id="vpn-方式">vpn 方式</h2>

<p>早期用 vpn 方式的时候，pptp 可以搭配 <a href="https://github.com/fivesheep/chnroutes">chnrouts</a> 来实现国外和国内走不同的路由。用起来也不错，不过问题是全局的有时候切换也不方便，并且有时候还需要连公司的 vpn 路由一乱就麻烦了。</p>

<p>pc 上面选择比较多。手机上面，试过 anyconnect，缺点就是全局翻墙（我试过让 server 只 push fb twitter 的路由，但是维护麻烦，效果也不好）。anyconnect 比较赞的地方是他的链接 cookie 可以设置比较长的有效期，这样网络切换什么的临时断开之后自动重连也不需要输入密码。哦，当然，我的 anyconnect 和后面提到的 openvpn 都是通过自己签的证书来认证的，也不需要输入密码。</p>

<p>后来用过 openvpn，openvpn 是基友维护的。他的思路很赞。</p>

<p>他买了一台 server 放家里，家里是联通 adsl 24h 联机，然后 server 上面跑一个 openvpn 的服务器端给手机连接用，服务器上面再通过 vpn 和 vps 的 vpn 链接，同时这机器配置只有国外路由才走 vps，国内都是直接链接。大概链路就是  手机 -&gt; 家里的 server -&gt; vps。如果是国内的网站，就直接通过家里的 server 访问了，比国外的 vps 访问速度快。</p>

<p>这个方法还有好处是有时候一些公开的场合链接一些 wifi 的时候，很不安全，而通过 vpn 之后，数据都是加密的，就安全多了。我在 surge 之前，在 hosts 不能用之后，基本都是用这个和 anyconnect。</p>

<h2 id="使用-ss">使用 ss</h2>

<p>开始使用 ss 的时候，是使用 goagentx （貌似已经比较难找到下载了）的，这个工具异常好用，支持切换全局还是使用 pac 非常方便。pac 推荐使用 <a href="https://github.com/JinnLynn/genpac">genpac</a> 来维护 pac，放到 dropbox 里面就可以四处用了。</p>

<p>我有相当长一段时间都是这么翻墙的。直到后面 ios 9 放开网络权限之后，出来了 surge。surge 现在卖的太贵了，不建议购买，最近好像看到有一些新的软件也在出现，可以考虑。</p>

<p>surge 出来之后，ios 基本就是用这个了。</p>

<p>surge 也有 mac 版本。如果没有，使用 ss mac 版本也可以，搭配 pac 可以做到透明。</p>

<h2 id="应对不稳定的网络情况">应对不稳定的网络情况</h2>

<p>家里是联通 adsl，链接我的 linode 一直都比较稳定，速度不错也没有丢包。公司访问 linode 有时候丢包比较严重，不过也将就用了。去年去长沙出差，那边完全访问不能把我搞的很痛苦。回来就开始琢磨怎么搞。</p>

<p>上面基友的思路提醒了我，就是自己家里一台 server 建长链接，然后在外面翻墙先连家里。但是家里的路由器完全不能定制，后来发现我的群晖的 nas 可以装 haproxy，就搞定这个事情了。在路由器上面映射一个端口给群晖，群晖上面跑 haproxy 转发到 linode。给路由器弄了个 ddns，在外面翻墙都连接这个 dns。</p>

<p>群晖上面跑 haproxy 还不影响硬盘休眠，还挺不错。这样就彻底解决了我翻墙的问题了。</p>

<p>但是遇到家里停电断网就虾米了。。</p>

<h2 id="家里的全局翻墙方案">家里的全局翻墙方案</h2>

<p>前段时间换了 Netgear R6300v2，才发现我之前错过了好多好玩的东西。刷了个国内论坛定制的梅林 rom，自带了 ss 客户端，并且配置的非常完美，支持多种翻墙策略，具体就不细说了。就说现在的效果吧。</p>

<p>直接映射了端口到 linode 的 ss，并且也支持 ddns（我用的 3322 的），这样 nas 上面的 haproxy 就彻底可以不用了。</p>

<p>路由器跑了 ss 客户端，加 redsocks2 和 dns2proxy，实现了国内网站直连，国外根据域名匹配到列表里面的服务器通过 ss 链接。这样家里所有的终端，不需要跑任何服务，就可以无缝翻墙了。我的 ps4，apple tv，ipad 上面的 yotube 都可以访问了。然后还支持黑名单，我把 nas 加进去了，防止使用 bt 下载的时候跑到国外流量。</p>

<p>这样我目前手机和 mac 都是直接通过 surge，国外流量通过 3322 的 dns 先链接到路由器，然后转发到 linode 实现翻墙。</p>

<h2 id="目前唯一的问题">目前唯一的问题</h2>

<p>mac 版本的 surge，还不能自己配置网络，这样临时想关掉代理的时候，就比较麻烦，得去网络配置里面关。也不能很简单的配置让全部流量走 proxy，有时候需要测试下什么的，就比较麻烦。所以我现在有时候还会使用 goagentx 辅助一下。</p>

    </div>

<div class="meta">
    
    <span class="comments"><a href="/Across-the-Great-Wall-we-can-reach-every-corner-in-the-world/#disqus_thread">Comments</a></span>
    
</div>
</article>

  <article class="post">
    <h2 class="title"> 
        <a href="/setup-proxy-for-emacs/">setup proxy for emacs</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2016-02-27T21:55:20.000&#43;08:00' itemprop="datePublished">2016-02-27</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/emacs">emacs</a>

<a href="/tags/osx">osx</a>


</div>
    </div>
        <p>我在 mac 上面使用 emacs 都是使用 daemon + emacsclient 模式。使用 <code>paradox</code> 包管理(其实就是比 <code>list-package</code> 稍微多了一点功能&rsquo;)，但是因为那些包什么的信息都在国外的网站，还有 github 什么的，导致速度巨慢甚至连不上，关键 emacs 单线程还得卡着别的操作，所以挺讨厌的(其实 paradox 提供了异步更新的方式，不会阻塞现在进程，但是有时候会不知道进度&hellip;)。</p>

<p>思路就是使用 <code>proxychains</code>。</p>

<p>新建一个 <code>/Library/LaunchAgents/gnu.emacs.daemon.plist</code> 文件</p>

<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot;
    &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;
 &lt;plist version=&quot;1.0&quot;&gt;
  &lt;dict&gt;
    &lt;key&gt;Label&lt;/key&gt;
    &lt;string&gt;gnu.emacs.daemon&lt;/string&gt;
    &lt;key&gt;ProgramArguments&lt;/key&gt;
    &lt;array&gt;
      &lt;string&gt;/usr/local/bin/proxychains4&lt;/string&gt;
      &lt;string&gt;-f&lt;/string&gt;
      &lt;string&gt;/Users/wd/.proxychains/proxychains.conf&lt;/string&gt;
      &lt;string&gt;/usr/local/opt/emacs-mac/bin/emacs&lt;/string&gt;
      &lt;string&gt;--daemon&lt;/string&gt;
    &lt;/array&gt;
   &lt;key&gt;RunAtLoad&lt;/key&gt;
   &lt;true/&gt;
   &lt;key&gt;ServiceDescription&lt;/key&gt;
   &lt;string&gt;Gnu Emacs Daemon&lt;/string&gt;
   &lt;key&gt;UserName&lt;/key&gt;
   &lt;string&gt;wd&lt;/string&gt;
  &lt;/dict&gt;
&lt;/plist&gt;
</code></pre>

<p>其中 <code>/Users/wd/.proxychains/proxychains.conf</code> 文件的内容如下</p>

<pre><code>strict_chain
proxy_dns
remote_dns_subnet 224
tcp_read_time_out 15000
tcp_connect_time_out 8000
localnet 127.0.0.0/255.0.0.0
localnet 10.0.0.0/255.0.0.0
localnet 172.16.0.0/255.240.0.0
localnet 192.168.0.0/255.255.0.0
quiet_mode

[ProxyList]
#socks5 127.0.0.1 1080
http 127.0.0.1 6152
</code></pre>

    </div>

<div class="meta">
    
    <span class="comments"><a href="/setup-proxy-for-emacs/#disqus_thread">Comments</a></span>
    
</div>
</article>

  <article class="post">
    <h2 class="title"> 
        <a href="/use-gearman-to-distribute-you-nagios-check/">use gearman to distribute you nagios check</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2016-01-18T15:14:36.000&#43;08:00' itemprop="datePublished">2016-01-18</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/nagios">nagios</a>

<a href="/tags/gearman">gearman</a>


</div>
    </div>
        

<h1 id="安装">安装</h1>

<h2 id="gearman">gearman</h2>

<p>需要 boost &gt; 1.39, libevent-devel, libuuid-devel, gperf
需要 gcc &gt;= 4.2</p>

<p>export CC=gcc44
export CC=g++44</p>

<h2 id="mod-gearman">mod-gearman</h2>

<p>libtool-ltdl-devel ncurses-devel
&ndash;with-gearman</p>

<h1 id="配置">配置</h1>

<p>gearman 分为几个模块
* mod_gearman: 负责把 nagios 中的检查任务发给 gearmand job server
* gearmand: 负责接收任务，分配给 worker 执行。这个是个通用的队列管理服务。
* gearman_workder: 负责消费 gearmand 中的 job。</p>

<p>其中 <code>mod_gearman</code> 的代码里面包括了上面提到的 mod_gearman 和 gearman_workder。</p>

<p>所以规划好 gearmand 启动的机器，以及你的 worker 机器。其中要注意 worker 机器上面是会执行所有[1] nagios 监控</p>

<p>需要配置的文件有几个
* nagios.cfg 增加 broker
* mod-gearman/etc/mod_gearman/mod_gearman_neb.conf broker 的配置文件
* mod-gearman/etc/mod_gearman/mod_gearman_worker.conf workder 的配置文件</p>

<h1 id="启动">启动</h1>

<ul>
<li>先启动 gearmand 使用 mod-gearman/etc/init.d/gearmand 这个脚本。</li>
<li>启动 worker 使用 mod-gearman/etc/init.d/mod_gearman_worker 这个脚本。启动之后可以用 gearman_top 看到多了一些队列。</li>
<li>重启 nagios</li>
</ul>

<p>确认 nagios.log 里面正常加载了 gearman，然后看 gearman_top 里面开始有一些 run 的 job 了。</p>

<h1 id="注意事项">注意事项</h1>

<p>基本上使用 gearman 还算是对用户透明，需要配置的东西不多，默认配置就可以跑。</p>

<p>一般使用 gearman 的时候都是现有 nagios 遇到瓶颈了，这个时候扩展的时候需要注意下，第一步可以在 nagios 机器上面（或者弄一台新的机器）做 gearman 的 job server，然后在 nagios 的机器上面跑一个 worker，这样基本就是 0 配置都可以跑起来，不会有任何问题。</p>

<p>第一步完成之后就会需要增加 worker，这个时候就要注意了，新的 worker 机器上面，需要在相同的路径下面包括所有你用到的 nagios plugin（包括自己写的，也包括这些 plugin 依赖的其他内容，比如临时文件路径，配置文件等），否则分发过来的 job 会执行不成功。</p>

<p>这个时候有个办法，就是把原来机器的 nagios 相关目录通过 nfs 共享给其他机器（但是得注意二进制程序是兼容的）。</p>

<p>另外如果需要测试一下新的 worker，也可以通过配置只让 worker 执行某些 servicegroup 或者 hostgroup 的任务。要注意这个时候需要配置 service, eventhandler, host 都为 no，然后配置 servicegroups 或者 hostgroups。</p>

<h1 id="footnotes">Footnotes</h1>

<p>[1] 其实 worker 是可以被配置为只处理某些监控的，这个后面会讲。</p>

    </div>

<div class="meta">
    
    <span class="comments"><a href="/use-gearman-to-distribute-you-nagios-check/#disqus_thread">Comments</a></span>
    
</div>
</article>

  <article class="post">
    <h2 class="title"> 
        <a href="/use-ivy-to-replace-isearch/">use ivy to replace isearch</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2016-01-10T19:22:20.000&#43;08:00' itemprop="datePublished">2016-01-10</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/emacs">emacs</a>


</div>
    </div>
        <p>之前习惯使用 <code>isearch</code> 来搜索了，最近看别人使用 <code>ivy</code> 看着心痒痒的，就想试试看。其实 ivy 的效果和 <code>swoop</code> 很像，不过区别是 ivy 是在 minibuffer 来显示可选信息的，swoop 是在一个 buffer 显示的。有洁癖的可能稍微计较一下。</p>

<pre><code>;; ivy swiper
(defun wd-swiper-at-point ()
  &quot;Pull next word from buffer into search string.&quot;
  (interactive)
  (let (query)
    (with-ivy-window
      (let ((tmp (symbol-at-point)))
        (setq query tmp)))
    (when query
      (insert (format &quot;%s&quot; query))
      )))

(use-package ivy
  :config
  (ivy-mode 1)
  (setq ivy-use-virtual-buffers t)
  (set-variable 'ivy-on-del-error-function '(lambda()))
  )

(use-package swiper
  :config
  (global-set-key &quot;\C-s&quot; 'swiper)
  (define-key swiper-map (kbd &quot;C-w&quot;) 'wd-swiper-at-point)
  (define-key swiper-map (kbd &quot;C-f&quot;) 'swiper-avy)
  )
</code></pre>

<p>我大致做了上面几个设定，<code>\C-s</code> 绑定了 swiper，启动 swiper 之后用 <code>\C-w</code> 可以快速把光标位置的 symbol 放到 minibuffer 来搜索。然后 swiper 和 isearch 有个区别是，默认情况下，swiper 如果 minibuffer 没有内容，按 backspace 会退出，这个和 isearch 的习惯不一样，把 <code>ivy-on-del-error-function</code> 重新绑定一下就可以了。</p>

<p>ivy 默认会绑定一个快捷键是在你 minibuffer 输入一些内容之后，会出来很多匹配结果，这个时候可以按 <code>C-'</code> 调用 <code>swiper-avy</code> 方便你快速定位，也挺好用的。不过我这里不好用，不知道怎么回事，只好重新绑定了一下。</p>

<p>还可以在 swiper 查询阶段按 <code>M-q</code> 进入替换模式。</p>

    </div>

<div class="meta">
    
    <span class="comments"><a href="/use-ivy-to-replace-isearch/#disqus_thread">Comments</a></span>
    
</div>
</article>



  <nav id="pagenavi">
    
        <a href="/page/2/" class="prev">Prev</a>
    
    
        <a href="/page/4/" class="next">Next</a>
    
  <div class="center"><a href="/archives/index.html">Blog Archives</a></div>
  </nav>


    </div>
    <footer id="footer">
    <div style="display:inline">
    Copyright &copy; 2017
    
    wd
    . Powered by <a href="http://gohugo.io" target="_blank">Hugo</a> |
    Theme is <a href="https://github.com/wd/hugo-fabric">hugo-fabric</a>, fork from <a href="https://github.com/wd/hexo-fabric">hexo-fabric</a> by <a href="https://wdicc.com">me</a>
</div>

    </footer>
    <script src="/js/fabric.js"></script>


</div>
</div>
<script src="/js/jquery.ui.totop.js" type="text/javascript"></script>
<script type="text/javascript">
 
;(function($){$().UItoTop({easingType:'easeOutCirc'});})(jQuery);
 
</script>
</body>
</html>
