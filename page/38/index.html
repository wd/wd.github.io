<!DOCTYPE HTML>
<html>
<head>
	<meta name="generator" content="Hugo 0.19" />
	<meta charset="utf-8">
    
    
    <title>wd and cc</title>
    <meta name="author" content="wd">
    <meta name="description" content="">
    <meta name="keywords" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <link href="https://wdicc.com/index.xml" rel="alternate" title="wd and cc" type="application/atom+xml">
	<link href="/favicon.ico" rel="shortcut icon">
    <link href="/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
    <link href="/css/custom.css" media="screen, projection" rel="stylesheet" type="text/css">

    <link href='//fonts.googleapis.com/css?family=Slackey' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Fjalla+One' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Amethysta' rel='stylesheet' type='text/css'>
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
    

    <script type="text/javascript" src="/js/jquery-tapir.js"></script>

    

    <link rel="stylesheet" href="/css/hljs.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
</head>


<body>
    <div id="wrapper">
        <header id="header" class="inner">
<h1 class="animated bounceInDown">
    <div id="headerbg">
        wd and cc
    </div>
</h1>

<span class="subtitle">happy every day</span>
<br>

<ul id="social-links" style="text-align:center; clear:both;">
    
    
    <li>
    <a href="https://github.com/wd" class="github" title="Github"></a>
    </li>
    
    
    
    
    
    <li>
    <a href="http://www.twitter.com/wd" class="twitter" title="Twitter"></a>
    </li>
    
    
    
    
    
</ul>


<ul id="nav">
	<li id="ajax"><a href="/index.html">Home</a></li>
	<li id="ajax"><a href="/archives/index.html">Archives</a></li>
	<li id="ajax"><a href="/tags/index.html">Tags</a></li>
    <li><a href="/atom.xml">RSS</a></li>
    <li>
    <div id="dark">
        <form action="//www.google.com.hk/search" method="get" accept-charset="UTF-8" id="search">
            <input type="hidden" name="sitesearch" value="https://wdicc.com/" />
            <input type="text" name="q" results="0" placeholder="Search..." x-webkit-speech />
        </form>
    </div>
    </li>
</ul>

</header>

<div id="toload">

    <div id="content" class="inner">
        




    
    <script id="dsq-count-scr" src="//wdicc.disqus.com/count.js" async></script>
    




  <article class="post">
    <h2 class="title"> 
        <a href="/qmail-queue/">Qmail邮件队列工作原理zz</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2006-03-30T00:00:00.000&#43;00:00' itemprop="datePublished">2006-03-30</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/mail">Mail</a>


</div>
    </div>
        http://www.gbunix.com/htmldata/2005_06/15/25/article_1223_1.html<br />

以下是qmail的数据流简图<br />

 qmail-smtpd --- &gt;&gt;qmail-queue ---&gt;&gt; qmail-send &lt;&lt;--- qmail-rspawn &lt;&lt;--- qmail-remote<br />
 &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; / &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; | <br />
 &nbsp; &nbsp; &nbsp; qmail-inject _/ qmail-clean \_ qmail-lspawn &lt;&lt;--- qmail-local<br />

 &nbsp; &nbsp;qmail中，每一条消息都发送到中央队列等待发送，由qmail-queue进程控制。它在以下情况被调用：<br />
 &nbsp; &nbsp;1、当产生本地消息时，qmail-inject进程调用qmail-queue。<br />
 &nbsp; &nbsp;2、qmail-smtpd准备SMTP协议下的投递邮件任务时调用它。<br />
 &nbsp; &nbsp;3、向前（forwarded）发送邮件时，qmail－local调用它。<br />
 &nbsp; &nbsp;4、退回邮件时，qmail－send调用它。<br />

 &nbsp; &nbsp;每封邮件接着由qmail-lspawn 和qmail-rspawn协助qmail－sned进程完成投递，最后由qmail－clean清除邮件队列。这四个进程是系统由始至终都在运行的，十分重要。<br />

由smtpd从域外接受邮件之后，会交给queue处理（也就是2），之后转到qmal-send，然后看是域内还是域外，域内用qmail-lspawn，域外用qmail-rspawn。域内邮件调用qmail-local处理，如果遇到.qmail文件转发邮件（也就是上面的3），还会交给queue处理，如果没有，就直接投递给用户（？）。域外邮件调用qmail-remote处理，如果对方拒收邮件，他就会产生一个新的邮件（bounce），交给qmail-send，然后交给queue（也就是4？）。<br />

本地用户发送mail的时候调用qmail-inject，然后交给queue（也就是1）。<br />

有几个问题。<br />
1&nbsp; 收到域外邮件之后，判断本机是否有这个用户后才接受邮件呢，还是先接受进来放到queue里等qmail-local处理的时候再说？<br />

2&nbsp; qmail-clean这个程序是怎么工作的？实时扫描queue的文件夹？<br />

    </div>

<div class="meta">
    
    <span class="comments"><a href="/qmail-queue/#disqus_thread">Comments</a></span>
    
</div>
</article>

  <article class="post">
    <h2 class="title"> 
        <a href="/how-mail-from-a-to-b/">邮件如何从A点到达B点zz</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2006-03-30T00:00:00.000&#43;00:00' itemprop="datePublished">2006-03-30</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/mail">Mail</a>


</div>
    </div>
        <p>当一个主机上的用户想要发送一个邮件给另一个主机上的用户时, 许多事情发生了, 这个场景后面的东西很多是不必要知道的那么确切的. </p>  <p>假设一个用户 Alice, alice@alpha.example.com 想要发送一个邮件给 Bob, bob@beta.example.com,     下面是发送接收过程: </p>  <p>1. Alice 用她的邮件用户代理(MUA)编写邮件, 比如使用 mutt 或者 pine. 她在 To 这一栏指定接收者, Subject 这一栏填写邮件主题,     加上邮件本身的文本部分. 整个邮件看起来是下面这样的: </p><pre>    To: bob@beta<br />
    Subject: lunch<br />

    How about pizza?<br />
</pre>  <p>2. 当她觉得这封邮件已经满意之后, 她指派 MUA 发送邮件. </p>  <p>3. 这时候, MUA 会加上附加的邮件头部分, 比如日期 Date 和邮件ID(Message-Id) 并且修改Alice输入的值(例如, 将 bob@beta     替换为"Bob &lt;bob@beta.example.com&gt;") 下一步, MUA 将邮件注入邮件系统. 有两种方式进行注入:     MUA 运行一个由邮件系统提供的为注入邮件为目的的程序; 或者使用SMTP协议和本地或者远程邮件服务器建立连接, 举个例子, 我们假定 MUA 使用本地注入程序将邮件传送给     MTA, 对于不同的MTA, 注入细节都是不同的, 不过对于UNIX系统, 使用sendmail 程序注入已经成了事实上的标准. 使用这种方式, MUA     可以将邮件头和邮件主体放置在一个文件内, 由空行分隔, 然后传递这个文件到 sendmail 程序. </p>  <p>4. 如果注入成功--邮件句法正确, 并且 sendmail 调用适当--那么现在邮件已经在 MTA 的职责内了. 不同的 MTA 细节是完全不同的,     通常MTA首先检查邮件头决定邮件将发往何处. 然后建立一个到主机beta的SMTP连接, 转发邮件给 beta 系统上的MTA. SMTP对话要求邮件被分成两部分发送:     信封, 这个部分确定了接收者的地址(bob@beta.example.com)和返回地址(alice@alpha.example.com), 以及邮件本身,     包括邮件头和邮件主体. </p>  <p>5. 如果beta主机的MTA拒绝这个邮件, 可能原因是在beta系统上没有这个bob用户, 在alpha 上的MTA发送一个反弹邮件给返回地址, 也就是     alice@alpha, 通知她邮件发送出现了问题. </p>  <p>6. 如果 beta主机上的 MTA接收了邮件, 它查看接收者地址, 决定是发送给本地local 还是远程 remote系统的邮件. 这个例子里面,     接收者是本地用户, 然后MTA或者传送邮件给 mail delivery agent (MDA), 比如 /bin/mail或者传送给 procmail.   </p>  <p>7. 如果传输失败了, 可能是Bob的邮箱超过了使用限额, beta 主机上的 MTA 将发送一个反弹信息给信封上的返回地址, 即 alice@alpha.   </p>  <p>8. 如果传输成功, 邮件将在Bob的邮箱中等待, 直到他使用MUA来阅读和显示邮件. </p><br />

    </div>

<div class="meta">
    
    <span class="comments"><a href="/how-mail-from-a-to-b/#disqus_thread">Comments</a></span>
    
</div>
</article>

  <article class="post">
    <h2 class="title"> 
        <a href="/about-awk/">AWK：Linux 管理员的智能工具包zz</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2006-03-27T00:00:00.000&#43;00:00' itemprop="datePublished">2006-03-27</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/other">other</a>


</div>
    </div>
        引用地址：http://www.oracle.com/technology/global/cn/pub/articles/dulaney_awk.html<br />
还可以参考：http://www.example.net.cn/archives/2005/01/awknieec.html<br />

<p><span class="boldbodycopy">您正在学习 Linux 吗？本文对于非常有用的 AWK 文本操作工具进行了介绍，非常有价值。</span></p><p>&lt;!--use&gt; <span class="bodycopy">AWK实用工具带有其自己的自包含语言，它不仅是 Linux中也是任何环境中现有的功能最强大的数据处理引擎之一。这种编程及数据操作语言（其名称得自于它的创始人 Alfred Aho、PeterWeinberger 和 Brian Kernighan姓氏的首个字母）的最大功能取决于一个人所拥有的知识。它允许您创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。</span></p><p><span class="parahead1"><br><!--more--><p><span class="parahead1">AWK 是什么？</span></p><p><span class="bodycopy">最简单地说，AWK 是一种用于处理文本的编程语言工具。AWK 实用工具的语言在很多方面类似于shell 编程语言，尽管 AWK 具有完全属于其本身的语法。在最初创造 AWK时，其目的是用于文本处理，并且这种语言的基础是，只要在输入数据中有模式匹配，就执行一系列指令。该实用工具扫描文件中的每一行，查找与命令行中所给定内容相匹配的模式。如果发现匹配内容，则进行下一个编程步骤。如果找不到匹配内容，则继续处理下一行。</span></p><p><span class="bodycopy">尽管操作可能会很复杂，但命令的语法始终是：</span></p><pre>awk '{pattern + action}' {filenames} <br />
</pre><p><span class="bodycopy">其中 </span><tt>pattern</tt><span class="bodycopy"> 表示 AWK 在数据中查找的内容，而 action 是在找到匹配内容时所执行的一系列命令。花括号 ({}) 不需要在程序中始终出现，但它们用于根据特定的模式对一系列指令进行分组。</span></p><p> <span class="parahead1">了解字段</span></p><p><span class="bodycopy">实用工具将每个输入行分为记录和字段。</span><span class="italicbodycopy">记录</span><span class="bodycopy">是单行的输入，而每条记录包含若干字段。默认的字段分隔符是空格或制表符，而记录的分隔符是换行。虽然在默认情况下将制表符和空格都看作字段分隔符（多个空格仍然作为一个分隔符），但是可以将分隔符从空格改为任何其它字符。</span></p><p><span class="bodycopy">为了进行演示，请查看以下保存为 emp_names 的员工列表文件：</span></p><pre>46012   DULANEY     EVAN        MOBILE   AL<br />
46013   DURHAM      JEFF        MOBILE   AL<br />
46015   STEEN       BILL        MOBILE   AL<br />
46017   FELDMAN     EVAN        MOBILE   AL<br />
46018   SWIM        STEVE       UNKNOWN  AL<br />
46019   BOGUE       ROBERT      PHOENIX  AZ<br />
46021   JUNE        MICAH       PHOENIX  AZ<br />
46022   KANE        SHERYL      UNKNOWN  AR<br />
46024   WOOD        WILLIAM     MUNCIE   IN<br />
46026   FERGUS      SARAH       MUNCIE   IN<br />
46027   BUCK        SARAH       MUNCIE   IN<br />
46029   TUTTLE      BOB         MUNCIE   IN<br />
</pre><p><span class="bodycopy">当 AWK 读取输入内容时，整条记录被分配给变量 </span><tt>$0</tt><span class="bodycopy">。每个字段以字段分隔符分开，被分配给变量 </span><tt>$1、$2、$3</tt><span class="bodycopy"> 等等。一行在本质上可以包含无数个字段，通过字段号来访问每个字段。因此，命令</span></p><pre>awk '{print $1,$2,$3,$4,$5}' names<br />
</pre><p><span class="bodycopy">将会产生的打印输出是</span></p><pre>46012 DULANEY EVAN MOBILE AL<br />
46013 DURHAM JEFF MOBILE AL<br />
46015 STEEN BILL MOBILE AL<br />
46017 FELDMAN EVAN MOBILE AL<br />
46018 SWIM STEVE UNKNOWN AL<br />
46019 BOGUE ROBERT PHOENIX AZ<br />
46021 JUNE MICAH PHOENIX AZ<br />
46022 KANE SHERYL UNKNOWN AR<br />
46024 WOOD WILLIAM MUNCIE IN<br />
46026 FERGUS SARAH MUNCIE IN<br />
46027 BUCK SARAH MUNCIE IN<br />
46029 TUTTLE BOB MUNCIE IN<br />
</pre><p><span class="bodycopy">值得注意的一项重要内容是，AWK 解释由空格分隔的五个字段，但当它打印显示内容时，在每个字段间只有一个空格。利用为每个字段指定了唯一号码的功能，您可以选择只打印特定的字段。例如，只打印每条记录的姓名时，只需选择第二个和第三个字段进行打印：</span></p><pre>$ awk '{print $2,$3}' emp_names<br />
DULANEY EVAN<br />
DURHAM JEFF<br />
STEEN BILL<br />
FELDMAN EVAN<br />
SWIM STEVE<br />
BOGUE ROBERT<br />
JUNE MICAH<br />
KANE SHERYL<br />
WOOD WILLIAM<br />
FERGUS SARAH<br />
BUCK SARAH<br />
TUTTLE BOB<br />
$<br />
</pre><p><span class="bodycopy">您还可以指定按任何顺序打印字段，而无论它们在记录中是如何存在的。因此，只需要显示姓名字段，并且使其顺序颠倒，先显示名字再显示姓氏：</span></p><pre>$ awk '{print $3,$2}' emp_names<br />
EVAN DULANEY<br />
JEFF DURHAM<br />
BILL STEEN<br />
EVAN FELDMAN<br />
STEVE SWIM<br />
ROBERT BOGUE<br />
MICAH JUNE<br />
SHERYL KANE<br />
WILLIAM WOOD<br />
SARAH FERGUS<br />
SARAH BUCK<br />
BOB TUTTLE<br />
$<br />
</pre><p><span class="parahead1">使用模式</span></p><p><span class="bodycopy">通过包含一个必须匹配的模式，您可以选择只对特定的记录而不是所有的记录进行操作。模式匹配的最简单形式是搜索，其中要匹配的项目被包含在斜线 (</span><tt>/pattern/</tt><span class="bodycopy">) 中。例如，只对那些居住在阿拉巴马州的员工执行前面的操作：</span></p><pre>$ awk '/AL/ {print $3,$2}' emp_names<br />
EVAN DULANEY<br />
JEFF DURHAM<br />
BILL STEEN<br />
EVAN FELDMAN<br />
STEVE SWIM<br />
$<br />
</pre><p><span class="bodycopy">如果您不指定要打印的字段，则会打印整个匹配的条目：</span></p><pre>$ awk '/AL/' emp_names<br />
46012   DULANEY     EVAN     MOBILE     AL<br />
46013   DURHAM      JEFF     MOBILE     AL<br />
46015   STEEN       BILL     MOBILE     AL<br />
46017   FELDMAN     EVAN     MOBILE     AL<br />
46018   SWIM        STEVE    UNKNOWN    AL<br />
$<br />
</pre><p><span class="bodycopy">对同一数据集的多个命令可以用分号 (</span><tt>;</tt><span class="bodycopy">) 分隔开。例如，在一行中打印姓名，而在另一行中打印城市和州名：</span></p><pre>$ awk '/AL/ {print $3,$2 ; print $4,$5}' emp_names<br />
EVAN DULANEY<br />
MOBILE AL<br />
JEFF DURHAM<br />
MOBILE AL<br />
BILL STEEN<br />
MOBILE AL<br />
EVAN FELDMAN<br />
MOBILE AL<br />
STEVE SWIM<br />
UNKNOWN AL<br />
$<br />
</pre><p><span class="bodycopy">如果没有使用分号 (</span><tt>print $3,$2,$4,$5</tt><span class="bodycopy">)，则会在同一行中显示所有内容。另一方面，如果分别给出两个打印语句，则会产生完全不同的结果：</span></p><pre>$ awk '/AL/ {print $3,$2} {print $4,$5}' emp_names<br />
EVAN DULANEY<br />
MOBILE AL<br />
JEFF DURHAM<br />
MOBILE AL<br />
BILL STEEN<br />
MOBILE AL<br />
EVAN FELDMAN<br />
MOBILE AL<br />
STEVE SWIM<br />
UNKNOWN AL<br />
PHOENIX AZ<br />
PHOENIX AZ<br />
UNKNOWN AR<br />
MUNCIE IN<br />
MUNCIE IN<br />
MUNCIE IN<br />
MUNCIE IN<br />
$<br />
</pre><p><span class="bodycopy">只有在列表中找到 </span><tt>AL</tt><span class="bodycopy"> 时才会给出字段三和字段二。但是，字段四和字段五是无条件的，始终打印它们。只有第一组花括号中的命令对前面紧邻的命令 (</span><tt>/AL/</tt><span class="bodycopy">) 起作用。</span></p><p><span class="bodycopy">结果非常不便于阅读，可以使其稍微更清晰一些。首先，在城市与州之间插入一个空格和逗号。然后，在每两行显示之后放置一个空行：</span></p><pre>$ awk '/AL/ {print $3,$2 ; print $4", "$5"\n"}' emp_names<br />
EVAN DULANEY<br />
MOBILE, AL<br />

JEFF DURHAM<br />
MOBILE, AL<br />

BILL STEEN<br />
MOBILE, AL<br />

EVAN FELDMAN<br />
MOBILE, AL<br />

STEVE SWIM<br />
UNKNOWN, AL<br />
$<br />
</pre><p><span class="bodycopy">在第四和第五个字段之间，添加一个逗号和一个空格（在引号之间），在第五个字段后面，打印一个换行符 (</span><tt>\n</tt><span class="bodycopy">)。在 AWK 打印语句中还可以使用那些可在 </span><tt>echo</tt><span class="bodycopy"> 命令中使用的所有特殊字符，包括：</span></p><ul><li><tt>\n</tt><span class="bodycopy">（换行）</span></li><li><tt>\t</tt><span class="bodycopy">（制表）</span></li><li><tt>\b</tt><span class="bodycopy">（退格）</span></li><li><tt>\f</tt><span class="bodycopy">（进纸）</span></li><li><tt>\r</tt><span class="bodycopy">（回车）</span></li></ul><p><span class="bodycopy">因此，要读取全部五个最初由制表符分隔开的字段，并且也利用制表符打印它们，您可以编程如下</span></p><pre>$ awk '{print $1"\t"$2"\t"$3"\t"$4"\t"$5}' emp_names<br />
46012   DULANEY     EVAN     MOBILE    AL<br />
46013   DURHAM      JEFF     MOBILE    AL<br />
46015   STEEN       BILL     MOBILE    AL<br />
46017   FELDMAN     EVAN     MOBILE    AL<br />
46018   SWIM        STEVE    UNKNOWN   AL<br />
46019   BOGUE       ROBERT   PHOENIX   AZ<br />
46021   JUNE        MICAH    PHOENIX   AZ<br />
46022   KANE        SHERYL   UNKNOWN   AR<br />
46024   WOOD        WILLIAM  MUNCIE    IN<br />
46026   FERGUS      SARAH    MUNCIE    IN<br />
46027   BUCK        SARAH    MUNCIE    IN<br />
46029   TUTTLE      BOB      MUNCIE    IN<br />
$<br />
</pre><p><span class="bodycopy">通过连续设置多项标准并用管道 (</span><tt>|</tt><span class="bodycopy">) 符号将其分隔开，您可以一次搜索多个模式匹配：</span></p><pre>$ awk '/AL|IN/' emp_names<br />
46012   DULANEY     EVAN     MOBILE    AL<br />
46013   DURHAM      JEFF     MOBILE    AL<br />
46015   STEEN       BILL     MOBILE    AL<br />
46017   FELDMAN     EVAN     MOBILE    AL<br />
46018   SWIM        STEVE    UNKNOWN   AL<br />
46024   WOOD        WILLIAM  MUNCIE    IN<br />
46026   FERGUS      SARAH    MUNCIE    IN<br />
46027   BUCK        SARAH    MUNCIE    IN<br />
46029   TUTTLE      BOB      MUNCIE    IN<br />
$<br />
</pre><p><span class="bodycopy">这样可找到每个阿拉巴马州和印第安那州居民的匹配记录。但是在试图找出居住在亚利桑那州的人时，出现了一个问题：</span></p><pre>$ awk '/AR/' emp_names<br />
46019   BOGUE       ROBERT   PHOENIX   AZ<br />
46021   JUNE        MICAH    PHOENIX   AZ<br />
46022   KANE        SHERYL   UNKNOWN   AZ<br />
46026   FERGUS      SARAH    MUNCIE    IN<br />
46027   BUCK        SARAH    MUNCIE    IN<br />
$<br />
</pre><p><span class="bodycopy">员工 46026 和 46027 没有住在亚利桑那州；但是他们的名字中包含所搜索的字符序列。切记，当在 AWK 中进行模式匹配时，例如 </span><tt>grep、sed</tt><span class="bodycopy"> 或者大部分其他 Linux/Unix 命令，将在记录（行）中的任何位置查找匹配，除非指定进行其他操作。为解决这一问题，必须将搜索与特定字段联系起来。通过利用代字号 (˜) 以及对特定字段的说明，可以达到这一目的，如下例所示：</span></p><pre>$ awk '$5 ˜ /AR/' emp_names<br />
46019   BOGUE       ROBERT   PHOENIX   AZ<br />
46021   JUNE        MICAH    PHOENIX   AZ<br />
46022   KANE        SHERYL   UNKNOWN   AZ<br />
$<br />
</pre><p><span class="bodycopy">代字号（表示匹配）的对应符号是一个前面带有感叹号的代字号 (!˜)。这些字符通知程序，如果搜索序列没有出现在指定字段中，则找出与搜索序列相匹配的所有行：</span></p><pre>$ awk '$5 !˜ /AR/' names<br />
46012   DULANEY     EVAN     MOBILE    AL<br />
46013   DURHAM      JEFF     MOBILE    AL<br />
46015   STEEN       BILL     MOBILE    AL<br />
46017   FELDMAN     EVAN     MOBILE    AL<br />
46018   SWIM        STEVE    UNKNOWN   AL<br />
46024   WOOD        WILLIAM  MUNCIE    IN<br />
46026   FERGUS      SARAH    MUNCIE    IN<br />
46027   BUCK        SARAH    MUNCIE    IN<br />
46029   TUTTLE      BOB      MUNCIE    IN<br />
$<br />
</pre><p><span class="bodycopy">在这种情况下，将显示第五个字段中没有 AR 的所有行 — 包括两个 Sarah 条目，这两个条目确实包含 AR，但却是在第三个字段而不是第五个字段中。</span></p><p><span class="parahead1">花括号和字段分隔符</span></p><p><span class="bodycopy">括号字符在 AWK 命令中起着很重要的作用。出现在括号之间的操作指出将要发生什么以及何时发生。当只使用一对括号时：</span></p><pre>{print $3,$2}<br />
</pre><p><span class="bodycopy">括号间的所有操作同时发生。当使用多于一对的括号时：</span></p><pre>{print $3}{print $2}<br />
</pre><p><span class="bodycopy">执行第一组命令，在该命令完成后执行第二组命令。注意以下两列清单的区别：</span></p><pre>$ awk '{print $3,$2}' names<br />
EVAN DULANEY<br />
JEFF DURHAM<br />
BILL STEEN<br />
EVAN FELDMAN<br />
STEVE SWIM<br />
ROBERT BOGUE<br />
MICAH JUNE<br />
SHERYL KANE<br />
WILLIAM WOOD<br />
SARAH FERGUS<br />
SARAH BUCK<br />
BOB TUTTLE<br />
$<br />

$ awk '{print $3}{print $2}' names<br />
EVAN<br />
DULANEY<br />
JEFF<br />
DURHAM<br />
BILL<br />
STEEN<br />
EVAN<br />
FELDMAN<br />
STEVE<br />
SWIM<br />
ROBERT<br />
BOGUE<br />
MICAH<br />
JUNE<br />
SHERYL<br />
KANE<br />
WILLIAM<br />
WOOD<br />
SARAH<br />
FERGUS<br />
SARAH<br />
BUCK<br />
BOB<br />
TUTTLE<br />
$<br />
</pre><p><span class="bodycopy">要利用多组括号进行重复查找，执行第一组中的命令直到完成为止；然后处理第二组命令。如果有第三组命令，则在第二组命令完成后执行它，以此类推。在所生成的打印输出中，有两个分隔的打印命令，因此先执行第一个命令，随后执行第二个命令，这样导致每个条目显示在两行而不是一行中。</span></p><p><span class="bodycopy">区分两个字段的字段分隔符不一定始终是空格；它可以是任何可识别的字符。为进行演示，假定 </span><tt>emp_names</tt><span class="bodycopy"> 文件利用冒号而不是制表符来分隔字段：</span></p><pre>$ cat emp_names<br />
46012:DULANEY:EVAN:MOBILE:AL<br />
46013:DURHAM:JEFF:MOBILE:AL<br />
46015:STEEN:BILL:MOBILE:AL<br />
46017:FELDMAN:EVAN:MOBILE:AL<br />
46018:SWIM:STEVE:UNKNOWN:AL<br />
46019:BOGUE:ROBERT:PHOENIX:AZ<br />
46021:JUNE:MICAH:PHOENIX:AZ<br />
46022:KANE:SHERYL:UNKNOWN:AR<br />
46024:WOOD:WILLIAM:MUNCIE:IN<br />
46026:FERGUS:SARAH:MUNCIE:IN<br />
46027:BUCK:SARAH:MUNCIE:IN<br />
46029:TUTTLE:BOB:MUNCIE:IN<br />
$<br />
</pre><p><span class="bodycopy">如果试图通过指定所需要的第二个字段来打印姓氏</span></p><pre>$ awk '{print $2}' emp_names<br />
</pre><p><span class="bodycopy">您最后会得到十二个空行。因为文件中没有空格，除了第一个字段之外没有可认别的字段。为解决这一问题，必须通知 AWK 是空格之外的另一个字符作为分隔符，有两种方法可通知 AWK 使用新的字段分隔符：使用命令行参数 </span><tt>-F</tt><span class="bodycopy">，或在程序中指定变量 FS。两种方法的效果相同，只有一种例外情况，如下例所示：</span></p><pre>$ awk '{FS=":"}{print $2}' emp_names<br />

DURHAM<br />
STEEN<br />
FELDMAN<br />
SWIM<br />
BOGUE<br />
JUNE<br />
KANE<br />
WOOD<br />
FERGUS<br />
BUCK<br />
TUTTLE<br />
$<br />

$ awk -F: '{print $2}' emp_names<br />
DULANEY<br />
DURHAM<br />
STEEN<br />
FELDMAN<br />
SWIM<br />
BOGUE<br />
JUNE<br />
KANE<br />
WOOD<br />
FERGUS<br />
BUCK<br />
TUTTLE<br />
$<br />
</pre><p><span class="bodycopy">在第一个命令中，头一条记录返回不正确的空行，而其他结果正确。直到读取第二条记录时，才识别字段分隔符并正确地执行。通过使用 </span><tt>BEGIN</tt><span class="bodycopy"> 语句可以纠正这一缺点（在后文详述）。</span><tt>-F</tt><span class="bodycopy"> 的功能非常类似于 </span><tt>BEGIN</tt><span class="bodycopy">，能够正确地读取第一条记录并按要求执行。</span></p><p><span class="bodycopy">在本文开始处我曾提到，默认的显示/输出字段分隔符是空格。通过使用输出字段分隔符 (</span><tt>OFS</tt><span class="bodycopy">) 变量，可以在程序中更改此特性。例如，要读取文件（由冒号分隔）并以短划线显示，则命令是</span></p><pre>$ awk -F":" '{OFS="-"}{print $1,$2,$3,$4,$5}' emp_names<br />
46012-DULANEY-EVAN-MOBILE-AL<br />
46013-DURHAM-JEFF-MOBILE-AL<br />
46015-STEEN-BILL-MOBILE-AL<br />
46017-FELDMAN-EVAN-MOBILE-AL<br />
46018-SWIM-STEVE-UNKNOWN-AL<br />
46019-BOGUE-ROBERT-PHOENIX-AZ<br />
46021-JUNE-MICAH-PHOENIX-AZ<br />
46022-KANE-SHERYL-UNKNOWN-AR<br />
46024-WOOD-WILLIAM-MUNCIE-IN<br />
46026-FERGUS-SARAH-MUNCIE-IN<br />
46027-BUCK-SARAH-MUNCIE-IN<br />
46029-TUTTLE-BOB-MUNCIE-IN<br />
$<br />
</pre><p><tt>FS </tt><span class="bodycopy"> 和 </span><tt>OFS</tt><span class="bodycopy"> 是（输入）字段分隔符和输出字段分隔符，它们只是一对可以在 AWK 实用工具中使用的变量。例如，要在打印时为每行编号，可以采用以下方式使用 </span><tt>NR</tt><span class="bodycopy"> 变量：</span></p><pre>$ awk -F":" '{print NR,$1,$2,$3}' emp_names<br />
1 46012 DULANEY EVAN<br />
2 46013 DURHAM JEFF<br />
3 46015 STEEN BILL<br />
4 46017 FELDMAN EVAN<br />
5 46018 SWIM STEVE<br />
6 46019 BOGUE ROBERT<br />
7 46021 JUNE MICAH<br />
8 46022 KANE SHERYL<br />
9 46024 WOOD WILLIAM<br />
10 46026 FERGUS SARAH<br />
11 46027 BUCK SARAH<br />
12 46029 TUTTLE BOB<br />
$<br />
</pre><p><span class="bodycopy">找出员工号码处于 46012 和 46015 之间的所有行：</span></p><pre>$ awk -F":" '/4601[2-5]/' emp_names<br />
46012   DULANEY EVAN  MOBILE AL<br />
46013   DURHAM  JEFF  MOBILE AL<br />
46015   STEEN   BILL  MOBILE AL<br />
$<br />
</pre><p><span class="parahead1">添加文本</span></p><p><span class="bodycopy">可以按照添加控制序列或其他字符的相同方式将文本添加到显示中。例如，要将分隔符从空格改为冒号，则命令是</span></p><pre>awk '{print $1":"$2":"$3":"$4":"$5}' emp_names &gt; new_emp_names<br />
</pre><p><span class="bodycopy">在这种情况下，字符 (</span><tt>:</tt><span class="bodycopy">) 包含在引号 (</span><tt>"/"</tt><span class="bodycopy">) 中，它被添加到每个字段之间。在引号之间的值可以是任何内容。例如，创建一个关于居住在阿拉巴马州的员工的外观类似数据库的显示：</span></p><pre>$ awk '$5 ~ /AL/ {print "NAME: "$2", "$3"\nCITY-STATE:<br />
  "$4", "$5"\n"}' emp_names<br />

NAME: DULANEY, EVAN<br />
CITY-STATE: MOBILE, AL<br />

NAME: DURHAM, JEFF<br />
CITY-STATE: MOBILE, AL<br />

NAME: STEEN, BILL<br />
CITY-STATE: MOBILE, AL<br />

NAME: FELDMAN, EVAN<br />
CITY-STATE: MOBILE, AL<br />

NAME: SWIM, STEVE<br />
CITY-STATE: UNKNOWN, AL<br />
$<br />
</pre><p><span class="parahead1">数学操作</span></p><p><span class="bodycopy">AWK 除了提供文本功能，还提供全部范围的算术操作符，包括以下符号：</span></p><p><tt>+    </tt><span class="bodycopy">将数字相加</span><br />
 <tt>-    </tt><span class="bodycopy">减</span><br />
 <tt>*    </tt><span class="bodycopy">乘</span><br />
 <tt>/    </tt><span class="bodycopy">除</span><br />
 <tt>^    </tt><span class="bodycopy">执行指数运算</span><br />
 <tt>%    </tt><span class="bodycopy">提供模</span><br />
 <tt>++   </tt><span class="bodycopy">将变量值加一</span><br />
 <tt>+=   </tt><span class="bodycopy">将其他操作的结果分配给变量</span><br />
 <tt>— </tt><span class="bodycopy">将变量减一</span><br />
 <tt>-=   </tt><span class="bodycopy">将减法操作的结果分配给变量</span><br />
 <tt>*=   </tt><span class="bodycopy">分配乘法操作的结果</span><br />
 <tt>/=   </tt><span class="bodycopy">分配除法操作的结果</span><br />
 <tt>%=   </tt><span class="bodycopy">分配求模操作的结果</span></p><p><span class="bodycopy">例如，假定您的机器上存在以下的文件，详细地列出硬件商店中的物品：</span></p><pre>$ cat inventory<br />
hammers 5       7.99<br />
drills  2      29.99<br />
punches 7       3.59<br />
drifts  2       4.09<br />
bits   55       1.19<br />
saws  123      14.99<br />
nails 800        .19<br />
screws 80        .29<br />
brads 100        .24<br />
$<br />
</pre><p><span class="bodycopy">第一项业务定单是通过将第二个字段（数量）的值乘以第三个字段（价格）的值，计算每种物品的库存价值：</span></p><pre>$ awk '{print $1,"QTY: "$2,"PRICE: "$3,"TOTAL: "$2*$3}' inventory<br />
hammers QTY: 5 PRICE: 7.99 TOTAL: 39.95<br />
drills QTY: 2 PRICE: 29.99 TOTAL: 59.98<br />
punches QTY: 7 PRICE: 3.59 TOTAL: 25.13<br />
drifts QTY: 2 PRICE: 4.09 TOTAL: 8.18<br />
bits QTY: 55 PRICE: 1.19 TOTAL: 65.45<br />
saws QTY: 123 PRICE: 14.99 TOTAL: 1843.77<br />
nails QTY: 800 PRICE: .19 TOTAL: 152<br />
screws QTY: 80 PRICE: .29 TOTAL: 23.2<br />
brads QTY: 100 PRICE: .24 TOTAL: 24<br />
$<br />
</pre><p><span class="bodycopy">如果这些行本身并不重要，您只是希望确定商店中有多少件物品，则可以分配一个普通变量，按照每条记录中的物品数量增加：</span></p><pre>$ awk '{x=x+$2} {print x}' inventory<br />
5<br />
7<br />
14<br />
16<br />
71<br />
194<br />
994<br />
1074<br />
1174<br />
$<br />
</pre><p><span class="bodycopy">根据这一数据，商店中有 1174 件物品。第一次执行时，变量 x 没有值，因此它采用第一行第二个字段的值。第二次执行时，它保留了第一行的值并加上第二行的值，以此类推，直到达到累计的总合。</span></p><p><span class="bodycopy">可以应用相同的过程来确定现有库存的总价值：</span></p><pre>$ awk '{x=x+($2*$3)} {print x}' inventory<br />
39.95<br />
99.93<br />
125.06<br />
133.24<br />
198.69<br />
2042.46<br />
2194.46<br />
2217.66<br />
2241.66<br />
$<br />
</pre><p><span class="bodycopy">因此，1174 件物品的价值是 $2,241.66。虽然这一过程可以获得总计值，但它的外观很差，需要加工成实际的报表。利用一些附加项，很容易使显示变得更整洁：</span></p><pre>$ awk '{x=x+($2*$3)}{print $1,"QTY: "$2,"PRICE: "$3,"TOTAL: "$2*$3,"BAL: "x}' inventory<br />
hammers QTY: 5 PRICE: 7.99 TOTAL: 39.95 BAL: 39.95<br />
drills QTY: 2 PRICE: 29.99 TOTAL: 59.98 BAL: 99.93<br />
punches QTY: 7 PRICE: 3.59 TOTAL: 25.13 BAL: 125.06<br />
drifts QTY: 2 PRICE: 4.09 TOTAL: 8.18 BAL: 133.24<br />
bits QTY: 55 PRICE: 1.19 TOTAL: 65.45 BAL: 198.69<br />
saws QTY: 123 PRICE: 14.99 TOTAL: 1843.77 BAL: 2042.46<br />
nails QTY: 800 PRICE: .19 TOTAL: 152 BAL: 2194.46<br />
screws QTY: 80 PRICE: .29 TOTAL: 23.2 BAL: 2217.66<br />
brads QTY: 100 PRICE: .24 TOTAL: 24 BAL: 2241.66<br />
$<br />
</pre><p><span class="bodycopy">该过程提供了每条记录的清单，同时将总价值分配给库存值，并保持商店资产的运作平衡。</span></p><p><tt><strong>BEGIN</strong></tt><span class="bodycopy"> 和 </span><tt><strong>END</strong></tt></p><p><span class="bodycopy">使用 </span><tt>BEGIN</tt><span class="bodycopy"> 和 </span><tt>END</tt><span class="bodycopy"> 语句可以分别指定在处理实际开始之前或者完成之后进行操作。</span><tt>BEGIN</tt><span class="bodycopy"> 语句最常用于建立变量或显示标题。另一方面，</span><tt>END</tt><span class="bodycopy"> 语句可用于在程序结束后继续进行处理。</span></p><p><span class="bodycopy">在前面的示例中，利用以下例程生成了物品的总价值：</span></p><pre>awk '{x=x+($2*$3)} {print x}' inventory<br />
</pre><p><span class="bodycopy">该例程在运行总计累加时显示了文件中的每一行。没有其他方法可以指定它，而不让在每一行进行打印也导致它始终不打印出来。但是，利用 </span><tt>END</tt><span class="bodycopy"> 语句可以避免这一问题：</span></p><pre>$ awk '{x=x+($2*$3)} END {print "Total Value of Inventory:"x}' inventory<br />
Total Value of Inventory: 2241.66<br />
$<br />
</pre><p><span class="bodycopy">定义了变量 </span><tt><em>x</em></tt><span class="bodycopy">，它对每一行进行处理；但是，在所有处理完成之前不会生成显示。尽管可以作为独立例程使用，它也可以置入到先前的代码列表，添加更多信息并生成更完整的报表：</span></p><pre>$ awk '{x=x+($2*$3)} {print $1,"QTY: "$2,"PRICE: <br />
    "$3,"TOTAL: "$2*$3} END {print "Total Value of Inventory: " x}' inventory<br />

hammers QTY: 5 PRICE: 7.99 TOTAL: 39.95<br />
drills QTY: 2 PRICE: 29.99 TOTAL: 59.98<br />
punches QTY: 7 PRICE: 3.59 TOTAL: 25.13<br />
drifts QTY: 2 PRICE: 4.09 TOTAL: 8.18<br />
bits QTY: 55 PRICE: 1.19 TOTAL: 65.45<br />
saws QTY: 123 PRICE: 14.99 TOTAL: 1843.77<br />
nails QTY: 800 PRICE: .19 TOTAL: 152<br />
screws QTY: 80 PRICE: .29 TOTAL: 23.2<br />
brads QTY: 100 PRICE: .24 TOTAL: 24<br />
Total Value of Inventory: 2241.66<br />
$<br />
</pre><p><span class="bodycopy"></span><tt>BEGIN</tt><span class="bodycopy"> 命令与 </span><tt>END</tt><span class="bodycopy"> 的工作方式相同，但它建立了那些需要在完成其他工作之前所做的项目。该过程最常见的目的是创建报表的标题。此例程的语法类似于</span></p><pre>$ awk 'BEGIN {print "ITEM   QUANTITY   PRICE   TOTAL"}'<br />
</pre><p><span class="parahead1">输入、输出和源文件</span></p><p><span class="bodycopy">AWK 工具可以从文件中读取其输入，正如在此之前所有示例所做的那样，它也可以从其他命令的输出中获取输入。例如：</span></p><pre>$ sort emp_names | awk '{print $3,$2}'<br />
</pre><p><span class="bodycopy"></span><tt>awk</tt><span class="bodycopy"> 命令的输入是排序操作的输出。除了 </span><tt>sort</tt><span class="bodycopy">，还可以使用任何其他的 Linux 命令 — 例如 </span><tt>grep</tt><span class="bodycopy">。该过程允许您在离开所选定字段前对文件执行其他操作。</span></p><p><span class="bodycopy">类似于解释程序，AWK 使用输出改向操作符 </span><tt>&gt;</tt><span class="bodycopy"> 和 </span><tt>&gt;&gt;</tt><span class="bodycopy"> 将其输出放入文件中而不是标准输出设备。这些符号的作用类似于它们在解释程序中的对应符号，因此 </span><tt>&gt;</tt><span class="bodycopy"> 在不存在文件时创建文件，而 </span><tt>&gt;&gt;</tt><span class="bodycopy"> 追加到现有文件的尾部。请看以下的示例：</span></p><pre>$ awk '{print NR, $1 ) &gt; "/tmp/filez" }' emp_names<br />
$ cat /tmp/filez<br />
1	46012<br />
2	46013<br />
3	46015<br />
4	46017<br />
5	46018<br />
6	46019<br />
7	46021<br />
8	46022<br />
9	46024<br />
10	46026<br />
11	46027<br />
12	46029<br />
$<br />
</pre><p><span class="bodycopy">检查该语句的语法，您会看到输出改向是在打印语句完成后进行的。必须将文件名包含在引号中，否则它只是一个未初始化的 AWK 变量，而将指令联接起来会在 AWK 中产生错误。（如果不正确地使用改向符号，则 AWK无法了解该符号意味着“改向”还是一个关系操作符。）</span></p><p><span class="bodycopy">在 AWK 中输出到管道也类似于解释程序中所实现的相同操作。要将打印命令的输出发送到管道中，可以在打印命令后附加管道符号以及命令的名称，如下所示：</span></p><pre>$ awk '{ print $2 | "sort" }' emp_names<br />
BOGUE<br />
BUCK<br />
DULANEY<br />
DURHAM<br />
FELDMAN<br />
FERGUS<br />
JUNE<br />
KANE<br />
STEEN<br />
SWIM<br />
TUTTLE<br />
WOOD<br />
$<br />
</pre><p><span class="bodycopy">这是输出改向的情况，必须将命令包含在引号中，而管道的名称是被执行命令的名称。</span></p><p><span class="bodycopy">AWK 所使用的命令可以来自两个地方。首先，可以在命令行中指定它们，如示例中所示。其次，它们可以由源文件提供。如果是这种情况，通过 </span><tt>-f</tt><span class="bodycopy"> 选项将这种情况向 AWK 发出警告。演示如下：</span></p><pre>$ cat awklist<br />
{print $3,$2}<br />
{print $4,$5,"\n"}<br />
$<br />

$ awk -f awklist emp_names<br />
EVAN DULANEY<br />
MOBILE AL<br />

JEFF DURHAM<br />
MOBILE AL<br />

BILL STEEN<br />
MOBILE AL<br />

EVAN FELDMAN<br />
MOBILE AL<br />

STEVE SWIM<br />
UNKNOWN AL<br />

ROBERT BOGUE<br />
PHOENIX AZ<br />

MICAH JUNE<br />
PHOENIX AZ<br />

SHERYL KANE<br />
UNKNOWN AR<br />

WILLIAM WOOD<br />
MUNCIE IN<br />

SARAH FERGUS<br />
MUNCIE IN<br />

SARAH BUCK<br />
MUNCIE IN<br />

BOB TUTTLE<br />
MUNCIE IN<br />

$<br />
</pre><p><span class="bodycopy">注意，在源文件中的任何地方或者在命令行中调用它时，不使用单引号。单引号只用于区别命令行中的命令与文件名称。</span></p><p><span class="bodycopy">如果简单的输出不能处理您的程序中所需要的复杂信息，则可以尝试由 </span><tt>printf</tt><span class="bodycopy"> 命令获得的更加复杂的输出，其语法是</span></p><pre>printf( format, value, value ...)<br />
</pre><p><span class="bodycopy">该语法类似于 C 语言中的 </span><tt>printf</tt><span class="bodycopy"> 命令，而格式的规格是相同的。通过插入一项定义如何打印数值的规格，可以定义该格式。格式规格包含一个跟有字母的 %。类似于打印命令，</span><tt>printf</tt><span class="bodycopy"> 不必包含在圆括号中，但是可以认为使用圆括号是一种良好的习惯。</span></p><p><span class="bodycopy">下表列出 </span><tt>printf</tt><span class="bodycopy"> 命令提供的各种规格。</span></p><table align="left" bgcolor="#ffffff" border="0" cellpadding="5" hspace="5" vspace="5" width="100%"><tbody><tr><td width="15%"><span class="boldbodycopy">规格</span></td><td width="85%"><span class="boldbodycopy">说明</span></td></tr><tr><td><tt>%c</tt></td><td><span class="bodycopy">打印单个 ASCII 字符</span></td></tr><tr><td><tt>%d</tt></td><td><span class="bodycopy">打印十进制数</span></td></tr><tr><td><tt>%e</tt></td><td><span class="bodycopy">打印数字的科学计数表示</span></td></tr>		                                                             <tr><td><tt>%f</tt></td><td><span class="bodycopy">打印浮点表示</span></td></tr><tr><td><tt>%g</tt></td><td><span class="bodycopy">打印 %e 或 %f；两种方式都更简短</span></td></tr><tr><td><tt>%o</tt></td><td><span class="bodycopy">打印无符号的八进制数</span></td></tr><tr><td><tt>s</tt></td><td><span class="bodycopy">打印 ASCII 字符串</span></td></tr><tr><td><tt>%x</tt></td><td><span class="bodycopy">打印无符号的十六进制数</span></td></tr><tr><td><tt>%%</tt></td><td><span class="bodycopy">打印百分号；不执行转换</span></td></tr></tbody></table><br />
<p><span class="bodycopy">可以在 % 与字符之间提供某些附加的格式化参数。这些参数进一步改进数值的打印方式：</span></p><table align="left" bgcolor="#ffffff" border="0" cellpadding="5" hspace="5" vspace="5" width="100%"><tbody><tr><td width="25%"><span class="boldbodycopy">参数</span></td><td width="75%"><span class="boldbodycopy">说明</span></td></tr><tr><td><tt>-</tt></td><td><span class="bodycopy">将字段中的表达式向左对齐</span></td></tr><tr><td><tt>,width</tt></td><td><span class="bodycopy">根据需要将字段补齐到指定宽度（前导零使用零将字段补齐） </span></td></tr><tr><td><tt>.prec</tt></td><td><span class="bodycopy">小数点右面数字的最大字符串宽度或最大数量</span></td></tr></tbody></table><p><span class="bodycopy"></span><tt>printf</tt><span class="bodycopy"> 命令能够控制并将数值从一种格式转换为另一种格式。当需要打印变量的值时，只需提供一种规格，指示 </span><tt>printf</tt><span class="bodycopy"> 如何打印信息（通常包含在双引号中）即可。必须为每个传递到 </span><tt>printf</tt><span class="bodycopy"> 的变量包含一个规格参数；如果包含过少的参数，则 </span><tt>printf</tt><span class="bodycopy"> 不会打印所有的数值。</span></p><p><span class="parahead1">处理错误</span></p><p><span class="bodycopy">AWK 工具报告所发生错误的方式很令人恼火。一个错误会阻碍任何操作的进行，所提供的错误信息非常含混不清：</span></p><pre>awk: syntax error near line 2<br />
awk: bailing out near line 2<br />
</pre><p><span class="bodycopy">您可能会花几小时的时间查看第 2 行，试图找出它为什么阻碍程序运行；这就是支持使用源文件的一个有力论据。</span></p><br />
<p><span class="bodycopy">切记有两条规则可以帮助您避免出现语法错误：</span></p><p><span class="bodycopy">1. 确保命令位于括号中，而括号位于单引号中。没有使用这些字符之一必然导致程序无法运行。</span></p><p><span class="bodycopy">2. 搜索命令需要位于斜线之间。要找出住在印第安那州的员工，您必须使用“</span><tt>/IN/</tt><span class="bodycopy">”而不是“</span><tt>IN</tt><span class="bodycopy">”。</span></p><p><span class="parahead1">结论</span></p><p><span class="bodycopy">尽管 AWK 完全代表另外的含意，但它应该是管理员智能工具包的首字母缩写。连同 SED一起，AWK 实用工具是 Linux管理员所拥有的功能最强大和灵活的工具之一。通过了解其语言的一些特性，您可以开辟出能够简化任务的领域，否则这些任务将会是非常费时和困难的。 </span></p><br />
</span></p><br />

    </div>

<div class="meta">
    
    <span class="comments"><a href="/about-awk/#disqus_thread">Comments</a></span>
    
</div>
</article>

  <article class="post">
    <h2 class="title"> 
        <a href="/about-tcp-ip/">TCP三次握手及原理 zz</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2006-03-27T00:00:00.000&#43;00:00' itemprop="datePublished">2006-03-27</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/windows">Windows</a>


</div>
    </div>
        <span class="unnamed3">TCP/IP是很多的不同的协议组成，实际上是一个协议组，TCP用户数据报表协议(也称作TCP传输控制协议，Transport ControlProtocol。可靠的主机到主机层协议。这里要先强调一下，传输控制协议是OSI网络的第四层的叫法，TCP传输控制协议是TCP/IP传输的6个基本协议的一种。两个TCP意思非相同。)。TCP是一种可靠的面向连接的传送服务。它在传送数据时是分段进行的，主机交换数据必须建立一个会话。它用比特流通信，即数据被作为无结构的字节流。通过每个TCP传输的字段指定顺序号，以获得可靠性。是在OSI参考模型中的第四层，TCP是使用IP的网间互联功能而提供可靠的数据传输，IP不停的把报文放到网络上，而TCP是负责确信报文到达。在协同IP的操作中TCP负责：握手过程、报文管理、流量控制、错误检测和处理（控制），可以根据一定的编号顺序对非正常顺序的报文给予从新排列顺序。关于TCP的RFC文档有RFC793、RFC791、RFC1700。<br />
<p>　　在TCP会话初期，有所谓的“三握手”：对每次发送的数据量是怎样跟踪进行协商使数据段的发送和接收同步，根据所接收到的数据量而确定的数据确认数及数据发送、接收完毕后何时撤消联系，并建立虚连接。为了提供可靠的传送，TCP在发送新的数据之前，以特定的顺序将数据包的序号，并需要这些包传送给目标机之后的确认消息。TCP总是用来发送大批量的数据。当应用程序在收到数据后要做出确认时也要用到TCP。由于TCP需要时刻跟踪，这需要额外开销，使得TCP的格式有些显得复杂。下面就让我们看一个TCP的经典案例，这是后来被称为MITNICK攻击中KEVIN开创了两种攻击技术： </p><p>　　TCP会话劫持 <br />
　　SYN FLOOD（同步洪流） </p><br />
<br><!--more--><p>　　在这里我们讨论的时TCP会话劫持的问题。 </p><p>　　先让我们明白TCP建立连接的基本简单的过程。为了建设一个小型的模仿环境我们假设有3台接入互联网的机器。A为攻击者操纵的攻击机。B为中介跳板机器（受信任的服务器）。C为受害者使用的机器（多是服务器），这里把C机器锁定为目标机器。A机器向B机器发送SYN包，请求建立连接，这时已经响应请求的B机器会向A机器回应SYN/ACK表明同意建立连接，当A机器接受到B机器发送的SYN/ACK回应时，发送应答ACK建立A机器与B机器的网络连接。这样一个两台机器之间的TCP通话信道就建立成功了。 </p><p>　　B终端受信任的服务器向C机器发起TCP连接，A机器对服务器发起SYN信息，使C机器不能响应B机器。在同时A机器也向B机器发送虚假的C机器回应的SYN数据包，接收到SYN数据包的B机器（被C机器信任）开始发送应答连接建立的SYN/ACK数据包，这时C机器正在忙于响应以前发送的SYN数据而无暇回应B机器，而A机器的攻击者预测出B机器包的序列号（现在的TCP序列号预测难度有所加大）假冒C机器向B机器发送应答ACK这时攻击者骗取B机器的信任，假冒C机器与B机器建立起TCP协议的对话连接。这个时候的C机器还是在响应攻击者A机器发送的SYN数据。 </p><p>　　TCP协议栈的弱点：TCP连接的资源消耗，其中包括：数据包信息、条件状态、序列号等。通过故意不完成建立连接所需要的三次握手过程，造成连接一方的资源耗尽。 </p><p>　　通过攻击者有意的不完成建立连接所需要的三次握手的全过程，从而造成了C机器的资源耗尽。序列号的可预测性，目标主机应答连接请求时返回的SYN/ACK的序列号时可预测的。（早期TCP协议栈，具体的可以参见1981年出的关于TCP雏形的RFC793文档） </p><p>　　TCP头结构 </p><p>　　TCP协议头最少20个字节，包括以下的区域（由于翻译不禁相同，文章中给出相应的英文单词）： </p><p>　　<strong>TCP源端口(Source Port)</strong>：16位的源端口其中包含初始化通信的端口。源端口和源IP地址的作用是标示报问的返回地址。 </p><p>　　<strong>TCP目的端口(Destination port)</strong>：16位的目的端口域定义传输的目的。这个端口指明报文接收计算机上的应用程序地址接口。 </p><p>　　<strong>TCP序列号（序列码,Sequence Number）</strong>：32位的序列号由接收端计算机使用，重新分段的报文成最初形式。当SYN出现，序列码实际上是初始序列码（ISN），而第一个数据字节是ISN+1。这个序列号（序列码）是可以补偿传输中的 不一致。 </p><p>　　<strong>TCP应答号(Acknowledgment Number)</strong>：32位的序列号由接收端计算机使用，重组分段的报文成最初形式。，如果设置了ACK控制位，这个值表示一个准备接收的包的序列码。 </p><p>　　<strong>数据偏移量(HLEN)</strong>：4位包括TCP头大小，指示何处数据开始。 </p><p>　　<strong>保留(Reserved)</strong>：6位值域，这些位必须是0。为了将来定义新的用途所保留。 </p><p>　　<strong>标志(Code Bits)</strong>：6位标志域。表示为：紧急标志、有意义的应答标志、推、重置连接标志、同步序列号标志、完成发送数据标志。按照顺序排列是：URG、ACK、PSH、RST、SYN、FIN。 </p><p>　　<strong>窗口(Window)</strong>：16位，用来表示想收到的每个TCP数据段的大小。 </p><p>　　<strong>校验位(Checksum)</strong>：16位TCP头。源机器基于数据内容计算一个数值，收信息机要与源机器数值 结果完全一样，从而证明数据的有效性。 </p><p>　　<strong>优先指针（紧急,Urgent Pointer）</strong>：16位，指向后面是优先数据的字节，在URG标志设置了时才有效。如果URG标志没有被设置，紧急域作为填充。加快处理标示为紧急的数据段。 </p><p>　　<strong>选项(Option)</strong>：长度不定，但长度必须以字节。如果 没有 选项就表示这个一字节的域等于0。 </p><p>　　<strong>填充</strong>：不定长，填充的内容必须为0，它是为了数学目的而存在。目的是确保空间的可预测性。保证包头的结合和数据的开始处偏移量能够被32整除，一般额外的零以保证TCP头是32位的整数倍。 标志控制功能 </p><p>　<strong>　URG</strong>：紧急标志 <br />

　　紧急(The urgent pointer) 标志有效。紧急标志置位， </p><p>　　<strong>ACK</strong>：确认标志 <br />

　　确认编号(Acknowledgement Number)栏有效。大多数情况下该标志位是置位的。TCP报头内的确认编号栏内包含的确认编号(w+1，Figure：1)为下一个预期的序列编号，同时提示远端系统已经成功接收所有数据。 </p><p>　　<strong>PSH</strong>：推标志 </p><p>　　该标志置位时，接收端不将该数据进行队列处理，而是尽可能快将数据转由应用处理。在处理 telnet 或 rlogin 等交互模式的连接时，该标志总是置位的。 </p><p>　　<strong>RST</strong>：复位标志 </p><p>　　复位标志有效。用于复位相应的TCP连接。 </p><p>　　<strong>SYN</strong>：同步标志 </p><p>　　同步序列编号(Synchronize SequenceNumbers)栏有效。该标志仅在三次握手建立TCP连接时有效。它提示TCP连接的服务端检查序列编号，该序列编号为TCP连接初始端(一般是客户端)的初始序列编号。在这里，可以把TCP序列编号看作是一个范围从0到4，294，967，295的32位计数器。通过TCP连接交换的数据中每一个字节都经过序列编号。在TCP报头中的序列编号栏包括了TCP分段中第一个字节的序列编号。 </p><p>　　<strong>FIN</strong>：结束标志 </p><p>　　带有该标志置位的数据包用来结束一个TCP回话，但对应端口仍处于开放状态，准备接收后续数据。 </p><p>　　服务端处于监听状态，客户端用于建立连接请求的数据包(IP packet)按照TCP/IP协议堆栈组合成为TCP处理的分段(segment)。 </p><p>　　<strong>分析报头信息</strong>： TCP层接收到相应的TCP和IP报头，将这些信息存储到内存中。 </p><p>　　<strong>检查TCP校验和(checksum)</strong>：标准的校验和位于分段之中(Figure：2)。如果检验失败，不返回确认，该分段丢弃，并等待客户端进行重传。 </p><p>　　<strong>查找协议控制块(PCB{})</strong>：TCP查找与该连接相关联的协议控制块。如果没有找到，TCP将该分段丢弃并返回RST。(这就是TCP处理没有端口监听情况下的机制)如果该协议控制块存在，但状态为关闭，服务端不调用connect()或listen()。该分段丢弃，但不返回RST。客户端会尝试重新建立连接请求。</p><p>　　<strong>建立新的socket</strong>：当处于监听状态的socket收到该分段时，会建立一个子socket，同时还有socket{}，tcpcb{}和pub{}建立。这时如果有错误发生，会通过标志位来拆除相应的socket和释放内存，TCP连接失败。如果缓存队列处于填满状态，TCP认为有错误发生，所有的后续连接请求会被拒绝。这里可以看出SYN Flood攻击是如何起作用的。 </p><p>　　<strong>丢弃</strong>：如果该分段中的标志为RST或ACK，或者没有SYN标志，则该分段丢弃。并释放相应的内存。 </p><p>　　发送序列变量 </p><p>　　SND.UNA ： 发送未确认 </p><p>　　SND.NXT ： 发送下一个 </p><p>　　SND.WND ： 发送窗口 </p><p>　　SND.UP ： 发送优先指针 </p><p>　　SND.WL1 ： 用于最后窗口更新的段序列号 </p><p>　　SND.WL2 ： 用于最后窗口更新的段确认号 </p><p>　　ISS ： 初始发送序列号 </p><p>　　接收序列号 </p><p>　　RCV.NXT ： 接收下一个 </p><p>　　RCV.WND ： 接收下一个 </p><p>　　RCV.UP ： 接收优先指针 </p><p>　　IRS ： 初始接收序列号 </p><p>当前段变量 </p><p>　　SEG.SEQ ： 段序列号 </p><p>　　SEG.ACK ： 段确认标记 </p><p>　　SEG.LEN ： 段长 </p><p>　　SEG.WND ： 段窗口 </p><p>　　SEG.UP ： 段紧急指针 </p><p>　　SEG.PRC ： 段优先级 </p><p>　　CLOSED表示没有连接，各个状态的意义如下： </p><p>　　LISTEN ： 监听来自远方TCP端口的连接请求。 </p><p>　　SYN-SENT ： 在发送连接请求后等待匹配的连接请求。 </p><p>　　SYN-RECEIVED ： 在收到和发送一个连接请求后等待对连接请求的确认。 </p><p>　　ESTABLISHED ： 代表一个打开的连接，数据可以传送给用户。 </p><p>　　FIN-WAIT-1 ： 等待远程TCP的连接中断请求，或先前的连接中断请求的确认。 </p><p>　　FIN-WAIT-2 ： 从远程TCP等待连接中断请求。 </p><p>　　CLOSE-WAIT ： 等待从本地用户发来的连接中断请求。 </p><p>　　CLOSING ： 等待远程TCP对连接中断的确认。 </p><p>　　LAST-ACK ： 等待原来发向远程TCP的连接中断请求的确认。 </p><p>　　TIME-WAIT ： 等待足够的时间以确保远程TCP接收到连接中断请求的确认。 </p><p>　　CLOSED ： 没有任何连接状态。 </p><p>　　TCP连接过程是状态的转换，促使发生状态转换的是用户调用：OPEN，SEND，RECEIVE，CLOSE，ABORT和STATUS。传送过来的数据段，特别那些包括以下标记的数据段SYN，ACK，RST和FIN。还有超时，上面所说的都会时TCP状态发生变化。 </p><p>　　序列号 </p><p>　　请注意，我们在TCP连接中发送的字节都有一个序列号。因为编了号，所以可以确认它们的收到。对序列号的确认是累积性的。TCP必须进行的序列号比较操作种类包括以下几种： </p><p>　　①决定一些发送了的但未确认的序列号。 </p><p>　　②决定所有的序列号都已经收到了。 </p><p>　　③决定下一个段中应该包括的序列号。 </p><p>　　对于发送的数据TCP要接收确认，确认时必须进行的： </p><p>　　SND.UNA = 最老的确认了的序列号。 </p><p>　　SND.NXT = 下一个要发送的序列号。 </p><p>　　SEG.ACK = 接收TCP的确认，接收TCP期待的下一个序列号。 </p><p>　　SEG.SEQ = 一个数据段的第一个序列号。 </p><p>　　SEG.LEN = 数据段中包括的字节数。 </p><p>　　SEG.SEQ+SEG.LEN-1 = 数据段的最后一个序列号。 </p><p>　　如果一个数据段的序列号小于等于确认号的值，那么整个数据段就被确认了。而在接收数据时下面的比较操作是必须的： </p><p>　　RCV.NXT = 期待的序列号和接收窗口的最低沿。 </p><p>　　RCV.NXT+RCV.WND：1 = 最后一个序列号和接收窗口的最高沿。 </p><p>　　SEG.SEQ = 接收到的第一个序列号。 </p><p>　　SEG.SEQ+SEG.LEN：1 = 接收到的最后一个序列号.</p></span><br />

    </div>

<div class="meta">
    
    <span class="comments"><a href="/about-tcp-ip/#disqus_thread">Comments</a></span>
    
</div>
</article>

  <article class="post">
    <h2 class="title"> 
        <a href="/lns-firewall/">LNS防火墙中级使用指南zz</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2006-03-26T00:00:00.000&#43;00:00' itemprop="datePublished">2006-03-26</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/windows">Windows</a>


</div>
    </div>
        http://bbs.zol.com.cn/index20060306/index_40_72576.html<br />

<p><span style="font-size: 12px">安装方法： <br />

双击运行LooknStop_Setup_205p2.exe即可！ <br />

注意：安装时会弹出一个没有通过 Windows 徽标测试的提示窗口，点击仍然继续即可！ <br />


汉化方法： <br />

将汉化补丁文件内的语言文件chinese.lng及语言插件复制到look'n'stop的安装目录下(默认是C:\ProgramFiles\Soft4Ever\looknstop)，然后打开look'n'stop就应该是中文界面了，如果仍是英文界面，可以按下面的步骤操作： <br />

1) 点击"Options"选项卡的"Advanced Options"按钮； <br />
2) 点击"Plugins"按钮； <br />
3) 在"Avilable_plugins"框中打勾"plugin_language.dll"； <br />
4) 点击"Configure"按钮； <br />
5) 选中"简体中文"，确定。 <br />

注册方法： <br />

切换到"注册"选项卡，然后复制"代码"里的注册代码，接着运行"注册机.exe"即可取得序列号！ <br />

注意： <br />

1.如果安装look'n'stop后无法上网，可以这样解决：切换到主界面的"互联网过滤"，然后双击最后一条规则<a name="3"></a>"All oter packets"，把以"太网 : 类型"的中的"全部"改为"IP"，保存后应用即可！ <br />
2.该防火墙功能强大，但设置也非常繁多复杂，因此建议一般用户请谨慎使用！ <br />

注意：你在使用下述图解时，<span style="color: rgb(255, 0, 0)">请一定先打开“选项”—&gt;选中“高级模式”</span>，切记。 <br />
</span></p><p><span style="font-size: 12px"><br><!--more--><p><span style="font-size: 12px">1.应用程序过滤----专门对程序进行设定，决定应用程序行为的控制。<br />
<img style="width: 591px; height: 443px" alt="Click here to open new window" src="http://www.magicwinmail.com/course/looknstop/images/22_96947.jpg" rel="lightbox"/><br />
先看看红色编号1区，这个区显示是正连接在网络上或者曾经连接过网络目前还没有关闭的软件清单。 <br />

重点是看绝色编号2区，这个区才是重点，有N多的门道在里面。这个区猛一看是已允许的相信的程序，仔细看看，偶已经列出了11种属性，当然也是可能的全部属性了。 <br />

现在按此区的“列”来开讲^_^，之前必需选中黑色编号13“应用程序过滤已启用”，否则所做的任何设置都不起作用，嘿嘿。 <br />

第一列只有此二种属性，简而言之就是启用或者禁用该规则，单击实现二种属性之间的切换。见黑色编号1，黑色编号2。 <br />

黑色编号1，是指启用为它所在行的那个程序制定的规则，也就是说让该程序按既定的规则运行，此所谓的应用程序过滤。如果你不想为这个程序设置的规则起作用的话，那么点击一下，就会变成黑色编号2所指的样子。 <br />

第二列有三种属性，分别是允许（黑色编号5）、禁止（黑色编号4）、自定义（黑色编号3）。单击则在允许与禁止之间切换，如果有自定义属性，则在三者之间进行切换。 <br />
黑色编号3：黄色圆饼标志。当你为此程序制定了特殊规则，如指定程序只能连接远程的哪些端口、或者不允许连接哪些端口；允许连接哪些地址、禁止连接哪些地址时，则出现黄色的圆。（功能强大，设置之灵活让人唏嘘。）具体看看如下： <br />

双击某个程序（当然也可以通过点击点击黑色编号12来实现），就会出现如图二所示的“选择端口和IP地址”窗口，此时你可以设置具体的内容了。 <br />
<img src="http://www.magicwinmail.com/course/looknstop/images/22_96948.jpg" if(this.width="" alt=""/><br />
比如，偶的TW，偶只允许它连接远程的80端口，不允许连接其它端口，那么就按上面的设置；此时对IP地址没有限制。如果你想让他只连接远程的某个IP地址，那么就在IP地址栏输入。当然没有人会这么对待浏览器。 <br />

这个自定义功能不会只是如此简单吧？当然不是，其实重要的不是允许去什么地方，而是禁止它去什么去什么地方。比如，你的CuteFTP一启动就想去它的主站验证一下它的合法性，那么你就可以在这里设置一下了，而又不影响其它程序（如IE）访问CuteFTP的主站（目前偶还没有发现哪个防火墙能这样设置的，嘿嘿，如果有恕偶无知）。 <br />

说了半天，允许和禁止在这里是看不出区别的，该怎么办？其它很简单，允许访问的端口或者IP，则直接输入在上面就行。如果你要禁止某个端口或者地址，呵呵，只要在端口前面加上一个感叹号“！”就行了，是不是真的简单？对了，如果是多个IP或者端口，不要忘记在它们之间加上一个半角的分号“；”哦。 <br />

黑色编号4：红色禁止标志。此标志表示禁止该程序连接网络。 <br />

黑色编号5：绿色允许标志。此标志表示允许该程序连接网络。 <br />

现在来看第三列，此列只有二种属性，单击则实现二种属性之间的切换。见黑色编号7、黑色编号9。这一列是强大功能的一个体现，作用是允许或者禁止此程序调用另一个程序并且使用被调用的这个程序连接网络，也就是说：A程序启动了B程序，B程序有连网企图，此属性就是对这种情况进行控制的。必须打开“高级选项”中的“高级模式”才会出现此列。 <br />

黑色编号7：双箭头标志。当为此标志时则意味着允许当前程序去调用另外一个要使其连接网络的程序。如果发生这种情况，则出现提示窗。 <br />

黑色编号9：红色禁止标志。当为此标志时不允许当前程序去调用另外一个要使其连接网络的程序，当然如果被调用的程序没有连接网络的企图，则防火墙是不出现提示的。 <br />

第四列，此列有三种属性，其中二种属性与第一列的属性配合才能看到效果。黑色编号6、黑色编号10、黑色编号11。 <br />

黑色编号11：如果是这个标志，则什么也不发生。相当于此属性被禁用。 <br />

黑色编号10：单感叹号标志。此标志表示在日志中记录该应用程序的连网“企图”，此时要与第一列配合使用，第一列的属性必须是禁止标志才起作用。这个功能的好处太多了，比如：一个被你禁止了的程序，可能也已经关闭了，但频频试图连网，估计它也不是什么好东西，木马常常这么干！ <br />

黑色编号6： 双感叹号标志。此标志表示无论该程序是禁止还是允许连网，都在日志中记录。 <br />

好了，应用程序过滤篇到此完毕。可以看出，LNS对程序的控制非常灵活且强大，10个属性有36种不同组合。仅一个页面可以实现允许禁止、记录与否、单程序访问控制、进程调用四种功能的控制。<br />
<span id="text2" style="font-size: 12px">2.互联网过滤----专门对防火墙规则进行设定，也有少量设定涉及到程序。决定网络连接及数据包行为的控制。 <br />

图三是互联网过滤，继续按“列”进行讲解。此页面部分功能与“选项”时的“消息框”、“声音”、“日志”配合使用。<br />

<img src="http://www.magicwinmail.com/course/looknstop/images/22_96949.jpg" if(this.width="" alt=""/><br />
第一列，有三种属性。自定义的启动该规则属性、默认的启用该规则属性、不启用该规则属性，分别对应黑色编号3、黑色编号1和黑色编号2。三种属性之间点击进行切换，但如果没有进行自定义，则只在二种属性间切换。 <br />

黑色编号1：绿色带勾标志。此标志表示启用该规则，且该规则没有进行特别的自定义。 <br />

黑色编号2：灰色小圆点标志。此标示表示不使用该规则，也就是说防火墙对网络连接请进行检查时不与该规则进行匹配操作。相当于这条规则只是临时放在这里，并没有什么作用。 <br />

黑色编号3：暗红色带勾标志。此标志表明这条规则只对特定的程序起作用，当此特定的程序启动后，此标志则变为绝色带勾标志，表示规则启用了，否则为暗红色带勾标志，表示这规则暂时未被启用。这种设置方式似乎也没有在其它防火墙中见到，极其特别，也是LNS灵活的一个体现。它的好象是什么呢？显示易见，当该特定程序没有启动时，就相当于少了一条规则，少一条规则多一分安全是主要的；其次可以加快对规则匹配操作的时间。设置特定程序的方法为双击当前规则，出现一个设置窗如图四所示。 <br />

<img style="width: 596px; height: 467px" src="http://www.magicwinmail.com/course/looknstop/images/22_96950.jpg" if(this.width="" alt=""/><br />
双击一条规则后会出现如红色编号1的窗口，点击些窗口上的“应用程序…”按钮，出现如红色编号2所示的窗口，将此窗口中右侧的程序双击添加到左侧，然后一路确定就可以了。图示是偶为BT添加的自定义规则，只有当BT启动后它才启用，平时这条规则相当于不存在，呵呵，否则会浪费偶的资源的。 <br />

第二列，有二种属性。分别是禁止与允许，对应于黑色编号4。此列主要用途是，允许执行与此规则匹配的连接请求，还是禁止与此规则匹配的连接请求。 <br />

黑色编号4：红色禁止标志。此标志表示，当某个连接请求或者操作与此规则匹配时，则禁止该连接请求或者操作。如果是灰色圆点标志，则表示此允许此连接请求或者操作。此属性的好处是，可以用来限制某些特定的操作而又不产生全局影响，而当你需要时又可以打开这一特定规则。 <br />

第三列，二种属性。记录或者不记录与该规则匹配的操作信息。 <br />

黑色编号6：单感叹号标志。表示当某个连网请求或者操作与此规则匹配时，则记录些操作的信息，这些信息一定会在日志标签的窗口里显示出来。如果你启用了“选项”标签中的日志文件功能，则这些信息保存在日志文件中，如果没有启用日志文件功能，则不保存。另一灰色圆点标志表示不记录也不保存这些信息。本人建议把LNS的记录功能打开，这样一旦某些软件不能正常上网时，可以在日志中发现并生成规则（后面讲到如何用日志生成适用规则）。 <br />

第四列，二种属性。分别对应黑色编号7、黑色编号8。功能比较简单，但却非常的有用啊。 <br />

黑色编号7：黄色下箭头标志。些标志表示，如果某个操作与此规则匹配时，则直接进行相应的操作（即第一列、第二列、第三列所定义的属性及具体规则内容进行操作），不再继续匹配后续的其它规则，因为LNS匹配规则的顺序是自上而下的（故大家最好不要调整那些LNS默认生成的规则的上下顺序，否则可能什么程序也上不了网）。这种属性产生的操作带来的好处是：不用将所有规则匹配一遍，极大地减少了LNS规则匹配操作所用的时间；其次如果你添加了一条过于宽泛自己不知道有没有漏洞的规则，那么你可以关闭此属性，则当有某个操作与此规则匹配后，后续规则继续对其进行检测，以发现问题。 <br />

黑色编号8：灰色圆点标志。此标志表示匹配完此规则后，再继续匹配后续规则。 <br />

第五列，三种属性。对应于黑色编号9、黑色编号10。作用是当有某操作与此规则匹配时，以什么方式来报警。 <br />

黑色编号9：小喇叭标志。此标志表示某操作与此规则匹配时，以发生声音的方式报警。打开此属性必须同时在“选项”标签中选中“声音”功能。 <br />

黑色编号10：双感叹号标志。此标志表示某操作与此规则匹配时，不但发出声音报警，而且跳出消息框报警。也必须同时打开“选项”标签中的“声音”与“消息框”功能，否则不起作用。 <br />

灰色小圆点标志，表示不需要报警。 <br />
此列的属性建议对系统默认的规则打开，此时能看到一些异常操作，及时采用措施。对于其它的频繁正常操作，如果打开了会不胜其烦的。比如在你为BT设置的规则上设置此属性，消息框会跳满一屏幕，呵呵。 <br />

最后再说一下，如果你取消对图三右下角的“互联网过滤已启用”选中的话，则此规则表中所有规则都相当于不存在，基本上是门户大开啊。切记！<br />
<span id="text3" style="font-size: 12px">3.规则编辑----定义符号你自己需要的规则。 <br />
在LNS里定义规则有两种方法，在“互联网过滤”里“添加”规则是最难的一种；另一种方法是从“日志”标签里进行添加，则简单得多了，后面再讲到。 <br />

图五是规则编辑窗的界面，分为8个区域，按“区”讲吧。分别为“规则名称”、“方向”、“规则说明”、“以太网”、“IP”、“标识”、“来源”、“目标”8个区。<br />


<img style="width: 587px; height: 440px" alt="Click here to open new window" src="http://www.magicwinmail.com/course/looknstop/images/22_96962.jpg" if(this.width=""/><br />
首先，LNS防火墙在编辑时规则是中性的，也就是说在编辑界面上，我们不能够确定该规则是禁止了某个操作还是允许了某个操作，一旦“确定”后，LNS默认这个规则是允许与之匹配的操作的；如果你编制规则的目的是想禁止某种操作，那么你只要把规则说清楚，“确定”后再点图四所示的第二列的“红色禁止”标志就行了，此时在该规则也会出现一个禁止标志，意思就是禁止那些与此规则匹配的操作。这一点与任何防火墙都不同。 <br />

LNS防火墙的规则的信任关系是基于IP地址+MAC地址的，这是一种理想的信任关系模式。IP地址是可以欺骗的，MAC地址也同样，但IP+MAC的欺骗就困难得多，所以LNS安全性能可想而知。因此在图五中大家会看到“以太网：类型”和“以太网：地址”区域，使设置显得复杂常常令人困惑。其实了解了它的作用就不感到复杂了。<br />

“规则名称”区 <br />
黑色编号1：规则名称，不用多说。 <br />

“方向”区 <br />
黑色编号2：设定此规则的数据方向。你可以定义这条规则只对传入的连接（数据）起作用，或是对传出的生效，或对传入传出都起作用。此设置与“来源”和“目标”区有关联，选中“传入”或者“传出”则“来源”和“目标”内容有变化，此时更直接；但选中“两者”时，“来源”和“目标”区域显得复杂。 <br />

“规则说明”区 <br />
黑色编号3：可以对该规则进行说明，以便记忆或了解。 <br />

“以太网:类型”区 <br />
黑色编号4：可能也是让大家头痛的地方，常常不知道如何设置这个地方。“以太网：类型”其实就是告诉防火墙你的机器是局域网中的机器还是独立的一台机器，或者你理解“以太网：类型”就是要告诉LNS此条规则是适用于网域局中的通讯或者适用于互联网中的通讯。在这里就得多唠叨几句。这个类型里有四种选择，分别是“全部”、“IP”、“ARP”、“其它”，“全部”即指包括“IP、ARP、其它”的全部类型。 <br />
“全部”类型极少用到，除非你的机器处于混合网络（如同时有windows、Linux、Unix、Mac os、VAX、Netware等操作系统的机器）中，可能会同时存在多种不同的局域网协议时。因此不赞成独立PC和单纯局域网选择该类型。 <br />
"IP”类型，网际协议类型，用于把数据包从源地址发往目的地，多数情况下选择这种类型是合适的，尤其你的机器是通过非代理非网关直接上网时至少得（选择“全部”当然可以，但开放了不必要的协议）选择此类型，制定那些与互联网连接相关的规则时必须选择它，当然如果规则是局域相关的也同样可以选择它。 <br />
“ARP”类型，地址解析协议，它的作用是把IP地址解析（转换）为与此IP对应的MAC地址，从而找到该机器，只能用于与局域网相关的规则中，用在与互联网相关的规则中会造成该规则不起作用。除非你是在局域网中使用本机，否则不要生成选中此类型的规则；如果你是在局域网中通过代理或者网关上网，那么LNS默认有一条规则使用的此类型，规则名是“ARP : Authorize all ARP packets”，则必须打开并允许此规则，否则你无法上互联网。 <br />

“IP”区 <br />
黑色编号5：也就是为当前规则指定协议，共有8种类型。最常用的是TCP和UDP，偶一般人用这2个协议足够，其它协议给高手们用。编号右侧的“碎片偏移”和“碎片标志”俺不知道是个啥，所以通常用“全部”没有不良影响，呵呵。如果选择了TCP协议，则右侧的“TCP标志”是可选的；如果选择了ICMP/IGMP，侧“标志”内容也不同。 <br />

“来源”区，我想它后面的一串文字和方向，是造成大家不好理解的重要原因。与其它任何防火墙不同的是：在LNS的这个规则编辑器里，“来源”完全表示本地，“目标”则表示远程，而不管实际的连接请求或者数据包方向，大家在此一定要转变思路。所以，“来源”区所填写的数据都是与本地有关的，比如你要打开或者关闭本机的某个端口、允许或禁止本地的某个IP（当LNS安装在网关或者代理服务器上时有用），都可以把端口、IP地址信息输入在这里，理解了这一点，规则就好编了。 <br />

黑色编号的7、8：用来限定MAC地址的，当编号7选择了“全部”时，后面的不用填任何地址，填了也没用；只有当编号7选择了“等于”或者“不等于”时填MAC地址才有用，而且此时LNS也应该在代理服务器或者网关上才真正有用。它的作用就是限制内网的一个或某些机器的特定操作的，具体是什么特定操作还要看其它设置的配合情况。 <br />

黑色编号9：用来对IP地址进行各种组合和排除的，共10种方法，真是了得！当选择了“全部”时，它下面黑色编号11的地址栏是灰色不能进行输入的，否则要进行输入。但LNS有个BUG，即在此输入的IP地址无法输入3位数，解决方法是先能输入多少输入多少，保存后，用文本工具打开LNS目录的对应的规则文件，按你在此所定义的规则名称，找到你所输入的内容后把IP地址改为3位数保存后，重启LNS就行了，呵呵，这个BUG真不应该。 <br />

黑色编号10：用来定义具体的端口号的，此时建议尽量选择你想要的协议，然后输入端口号。如果不选择协议就输入端口号，则此端口号对所有协议开放，安全性应该会下降。同样黑色编号12有7种方法，以便对端口号进行排除。 <br />

黑色编号13：用来指定程序的。也就是说，当你指定了程序后，该规则只对此程序起作用，当该程序没有启动时，该规则是不执行的，因而也不会影响到其它程序。比如你为BT制定了特殊的<strong>规</strong>规则，那么就可以在这里设置好，当BT启动后该规则也自动加载。有此功能，就既可以定义特殊规则，又不会让此规则影响到全部程序了。 <br />

“目标”区，此区是与“来源”区相对应的，一定要注意，你的本地的信息永远不要出现在这个区，虽然它叫“目标”，但它完全是指远程机器的，那怕你的本地机器被全宇宙的黑客当成“目标”！所以在这个区出现的IP地址、端口号都是批你想要访问或者你不想要访问，再或者你不想让它来访问你的那些远程机器的IP和端口号。我想现在大家知道了“来源”和“目标”的实质，编规则也好办了。那么此区的“以太网：地址”、“IP地址”、“TCP/UDP端口”的设置方法与“来源”区所讲到的完全相同，不用再说了，不同的是它们是指的远程！！！</span> </span></span></p><p><span style="font-size: 12px"><span style="font-size: 12px"><span id="text4" style="font-size: 12px">“规则编辑”看来不讲例子是不行的，下面先讲一个开放特殊端口的例子，以BT为例，见图<br />

<img style="width: 596px; height: 421px" alt="Click here to open new window" src="http://www.magicwinmail.com/course/looknstop/images/22_96963.jpg" if(this.width=""/><br />
事先说明偶的BT监听的端口是10521，Bt（Emule、Edonkey都是工作原理类似的软件）比较特殊，它与其它下载工具的工作原理不同，偶认为BT是用其它端口发送连接请求等等信息，而用10521端口来专门进行数据包的传输，故10521端口是不主动向外发送信息，因而当其它的远程BT端收到本地BT发出的信息后，便把回应信息向10521端口发送，此时在LNS里便认为这个操作有隐患，故而拦截。那么便需要对LNS进行设置，让它放这种信息一马，这样BT才能正常工作。（随便说一下，多数防火墙基于程序的信任程度更高一些，在此类防火墙里，应用程序所打开的所有端口都是对外开放的，也就是说外部程序可以主动联系该程序打开的所有端口，因而不用进行端口设置。看起来没有在LNS里这么麻烦，但仔细想想，安全性要低一些。就象是在一个正常卖票的窗口旁边有一个本来不是卖票的关着窗口，但当有人去敲了敲，窗口竞然打开了或许还进行了某种交易？！） <br />
言归正传，下面说如何为BT打开这个被动的端口，通过下述设置偶在BT里每任务最大100个连接，当有80个左右的用户时，下载速度可以轻松达到120KB以上。 <br />

?首先给该规则起个名，定义方向，略加说明，如图六中的1、2、4所示； <br />
?然后在“以太网：类型”里选择“IP”，等于告诉LNS这是一条通关于数据包往来的规则，如3所示； <br />

?在黑色编号5的“IP”里选择“TCP或UDP”，告诉LNS这是基于TCP或者UDP协议的数据包的规则（通常在BT里只用TCP协议，但偶在日志中发现它偶有用到UDP，所以也打开了，偶对BT的机制并不熟悉）； <br />

?在黑色编号7里不用填任何MAC地址，本规则是对本机的，不需要进行MAC地址的排除组合等（但如果LNS安装在网关上，而BT在你的机器上，则可以在MAC地址里填写上你的MAC地址，呵呵，则只有你可以用BT了因为MAC地址在局域网里有唯一性，尤其它你们的局域网是自动分配IP地址的话。）； <br />

?黑色编号8，IP地址选择“等于本机”就不用手工输入了。同样，如果你的机器在内网，而LNS在网关上，你就可以指定哪些IP可以使用BT而哪些机器不能使用了；比如你的内部机器IP=192.168.2.4，此时可以在“IP地址”里选择“等于”，并把192.168.2.4填写在正文，那么只有这台机器的10521端口可以被外部其它机器连接。大家多试试就可以体会。 <br />

?黑色编号9，选择“等于”，然后填写你的BT监听的端口号。 <br />

?点“应用程序”，如果黑色编号13、14所示，把你的Bt软件添加上，然后一路确定，回到“互联网过滤”界面，保存和应用就可以了（OK，此时打开BT开始下载，看看“日志”里有没有大量的记录，如果没有恭喜了，如果有大量的与端口有关的记录，说明某个地方弄错了，再仔细检查一下该规则）。这样该条规则就是BT专用的了，绝对不影响其它程序。 <br />
同样的道理，如果你是想禁用远程机器与本地/本机的某个端口进行连接，那么只要在图三所示的“第二列”为该规则打上禁止标示就可以了，那么此时与该IP地址或者Mac地址匹配的机器的10521端口就永远无法被其它连接，且该端口也无法向外发送信息了。</span> </span></span></p><p><span style="font-size: 12px"><span style="font-size: 12px"><span id="text5" style="font-size: 12px">上面的例子是控制本地/本机资源的，那么如何限制你本地/本机应用程序对远程机器的访问，将在下面再举一例。见图七。 <br />

<img style="width: 595px; height: 418px" alt="Click here to open new window" src="http://www.magicwinmail.com/course/looknstop/images/22_96964.jpg" if(this.width=""/><br />
虽然在“应用程序过滤”里已经讲到了如何限制对远程的访问，但它不具有全局性，也就是说“应用程序过滤”里的规则优先级低于“互联网过滤”，LNS先匹配“应用程序过滤”然后再匹配“互联网过滤”，如果在“应用程序过滤”里已经禁止了的，在“互联网过滤”里将继续禁止；如果在“应用程序过滤”里允许了的，那么还得经过“互联网过滤”的审查。在这里编写的规则具有全局性，当然也可以针对某个特定程序。 <br />

讲一个禁止与远程某个端口连接的例子，或者理解为禁止本地与远程某个端口进行通讯，此例子规则的意思为：禁止与12.10.2.20地址的77777端口进行双向联系。编写一条禁止规则通常有二个步骤。 <br />

第一步：远程机器的信息只能设置在图七所示的目标区，黑色编号1选择“IP”类型，编号2选择“TCP”或者其它协议，如果不能确定，填上“TCP或者UDP”也不会有问题。 <br />

在“目标”区域，如果你要禁止具体的某个远程主机，则在“IP地址”里选择“等于”（如果是对所有的远程主机则选择“全部”），然后再下面填写具体IP地址（例子里随便写了个12.10.2.20），“TCP/UDP端口”里填上端口号77777。 <br />

如果这个禁止规则是与某个具体程序对应的，那么点“应用程序”，把具体的程序加入就行了；如果是对本机所有程序的，侧不需要添加任何程序。一路确定，回到“互联网过滤”界面。 <br />

第二步：点击如图三所示的“第二列”（当然位置要与此条规则对应），当出现红色禁止标志时，点击“保存”和“应用”，OK！此时12.10.2.20地址的77777端口不能联系你的机器，你的机器也不能联系12.10.2.20机器的77777端口。当然其它端口是可以双向联系的。 <br />

如果你想写一条禁止本地/本机的具体地址的具体端口与远程的具体地址的具体端口进行连接的规则时，则在“目标”区域填写你的本地/本机的IP和端口信息，而在“目标”区域填写远程机器的IP和端口信息，完成后再在“互联网过滤”界面上打上禁止标志就行了。通常很难存在一条这样的“允许”规则的。</span> </span></span></p><p><span style="font-size: 12px"><span style="font-size: 12px"><span id="text6" style="font-size: 12px">4.日志标签---告诉你当前阻止了哪些连接；允许了哪些连接（如果你也设置了记录的话，LNS默认对阻止的规则进行记录）；可以用来建立特殊规则。如图八所示。<br />
<img style="width: 597px; height: 447px" alt="Click here to open new window" src="http://www.magicwinmail.com/course/looknstop/images/22_96965.jpg" if(this.width=""/><br />
当你使用了某些软件并允许了它上网但却不能正常使用，此时可以查看“日志标签”，只是此时日志中不显示对应的程序名称，会显示连续的规则名称相同的一些信息。首先你确保这些信息是因为阻止了此类连接而生成的（通过规则名称在“互联网过滤标签”里看此规则前面是否有禁止标志），然后再看在端口号上有没有规律性，当规则名称相同、端口号也有规律性时，就可以用它来生成规则了。 <br />

以例子说明，图八所示为BT在没有打开端口时的日志情况。黑色编号4区显示的是规则名称，几乎完全一样；黑色编号3区是端口；黑色编号2区所示为有一致性的端口号，都为10521（偶的BT监听端口）。从日志可以明显看出，BT的10521端口不允许被外界连接，也就是造成BT下载速度慢的全部原因（虽然已经把BT设置为任凭程序了，但对它的端口还是有限制的。）。<br />

设置方法：在任意一条记录上点鼠标右键，会出现图八黑色编号1所示的菜单，菜单上总共会出现2个选择，你应该用鼠标点在黑色编号3区域中看到的那个频繁出现的端口所在的选择项。如本例中在黑色编号3区域中看到的频繁出现的端口号是10521，则在此菜单上就选择“允许Port10521-服务器”（此外的“服务器”意思是本机被其它机器连接，有点服务器的味道P），选择后会返回到“互联网过滤”标签，此时可以看到LNS已经为你自动增加了一条规则，并为此规则起了一个名称和简单的说明，你可以双击此规则改变规则名称和说明以使你清楚知道此规则的作用。 <br />

回到日志来继续看，如果在某条日志上双击，则出现如图九中红色编号1所示的窗口，在此窗口中可以看到该条日志的详细信息（可惜没有与程序具体对应），有源/目标的IP地址、端口、数据报等详细内容，有经验的用户可以就此进行深入分析，以手工建立规则。在此不详细讲了。 <br />
<img style="width: 596px; height: 447px" alt="Click here to open new window" src="http://www.magicwinmail.com/course/looknstop/images/22_96966.jpg" if(this.width=""/></span></span></span></p><p><span style="font-size: 12px"><span style="font-size: 12px;"><span style="font-size: 12px;"><span id="text7" style="font-size: 12px;">5.选项标签-高级设置及其它杂项，如图十所示 <br />


<img style="width: 592px; height: 224px" alt="Click here to open new window" src="http://www.magicwinmail.com/course/looknstop/images/22_97053.jpg" if(this.width=""/><br />
这一部分没有什么内容可讲，当鼠标停留在某个选项上时，都会自动跳出提示的。主要说说选择网络接口的操作。 <br />
图中红色编号1区即为选择界面，通常按“自动选择”方式就能很好的工作，如果不能时，请按图十二所示按自己的上网方式进行选择。<br />
<img style="width: 598px; height: 430px" src="http://www.magicwinmail.com/course/looknstop/images/22_97055.jpg" if(this.width="" alt=""/><br />
点击红色编号2，则出现如图十一所示的“高级选项”界面，这个也大概说一下。<br />
<img src="http://www.magicwinmail.com/course/looknstop/images/22_97054.jpg" if(this.width="" alt=""/><br />
除了黑色编号3所在区域，其它编号区当鼠标指向时都有提示跳出，而且容易理解，不详细讲了，如果以后有时间再补充。重点讲黑色编号4、5、6、7区的。先来看看黑色编号3区的。 <br />

“高级模式”----选中它，则在“应用程序过滤”、“互联网过滤”标签里才有一些高级属性出现。大家视自己的情况决定，不过偶建议打开。 <br />
“原始日志”----选中它，则在日志文件中记录更多的信息，也就是日志文件更加详细，提供更多的基层信息，而且需要用第三方的工具才能打开察看日志文件。一般人没有必要打开，而且偶不建议记录日志文件，一来作用不大，二来记录日志文件的话，会增加CPU使用量。 <br />
“退出时确认”----不用说。 <br />
“TCP全状态包检测”----读为“TCP全状态?包检测”，一种数据包过滤技术，通过对报文的TCP标志进行检测而实现的。建议大家打开此功能；但这个功能默认是记录日志的，不能更改。 <br />
“在此程序退出后保持互联网过滤处于活动状态”----2000以上有用。作用是当退出LNS，互联网过滤规则也在后台运行。偶想不出这个功能的必要性，故不建议大家打开，尤其是新安装LNS还处于调试阶段时更不要打开这个功能。否则可能会造成退出LNS了，上网还不正常。 <br />
“监视DNS呼叫”----2000以上才起作用，用于监视应用程序向DNS服务器发出地址解析请求的。建议打开，但如果打开它LNS经常导致机器蓝屏，请关闭它。另外，在2003下千万不要打开，否则肯定蓝屏。 <br />
“监视线程侵加（恶意代码插入）”----2000以上有用。也就是对付内存数据改写之类操作的，建议打开。 <br />
最后面二条一看就明白，建议选中。 <br />

黑色编号7，当你在图十中选中了网络界面接口的“自动选择”时，这个功能必较有用。它是用来排除那些不用检测的网卡的，比如说，你机器上有2个以上的网卡，其中一个是连接互联网的，其它的是连接不同网段的，那么你就把其它网段的IP输入在这里，以保证LNS能正常检测到你的上网网卡。可以在这里输入多个网段，之间用半角的分号分隔开。 <br />

黑色编号4，点击后出现图十三所示的界面。 <br />
<img src="http://www.magicwinmail.com/course/looknstop/images/22_97089.jpg" if(this.width="" alt=""/><br />
黑色编号1为本机现有网络协议以及LNS是否允许此协议，当前哪些协议处于活动状态等信息。不同的操作系统显示的不同，2000以上系统只有NETBT.SYS和TCPIP.SYS二种。这二种协议的属性都是默认，且不可更改。当有其它协议时，比如图中的NPF.sys（网络监视），可以用“拦截”来控制是否允许它，也可以用“移除”删除它而不对该协议进行监控。 <br />

黑色编号2，此区域决定了是否对已经激活的协议进行过滤（控制与该协议相关的网络操作），当选择禁用时不对当前活动的协议进行过滤，如果启用了则进行过滤，以增加安全性。建议打开“启用”。 <br />

当点击图十一中的黑色编号5“插件”时，则出现一个已安装插件的选择窗口，选择了某个插件后就具备相关的扩展功能。这个不多讲了，除了多语言支持插件以外，其它都太高深了，偶们一般也用不到。 <br />

当点击图十一中的黑色编号6“动态链接库”，会出现如图十四所示的动态链接库设置的窗口。此时勾“启用动态链接库检测”则当程序第一次加载一个DLL时LNS会询问允许或禁止，经过一些时间的学习后就不询问了。但当某个DLL的数字签名发生了变化，则LNS会再询问以保证DLL是合法修改，确保系统安全性；当然你也可以手工直接添加那些你认为有必要进行检测的DLL。2000以上系统才有此功能。使用windows2003的兄弟注意了，在2003下不要打开这个功能，否则Crash。这个功能也就是ZA、OP等的“组件功能”，但应该说LNS的这种处理方式更安全一些。</span> </span></span></span></p><p><span style="font-size: 12px;"><span style="font-size: 12px;"><span style="font-size: 12px;"><span id="text8" style="font-size: 12px;">三、特定事件处理 <br />
1.阻止网络执法官控制 <br />

　　网络执法官是利用的ARp欺骗的来达到控制目的的。　　 <br />
　　ARP协议用来解析IP与MAC的对应关系，所以用下列方法可以实现抗拒网络执法官的控制。 <br />
如果你的机器不准备与局域网中的机器通讯，那么可以使用下述方法： <br />
　　A.在“互联网过滤”里面有一条“ARP : Authorize all ARP packets”规则，在这个规则前面打上禁止标志； <br />
　　B.但这个规则默认会把网关的信息也禁止了，处理的办法是把网关的MAC地址（通常网关是固定的）放在这条规则的“目标”区，在“以太网：地址”里选择“不等于”，并把网关的MAC地址填写在那时；把自己的MAC地址放在“来源”区，在“以太网：地址”里选择“不等于”。 <br />
　　C.在最后一条“All other packet”里，修改这条规则的“目标”区，在“以太网：地址”里选择“不等于”，MAC地址里填FF:FF:FF:FF:FF:FF；把自己的MAC地址放在“来源”区，在“以太网：地址”里选择“不等于”。其它不改动。 <br />
　　这样网络执法官就无能为力了。此方法适用于不与局域网中其它机器通讯，且网关地址是固定的情况下。 <br />
　　如果你的机器需要与局域网中的机器通讯，仅需要摆脱网络执法官的控制，那么下述方法更简单实用（此方法与防火墙无关）： <br />
　　进入命令行状态，运行“ARP -s 网关IP 网关MAC”就可以了，想获得网关的MAC，只要Ping一下网关，然后用Arp-a命令查看，就可以得到网关的IP与MAC的对应。此方法应该更具通用性，而且当网关地址可变时也很好操作，重复一次“ARP -s 网关IP网关MAC”就行了。此命令作用是建立静态的ARP解析表。 <br />

2.安装后不能上网 <br />

　　安装LNS后不能上网的问题很是奇怪，可能与个人的具体上网方式关系较大。此时先确保在LNS中的网络接口选择是正确的（参见图十二）。 <br />
　　其次看看LNS的“欢迎”标签里的“已连接”前面有没有勾，并且在“IP地址”里面有没有地址，如果这二项都没有问题，那么请把“互联网过滤”的规则表最后一条规则的“以太网：类型”中的“全部”改为“IP”再试，一般应该可以解决。如果这样做都无法解决上网，请再后面发帖，详细说明上网方式和LNS的设置情况，偶研究一下。^^_ <br />

3.记不住规则<br />
　　LNS记不住规则的情况是：当你的应用程序安装在一个中文目录中时。所以你重新安装应用程序，不要安装在中文目录下就可以解决。 <br />

4.“已连接”没有选中 <br />

　　“已连接”前面没有出现一个勾，此时并不意味着LnS不正常工作。出现此现象时，说明LNS并不确定网络接口选择的是否正确，特殊的上网方式或者一台机器安装有几块网卡时会出现此现象，而且要注意自己的IP地址是否与“高级选项”中的“网络自动检测时排除的IP”中的地址有冲突。 <br />
　　解决办法是：先排除不是由于“网络自动检测时排除的IP”中包含了本机IP，如果是此情况，请删除“网络自动检测时排除的IP”列表中与自己IP冲突的数值；如果不是此情况，请手工在“网络接口”窗口中选择接口，直到“已连接”前面出现勾，且“IP地址”栏里出现正确的本机IP为止。 <br />

5.关机超慢 <br />

　　关机慢通常是由于没有退出网络连接造成的（通过网关上网的机器应该没有此现象），解决办法是关闭连接（比如断开ADSL连接）后再关机。 <br />

四、LNS的优化 <br />

（一）.应用程序过滤区的优化 <br />

　　对应用程序过滤区的优化可以把程序类型分为操作系统软件和第三方软件。 <br />
　　1.对于操作系统自己的文件，允许连网的数量越少越好，但数量取决于你希望系统提供哪些服务。比如，偶在内网，通过网关代理上网，本机不开任何其它服务，访问局域网中的其它机器的共享文件，那么偶只允许SVChost.exe通过防火墙（虽然SVChost.exe自己不上网，只加载其它程序）。而SVchost.exe想要做什么呢？它调用了其它系统某个网络应用（偶不知道是哪个）去进行域名解析，也就是连接到你的DNS的53端口，这样就可以在LNS里对Svchost.exe的行为进行限定。 <br />
　　方法是： <br />
　　A.双击“应用程序过滤”列表里的Svchost.exe，在出现的窗口中端口填写53，IP填写你自己所在地的域名解析服务器的IP地址； <br />
　　B.点SVChost.exe所在行的绿色双箭头标志，让它变为红色的禁止标志； <br />
　　C.其它所有如Explorer.exe等系统程序都禁止通过。 <br />
　　这样，SVChost.exe所调用的系统文件、包括所调用的其它程序也只能访问这个地址和53号端口；且当系统启动后Svchost.exe也不能再调用并运行其它程序了。好处是让SVChost.exe只访问一个IP的一个端口，即使中了一些利用Svchost.exe调用以运行并且连网的病毒也不怕此病毒下载安装其它东东。 <br />
　　2.第三方应用软件，则尽量根据各软件的特点，设定对应的端口就行了，IP地址不做限制。 <br />
A.邮件客户端软件。则在前面所说的端口里只打开110和25端口就好了，方法是输入“110;25”不包括双引号。这样邮件客户端就只连接远程的这二个端口。 <br />
　　B.FTP客户端软件。则打开FTP端口和高端口，方法是输入“20-24;60000-65000”不包括双引号。有些FTP服务端打开的可能是21、22、23端口；而发数据通常是60000以上的端口。有人可能说：“应用程序过滤”的优先级低于“互联网过滤”的优先级，在这里打开60000以上端口会不会也需要制定一条专门的规则呢（因为BT就得专门开一个端口）？其实不用，FTP的原理与BT不同，BT的监听端口是被动的，而FTP的高端口是主动的。</span> </span></span></span></p></span></p><br />

    </div>

<div class="meta">
    
    <span class="comments"><a href="/lns-firewall/#disqus_thread">Comments</a></span>
    
</div>
</article>

  <article class="post">
    <h2 class="title"> 
        <a href="/about-ip/">详解：IP的分类、寻址规则及子网掩码zz</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2006-03-25T00:00:00.000&#43;00:00' itemprop="datePublished">2006-03-25</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/windows">Windows</a>


</div>
    </div>
        http://www.edu.cn/20031208/3095629.shtml<br />
<p>　　随着电脑技术的普及和因特网技术的迅猛发展，因特网已作为二十一世纪人类的一种新的生活方式而深入到寻常百姓家。谈到因特网，IP地址就不能不提，因为无论是从学习还是使用因特网的角度来看，IP地址都是一个十分重要的概念，INTERNET的许多服务和特点都是通过IP地址体现出来的。 </p><p>　　<strong>一、IP地址的概念</strong></p><p>　　我们知道因特网是全世界范围内的计算机联为一体而构成的通信网络的总称。联在某个网络上的两台计算机之间在相互通信时，在它们所传送的数据包里都会含有某些附加信息，这些附加信息就是发送数据的计算机的地址和接受数据的计算机的地址。象这样，人们为了通信的方便给每一台计算机都事先分配一个类似我们日常生活中的电话号码一样的标识地址，该标识地址就是我们今天所要介绍的IP地址。根据TCP/IP协议规定，IP地址是由32位二进制数组成，而且在INTERNET范围内是唯一的。例如，某台联在因特网上的计算机的IP地址为： </p><p>　　11010010 01001001 10001100 00000010 </p><p>　　很明显，这些数字对于人来说不太好记忆。人们为了方便记忆，就将组成计算机的IP地址的32位二进制分成四段，每段8位，中间用小数点隔开，然后将每八位二进制转换成十进制数，这样上述计算机的IP地址就变成了：210.73.140.2。</p><br><!--more--><p>　　<strong>二、IP地址的分类</strong></p><p>　　我们说过因特网是把全世界的无数个网络连接起来的一个庞大的网间网，每个网络中的计算机通过其自身的IP地址而被唯一标识的，据此我们也可以设想，在INTERNET上这个庞大的网间网中，每个网络也有自己的标识符。这与我们日常生活中的电话号码很相像，例如有一个电话号码为0515163，这个号码中的前四位表示该电话是属于哪个地区的，后面的数字表示该地区的某个电话号码。与上面的例子类似，我们把计算机的IP地址也分成两部分，分别为网络标识和主机标识。同一个物理网络上的所有主机都用同一个网络标识，网络上的一个主机(包括网络上工作站、服务器和路由器等)都有一个主机标识与其对应?IP地址的4个字节划分为2个部分，一部分用以标明具体的网络段，即网络标识；另一部分用以标明具体的节点，即主机标识，也就是说某个网络中的特定的计算机号码。例如，盐城市信息网络中心的服务器的IP地址为210.73.140.2，对于该IP地址，我们可以把它分成网络标识和主机标识两部分，这样上述的IP地址就可以写成：</p><p>　　网络标识：210.73.140.0</p><p>　　主机标识：　　　　　2</p><p>　　合起来写：210.73.140.2</p><p>　　由于网络中包含的计算机有可能不一样多，有的网络可能含有较多的计算机，也有的网络包含较少的计算机，于是人们按照网络规模的大小，把32位地址信息设成三种定位的划分方式，这三种划分方法分别对应于A类、B类、C类IP地址。</p><p>　　1.A类IP地址</p><p>　　一个A类IP地址是指，在IP地址的四段号码中，第一段号码为网络号码，剩下的三段号码为本地计算机的号码。如果用二进制表示IP地址的话，A类IP地址就由1字节的网络地址和3字节主机地址组成，网络地址的最高位必须是“0”。A类IP地址中网络的标识长度为7位，主机标识的长度为24位，A类网络地址数量较少，可以用于主机数达1600多万台的大型网络。</p><p> &nbsp; &nbsp;&nbsp; <span style="color: rgb(255, 0, 0)">A类网络地址的最高位必须是“0”，也就是说第一位必须是00000000~01111111，换算过来就是0~127(2^7-1)，也就是从0.0.0.0~127.255.255.255，总共128个A类网络。每一个可以包含255x255x255=16581375台主机（其中应该除去127.x.x.x和0.0.0.0类型的ip，127开头的ip被保留用作回路测试，0.0.0.0用于启动后不再使用的主机）。A类网址的掩码最后三位都是0。</span><br />
</p><p>　　2.B类IP地址</p><p>　　一个B类IP地址是指，在IP地址的四段号码中，前两段号码为网络号码，剩下的两段号码为本地计算机的号码。如果用二进制表示IP地址的话，B类IP地址就由2字节的网络地址和2字节主机地址组成，网络地址的最高位必须是“10”。B类IP地址中网络的标识长度为14位，主机标识的长度为16位，B类网络地址适用于中等规模规模的网络，每个网络所能容纳的计算机数为6万多台。</p><p> &nbsp; &nbsp;&nbsp; <span style="color: rgb(255, 0, 0)">B类网络地址的最高位必须是“10”，也就是说第一位必须是10000000~10111111，换算过来就是128(2^7)~191(2^7+2^6-1)，从128.0.0.0~191.255.255.255，总共64x255=16320个B类网络。每一个可以包含255x255=65025台主机。B类网址的掩码最后两位是0。</span> </p><p>　　3.C类IP地址 </p><p>　　一个C类IP地址是指，在IP地址的四段号码中，前三段号码为网络号码，剩下的一段号码为本地计算机的号码。如果用二进制表示IP地址的话，C类IP地址就由3字节的网络地址和1字节主机地址组成，网络地址的最高位必须是“110”。C类IP地址中网络的标识长度为21位，主机标识的长度为8位，C类网络地址数量较多，适用于小规模的局域网络，每个网络最多只能包含254台计算机。</p><p> &nbsp; &nbsp;&nbsp; <span style="color: rgb(255, 0, 0)">C类网络地址的最高位必须是“110”，也就是说第一位必须是11000000~11011111，换算过来就是192(2^7+2^6)~223(2^7+2^6+2^5-1=128+64+32-1)，从192.0.0.0~223.255.255.255，总共32x255x255=2080800个C类网络。每一个可以包含255台主机。C类网络的掩码最后一位是0。</span> </p><p>　　除了上面三种类型的IP地址外，还有几种特殊类型的IP地址，TCP/IP协议规定，凡IP地址中的第一个字节以“lll0”开始的地址都叫多点广播地址。因此，任何第一个字节大于223小于240的IP地址是多点广播地址；IP地址中的每一个字节都为0的地址(“0.0.0.0”)对应于当前主机；IP地址中的每一个字节都为1的IP地址(“255.255.255.255”)是当前子网的广播地址；IP地址中凡是以“llll0”的地址都留着将来作为特殊用途使用；IP地址中不能以十进制“127”作为开头，127.x.x.x用于回路测试，同时网络ID的第一个6位组也不能全置为“0”，全“0”表示本地网络。 </p><p>　　<strong>三、IP的寻址规则　</strong></p><p>　　1.网络寻址规则 </p><p>　　A、 网络地址必须唯一。 </p><p>　　B、 网络标识不能以数字127开头。在A类地址中，数字127保留给内部回送函数。 </p><p>　　C、 网络标识的第一个字节不能为255。数字255作为广播地址。 </p><p>　　D、 网络标识的第一个字节不能为“0”，“0”表示该地址是本地主机，不能传送。 </p><p>　　2.主机寻址规则 </p><p>　　A、主机标识在同一网络内必须是唯一的。 </p><p>　　B、主机标识的各个位不能都为“1”，如果所有位都为“1”，则该机地址是广播地址，而非主机的地址。 </p><p>　　C、主机标识的各个位不能都为“0”，如果各个位都为“0”，则表示“只有这个网络”，而这个网络上没有任何主机。 </p><p>　　<strong>四、IP子网掩码概述　</strong></p><p>　　1.子网掩码的概念 </p><p>　　子网掩码是一个32位地址，用于屏蔽IP地址的一部分以区别网络标识和主机标识，并说明该IP地址是在局域网上，还是在远程网上。 </p><p>　　2.确定子网掩码数 </p><p>　　用于子网掩码的位数决定于可能的子网数目和每个子网的主机数目。在定义子网掩码前，必须弄清楚本来使用的子网数和主机数目。 </p><p>　　定义子网掩码的步骤为： </p><p>　　A、确定哪些组地址归我们使用。比如我们申请到的网络号为 “210.73.a.b”，因为c类网络从192~223，所以该网络地址为c类IP地址，网络标识为“210.73”，主机标识为“a.b”。 </p><p>　　B、根据我们现在所需的子网数以及将来可能扩充到的子网数，用宿主机的一些位来定义子网掩码。比如我们现在需要12个子网，将来可能需要16个。用第三个字节的前四位确定子网掩码。前四位都置为“1”，即第三个字节为“11110000”，这个数我们暂且称作新的二进制子网掩码。 </p><p>　　C、把对应初始网络的各个位都置为“1”，即前两个字节都置为“1”，第四个字节都置为“0”，则子网掩码的间断二进制形式为：“11111111.11111111.11110000.00000000” </p><p>　　D、把这个数转化为间断十进制形式为：“255.255.240.0”</p><p> &nbsp; &nbsp;&nbsp; 也可以这么计算，因为是C类网络，所以掩码的最后一位肯定是0，从255往下算16个C类网络，应该到240就够了，所以掩码应该是255.255.240.0。<br />
 </p><p>　　这个数为该网络的子网掩码。 </p><p>　　3.IP掩码的标注 </p><p>　　A、无子网的标注法 </p><p>　　对无子网的IP地址，可写成主机号为0的掩码。如IP地址210.73.140.5，掩码为255.255.255.0，也可以缺省掩码，只写IP地址。 </p><p>　　B、有子网的标注法 </p><p>　　有子网时，一定要二者配对出现。以C类地址为例。 </p><p>　　1.IP地址中的前3个字节表示网络号，后一个字节既表明子网号，又说明主机号，还说明两个IP地址是否属于一个网段。如果属于同一网络区间，这两个地址间的信息交换就不通过路由器。如果不属同一网络区间，也就是子网号不同，两个地址的信息交换就要通过路由器进行。例如：对于IP地址为210.73.140.5的主机来说，其主机标识为00000101，对于IP地址为210.73.140.16的主机来说它的主机标识为00010000，以上两个主机标识的前面三位全是000，说明这两个IP地址在同一个网络区域中。 </p><p>　　2.掩码的功用是说明有子网和有几个子网，但子网数只能表示为一个范围，不能确切讲具体几个子网，掩码不说明具体子网号，有子网的掩码格式(对C类地址):主机标识前几位为子网号，后面不写主机，全写0。 </p><p>　　<strong>五、IP的其他事项　</strong></p><p>　　1.一般国际互联网信息中心在分配IP地址时是按照网络来分配的，因此只有说到网络地址时才能使用A类、B类、C类的说法； </p><p>　　2.在分配网络地址时，网络标识是固定的，而计算机标识是可以在一定范围内变化的，下面是三类网络地址的组成形式： </p><p>　　A类地址：73.0.0.0 </p><p>　　B类地址：160.153.0.0 </p><p>　　C类地址：210.73.140.0 </p><p>　　上述中的每个0均可以在0~255之间进行变化。 </p><p>　　3.因为IP地址的前三位数字已决定了一个IP地址是属于何种类型的网络，所以A类网络地址将无法再分成B类IP地址，B类IP地址也不能再分成C类IP地址。 </p><p>　　4.在谈到某一特定的计算机IP地址时不宜使用A类、B类、C类的说法，但可以说主机地址是属于哪一个A类、B类、C类网络了。 </p><p>　　通过上面的学习，大家对IP地址肯定有了了解。有了IP地址大家就可以发送电子邮件了，并且可以获得Internet网上的其他信息，例如可以获得Internet上的WWW服务、BBS服务、FTP服务等等。</p><br />

    </div>

<div class="meta">
    
    <span class="comments"><a href="/about-ip/#disqus_thread">Comments</a></span>
    
</div>
</article>

  <article class="post">
    <h2 class="title"> 
        <a href="/L3-switch/">L3 switch</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2006-03-23T00:00:00.000&#43;00:00' itemprop="datePublished">2006-03-23</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/windows">Windows</a>


</div>
    </div>
        http://vbb3.twftp.org/archive/index.php/t-4016.html<br />

一般常用的交換器 Switch 是屬於第二層交換器 Layer 2 Switch，這種交換器是利用 OSI 第二層 MAC 位址的資訊來進行資料交換，它可以記憶學習第一個 Port 連接的 MAC 位址，透過 MAC 位址及封包目的的位址的辨別，L2 Switch 會將該封包直接傳送至連接目的地的 Port，而不會將該封包傳送到其他的 Port。若並無此目的地 IP 的資訊時，則 L2 Switch 會廣播至所有的連接埠上，待目的 IP 回應時，將新的連接埠對應學習起來，那麼下次就不用廣播而直接傳送。<br />

如果再把路由表的功能加入 L2 Switch，那麼它就會變成 L3 Switch，可以為 VLAN 建立適當的路由表，讓效能更加提昇。L3 的交換器又稱為 IP Switch 或 Switch Router，透過專屬的 ASIC 晶片來解析第三層表頭（如 IP Header）以達到傳送目的，因此通常可以提高到每秒百萬封包的效能以及數十個高速乙太網路連接埠之容量。L3 Switch 的路由表可以對 VLAN 做更有效的管制，讓廣播封包不會無限制的傳送。<br />
http://140.111.152.100/archives/2004_09.html<br />

    </div>

<div class="meta">
    
    <span class="comments"><a href="/L3-switch/#disqus_thread">Comments</a></span>
    
</div>
</article>

  <article class="post">
    <h2 class="title"> 
        <a href="/LDAPLightweight-Directory-Access-Protocol/">LDAP,Lightweight Directory Access Protocol</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2006-03-23T00:00:00.000&#43;00:00' itemprop="datePublished">2006-03-23</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/other">other</a>


</div>
    </div>
        <strong>1 什么是LDAP</strong><br />

LDAP的英文全称是Lightweight Directory Access Protocol，一般都简称为LDAP。<br />

LDAP目录中可以存储各种类型的数据：电子邮件地址、邮件路由信息、人力资源数据、公用密匙、联系人列表，等等。通过把LDAP目录作为系统集成中的一个重要环节，可以简化员工在企业内部查询信息的步骤，甚至连主要的数据源都可以放在任何地方。<br />

<br><!--more--><strong>2 LDAP目录的优势</strong><br />

使用Win下面的IIS＋acess（or sql server），或者Linux下面的Apache＋mysql（or oracle）之类的后台，这种数据库也可以针对某个用户对数据库、表等作一些权限设置，最低只能到表一级，不能控制到记录一级。并且使用数据库需要不停的对数据类型做验证等，也会导致系统的整体性能一定程度的降低。<br />

目录主要面向数据的查询服务，查询操作比修改操作多很多时，适宜使用目录服务。LDAP协议是跨平台的一个<br />

    </div>

<div class="meta">
    
    <span class="comments"><a href="/LDAPLightweight-Directory-Access-Protocol/#disqus_thread">Comments</a></span>
    
</div>
</article>

  <article class="post">
    <h2 class="title"> 
        <a href="/WSUSMicrosoft-Windows-Server-Update-Services/">WSUS,Microsoft Windows Server Update Services</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2006-03-23T00:00:00.000&#43;00:00' itemprop="datePublished">2006-03-23</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/windows">Windows</a>


</div>
    </div>
        http://www.winsvr.org/info/info.php?sessid=&infoid=12<br />

<strong>1 什么是wsus</strong><br />

WSUS（Microsoft Windows Server Update Services）是微软推出的免费的Windows更新管理服务，目前最新版本为2.0.0.2472，除了支持Windows系统（Windows 2000全系列、Windows XP全系列和Windows server 2003全系列）的更新管理外，还可以支持SQL Server、Exchange 2000/2003、Office XP/2003等系统的更新管理，并且在以后，WSUS将实现微软全系列产品的更新管理。<br />

<strong>2 为什么要用wsus</strong><br />

在小规模的企业网络中，客户端计算机通过自动更新连接Microsoft Update来进行系统更新并不会对企业的外部网络带宽造成太大的影响，例如有5台客户端计算机每台下载20M的更新程序，那么总占用的企业外部网络流量只是100M；但是在中大规模的企业网络中，如果每台客户端计算机都通过连接到Microsoft Update来实现更新，则会极大的影响企业的外部网络带宽，例如有500台客户端计算机每台下载20M的更新程序，就会占用10G的流量。更新变成了下面的流程“Microsoft Update->本地企业网络中的WSUS服务器->客户端计算机”。<br />

<br><!--more--><strong>3 wsus需要的配置</strong><br />

wsus服务器通过80和443端口从Mircosoft update获取更新，WSUS服务器到以下Web站点的HTTP/HTTPS获取更新。<br />

http://windowsupdate.microsoft.com <br />
http://*.windowsupdate.microsoft.com <br />
https://*.windowsupdate.microsoft.com <br />
http://*.update.microsoft.com <br />
https://*.update.microsoft.com <br />
http://*.windowsupdate.com <br />
http://download.windowsupdate.com <br />
http://download.microsoft.com <br />
http://*.download.windowsupdate.com <br />
http://wustat.windows.com <br />
http://ntservicepack.microsoft.com <br />

WSUS与IIS服务器结合创建Web站点来实现更新程序的分发，可以配置WSUS Web站点共享使用默认Web站点（服务端口为TCP 80）或者使用其他的端口为客户端计算机提供服务。在安装WSUS服务器时，如果不选择使用默认的Web站点，那么WSUS将创建自定义的Web站点并在TCP端口8530侦听HTTP连接请求，建议使用默认的Web站点。 <br />

<strong>4 wsus客户端的配置</strong><br />

WSUS服务器要求客户端计算机上运行WSUS客户端，WSUS客户端可以在打过SP3及以上补丁的Windows 2000全系列产品、Windows XP全系列产品、Windows server 2003全系列产品上运行，换言之，WSUS服务器支持运行这些操作系统的客户端计算机从其获得更新程序。其中Windows XP SP2以及Windows server 2003 SP1已经内建了WSUS客户端；而其他的操作系统中除了没有安装过任何SP的Windows XP外，内建的自动更新组件均具有自我更新特性，可以通过WSUS提供的自我更新程序包自动更新至WSUS客户端；对于没有安装过任何SP的Windows XP，你必须安装SUS客户端，从而通过SUS客户端来实现自我更新至WSUS客户端。 <br />

由于客户端计算机的自动更新组件只能通过服务端口TCP 80来实现自我更新，因此，如果你在安装WSUS时不使用默认的Web站点而自定义一个Web站点，你也必须在侦听TCP 80端口的Web站点中创建一个名为Selfupdate的虚拟目录来为客户端计算机提供自我更新程序包，否则非WSUS客户端计算机不能正常的进行自我更新，从而不能从WSUS服务器获取更新程序。 <br />

<strong>5 链式WSUS服务器环境</strong><br />

WSUS服务器不仅仅可以从Windows Update中获取更新程序，也可以从其他WSUS服务器中获取更新程序。所以大规模的企业可以配置多台wsus服务器，形成链式WSUS服务器环境。<br />

<strong>6 wsus的工作模式</strong><br />

wsus服务器支持两种工作模式：集中管理和分布管理。<br />

集中管理模式的WSUS服务器采用独立管理服务器和复制服务器这两种角色，它的含义是单个服务器（主服务器）作为独立管理服务器，而一个或多个从属服务器（复制服务器）只是复制主服务器上的数据。<br />

分布管理模式只允许你配置每台WSUS服务器为独立管理服务器。<br />

<strong>7 wsus使用的数据库</strong><br />

WSUS数据库存储以下信息：WSUS服务器配置信息；用于描述更新程序作用的元数据；客户端计算机、更新程序信息以及客户端计算机所进行的更新情况。每个WSUS服务器需要自己的数据库，如果具有多个WSUS服务器，必须具有多个WSUS数据库。<br />

<strong>8 更新存储位置</strong><br />

更新可以分为两个部分：元数据和更新文件。元数据存储在wsus数据库中，而更新文件可以存储在Microsoft update服务器上，或者存储在本地wsus服务器。第一种方式wsus部署更新之后，客户端从Microsoft update服务器上面获取更新，这样可以节省本地服务器的空间，但是客户端较多的时候，更新时会占用大量带宽。第二种方式为默认选项，wsus下载更新后存储在本地，客户端更新时从wsus服务器下载。<br />

<strong>9 性能相关的设置</strong><br />

wsus允许设置为只有在批准更新时才下载更新文件，还可以对更新做过滤，只下载需要的更新。还有一个快速更新的设置，设置之后占用的外部带宽会增加，而内部带宽会减少。<br />

    </div>

<div class="meta">
    
    <span class="comments"><a href="/WSUSMicrosoft-Windows-Server-Update-Services/#disqus_thread">Comments</a></span>
    
</div>
</article>

  <article class="post">
    <h2 class="title"> 
        <a href="/flickr-free-photo-album/">flickr,免费相册</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2006-03-23T00:00:00.000&#43;00:00' itemprop="datePublished">2006-03-23</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/web">web</a>


</div>
    </div>
        其实很早就知道flickr了，不过是发现那上面的图片似乎只能看小图，不能看大图，那多郁闷。刚才又去看了一下，发现可以看大图了，哇哇。。。这个真不错，推荐大家使用。<br />

比较详细的使用说明<br />
<a href="http://www.mugou.com/user3/13903/archives/2006/8374.shtml">http://www.mugou.com/user3/13903/archives/2006/8374.shtml</a><br />

    </div>

<div class="meta">
    
    <span class="comments"><a href="/flickr-free-photo-album/#disqus_thread">Comments</a></span>
    
</div>
</article>



  <nav id="pagenavi">
    
        <a href="/page/37/" class="prev">Prev</a>
    
    
        <a href="/page/39/" class="next">Next</a>
    
  <div class="center"><a href="/archives/index.html">Blog Archives</a></div>
  </nav>


    </div>
    <footer id="footer">
    <div style="display:inline">
    Copyright &copy; 2017
    
    wd
    . Powered by <a href="http://gohugo.io" target="_blank">Hugo</a> |
    Theme is <a href="https://github.com/wd/hugo-fabric">hugo-fabric</a>, fork from <a href="https://github.com/wd/hexo-fabric">hexo-fabric</a> by <a href="https://wdicc.com">me</a>
</div>

    </footer>
    <script src="/js/fabric.js"></script>


</div>
</div>
<script src="/js/jquery.ui.totop.js" type="text/javascript"></script>
<script type="text/javascript">
 
;(function($){$().UItoTop({easingType:'easeOutCirc'});})(jQuery);
 
</script>
</body>
</html>
