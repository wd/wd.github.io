<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
    
	<title>AWK：Linux 管理员的智能工具包zz - wd and cc</title>
    <meta name="author" content="wd">
    
	<meta name="description" content="引用地址：http://www.oracle.com/technology/global/cn/pub/articles/dulaney_awk.html
还可以参考：http://www.example.net.cn/archives/2005/01/awknieec.html

&lt;p&gt;&lt;span class=&quot;boldbodycopy&quot;&gt;您正在学习 Linux 吗？本文对于非常有用的 AWK 文本操作工具进行了介绍，非常有价值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&amp;lt;!--use&amp;gt; &lt;span class=&quot;bodycopy&quot;&gt;AWK实用工具带有其自己的自包含语言，它不仅是 Linux中也是任何环境中现有的功能最强大的数据处理引擎之一。这种编程及数据操作语言（其名称得自于它的创始人 Alfred Aho、PeterWeinberger 和 Brian Kernighan姓氏的首个字母）的最大功能取决于一个人所拥有的知识。它允许您创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;parahead1&quot;&gt;&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;p&gt;&lt;span class=&quot;parahead1&quot;&gt;AWK 是什么？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;最简单地说，AWK 是一种用于处理文本的编程语言工具。AWK 实用工具的语言在很多方面类似于shell 编程语言，尽管 AWK 具有完全属于其本身的语法。在最初创造 AWK时，其目的是用于文本处理，并且这种语言的基础是，只要在输入数据中有模式匹配，就执行一系列指令。该实用工具扫描文件中的每一行，查找与命令行中所给定内容相匹配的模式。如果发现匹配内容，则进行下一个编程步骤。如果找不到匹配内容，则继续处理下一行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;尽管操作可能会很复杂，但命令的语法始终是：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;awk &#39;{pattern + action}&#39; {filenames} 
&lt;/pre&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;其中 &lt;/span&gt;&lt;tt&gt;pattern&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt; 表示 AWK 在数据中查找的内容，而 action 是在找到匹配内容时所执行的一系列命令。花括号 ({}) 不需要在程序中始终出现，但它们用于根据特定的模式对一系列指令进行分组。&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;span class=&quot;parahead1&quot;&gt;了解字段&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;实用工具将每个输入行分为记录和字段。&lt;/span&gt;&lt;span class=&quot;italicbodycopy&quot;&gt;记录&lt;/span&gt;&lt;span class=&quot;bodycopy&quot;&gt;是单行的输入，而每条记录包含若干字段。默认的字段分隔符是空格或制表符，而记录的分隔符是换行。虽然在默认情况下将制表符和空格都看作字段分隔符（多个空格仍然作为一个分隔符），但是可以将分隔符从空格改为任何其它字符。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;为了进行演示，请查看以下保存为 emp_names 的员工列表文件：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;46012   DULANEY     EVAN        MOBILE   AL
46013   DURHAM      JEFF        MOBILE   AL
46015   STEEN       BILL        MOBILE   AL
46017   FELDMAN     EVAN        MOBILE   AL
46018   SWIM        STEVE       UNKNOWN  AL
46019   BOGUE       ROBERT      PHOENIX  AZ
46021   JUNE        MICAH       PHOENIX  AZ
46022   KANE        SHERYL      UNKNOWN  AR
46024   WOOD        WILLIAM     MUNCIE   IN
46026   FERGUS      SARAH       MUNCIE   IN
46027   BUCK        SARAH       MUNCIE   IN
46029   TUTTLE      BOB         MUNCIE   IN
&lt;/pre&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;当 AWK 读取输入内容时，整条记录被分配给变量 &lt;/span&gt;&lt;tt&gt;$0&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt;。每个字段以字段分隔符分开，被分配给变量 &lt;/span&gt;&lt;tt&gt;$1、$2、$3&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt; 等等。一行在本质上可以包含无数个字段，通过字段号来访问每个字段。因此，命令&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;awk &#39;{print $1,$2,$3,$4,$5}&#39; names
&lt;/pre&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;将会产生的打印输出是&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;46012 DULANEY EVAN MOBILE AL
46013 DURHAM JEFF MOBILE AL
46015 STEEN BILL MOBILE AL
46017 FELDMAN EVAN MOBILE AL
46018 SWIM STEVE UNKNOWN AL
46019 BOGUE ROBERT PHOENIX AZ
46021 JUNE MICAH PHOENIX AZ
46022 KANE SHERYL UNKNOWN AR
46024 WOOD WILLIAM MUNCIE IN
46026 FERGUS SARAH MUNCIE IN
46027 BUCK SARAH MUNCIE IN
46029 TUTTLE BOB MUNCIE IN
&lt;/pre&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;值得注意的一项重要内容是，AWK 解释由空格分隔的五个字段，但当它打印显示内容时，在每个字段间只有一个空格。利用为每个字段指定了唯一号码的功能，您可以选择只打印特定的字段。例如，只打印每条记录的姓名时，只需选择第二个和第三个字段进行打印：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;$ awk &#39;{print $2,$3}&#39; emp_names
DULANEY EVAN
DURHAM JEFF
STEEN BILL
FELDMAN EVAN
SWIM STEVE
BOGUE ROBERT
JUNE MICAH
KANE SHERYL
WOOD WILLIAM
FERGUS SARAH
BUCK SARAH
TUTTLE BOB
$
&lt;/pre&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;您还可以指定按任何顺序打印字段，而无论它们在记录中是如何存在的。因此，只需要显示姓名字段，并且使其顺序颠倒，先显示名字再显示姓氏：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;$ awk &#39;{print $3,$2}&#39; emp_names
EVAN DULANEY
JEFF DURHAM
BILL STEEN
EVAN FELDMAN
STEVE SWIM
ROBERT BOGUE
MICAH JUNE
SHERYL KANE
WILLIAM WOOD
SARAH FERGUS
SARAH BUCK
BOB TUTTLE
$
&lt;/pre&gt;&lt;p&gt;&lt;span class=&quot;parahead1&quot;&gt;使用模式&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;通过包含一个必须匹配的模式，您可以选择只对特定的记录而不是所有的记录进行操作。模式匹配的最简单形式是搜索，其中要匹配的项目被包含在斜线 (&lt;/span&gt;&lt;tt&gt;/pattern/&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt;) 中。例如，只对那些居住在阿拉巴马州的员工执行前面的操作：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;$ awk &#39;/AL/ {print $3,$2}&#39; emp_names
EVAN DULANEY
JEFF DURHAM
BILL STEEN
EVAN FELDMAN
STEVE SWIM
$
&lt;/pre&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;如果您不指定要打印的字段，则会打印整个匹配的条目：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;$ awk &#39;/AL/&#39; emp_names
46012   DULANEY     EVAN     MOBILE     AL
46013   DURHAM      JEFF     MOBILE     AL
46015   STEEN       BILL     MOBILE     AL
46017   FELDMAN     EVAN     MOBILE     AL
46018   SWIM        STEVE    UNKNOWN    AL
$
&lt;/pre&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;对同一数据集的多个命令可以用分号 (&lt;/span&gt;&lt;tt&gt;;&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt;) 分隔开。例如，在一行中打印姓名，而在另一行中打印城市和州名：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;$ awk &#39;/AL/ {print $3,$2 ; print $4,$5}&#39; emp_names
EVAN DULANEY
MOBILE AL
JEFF DURHAM
MOBILE AL
BILL STEEN
MOBILE AL
EVAN FELDMAN
MOBILE AL
STEVE SWIM
UNKNOWN AL
$
&lt;/pre&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;如果没有使用分号 (&lt;/span&gt;&lt;tt&gt;print $3,$2,$4,$5&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt;)，则会在同一行中显示所有内容。另一方面，如果分别给出两个打印语句，则会产生完全不同的结果：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;$ awk &#39;/AL/ {print $3,$2} {print $4,$5}&#39; emp_names
EVAN DULANEY
MOBILE AL
JEFF DURHAM
MOBILE AL
BILL STEEN
MOBILE AL
EVAN FELDMAN
MOBILE AL
STEVE SWIM
UNKNOWN AL
PHOENIX AZ
PHOENIX AZ
UNKNOWN AR
MUNCIE IN
MUNCIE IN
MUNCIE IN
MUNCIE IN
$
&lt;/pre&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;只有在列表中找到 &lt;/span&gt;&lt;tt&gt;AL&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt; 时才会给出字段三和字段二。但是，字段四和字段五是无条件的，始终打印它们。只有第一组花括号中的命令对前面紧邻的命令 (&lt;/span&gt;&lt;tt&gt;/AL/&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt;) 起作用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;结果非常不便于阅读，可以使其稍微更清晰一些。首先，在城市与州之间插入一个空格和逗号。然后，在每两行显示之后放置一个空行：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;$ awk &#39;/AL/ {print $3,$2 ; print $4&quot;, &quot;$5&quot;\n&quot;}&#39; emp_names
EVAN DULANEY
MOBILE, AL

JEFF DURHAM
MOBILE, AL

BILL STEEN
MOBILE, AL

EVAN FELDMAN
MOBILE, AL

STEVE SWIM
UNKNOWN, AL
$
&lt;/pre&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;在第四和第五个字段之间，添加一个逗号和一个空格（在引号之间），在第五个字段后面，打印一个换行符 (&lt;/span&gt;&lt;tt&gt;\n&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt;)。在 AWK 打印语句中还可以使用那些可在 &lt;/span&gt;&lt;tt&gt;echo&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt; 命令中使用的所有特殊字符，包括：&lt;/span&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;tt&gt;\n&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt;（换行）&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;tt&gt;\t&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt;（制表）&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;tt&gt;\b&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt;（退格）&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;tt&gt;\f&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt;（进纸）&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;tt&gt;\r&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt;（回车）&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;因此，要读取全部五个最初由制表符分隔开的字段，并且也利用制表符打印它们，您可以编程如下&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;$ awk &#39;{print $1&quot;\t&quot;$2&quot;\t&quot;$3&quot;\t&quot;$4&quot;\t&quot;$5}&#39; emp_names
46012   DULANEY     EVAN     MOBILE    AL
46013   DURHAM      JEFF     MOBILE    AL
46015   STEEN       BILL     MOBILE    AL
46017   FELDMAN     EVAN     MOBILE    AL
46018   SWIM        STEVE    UNKNOWN   AL
46019   BOGUE       ROBERT   PHOENIX   AZ
46021   JUNE        MICAH    PHOENIX   AZ
46022   KANE        SHERYL   UNKNOWN   AR
46024   WOOD        WILLIAM  MUNCIE    IN
46026   FERGUS      SARAH    MUNCIE    IN
46027   BUCK        SARAH    MUNCIE    IN
46029   TUTTLE      BOB      MUNCIE    IN
$
&lt;/pre&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;通过连续设置多项标准并用管道 (&lt;/span&gt;&lt;tt&gt;|&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt;) 符号将其分隔开，您可以一次搜索多个模式匹配：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;$ awk &#39;/AL|IN/&#39; emp_names
46012   DULANEY     EVAN     MOBILE    AL
46013   DURHAM      JEFF     MOBILE    AL
46015   STEEN       BILL     MOBILE    AL
46017   FELDMAN     EVAN     MOBILE    AL
46018   SWIM        STEVE    UNKNOWN   AL
46024   WOOD        WILLIAM  MUNCIE    IN
46026   FERGUS      SARAH    MUNCIE    IN
46027   BUCK        SARAH    MUNCIE    IN
46029   TUTTLE      BOB      MUNCIE    IN
$
&lt;/pre&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;这样可找到每个阿拉巴马州和印第安那州居民的匹配记录。但是在试图找出居住在亚利桑那州的人时，出现了一个问题：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;$ awk &#39;/AR/&#39; emp_names
46019   BOGUE       ROBERT   PHOENIX   AZ
46021   JUNE        MICAH    PHOENIX   AZ
46022   KANE        SHERYL   UNKNOWN   AZ
46026   FERGUS      SARAH    MUNCIE    IN
46027   BUCK        SARAH    MUNCIE    IN
$
&lt;/pre&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;员工 46026 和 46027 没有住在亚利桑那州；但是他们的名字中包含所搜索的字符序列。切记，当在 AWK 中进行模式匹配时，例如 &lt;/span&gt;&lt;tt&gt;grep、sed&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt; 或者大部分其他 Linux/Unix 命令，将在记录（行）中的任何位置查找匹配，除非指定进行其他操作。为解决这一问题，必须将搜索与特定字段联系起来。通过利用代字号 (˜) 以及对特定字段的说明，可以达到这一目的，如下例所示：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;$ awk &#39;$5 ˜ /AR/&#39; emp_names
46019   BOGUE       ROBERT   PHOENIX   AZ
46021   JUNE        MICAH    PHOENIX   AZ
46022   KANE        SHERYL   UNKNOWN   AZ
$
&lt;/pre&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;代字号（表示匹配）的对应符号是一个前面带有感叹号的代字号 (!˜)。这些字符通知程序，如果搜索序列没有出现在指定字段中，则找出与搜索序列相匹配的所有行：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;$ awk &#39;$5 !˜ /AR/&#39; names
46012   DULANEY     EVAN     MOBILE    AL
46013   DURHAM      JEFF     MOBILE    AL
46015   STEEN       BILL     MOBILE    AL
46017   FELDMAN     EVAN     MOBILE    AL
46018   SWIM        STEVE    UNKNOWN   AL
46024   WOOD        WILLIAM  MUNCIE    IN
46026   FERGUS      SARAH    MUNCIE    IN
46027   BUCK        SARAH    MUNCIE    IN
46029   TUTTLE      BOB      MUNCIE    IN
$
&lt;/pre&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;在这种情况下，将显示第五个字段中没有 AR 的所有行 — 包括两个 Sarah 条目，这两个条目确实包含 AR，但却是在第三个字段而不是第五个字段中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;parahead1&quot;&gt;花括号和字段分隔符&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;括号字符在 AWK 命令中起着很重要的作用。出现在括号之间的操作指出将要发生什么以及何时发生。当只使用一对括号时：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;{print $3,$2}
&lt;/pre&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;括号间的所有操作同时发生。当使用多于一对的括号时：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;{print $3}{print $2}
&lt;/pre&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;执行第一组命令，在该命令完成后执行第二组命令。注意以下两列清单的区别：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;$ awk &#39;{print $3,$2}&#39; names
EVAN DULANEY
JEFF DURHAM
BILL STEEN
EVAN FELDMAN
STEVE SWIM
ROBERT BOGUE
MICAH JUNE
SHERYL KANE
WILLIAM WOOD
SARAH FERGUS
SARAH BUCK
BOB TUTTLE
$

$ awk &#39;{print $3}{print $2}&#39; names
EVAN
DULANEY
JEFF
DURHAM
BILL
STEEN
EVAN
FELDMAN
STEVE
SWIM
ROBERT
BOGUE
MICAH
JUNE
SHERYL
KANE
WILLIAM
WOOD
SARAH
FERGUS
SARAH
BUCK
BOB
TUTTLE
$
&lt;/pre&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;要利用多组括号进行重复查找，执行第一组中的命令直到完成为止；然后处理第二组命令。如果有第三组命令，则在第二组命令完成后执行它，以此类推。在所生成的打印输出中，有两个分隔的打印命令，因此先执行第一个命令，随后执行第二个命令，这样导致每个条目显示在两行而不是一行中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;区分两个字段的字段分隔符不一定始终是空格；它可以是任何可识别的字符。为进行演示，假定 &lt;/span&gt;&lt;tt&gt;emp_names&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt; 文件利用冒号而不是制表符来分隔字段：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;$ cat emp_names
46012:DULANEY:EVAN:MOBILE:AL
46013:DURHAM:JEFF:MOBILE:AL
46015:STEEN:BILL:MOBILE:AL
46017:FELDMAN:EVAN:MOBILE:AL
46018:SWIM:STEVE:UNKNOWN:AL
46019:BOGUE:ROBERT:PHOENIX:AZ
46021:JUNE:MICAH:PHOENIX:AZ
46022:KANE:SHERYL:UNKNOWN:AR
46024:WOOD:WILLIAM:MUNCIE:IN
46026:FERGUS:SARAH:MUNCIE:IN
46027:BUCK:SARAH:MUNCIE:IN
46029:TUTTLE:BOB:MUNCIE:IN
$
&lt;/pre&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;如果试图通过指定所需要的第二个字段来打印姓氏&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;$ awk &#39;{print $2}&#39; emp_names
&lt;/pre&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;您最后会得到十二个空行。因为文件中没有空格，除了第一个字段之外没有可认别的字段。为解决这一问题，必须通知 AWK 是空格之外的另一个字符作为分隔符，有两种方法可通知 AWK 使用新的字段分隔符：使用命令行参数 &lt;/span&gt;&lt;tt&gt;-F&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt;，或在程序中指定变量 FS。两种方法的效果相同，只有一种例外情况，如下例所示：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;$ awk &#39;{FS=&quot;:&quot;}{print $2}&#39; emp_names

DURHAM
STEEN
FELDMAN
SWIM
BOGUE
JUNE
KANE
WOOD
FERGUS
BUCK
TUTTLE
$

$ awk -F: &#39;{print $2}&#39; emp_names
DULANEY
DURHAM
STEEN
FELDMAN
SWIM
BOGUE
JUNE
KANE
WOOD
FERGUS
BUCK
TUTTLE
$
&lt;/pre&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;在第一个命令中，头一条记录返回不正确的空行，而其他结果正确。直到读取第二条记录时，才识别字段分隔符并正确地执行。通过使用 &lt;/span&gt;&lt;tt&gt;BEGIN&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt; 语句可以纠正这一缺点（在后文详述）。&lt;/span&gt;&lt;tt&gt;-F&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt; 的功能非常类似于 &lt;/span&gt;&lt;tt&gt;BEGIN&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt;，能够正确地读取第一条记录并按要求执行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;在本文开始处我曾提到，默认的显示/输出字段分隔符是空格。通过使用输出字段分隔符 (&lt;/span&gt;&lt;tt&gt;OFS&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt;) 变量，可以在程序中更改此特性。例如，要读取文件（由冒号分隔）并以短划线显示，则命令是&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;$ awk -F&quot;:&quot; &#39;{OFS=&quot;-&quot;}{print $1,$2,$3,$4,$5}&#39; emp_names
46012-DULANEY-EVAN-MOBILE-AL
46013-DURHAM-JEFF-MOBILE-AL
46015-STEEN-BILL-MOBILE-AL
46017-FELDMAN-EVAN-MOBILE-AL
46018-SWIM-STEVE-UNKNOWN-AL
46019-BOGUE-ROBERT-PHOENIX-AZ
46021-JUNE-MICAH-PHOENIX-AZ
46022-KANE-SHERYL-UNKNOWN-AR
46024-WOOD-WILLIAM-MUNCIE-IN
46026-FERGUS-SARAH-MUNCIE-IN
46027-BUCK-SARAH-MUNCIE-IN
46029-TUTTLE-BOB-MUNCIE-IN
$
&lt;/pre&gt;&lt;p&gt;&lt;tt&gt;FS &lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt; 和 &lt;/span&gt;&lt;tt&gt;OFS&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt; 是（输入）字段分隔符和输出字段分隔符，它们只是一对可以在 AWK 实用工具中使用的变量。例如，要在打印时为每行编号，可以采用以下方式使用 &lt;/span&gt;&lt;tt&gt;NR&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt; 变量：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;$ awk -F&quot;:&quot; &#39;{print NR,$1,$2,$3}&#39; emp_names
1 46012 DULANEY EVAN
2 46013 DURHAM JEFF
3 46015 STEEN BILL
4 46017 FELDMAN EVAN
5 46018 SWIM STEVE
6 46019 BOGUE ROBERT
7 46021 JUNE MICAH
8 46022 KANE SHERYL
9 46024 WOOD WILLIAM
10 46026 FERGUS SARAH
11 46027 BUCK SARAH
12 46029 TUTTLE BOB
$
&lt;/pre&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;找出员工号码处于 46012 和 46015 之间的所有行：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;$ awk -F&quot;:&quot; &#39;/4601[2-5]/&#39; emp_names
46012   DULANEY EVAN  MOBILE AL
46013   DURHAM  JEFF  MOBILE AL
46015   STEEN   BILL  MOBILE AL
$
&lt;/pre&gt;&lt;p&gt;&lt;span class=&quot;parahead1&quot;&gt;添加文本&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;可以按照添加控制序列或其他字符的相同方式将文本添加到显示中。例如，要将分隔符从空格改为冒号，则命令是&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;awk &#39;{print $1&quot;:&quot;$2&quot;:&quot;$3&quot;:&quot;$4&quot;:&quot;$5}&#39; emp_names &amp;gt; new_emp_names
&lt;/pre&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;在这种情况下，字符 (&lt;/span&gt;&lt;tt&gt;:&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt;) 包含在引号 (&lt;/span&gt;&lt;tt&gt;&quot;/&quot;&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt;) 中，它被添加到每个字段之间。在引号之间的值可以是任何内容。例如，创建一个关于居住在阿拉巴马州的员工的外观类似数据库的显示：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;$ awk &#39;$5 ~ /AL/ {print &quot;NAME: &quot;$2&quot;, &quot;$3&quot;\nCITY-STATE:
  &quot;$4&quot;, &quot;$5&quot;\n&quot;}&#39; emp_names

NAME: DULANEY, EVAN
CITY-STATE: MOBILE, AL

NAME: DURHAM, JEFF
CITY-STATE: MOBILE, AL

NAME: STEEN, BILL
CITY-STATE: MOBILE, AL

NAME: FELDMAN, EVAN
CITY-STATE: MOBILE, AL

NAME: SWIM, STEVE
CITY-STATE: UNKNOWN, AL
$
&lt;/pre&gt;&lt;p&gt;&lt;span class=&quot;parahead1&quot;&gt;数学操作&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;AWK 除了提供文本功能，还提供全部范围的算术操作符，包括以下符号：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;tt&gt;+    &lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt;将数字相加&lt;/span&gt;
 &lt;tt&gt;-    &lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt;减&lt;/span&gt;
 &lt;tt&gt;*    &lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt;乘&lt;/span&gt;
 &lt;tt&gt;/    &lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt;除&lt;/span&gt;
 &lt;tt&gt;^    &lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt;执行指数运算&lt;/span&gt;
 &lt;tt&gt;%    &lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt;提供模&lt;/span&gt;
 &lt;tt&gt;++   &lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt;将变量值加一&lt;/span&gt;
 &lt;tt&gt;+=   &lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt;将其他操作的结果分配给变量&lt;/span&gt;
 &lt;tt&gt;— &lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt;将变量减一&lt;/span&gt;
 &lt;tt&gt;-=   &lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt;将减法操作的结果分配给变量&lt;/span&gt;
 &lt;tt&gt;*=   &lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt;分配乘法操作的结果&lt;/span&gt;
 &lt;tt&gt;/=   &lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt;分配除法操作的结果&lt;/span&gt;
 &lt;tt&gt;%=   &lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt;分配求模操作的结果&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;例如，假定您的机器上存在以下的文件，详细地列出硬件商店中的物品：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;$ cat inventory
hammers 5       7.99
drills  2      29.99
punches 7       3.59
drifts  2       4.09
bits   55       1.19
saws  123      14.99
nails 800        .19
screws 80        .29
brads 100        .24
$
&lt;/pre&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;第一项业务定单是通过将第二个字段（数量）的值乘以第三个字段（价格）的值，计算每种物品的库存价值：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;$ awk &#39;{print $1,&quot;QTY: &quot;$2,&quot;PRICE: &quot;$3,&quot;TOTAL: &quot;$2*$3}&#39; inventory
hammers QTY: 5 PRICE: 7.99 TOTAL: 39.95
drills QTY: 2 PRICE: 29.99 TOTAL: 59.98
punches QTY: 7 PRICE: 3.59 TOTAL: 25.13
drifts QTY: 2 PRICE: 4.09 TOTAL: 8.18
bits QTY: 55 PRICE: 1.19 TOTAL: 65.45
saws QTY: 123 PRICE: 14.99 TOTAL: 1843.77
nails QTY: 800 PRICE: .19 TOTAL: 152
screws QTY: 80 PRICE: .29 TOTAL: 23.2
brads QTY: 100 PRICE: .24 TOTAL: 24
$
&lt;/pre&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;如果这些行本身并不重要，您只是希望确定商店中有多少件物品，则可以分配一个普通变量，按照每条记录中的物品数量增加：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;$ awk &#39;{x=x+$2} {print x}&#39; inventory
5
7
14
16
71
194
994
1074
1174
$
&lt;/pre&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;根据这一数据，商店中有 1174 件物品。第一次执行时，变量 x 没有值，因此它采用第一行第二个字段的值。第二次执行时，它保留了第一行的值并加上第二行的值，以此类推，直到达到累计的总合。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;可以应用相同的过程来确定现有库存的总价值：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;$ awk &#39;{x=x+($2*$3)} {print x}&#39; inventory
39.95
99.93
125.06
133.24
198.69
2042.46
2194.46
2217.66
2241.66
$
&lt;/pre&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;因此，1174 件物品的价值是 $2,241.66。虽然这一过程可以获得总计值，但它的外观很差，需要加工成实际的报表。利用一些附加项，很容易使显示变得更整洁：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;$ awk &#39;{x=x+($2*$3)}{print $1,&quot;QTY: &quot;$2,&quot;PRICE: &quot;$3,&quot;TOTAL: &quot;$2*$3,&quot;BAL: &quot;x}&#39; inventory
hammers QTY: 5 PRICE: 7.99 TOTAL: 39.95 BAL: 39.95
drills QTY: 2 PRICE: 29.99 TOTAL: 59.98 BAL: 99.93
punches QTY: 7 PRICE: 3.59 TOTAL: 25.13 BAL: 125.06
drifts QTY: 2 PRICE: 4.09 TOTAL: 8.18 BAL: 133.24
bits QTY: 55 PRICE: 1.19 TOTAL: 65.45 BAL: 198.69
saws QTY: 123 PRICE: 14.99 TOTAL: 1843.77 BAL: 2042.46
nails QTY: 800 PRICE: .19 TOTAL: 152 BAL: 2194.46
screws QTY: 80 PRICE: .29 TOTAL: 23.2 BAL: 2217.66
brads QTY: 100 PRICE: .24 TOTAL: 24 BAL: 2241.66
$
&lt;/pre&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;该过程提供了每条记录的清单，同时将总价值分配给库存值，并保持商店资产的运作平衡。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;tt&gt;&lt;strong&gt;BEGIN&lt;/strong&gt;&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt; 和 &lt;/span&gt;&lt;tt&gt;&lt;strong&gt;END&lt;/strong&gt;&lt;/tt&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;使用 &lt;/span&gt;&lt;tt&gt;BEGIN&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt; 和 &lt;/span&gt;&lt;tt&gt;END&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt; 语句可以分别指定在处理实际开始之前或者完成之后进行操作。&lt;/span&gt;&lt;tt&gt;BEGIN&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt; 语句最常用于建立变量或显示标题。另一方面，&lt;/span&gt;&lt;tt&gt;END&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt; 语句可用于在程序结束后继续进行处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;在前面的示例中，利用以下例程生成了物品的总价值：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;awk &#39;{x=x+($2*$3)} {print x}&#39; inventory
&lt;/pre&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;该例程在运行总计累加时显示了文件中的每一行。没有其他方法可以指定它，而不让在每一行进行打印也导致它始终不打印出来。但是，利用 &lt;/span&gt;&lt;tt&gt;END&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt; 语句可以避免这一问题：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;$ awk &#39;{x=x+($2*$3)} END {print &quot;Total Value of Inventory:&quot;x}&#39; inventory
Total Value of Inventory: 2241.66
$
&lt;/pre&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;定义了变量 &lt;/span&gt;&lt;tt&gt;&lt;em&gt;x&lt;/em&gt;&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt;，它对每一行进行处理；但是，在所有处理完成之前不会生成显示。尽管可以作为独立例程使用，它也可以置入到先前的代码列表，添加更多信息并生成更完整的报表：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;$ awk &#39;{x=x+($2*$3)} {print $1,&quot;QTY: &quot;$2,&quot;PRICE: 
    &quot;$3,&quot;TOTAL: &quot;$2*$3} END {print &quot;Total Value of Inventory: &quot; x}&#39; inventory

hammers QTY: 5 PRICE: 7.99 TOTAL: 39.95
drills QTY: 2 PRICE: 29.99 TOTAL: 59.98
punches QTY: 7 PRICE: 3.59 TOTAL: 25.13
drifts QTY: 2 PRICE: 4.09 TOTAL: 8.18
bits QTY: 55 PRICE: 1.19 TOTAL: 65.45
saws QTY: 123 PRICE: 14.99 TOTAL: 1843.77
nails QTY: 800 PRICE: .19 TOTAL: 152
screws QTY: 80 PRICE: .29 TOTAL: 23.2
brads QTY: 100 PRICE: .24 TOTAL: 24
Total Value of Inventory: 2241.66
$
&lt;/pre&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;&lt;/span&gt;&lt;tt&gt;BEGIN&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt; 命令与 &lt;/span&gt;&lt;tt&gt;END&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt; 的工作方式相同，但它建立了那些需要在完成其他工作之前所做的项目。该过程最常见的目的是创建报表的标题。此例程的语法类似于&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;$ awk &#39;BEGIN {print &quot;ITEM   QUANTITY   PRICE   TOTAL&quot;}&#39;
&lt;/pre&gt;&lt;p&gt;&lt;span class=&quot;parahead1&quot;&gt;输入、输出和源文件&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;AWK 工具可以从文件中读取其输入，正如在此之前所有示例所做的那样，它也可以从其他命令的输出中获取输入。例如：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;$ sort emp_names | awk &#39;{print $3,$2}&#39;
&lt;/pre&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;&lt;/span&gt;&lt;tt&gt;awk&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt; 命令的输入是排序操作的输出。除了 &lt;/span&gt;&lt;tt&gt;sort&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt;，还可以使用任何其他的 Linux 命令 — 例如 &lt;/span&gt;&lt;tt&gt;grep&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt;。该过程允许您在离开所选定字段前对文件执行其他操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;类似于解释程序，AWK 使用输出改向操作符 &lt;/span&gt;&lt;tt&gt;&amp;gt;&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt; 和 &lt;/span&gt;&lt;tt&gt;&amp;gt;&amp;gt;&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt; 将其输出放入文件中而不是标准输出设备。这些符号的作用类似于它们在解释程序中的对应符号，因此 &lt;/span&gt;&lt;tt&gt;&amp;gt;&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt; 在不存在文件时创建文件，而 &lt;/span&gt;&lt;tt&gt;&amp;gt;&amp;gt;&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt; 追加到现有文件的尾部。请看以下的示例：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;$ awk &#39;{print NR, $1 ) &amp;gt; &quot;/tmp/filez&quot; }&#39; emp_names
$ cat /tmp/filez
1	46012
2	46013
3	46015
4	46017
5	46018
6	46019
7	46021
8	46022
9	46024
10	46026
11	46027
12	46029
$
&lt;/pre&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;检查该语句的语法，您会看到输出改向是在打印语句完成后进行的。必须将文件名包含在引号中，否则它只是一个未初始化的 AWK 变量，而将指令联接起来会在 AWK 中产生错误。（如果不正确地使用改向符号，则 AWK无法了解该符号意味着“改向”还是一个关系操作符。）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;在 AWK 中输出到管道也类似于解释程序中所实现的相同操作。要将打印命令的输出发送到管道中，可以在打印命令后附加管道符号以及命令的名称，如下所示：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;$ awk &#39;{ print $2 | &quot;sort&quot; }&#39; emp_names
BOGUE
BUCK
DULANEY
DURHAM
FELDMAN
FERGUS
JUNE
KANE
STEEN
SWIM
TUTTLE
WOOD
$
&lt;/pre&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;这是输出改向的情况，必须将命令包含在引号中，而管道的名称是被执行命令的名称。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;AWK 所使用的命令可以来自两个地方。首先，可以在命令行中指定它们，如示例中所示。其次，它们可以由源文件提供。如果是这种情况，通过 &lt;/span&gt;&lt;tt&gt;-f&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt; 选项将这种情况向 AWK 发出警告。演示如下：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;$ cat awklist
{print $3,$2}
{print $4,$5,&quot;\n&quot;}
$

$ awk -f awklist emp_names
EVAN DULANEY
MOBILE AL

JEFF DURHAM
MOBILE AL

BILL STEEN
MOBILE AL

EVAN FELDMAN
MOBILE AL

STEVE SWIM
UNKNOWN AL

ROBERT BOGUE
PHOENIX AZ

MICAH JUNE
PHOENIX AZ

SHERYL KANE
UNKNOWN AR

WILLIAM WOOD
MUNCIE IN

SARAH FERGUS
MUNCIE IN

SARAH BUCK
MUNCIE IN

BOB TUTTLE
MUNCIE IN

$
&lt;/pre&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;注意，在源文件中的任何地方或者在命令行中调用它时，不使用单引号。单引号只用于区别命令行中的命令与文件名称。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;如果简单的输出不能处理您的程序中所需要的复杂信息，则可以尝试由 &lt;/span&gt;&lt;tt&gt;printf&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt; 命令获得的更加复杂的输出，其语法是&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;printf( format, value, value ...)
&lt;/pre&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;该语法类似于 C 语言中的 &lt;/span&gt;&lt;tt&gt;printf&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt; 命令，而格式的规格是相同的。通过插入一项定义如何打印数值的规格，可以定义该格式。格式规格包含一个跟有字母的 %。类似于打印命令，&lt;/span&gt;&lt;tt&gt;printf&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt; 不必包含在圆括号中，但是可以认为使用圆括号是一种良好的习惯。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;下表列出 &lt;/span&gt;&lt;tt&gt;printf&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt; 命令提供的各种规格。&lt;/span&gt;&lt;/p&gt;&lt;table align=&quot;left&quot; bgcolor=&quot;#ffffff&quot; border=&quot;0&quot; cellpadding=&quot;5&quot; hspace=&quot;5&quot; vspace=&quot;5&quot; width=&quot;100%&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;&lt;span class=&quot;boldbodycopy&quot;&gt;规格&lt;/span&gt;&lt;/td&gt;&lt;td width=&quot;85%&quot;&gt;&lt;span class=&quot;boldbodycopy&quot;&gt;说明&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;tt&gt;%c&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;&lt;span class=&quot;bodycopy&quot;&gt;打印单个 ASCII 字符&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;tt&gt;%d&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;&lt;span class=&quot;bodycopy&quot;&gt;打印十进制数&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;tt&gt;%e&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;&lt;span class=&quot;bodycopy&quot;&gt;打印数字的科学计数表示&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;		                                                             &lt;tr&gt;&lt;td&gt;&lt;tt&gt;%f&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;&lt;span class=&quot;bodycopy&quot;&gt;打印浮点表示&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;tt&gt;%g&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;&lt;span class=&quot;bodycopy&quot;&gt;打印 %e 或 %f；两种方式都更简短&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;tt&gt;%o&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;&lt;span class=&quot;bodycopy&quot;&gt;打印无符号的八进制数&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;tt&gt;s&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;&lt;span class=&quot;bodycopy&quot;&gt;打印 ASCII 字符串&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;tt&gt;%x&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;&lt;span class=&quot;bodycopy&quot;&gt;打印无符号的十六进制数&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;tt&gt;%%&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;&lt;span class=&quot;bodycopy&quot;&gt;打印百分号；不执行转换&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;可以在 % 与字符之间提供某些附加的格式化参数。这些参数进一步改进数值的打印方式：&lt;/span&gt;&lt;/p&gt;&lt;table align=&quot;left&quot; bgcolor=&quot;#ffffff&quot; border=&quot;0&quot; cellpadding=&quot;5&quot; hspace=&quot;5&quot; vspace=&quot;5&quot; width=&quot;100%&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td width=&quot;25%&quot;&gt;&lt;span class=&quot;boldbodycopy&quot;&gt;参数&lt;/span&gt;&lt;/td&gt;&lt;td width=&quot;75%&quot;&gt;&lt;span class=&quot;boldbodycopy&quot;&gt;说明&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;tt&gt;-&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;&lt;span class=&quot;bodycopy&quot;&gt;将字段中的表达式向左对齐&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;tt&gt;,width&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;&lt;span class=&quot;bodycopy&quot;&gt;根据需要将字段补齐到指定宽度（前导零使用零将字段补齐） &lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;tt&gt;.prec&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;&lt;span class=&quot;bodycopy&quot;&gt;小数点右面数字的最大字符串宽度或最大数量&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;&lt;/span&gt;&lt;tt&gt;printf&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt; 命令能够控制并将数值从一种格式转换为另一种格式。当需要打印变量的值时，只需提供一种规格，指示 &lt;/span&gt;&lt;tt&gt;printf&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt; 如何打印信息（通常包含在双引号中）即可。必须为每个传递到 &lt;/span&gt;&lt;tt&gt;printf&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt; 的变量包含一个规格参数；如果包含过少的参数，则 &lt;/span&gt;&lt;tt&gt;printf&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt; 不会打印所有的数值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;parahead1&quot;&gt;处理错误&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;AWK 工具报告所发生错误的方式很令人恼火。一个错误会阻碍任何操作的进行，所提供的错误信息非常含混不清：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;awk: syntax error near line 2
awk: bailing out near line 2
&lt;/pre&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;您可能会花几小时的时间查看第 2 行，试图找出它为什么阻碍程序运行；这就是支持使用源文件的一个有力论据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;切记有两条规则可以帮助您避免出现语法错误：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;1. 确保命令位于括号中，而括号位于单引号中。没有使用这些字符之一必然导致程序无法运行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;2. 搜索命令需要位于斜线之间。要找出住在印第安那州的员工，您必须使用“&lt;/span&gt;&lt;tt&gt;/IN/&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt;”而不是“&lt;/span&gt;&lt;tt&gt;IN&lt;/tt&gt;&lt;span class=&quot;bodycopy&quot;&gt;”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;parahead1&quot;&gt;结论&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;bodycopy&quot;&gt;尽管 AWK 完全代表另外的含意，但它应该是管理员智能工具包的首字母缩写。连同 SED一起，AWK 实用工具是 Linux管理员所拥有的功能最强大和灵活的工具之一。通过了解其语言的一些特性，您可以开辟出能够简化任务的领域，否则这些任务将会是非常费时和困难的。 &lt;/span&gt;&lt;/p&gt;
&lt;/span&gt;&lt;/p&gt;
"> <!-- TODO: truncate -->
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="atom.xml" rel="alternate" title="wd and cc" type="application/atom+xml">
	<link href="/favicon.ico" rel="shortcut icon">
    <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
    <link href="/stylesheets/custom.css" media="screen, projection" rel="stylesheet" type="text/css">
    <link href="/stylesheets/hljs.css" media="screen, projection" rel="stylesheet" type="text/css">

    <link href='//fonts.googleapis.com/css?family=Slackey' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Fjalla+One' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Amethysta' rel='stylesheet' type='text/css'>
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
    <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![}]-->

    <script type="text/javascript" src="/javascripts/jquery-tapir.js"></script>

    <!-- remove or comment it to disable ajaxification -->   
    <!-- <script src="/javascripts/ajaxify.js"></script> -->

    

    

</head>


<body>
    <div id="wrapper">
    <header id="header" class="inner"><!-- for more effects see _animate.scss -->
<h1 class="animated bounceInDown">
    <div id="headerbg">
        wd and cc
    </div>
</h1>
<span class="subtitle">happy everyday</span>
<br>

<ul id="social-links" style="text-align:center; clear:both;">
  
  <!-- GitHub -->
  <li>
  <a href="https://github.com/wd" class="github" title="Github"></a>
  </li>
  
  
  
  
  <!-- Twitter -->
  <li>
  <a href="http://www.twitter.com/wd" class="twitter" title="Twitter"></a>
  </li>
  
  
  
  
  
</ul>


<!-- use full url including 'index.html' for navigation bar if you are using ajax -->
<ul id="nav">
	<li id="ajax"><a href="/index.html">Home</a></li>
	<li id="ajax"><a href="/archives/index.html">Archives</a></li>
    <li><a href="/atom.xml">RSS</a></li>
    
    <li>
    <div id="dark">
        <form method="get" action="/search.html" id="search">
            <input name="query" type="text" placeholder="Search..." x-webkit-speech />
        </form>
    </div>
    </li>
        
</ul>




</header>

<div id="toload">
<!-- begin toload -->
    <div id="content" class="inner">
        <article class="post">
	<h2 class="title">AWK：Linux 管理员的智能工具包zz</h2>
	<div class="entry-content">引用地址：http://www.oracle.com/technology/global/cn/pub/articles/dulaney_awk.html
还可以参考：http://www.example.net.cn/archives/2005/01/awknieec.html

<p><span class="boldbodycopy">您正在学习 Linux 吗？本文对于非常有用的 AWK 文本操作工具进行了介绍，非常有价值。</span></p><p>&lt;!--use&gt; <span class="bodycopy">AWK实用工具带有其自己的自包含语言，它不仅是 Linux中也是任何环境中现有的功能最强大的数据处理引擎之一。这种编程及数据操作语言（其名称得自于它的创始人 Alfred Aho、PeterWeinberger 和 Brian Kernighan姓氏的首个字母）的最大功能取决于一个人所拥有的知识。它允许您创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。</span></p><p><span class="parahead1"><br><a id="more"></a><p><span class="parahead1">AWK 是什么？</span></p><p><span class="bodycopy">最简单地说，AWK 是一种用于处理文本的编程语言工具。AWK 实用工具的语言在很多方面类似于shell 编程语言，尽管 AWK 具有完全属于其本身的语法。在最初创造 AWK时，其目的是用于文本处理，并且这种语言的基础是，只要在输入数据中有模式匹配，就执行一系列指令。该实用工具扫描文件中的每一行，查找与命令行中所给定内容相匹配的模式。如果发现匹配内容，则进行下一个编程步骤。如果找不到匹配内容，则继续处理下一行。</span></p><p><span class="bodycopy">尽管操作可能会很复杂，但命令的语法始终是：</span></p><pre>awk '{pattern + action}' {filenames} 
</pre><p><span class="bodycopy">其中 </span><tt>pattern</tt><span class="bodycopy"> 表示 AWK 在数据中查找的内容，而 action 是在找到匹配内容时所执行的一系列命令。花括号 ({}) 不需要在程序中始终出现，但它们用于根据特定的模式对一系列指令进行分组。</span></p><p> <span class="parahead1">了解字段</span></p><p><span class="bodycopy">实用工具将每个输入行分为记录和字段。</span><span class="italicbodycopy">记录</span><span class="bodycopy">是单行的输入，而每条记录包含若干字段。默认的字段分隔符是空格或制表符，而记录的分隔符是换行。虽然在默认情况下将制表符和空格都看作字段分隔符（多个空格仍然作为一个分隔符），但是可以将分隔符从空格改为任何其它字符。</span></p><p><span class="bodycopy">为了进行演示，请查看以下保存为 emp_names 的员工列表文件：</span></p><pre>46012   DULANEY     EVAN        MOBILE   AL
46013   DURHAM      JEFF        MOBILE   AL
46015   STEEN       BILL        MOBILE   AL
46017   FELDMAN     EVAN        MOBILE   AL
46018   SWIM        STEVE       UNKNOWN  AL
46019   BOGUE       ROBERT      PHOENIX  AZ
46021   JUNE        MICAH       PHOENIX  AZ
46022   KANE        SHERYL      UNKNOWN  AR
46024   WOOD        WILLIAM     MUNCIE   IN
46026   FERGUS      SARAH       MUNCIE   IN
46027   BUCK        SARAH       MUNCIE   IN
46029   TUTTLE      BOB         MUNCIE   IN
</pre><p><span class="bodycopy">当 AWK 读取输入内容时，整条记录被分配给变量 </span><tt>$0</tt><span class="bodycopy">。每个字段以字段分隔符分开，被分配给变量 </span><tt>$1、$2、$3</tt><span class="bodycopy"> 等等。一行在本质上可以包含无数个字段，通过字段号来访问每个字段。因此，命令</span></p><pre>awk '{print $1,$2,$3,$4,$5}' names
</pre><p><span class="bodycopy">将会产生的打印输出是</span></p><pre>46012 DULANEY EVAN MOBILE AL
46013 DURHAM JEFF MOBILE AL
46015 STEEN BILL MOBILE AL
46017 FELDMAN EVAN MOBILE AL
46018 SWIM STEVE UNKNOWN AL
46019 BOGUE ROBERT PHOENIX AZ
46021 JUNE MICAH PHOENIX AZ
46022 KANE SHERYL UNKNOWN AR
46024 WOOD WILLIAM MUNCIE IN
46026 FERGUS SARAH MUNCIE IN
46027 BUCK SARAH MUNCIE IN
46029 TUTTLE BOB MUNCIE IN
</pre><p><span class="bodycopy">值得注意的一项重要内容是，AWK 解释由空格分隔的五个字段，但当它打印显示内容时，在每个字段间只有一个空格。利用为每个字段指定了唯一号码的功能，您可以选择只打印特定的字段。例如，只打印每条记录的姓名时，只需选择第二个和第三个字段进行打印：</span></p><pre>$ awk '{print $2,$3}' emp_names
DULANEY EVAN
DURHAM JEFF
STEEN BILL
FELDMAN EVAN
SWIM STEVE
BOGUE ROBERT
JUNE MICAH
KANE SHERYL
WOOD WILLIAM
FERGUS SARAH
BUCK SARAH
TUTTLE BOB
$
</pre><p><span class="bodycopy">您还可以指定按任何顺序打印字段，而无论它们在记录中是如何存在的。因此，只需要显示姓名字段，并且使其顺序颠倒，先显示名字再显示姓氏：</span></p><pre>$ awk '{print $3,$2}' emp_names
EVAN DULANEY
JEFF DURHAM
BILL STEEN
EVAN FELDMAN
STEVE SWIM
ROBERT BOGUE
MICAH JUNE
SHERYL KANE
WILLIAM WOOD
SARAH FERGUS
SARAH BUCK
BOB TUTTLE
$
</pre><p><span class="parahead1">使用模式</span></p><p><span class="bodycopy">通过包含一个必须匹配的模式，您可以选择只对特定的记录而不是所有的记录进行操作。模式匹配的最简单形式是搜索，其中要匹配的项目被包含在斜线 (</span><tt>/pattern/</tt><span class="bodycopy">) 中。例如，只对那些居住在阿拉巴马州的员工执行前面的操作：</span></p><pre>$ awk '/AL/ {print $3,$2}' emp_names
EVAN DULANEY
JEFF DURHAM
BILL STEEN
EVAN FELDMAN
STEVE SWIM
$
</pre><p><span class="bodycopy">如果您不指定要打印的字段，则会打印整个匹配的条目：</span></p><pre>$ awk '/AL/' emp_names
46012   DULANEY     EVAN     MOBILE     AL
46013   DURHAM      JEFF     MOBILE     AL
46015   STEEN       BILL     MOBILE     AL
46017   FELDMAN     EVAN     MOBILE     AL
46018   SWIM        STEVE    UNKNOWN    AL
$
</pre><p><span class="bodycopy">对同一数据集的多个命令可以用分号 (</span><tt>;</tt><span class="bodycopy">) 分隔开。例如，在一行中打印姓名，而在另一行中打印城市和州名：</span></p><pre>$ awk '/AL/ {print $3,$2 ; print $4,$5}' emp_names
EVAN DULANEY
MOBILE AL
JEFF DURHAM
MOBILE AL
BILL STEEN
MOBILE AL
EVAN FELDMAN
MOBILE AL
STEVE SWIM
UNKNOWN AL
$
</pre><p><span class="bodycopy">如果没有使用分号 (</span><tt>print $3,$2,$4,$5</tt><span class="bodycopy">)，则会在同一行中显示所有内容。另一方面，如果分别给出两个打印语句，则会产生完全不同的结果：</span></p><pre>$ awk '/AL/ {print $3,$2} {print $4,$5}' emp_names
EVAN DULANEY
MOBILE AL
JEFF DURHAM
MOBILE AL
BILL STEEN
MOBILE AL
EVAN FELDMAN
MOBILE AL
STEVE SWIM
UNKNOWN AL
PHOENIX AZ
PHOENIX AZ
UNKNOWN AR
MUNCIE IN
MUNCIE IN
MUNCIE IN
MUNCIE IN
$
</pre><p><span class="bodycopy">只有在列表中找到 </span><tt>AL</tt><span class="bodycopy"> 时才会给出字段三和字段二。但是，字段四和字段五是无条件的，始终打印它们。只有第一组花括号中的命令对前面紧邻的命令 (</span><tt>/AL/</tt><span class="bodycopy">) 起作用。</span></p><p><span class="bodycopy">结果非常不便于阅读，可以使其稍微更清晰一些。首先，在城市与州之间插入一个空格和逗号。然后，在每两行显示之后放置一个空行：</span></p><pre>$ awk '/AL/ {print $3,$2 ; print $4", "$5"\n"}' emp_names
EVAN DULANEY
MOBILE, AL

JEFF DURHAM
MOBILE, AL

BILL STEEN
MOBILE, AL

EVAN FELDMAN
MOBILE, AL

STEVE SWIM
UNKNOWN, AL
$
</pre><p><span class="bodycopy">在第四和第五个字段之间，添加一个逗号和一个空格（在引号之间），在第五个字段后面，打印一个换行符 (</span><tt>\n</tt><span class="bodycopy">)。在 AWK 打印语句中还可以使用那些可在 </span><tt>echo</tt><span class="bodycopy"> 命令中使用的所有特殊字符，包括：</span></p><ul><li><tt>\n</tt><span class="bodycopy">（换行）</span></li><li><tt>\t</tt><span class="bodycopy">（制表）</span></li><li><tt>\b</tt><span class="bodycopy">（退格）</span></li><li><tt>\f</tt><span class="bodycopy">（进纸）</span></li><li><tt>\r</tt><span class="bodycopy">（回车）</span></li></ul><p><span class="bodycopy">因此，要读取全部五个最初由制表符分隔开的字段，并且也利用制表符打印它们，您可以编程如下</span></p><pre>$ awk '{print $1"\t"$2"\t"$3"\t"$4"\t"$5}' emp_names
46012   DULANEY     EVAN     MOBILE    AL
46013   DURHAM      JEFF     MOBILE    AL
46015   STEEN       BILL     MOBILE    AL
46017   FELDMAN     EVAN     MOBILE    AL
46018   SWIM        STEVE    UNKNOWN   AL
46019   BOGUE       ROBERT   PHOENIX   AZ
46021   JUNE        MICAH    PHOENIX   AZ
46022   KANE        SHERYL   UNKNOWN   AR
46024   WOOD        WILLIAM  MUNCIE    IN
46026   FERGUS      SARAH    MUNCIE    IN
46027   BUCK        SARAH    MUNCIE    IN
46029   TUTTLE      BOB      MUNCIE    IN
$
</pre><p><span class="bodycopy">通过连续设置多项标准并用管道 (</span><tt>|</tt><span class="bodycopy">) 符号将其分隔开，您可以一次搜索多个模式匹配：</span></p><pre>$ awk '/AL|IN/' emp_names
46012   DULANEY     EVAN     MOBILE    AL
46013   DURHAM      JEFF     MOBILE    AL
46015   STEEN       BILL     MOBILE    AL
46017   FELDMAN     EVAN     MOBILE    AL
46018   SWIM        STEVE    UNKNOWN   AL
46024   WOOD        WILLIAM  MUNCIE    IN
46026   FERGUS      SARAH    MUNCIE    IN
46027   BUCK        SARAH    MUNCIE    IN
46029   TUTTLE      BOB      MUNCIE    IN
$
</pre><p><span class="bodycopy">这样可找到每个阿拉巴马州和印第安那州居民的匹配记录。但是在试图找出居住在亚利桑那州的人时，出现了一个问题：</span></p><pre>$ awk '/AR/' emp_names
46019   BOGUE       ROBERT   PHOENIX   AZ
46021   JUNE        MICAH    PHOENIX   AZ
46022   KANE        SHERYL   UNKNOWN   AZ
46026   FERGUS      SARAH    MUNCIE    IN
46027   BUCK        SARAH    MUNCIE    IN
$
</pre><p><span class="bodycopy">员工 46026 和 46027 没有住在亚利桑那州；但是他们的名字中包含所搜索的字符序列。切记，当在 AWK 中进行模式匹配时，例如 </span><tt>grep、sed</tt><span class="bodycopy"> 或者大部分其他 Linux/Unix 命令，将在记录（行）中的任何位置查找匹配，除非指定进行其他操作。为解决这一问题，必须将搜索与特定字段联系起来。通过利用代字号 (˜) 以及对特定字段的说明，可以达到这一目的，如下例所示：</span></p><pre>$ awk '$5 ˜ /AR/' emp_names
46019   BOGUE       ROBERT   PHOENIX   AZ
46021   JUNE        MICAH    PHOENIX   AZ
46022   KANE        SHERYL   UNKNOWN   AZ
$
</pre><p><span class="bodycopy">代字号（表示匹配）的对应符号是一个前面带有感叹号的代字号 (!˜)。这些字符通知程序，如果搜索序列没有出现在指定字段中，则找出与搜索序列相匹配的所有行：</span></p><pre>$ awk '$5 !˜ /AR/' names
46012   DULANEY     EVAN     MOBILE    AL
46013   DURHAM      JEFF     MOBILE    AL
46015   STEEN       BILL     MOBILE    AL
46017   FELDMAN     EVAN     MOBILE    AL
46018   SWIM        STEVE    UNKNOWN   AL
46024   WOOD        WILLIAM  MUNCIE    IN
46026   FERGUS      SARAH    MUNCIE    IN
46027   BUCK        SARAH    MUNCIE    IN
46029   TUTTLE      BOB      MUNCIE    IN
$
</pre><p><span class="bodycopy">在这种情况下，将显示第五个字段中没有 AR 的所有行 — 包括两个 Sarah 条目，这两个条目确实包含 AR，但却是在第三个字段而不是第五个字段中。</span></p><p><span class="parahead1">花括号和字段分隔符</span></p><p><span class="bodycopy">括号字符在 AWK 命令中起着很重要的作用。出现在括号之间的操作指出将要发生什么以及何时发生。当只使用一对括号时：</span></p><pre>{print $3,$2}
</pre><p><span class="bodycopy">括号间的所有操作同时发生。当使用多于一对的括号时：</span></p><pre>{print $3}{print $2}
</pre><p><span class="bodycopy">执行第一组命令，在该命令完成后执行第二组命令。注意以下两列清单的区别：</span></p><pre>$ awk '{print $3,$2}' names
EVAN DULANEY
JEFF DURHAM
BILL STEEN
EVAN FELDMAN
STEVE SWIM
ROBERT BOGUE
MICAH JUNE
SHERYL KANE
WILLIAM WOOD
SARAH FERGUS
SARAH BUCK
BOB TUTTLE
$

$ awk '{print $3}{print $2}' names
EVAN
DULANEY
JEFF
DURHAM
BILL
STEEN
EVAN
FELDMAN
STEVE
SWIM
ROBERT
BOGUE
MICAH
JUNE
SHERYL
KANE
WILLIAM
WOOD
SARAH
FERGUS
SARAH
BUCK
BOB
TUTTLE
$
</pre><p><span class="bodycopy">要利用多组括号进行重复查找，执行第一组中的命令直到完成为止；然后处理第二组命令。如果有第三组命令，则在第二组命令完成后执行它，以此类推。在所生成的打印输出中，有两个分隔的打印命令，因此先执行第一个命令，随后执行第二个命令，这样导致每个条目显示在两行而不是一行中。</span></p><p><span class="bodycopy">区分两个字段的字段分隔符不一定始终是空格；它可以是任何可识别的字符。为进行演示，假定 </span><tt>emp_names</tt><span class="bodycopy"> 文件利用冒号而不是制表符来分隔字段：</span></p><pre>$ cat emp_names
46012:DULANEY:EVAN:MOBILE:AL
46013:DURHAM:JEFF:MOBILE:AL
46015:STEEN:BILL:MOBILE:AL
46017:FELDMAN:EVAN:MOBILE:AL
46018:SWIM:STEVE:UNKNOWN:AL
46019:BOGUE:ROBERT:PHOENIX:AZ
46021:JUNE:MICAH:PHOENIX:AZ
46022:KANE:SHERYL:UNKNOWN:AR
46024:WOOD:WILLIAM:MUNCIE:IN
46026:FERGUS:SARAH:MUNCIE:IN
46027:BUCK:SARAH:MUNCIE:IN
46029:TUTTLE:BOB:MUNCIE:IN
$
</pre><p><span class="bodycopy">如果试图通过指定所需要的第二个字段来打印姓氏</span></p><pre>$ awk '{print $2}' emp_names
</pre><p><span class="bodycopy">您最后会得到十二个空行。因为文件中没有空格，除了第一个字段之外没有可认别的字段。为解决这一问题，必须通知 AWK 是空格之外的另一个字符作为分隔符，有两种方法可通知 AWK 使用新的字段分隔符：使用命令行参数 </span><tt>-F</tt><span class="bodycopy">，或在程序中指定变量 FS。两种方法的效果相同，只有一种例外情况，如下例所示：</span></p><pre>$ awk '{FS=":"}{print $2}' emp_names

DURHAM
STEEN
FELDMAN
SWIM
BOGUE
JUNE
KANE
WOOD
FERGUS
BUCK
TUTTLE
$

$ awk -F: '{print $2}' emp_names
DULANEY
DURHAM
STEEN
FELDMAN
SWIM
BOGUE
JUNE
KANE
WOOD
FERGUS
BUCK
TUTTLE
$
</pre><p><span class="bodycopy">在第一个命令中，头一条记录返回不正确的空行，而其他结果正确。直到读取第二条记录时，才识别字段分隔符并正确地执行。通过使用 </span><tt>BEGIN</tt><span class="bodycopy"> 语句可以纠正这一缺点（在后文详述）。</span><tt>-F</tt><span class="bodycopy"> 的功能非常类似于 </span><tt>BEGIN</tt><span class="bodycopy">，能够正确地读取第一条记录并按要求执行。</span></p><p><span class="bodycopy">在本文开始处我曾提到，默认的显示/输出字段分隔符是空格。通过使用输出字段分隔符 (</span><tt>OFS</tt><span class="bodycopy">) 变量，可以在程序中更改此特性。例如，要读取文件（由冒号分隔）并以短划线显示，则命令是</span></p><pre>$ awk -F":" '{OFS="-"}{print $1,$2,$3,$4,$5}' emp_names
46012-DULANEY-EVAN-MOBILE-AL
46013-DURHAM-JEFF-MOBILE-AL
46015-STEEN-BILL-MOBILE-AL
46017-FELDMAN-EVAN-MOBILE-AL
46018-SWIM-STEVE-UNKNOWN-AL
46019-BOGUE-ROBERT-PHOENIX-AZ
46021-JUNE-MICAH-PHOENIX-AZ
46022-KANE-SHERYL-UNKNOWN-AR
46024-WOOD-WILLIAM-MUNCIE-IN
46026-FERGUS-SARAH-MUNCIE-IN
46027-BUCK-SARAH-MUNCIE-IN
46029-TUTTLE-BOB-MUNCIE-IN
$
</pre><p><tt>FS </tt><span class="bodycopy"> 和 </span><tt>OFS</tt><span class="bodycopy"> 是（输入）字段分隔符和输出字段分隔符，它们只是一对可以在 AWK 实用工具中使用的变量。例如，要在打印时为每行编号，可以采用以下方式使用 </span><tt>NR</tt><span class="bodycopy"> 变量：</span></p><pre>$ awk -F":" '{print NR,$1,$2,$3}' emp_names
1 46012 DULANEY EVAN
2 46013 DURHAM JEFF
3 46015 STEEN BILL
4 46017 FELDMAN EVAN
5 46018 SWIM STEVE
6 46019 BOGUE ROBERT
7 46021 JUNE MICAH
8 46022 KANE SHERYL
9 46024 WOOD WILLIAM
10 46026 FERGUS SARAH
11 46027 BUCK SARAH
12 46029 TUTTLE BOB
$
</pre><p><span class="bodycopy">找出员工号码处于 46012 和 46015 之间的所有行：</span></p><pre>$ awk -F":" '/4601[2-5]/' emp_names
46012   DULANEY EVAN  MOBILE AL
46013   DURHAM  JEFF  MOBILE AL
46015   STEEN   BILL  MOBILE AL
$
</pre><p><span class="parahead1">添加文本</span></p><p><span class="bodycopy">可以按照添加控制序列或其他字符的相同方式将文本添加到显示中。例如，要将分隔符从空格改为冒号，则命令是</span></p><pre>awk '{print $1":"$2":"$3":"$4":"$5}' emp_names &gt; new_emp_names
</pre><p><span class="bodycopy">在这种情况下，字符 (</span><tt>:</tt><span class="bodycopy">) 包含在引号 (</span><tt>"/"</tt><span class="bodycopy">) 中，它被添加到每个字段之间。在引号之间的值可以是任何内容。例如，创建一个关于居住在阿拉巴马州的员工的外观类似数据库的显示：</span></p><pre>$ awk '$5 ~ /AL/ {print "NAME: "$2", "$3"\nCITY-STATE:
  "$4", "$5"\n"}' emp_names

NAME: DULANEY, EVAN
CITY-STATE: MOBILE, AL

NAME: DURHAM, JEFF
CITY-STATE: MOBILE, AL

NAME: STEEN, BILL
CITY-STATE: MOBILE, AL

NAME: FELDMAN, EVAN
CITY-STATE: MOBILE, AL

NAME: SWIM, STEVE
CITY-STATE: UNKNOWN, AL
$
</pre><p><span class="parahead1">数学操作</span></p><p><span class="bodycopy">AWK 除了提供文本功能，还提供全部范围的算术操作符，包括以下符号：</span></p><p><tt>+    </tt><span class="bodycopy">将数字相加</span>
 <tt>-    </tt><span class="bodycopy">减</span>
 <tt>*    </tt><span class="bodycopy">乘</span>
 <tt>/    </tt><span class="bodycopy">除</span>
 <tt>^    </tt><span class="bodycopy">执行指数运算</span>
 <tt>%    </tt><span class="bodycopy">提供模</span>
 <tt>++   </tt><span class="bodycopy">将变量值加一</span>
 <tt>+=   </tt><span class="bodycopy">将其他操作的结果分配给变量</span>
 <tt>— </tt><span class="bodycopy">将变量减一</span>
 <tt>-=   </tt><span class="bodycopy">将减法操作的结果分配给变量</span>
 <tt>*=   </tt><span class="bodycopy">分配乘法操作的结果</span>
 <tt>/=   </tt><span class="bodycopy">分配除法操作的结果</span>
 <tt>%=   </tt><span class="bodycopy">分配求模操作的结果</span></p><p><span class="bodycopy">例如，假定您的机器上存在以下的文件，详细地列出硬件商店中的物品：</span></p><pre>$ cat inventory
hammers 5       7.99
drills  2      29.99
punches 7       3.59
drifts  2       4.09
bits   55       1.19
saws  123      14.99
nails 800        .19
screws 80        .29
brads 100        .24
$
</pre><p><span class="bodycopy">第一项业务定单是通过将第二个字段（数量）的值乘以第三个字段（价格）的值，计算每种物品的库存价值：</span></p><pre>$ awk '{print $1,"QTY: "$2,"PRICE: "$3,"TOTAL: "$2*$3}' inventory
hammers QTY: 5 PRICE: 7.99 TOTAL: 39.95
drills QTY: 2 PRICE: 29.99 TOTAL: 59.98
punches QTY: 7 PRICE: 3.59 TOTAL: 25.13
drifts QTY: 2 PRICE: 4.09 TOTAL: 8.18
bits QTY: 55 PRICE: 1.19 TOTAL: 65.45
saws QTY: 123 PRICE: 14.99 TOTAL: 1843.77
nails QTY: 800 PRICE: .19 TOTAL: 152
screws QTY: 80 PRICE: .29 TOTAL: 23.2
brads QTY: 100 PRICE: .24 TOTAL: 24
$
</pre><p><span class="bodycopy">如果这些行本身并不重要，您只是希望确定商店中有多少件物品，则可以分配一个普通变量，按照每条记录中的物品数量增加：</span></p><pre>$ awk '{x=x+$2} {print x}' inventory
5
7
14
16
71
194
994
1074
1174
$
</pre><p><span class="bodycopy">根据这一数据，商店中有 1174 件物品。第一次执行时，变量 x 没有值，因此它采用第一行第二个字段的值。第二次执行时，它保留了第一行的值并加上第二行的值，以此类推，直到达到累计的总合。</span></p><p><span class="bodycopy">可以应用相同的过程来确定现有库存的总价值：</span></p><pre>$ awk '{x=x+($2*$3)} {print x}' inventory
39.95
99.93
125.06
133.24
198.69
2042.46
2194.46
2217.66
2241.66
$
</pre><p><span class="bodycopy">因此，1174 件物品的价值是 $2,241.66。虽然这一过程可以获得总计值，但它的外观很差，需要加工成实际的报表。利用一些附加项，很容易使显示变得更整洁：</span></p><pre>$ awk '{x=x+($2*$3)}{print $1,"QTY: "$2,"PRICE: "$3,"TOTAL: "$2*$3,"BAL: "x}' inventory
hammers QTY: 5 PRICE: 7.99 TOTAL: 39.95 BAL: 39.95
drills QTY: 2 PRICE: 29.99 TOTAL: 59.98 BAL: 99.93
punches QTY: 7 PRICE: 3.59 TOTAL: 25.13 BAL: 125.06
drifts QTY: 2 PRICE: 4.09 TOTAL: 8.18 BAL: 133.24
bits QTY: 55 PRICE: 1.19 TOTAL: 65.45 BAL: 198.69
saws QTY: 123 PRICE: 14.99 TOTAL: 1843.77 BAL: 2042.46
nails QTY: 800 PRICE: .19 TOTAL: 152 BAL: 2194.46
screws QTY: 80 PRICE: .29 TOTAL: 23.2 BAL: 2217.66
brads QTY: 100 PRICE: .24 TOTAL: 24 BAL: 2241.66
$
</pre><p><span class="bodycopy">该过程提供了每条记录的清单，同时将总价值分配给库存值，并保持商店资产的运作平衡。</span></p><p><tt><strong>BEGIN</strong></tt><span class="bodycopy"> 和 </span><tt><strong>END</strong></tt></p><p><span class="bodycopy">使用 </span><tt>BEGIN</tt><span class="bodycopy"> 和 </span><tt>END</tt><span class="bodycopy"> 语句可以分别指定在处理实际开始之前或者完成之后进行操作。</span><tt>BEGIN</tt><span class="bodycopy"> 语句最常用于建立变量或显示标题。另一方面，</span><tt>END</tt><span class="bodycopy"> 语句可用于在程序结束后继续进行处理。</span></p><p><span class="bodycopy">在前面的示例中，利用以下例程生成了物品的总价值：</span></p><pre>awk '{x=x+($2*$3)} {print x}' inventory
</pre><p><span class="bodycopy">该例程在运行总计累加时显示了文件中的每一行。没有其他方法可以指定它，而不让在每一行进行打印也导致它始终不打印出来。但是，利用 </span><tt>END</tt><span class="bodycopy"> 语句可以避免这一问题：</span></p><pre>$ awk '{x=x+($2*$3)} END {print "Total Value of Inventory:"x}' inventory
Total Value of Inventory: 2241.66
$
</pre><p><span class="bodycopy">定义了变量 </span><tt><em>x</em></tt><span class="bodycopy">，它对每一行进行处理；但是，在所有处理完成之前不会生成显示。尽管可以作为独立例程使用，它也可以置入到先前的代码列表，添加更多信息并生成更完整的报表：</span></p><pre>$ awk '{x=x+($2*$3)} {print $1,"QTY: "$2,"PRICE: 
    "$3,"TOTAL: "$2*$3} END {print "Total Value of Inventory: " x}' inventory

hammers QTY: 5 PRICE: 7.99 TOTAL: 39.95
drills QTY: 2 PRICE: 29.99 TOTAL: 59.98
punches QTY: 7 PRICE: 3.59 TOTAL: 25.13
drifts QTY: 2 PRICE: 4.09 TOTAL: 8.18
bits QTY: 55 PRICE: 1.19 TOTAL: 65.45
saws QTY: 123 PRICE: 14.99 TOTAL: 1843.77
nails QTY: 800 PRICE: .19 TOTAL: 152
screws QTY: 80 PRICE: .29 TOTAL: 23.2
brads QTY: 100 PRICE: .24 TOTAL: 24
Total Value of Inventory: 2241.66
$
</pre><p><span class="bodycopy"></span><tt>BEGIN</tt><span class="bodycopy"> 命令与 </span><tt>END</tt><span class="bodycopy"> 的工作方式相同，但它建立了那些需要在完成其他工作之前所做的项目。该过程最常见的目的是创建报表的标题。此例程的语法类似于</span></p><pre>$ awk 'BEGIN {print "ITEM   QUANTITY   PRICE   TOTAL"}'
</pre><p><span class="parahead1">输入、输出和源文件</span></p><p><span class="bodycopy">AWK 工具可以从文件中读取其输入，正如在此之前所有示例所做的那样，它也可以从其他命令的输出中获取输入。例如：</span></p><pre>$ sort emp_names | awk '{print $3,$2}'
</pre><p><span class="bodycopy"></span><tt>awk</tt><span class="bodycopy"> 命令的输入是排序操作的输出。除了 </span><tt>sort</tt><span class="bodycopy">，还可以使用任何其他的 Linux 命令 — 例如 </span><tt>grep</tt><span class="bodycopy">。该过程允许您在离开所选定字段前对文件执行其他操作。</span></p><p><span class="bodycopy">类似于解释程序，AWK 使用输出改向操作符 </span><tt>&gt;</tt><span class="bodycopy"> 和 </span><tt>&gt;&gt;</tt><span class="bodycopy"> 将其输出放入文件中而不是标准输出设备。这些符号的作用类似于它们在解释程序中的对应符号，因此 </span><tt>&gt;</tt><span class="bodycopy"> 在不存在文件时创建文件，而 </span><tt>&gt;&gt;</tt><span class="bodycopy"> 追加到现有文件的尾部。请看以下的示例：</span></p><pre>$ awk '{print NR, $1 ) &gt; "/tmp/filez" }' emp_names
$ cat /tmp/filez
1	46012
2	46013
3	46015
4	46017
5	46018
6	46019
7	46021
8	46022
9	46024
10	46026
11	46027
12	46029
$
</pre><p><span class="bodycopy">检查该语句的语法，您会看到输出改向是在打印语句完成后进行的。必须将文件名包含在引号中，否则它只是一个未初始化的 AWK 变量，而将指令联接起来会在 AWK 中产生错误。（如果不正确地使用改向符号，则 AWK无法了解该符号意味着“改向”还是一个关系操作符。）</span></p><p><span class="bodycopy">在 AWK 中输出到管道也类似于解释程序中所实现的相同操作。要将打印命令的输出发送到管道中，可以在打印命令后附加管道符号以及命令的名称，如下所示：</span></p><pre>$ awk '{ print $2 | "sort" }' emp_names
BOGUE
BUCK
DULANEY
DURHAM
FELDMAN
FERGUS
JUNE
KANE
STEEN
SWIM
TUTTLE
WOOD
$
</pre><p><span class="bodycopy">这是输出改向的情况，必须将命令包含在引号中，而管道的名称是被执行命令的名称。</span></p><p><span class="bodycopy">AWK 所使用的命令可以来自两个地方。首先，可以在命令行中指定它们，如示例中所示。其次，它们可以由源文件提供。如果是这种情况，通过 </span><tt>-f</tt><span class="bodycopy"> 选项将这种情况向 AWK 发出警告。演示如下：</span></p><pre>$ cat awklist
{print $3,$2}
{print $4,$5,"\n"}
$

$ awk -f awklist emp_names
EVAN DULANEY
MOBILE AL

JEFF DURHAM
MOBILE AL

BILL STEEN
MOBILE AL

EVAN FELDMAN
MOBILE AL

STEVE SWIM
UNKNOWN AL

ROBERT BOGUE
PHOENIX AZ

MICAH JUNE
PHOENIX AZ

SHERYL KANE
UNKNOWN AR

WILLIAM WOOD
MUNCIE IN

SARAH FERGUS
MUNCIE IN

SARAH BUCK
MUNCIE IN

BOB TUTTLE
MUNCIE IN

$
</pre><p><span class="bodycopy">注意，在源文件中的任何地方或者在命令行中调用它时，不使用单引号。单引号只用于区别命令行中的命令与文件名称。</span></p><p><span class="bodycopy">如果简单的输出不能处理您的程序中所需要的复杂信息，则可以尝试由 </span><tt>printf</tt><span class="bodycopy"> 命令获得的更加复杂的输出，其语法是</span></p><pre>printf( format, value, value ...)
</pre><p><span class="bodycopy">该语法类似于 C 语言中的 </span><tt>printf</tt><span class="bodycopy"> 命令，而格式的规格是相同的。通过插入一项定义如何打印数值的规格，可以定义该格式。格式规格包含一个跟有字母的 %。类似于打印命令，</span><tt>printf</tt><span class="bodycopy"> 不必包含在圆括号中，但是可以认为使用圆括号是一种良好的习惯。</span></p><p><span class="bodycopy">下表列出 </span><tt>printf</tt><span class="bodycopy"> 命令提供的各种规格。</span></p><table align="left" bgcolor="#ffffff" border="0" cellpadding="5" hspace="5" vspace="5" width="100%"><tbody><tr><td width="15%"><span class="boldbodycopy">规格</span></td><td width="85%"><span class="boldbodycopy">说明</span></td></tr><tr><td><tt>%c</tt></td><td><span class="bodycopy">打印单个 ASCII 字符</span></td></tr><tr><td><tt>%d</tt></td><td><span class="bodycopy">打印十进制数</span></td></tr><tr><td><tt>%e</tt></td><td><span class="bodycopy">打印数字的科学计数表示</span></td></tr>		                                                             <tr><td><tt>%f</tt></td><td><span class="bodycopy">打印浮点表示</span></td></tr><tr><td><tt>%g</tt></td><td><span class="bodycopy">打印 %e 或 %f；两种方式都更简短</span></td></tr><tr><td><tt>%o</tt></td><td><span class="bodycopy">打印无符号的八进制数</span></td></tr><tr><td><tt>s</tt></td><td><span class="bodycopy">打印 ASCII 字符串</span></td></tr><tr><td><tt>%x</tt></td><td><span class="bodycopy">打印无符号的十六进制数</span></td></tr><tr><td><tt>%%</tt></td><td><span class="bodycopy">打印百分号；不执行转换</span></td></tr></tbody></table>
<p><span class="bodycopy">可以在 % 与字符之间提供某些附加的格式化参数。这些参数进一步改进数值的打印方式：</span></p><table align="left" bgcolor="#ffffff" border="0" cellpadding="5" hspace="5" vspace="5" width="100%"><tbody><tr><td width="25%"><span class="boldbodycopy">参数</span></td><td width="75%"><span class="boldbodycopy">说明</span></td></tr><tr><td><tt>-</tt></td><td><span class="bodycopy">将字段中的表达式向左对齐</span></td></tr><tr><td><tt>,width</tt></td><td><span class="bodycopy">根据需要将字段补齐到指定宽度（前导零使用零将字段补齐） </span></td></tr><tr><td><tt>.prec</tt></td><td><span class="bodycopy">小数点右面数字的最大字符串宽度或最大数量</span></td></tr></tbody></table><p><span class="bodycopy"></span><tt>printf</tt><span class="bodycopy"> 命令能够控制并将数值从一种格式转换为另一种格式。当需要打印变量的值时，只需提供一种规格，指示 </span><tt>printf</tt><span class="bodycopy"> 如何打印信息（通常包含在双引号中）即可。必须为每个传递到 </span><tt>printf</tt><span class="bodycopy"> 的变量包含一个规格参数；如果包含过少的参数，则 </span><tt>printf</tt><span class="bodycopy"> 不会打印所有的数值。</span></p><p><span class="parahead1">处理错误</span></p><p><span class="bodycopy">AWK 工具报告所发生错误的方式很令人恼火。一个错误会阻碍任何操作的进行，所提供的错误信息非常含混不清：</span></p><pre>awk: syntax error near line 2
awk: bailing out near line 2
</pre><p><span class="bodycopy">您可能会花几小时的时间查看第 2 行，试图找出它为什么阻碍程序运行；这就是支持使用源文件的一个有力论据。</span></p>
<p><span class="bodycopy">切记有两条规则可以帮助您避免出现语法错误：</span></p><p><span class="bodycopy">1. 确保命令位于括号中，而括号位于单引号中。没有使用这些字符之一必然导致程序无法运行。</span></p><p><span class="bodycopy">2. 搜索命令需要位于斜线之间。要找出住在印第安那州的员工，您必须使用“</span><tt>/IN/</tt><span class="bodycopy">”而不是“</span><tt>IN</tt><span class="bodycopy">”。</span></p><p><span class="parahead1">结论</span></p><p><span class="bodycopy">尽管 AWK 完全代表另外的含意，但它应该是管理员智能工具包的首字母缩写。连同 SED一起，AWK 实用工具是 Linux管理员所拥有的功能最强大和灵活的工具之一。通过了解其语言的一些特性，您可以开辟出能够简化任务的领域，否则这些任务将会是非常费时和困难的。 </span></p>
</span></p>
</div>

<div class="meta">
	
		<span class="comments"><a href="about-awk/index.html#disqus_thread">Comments</a></span>
	
</div>
</article>

	<div class="share">
	<div class="addthis_toolbox addthis_default_style ">
	
	
	<a class="addthis_button_tweet"></a>
	
	
	<a class="addthis_counter addthis_pill_style"></a>
	</div>
  <script type="text/javascript" src="http://s7.addthis.com/js/250/addthis_widget.js#pubid=null"></script>
</div>





    
      <script type="text/javascript">
        var disqus_config = function () {
            this.page.url = 'about-awk/';
            this.page.identifier = 'about-awk/';
        };

        (function() {
          var d = document, s = d.createElement('script');
          s.src = '//wdicc.disqus.com/embed.js';
          s.setAttribute('data-timestamp', +new Date());
          (d.head || d.body).appendChild(s);
        })();
      </script>
    


<section id="comment">
    <h2 class="title">Comments</h2>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
</section>


    </div>
    <footer id="footer">
    <div style="display:inline">
    Copyright &copy; 2016

    wd
. Powered by <a href="http://zespia.tw/hexo/" target="_blank">Hexo</a> |
    Theme is <a href="https://github.com/wd/hexo-fabric">hexo-fabric</a>, fork from <a href="http://github.com/panks/fabric">fabric</a> by <a href="http://panks.me">Pankaj Kumar</a>
</div>


    </footer>
    <script src="/javascripts/fabric.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script>
 <!-- Delete or comment this line to disable Fancybox -->



<!-- end toload --> 
</div>
</div>
<script src="/javascripts/jquery.ui.totop.js" type="text/javascript"></script>
<script type="text/javascript">
/*<![CDATA[*/
;(function($){$().UItoTop({easingType:'easeOutCirc'});})(jQuery); 
/*]]>*/
</script><!-- remove it to remove the scroll to top button -->
</body>
</html>
