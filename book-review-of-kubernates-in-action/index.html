<!doctype html><html lang=zh-CN><head><link rel=preload href=/lib/font-awesome/webfonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/lib/font-awesome/webfonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/lib/font-awesome/webfonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/lib/JetBrainsMono/web/woff2/JetBrainsMono-Regular.woff2 as=font type=font/woff2 crossorigin=anonymous><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Book Review of Kubernates in Action | wd and cc</title>
<link rel=canonical href=https://wdicc.com/book-review-of-kubernates-in-action/><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="all,follow"><meta name=googlebot content="index,follow,snippet,archive"><meta property="og:title" content="Book Review of Kubernates in Action"><meta property="og:description" content="这几天看了一下 Kubernates in action 这本书，看的是中文版本。把自己觉得有用的记录一下。 怎么决定一个 pod 里面包含多少容器"><meta property="og:type" content="article"><meta property="og:url" content="https://wdicc.com/book-review-of-kubernates-in-action/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-03-05T16:02:50+08:00"><meta property="article:modified_time" content="2020-03-05T16:02:50+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Book Review of Kubernates in Action"><meta name=twitter:description content="这几天看了一下 Kubernates in action 这本书，看的是中文版本。把自己觉得有用的记录一下。 怎么决定一个 pod 里面包含多少容器"><link rel=stylesheet href=https://wdicc.com/css/styles.94f653e9e151e28067a7c5dbbc4600cbd5a3c721e79faaf971e523c40f3b249b8e4f20bb57810dfffa8d559ca5c140fd56eb4cd9c0853113ad08e66afdb08bdd.css integrity="sha512-lPZT6eFR4oBnp8XbvEYAy9WjxyHnn6r5ceUjxA87JJuOTyC7V4EN//qNVZylwUD9VutM2cCFMROtCOZq/bCL3Q=="><link rel=stylesheet href=https://wdicc.com/wdicc.css><!--[if lt IE 9]><script src=https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js></script><script src=https://oss.maxcdn.com/respond/1.4.2/respond.min.js></script><![endif]--><link rel=icon type=image/png href=https://wdicc.com/favicon.ico></head><body class="max-width mx-auto px3 ltr"><div class="content index py4"><div id=header-post><a id=menu-icon href=#><i class="fas fa-bars fa-lg"></i></a>
<a id=menu-icon-tablet href=#><i class="fas fa-bars fa-lg"></i></a>
<a id=top-icon-tablet href=# onclick='$("html, body").animate({scrollTop:0},"fast")' style=display:none aria-label="Top of Page"><i class="fas fa-chevron-up fa-lg"></i></a>
<span id=menu><span id=nav><ul><li><a href=/>Home</a></li><li><a href=/posts>Posts</a></li><li><a href=/tags>Tags</a></li><li><a href="https://www.google.com.hk/search?sitesearch=https%3A%2F%2Fwdicc.com%2F&amp;q=">Search</a></li><li><a href=/atom.xml>Subscribe</a></li></ul></span><br><span id=actions><ul><li><a class=icon href=https://wdicc.com/interview-is-a-two-way-choise/ aria-label=Previous><i class="fas fa-chevron-left" aria-hidden=true onmouseover='$("#i-prev").toggle()' onmouseout='$("#i-prev").toggle()'></i></a></li><li><a class=icon href=https://wdicc.com/dont-need-kubernates/ aria-label=Next><i class="fas fa-chevron-right" aria-hidden=true onmouseover='$("#i-next").toggle()' onmouseout='$("#i-next").toggle()'></i></a></li><li><a class=icon href=# onclick='$("html, body").animate({scrollTop:0},"fast")' aria-label="Top of Page"><i class="fas fa-chevron-up" aria-hidden=true onmouseover='$("#i-top").toggle()' onmouseout='$("#i-top").toggle()'></i></a></li><li><a class=icon href=# aria-label=Share><i class="fas fa-share-alt" aria-hidden=true onmouseover='$("#i-share").toggle()' onmouseout='$("#i-share").toggle()' onclick='return $("#share").toggle(),!1'></i></a></li></ul><span id=i-prev class=info style=display:none>Previous post</span>
<span id=i-next class=info style=display:none>Next post</span>
<span id=i-top class=info style=display:none>Back to top</span>
<span id=i-share class=info style=display:none>Share post</span></span><br><div id=share style=display:none><ul><li><a class=icon href="http://www.facebook.com/sharer.php?u=https%3a%2f%2fwdicc.com%2fbook-review-of-kubernates-in-action%2f" aria-label=Facebook><i class="fab fa-facebook" aria-hidden=true></i></a></li><li><a class=icon href="https://twitter.com/share?url=https%3a%2f%2fwdicc.com%2fbook-review-of-kubernates-in-action%2f&text=Book%20Review%20of%20Kubernates%20in%20Action" aria-label=Twitter><i class="fab fa-twitter" aria-hidden=true></i></a></li><li><a class=icon href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2fwdicc.com%2fbook-review-of-kubernates-in-action%2f&title=Book%20Review%20of%20Kubernates%20in%20Action" aria-label=Linkedin><i class="fab fa-linkedin" aria-hidden=true></i></a></li><li><a class=icon href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2fwdicc.com%2fbook-review-of-kubernates-in-action%2f&is_video=false&description=Book%20Review%20of%20Kubernates%20in%20Action" aria-label=Pinterest><i class="fab fa-pinterest" aria-hidden=true></i></a></li><li><a class=icon href="mailto:?subject=Book%20Review%20of%20Kubernates%20in%20Action&body=Check out this article: https%3a%2f%2fwdicc.com%2fbook-review-of-kubernates-in-action%2f" aria-label=Email><i class="fas fa-envelope" aria-hidden=true></i></a></li><li><a class=icon href="https://getpocket.com/save?url=https%3a%2f%2fwdicc.com%2fbook-review-of-kubernates-in-action%2f&title=Book%20Review%20of%20Kubernates%20in%20Action" aria-label=Pocket><i class="fab fa-get-pocket" aria-hidden=true></i></a></li><li><a class=icon href="http://reddit.com/submit?url=https%3a%2f%2fwdicc.com%2fbook-review-of-kubernates-in-action%2f&title=Book%20Review%20of%20Kubernates%20in%20Action" aria-label=reddit><i class="fab fa-reddit" aria-hidden=true></i></a></li><li><a class=icon href="http://www.tumblr.com/share/link?url=https%3a%2f%2fwdicc.com%2fbook-review-of-kubernates-in-action%2f&name=Book%20Review%20of%20Kubernates%20in%20Action&description=%e8%bf%99%e5%87%a0%e5%a4%a9%e7%9c%8b%e4%ba%86%e4%b8%80%e4%b8%8b%20Kubernates%20in%20action%20%e8%bf%99%e6%9c%ac%e4%b9%a6%ef%bc%8c%e7%9c%8b%e7%9a%84%e6%98%af%e4%b8%ad%e6%96%87%e7%89%88%e6%9c%ac%e3%80%82%e6%8a%8a%e8%87%aa%e5%b7%b1%e8%a7%89%e5%be%97%e6%9c%89%e7%94%a8%e7%9a%84%e8%ae%b0%e5%bd%95%e4%b8%80%e4%b8%8b%e3%80%82%20%e6%80%8e%e4%b9%88%e5%86%b3%e5%ae%9a%e4%b8%80%e4%b8%aa%20pod%20%e9%87%8c%e9%9d%a2%e5%8c%85%e5%90%ab%e5%a4%9a%e5%b0%91%e5%ae%b9%e5%99%a8" aria-label=Tumblr><i class="fab fa-tumblr" aria-hidden=true></i></a></li><li><a class=icon href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2fwdicc.com%2fbook-review-of-kubernates-in-action%2f&t=Book%20Review%20of%20Kubernates%20in%20Action" aria-label="Hacker News"><i class="fab fa-hacker-news" aria-hidden=true></i></a></li></ul></div></span></div><article class=post itemscope itemtype=http://schema.org/BlogPosting><header><h1 class=posttitle itemprop="name headline">Book Review of Kubernates in Action</h1><div class=meta><span class=author itemprop=author itemscope itemtype=http://schema.org/Person><span itemprop=name>wd</span></span><div class=postdate><time datetime="2020-03-05 16:02:50 +0800 +0800" itemprop=datePublished>2020-03-05</time></div><div class=article-tag><i class="fas fa-tag"></i>
<a class=tag-link href=/tags/kubernates rel=tag>kubernates</a></div></div></header><div id=toc></div><div class=content itemprop=articleBody><p>这几天看了一下 Kubernates in action 这本书，看的是中文版本。把自己觉得有用的记录一下。</p><blockquote><p>怎么决定一个 pod 里面包含多少容器？基本上更倾向于分开。</p><ol><li>它们必须要一起运行还是可以在不同主机运行？</li><li>他们代表的是一个整体还是相互独立的组件？</li><li>他们必须一起进行扩缩容还是可以分别进行？</li></ol></blockquote><blockquote><p>pod 定义中的端口是展示性的，有没有设置不影响是否可以被连接，明确定义的 pod 端口可以方便查看，另外为端口命名还可以方便引用。</p></blockquote><blockquote><p>可以使用 kubectl explain pod.spec 查看具体字段的定义</p></blockquote><blockquote><p>可以使用 kubectl port-forward kubi-manual 8888:8080 把本地 8888 的请求转发到对应的 kubi-manual pod 里面。</p></blockquote><blockquote><p>使用标签组织 pod 可以方便的管理。</p><ol><li>app：指定 pod 属于哪个应用，组件，或者微服务。</li><li>rel：指定 pod 中运行的程序是版本是 stable，beta，canary。</li></ol><p>可以在 pod.yaml 文件中指定 label，也可以使用 kubectl label po kubia-manual rel=stable 增加标签。更改现有标签，需要使用 –overwrite 参数。</p></blockquote><p>TODO：命令行指定标签之后，如果再次 apply 那个 yaml 会出现什么情况？</p><blockquote><p>可以使用 kubectl label node worker1 gpu=true 给 node 打标签。</p></blockquote><blockquote><p>可以使用 nodeSelector 指定调度到符合条件的 node 上面。node 有一个 kubernates.io/hostname 标签是 node 的 hostname。</p></blockquote><blockquote><p>在使用多个 ns 的前提下，我们可以将包含大量组件的复杂系统拆分为更小的不同组，这些不同组也可以用于在多租户环境中分配资源，将资源分配为生产、开发和 QA 环境，或者以其他任何你需要的方式分配资源。资源名称只需要在命名空间内唯一即可，因此两个不同的命名空间可以包含同名的资源。</p><p>命名空间还可以用于允许某些用户访问某些特定资源，甚至限制单个用户可用的计算资源数量。</p><p>alias kcd=`kubectl config set-context $(kubectl cofig current-context) –namespace`</p><p>然后使用 kcd some-namespace 来切换。</p><p>命名空间之间是否网络隔离取决于 kubernates 使用的网络解决方案。</p></blockquote><blockquote><p>pod 的两个 probe 探针很重要</p><ol><li>readiness: 就绪探针，用来表示 pod 已经可以接受请求了。</li><li>liveness: 存活探针，用来表示 pod 是不是还在正常工作。有几个属性需要注意：delay 容器启动之后等多久开始监测，timeout 监测超时，period 周期。</li></ol><p>一个 pod 重新部署之后，可以通过 kubectl logs mypod –previous 看前一个 pod 的日志。</p><p>对于 liveness probe，一定要检查程序内部，而没有任何外部因素的影响。例如，当服务器无法连接到后端数据库的时候，前端 web 服务器的存活探针不应该返回失败。如果问题的底层原因在数据库中，重启 web 服务器容器不会解决任何问题，由于重启之后探针会继续失败，web 容器将被反复重启。同时保持探针轻量，无需在探针里面重试。</p></blockquote><blockquote><p>一个 RC(replicationController) 有三个主要部分</p><ol><li>label selector：选择 pod</li><li>replica count：有几个副本</li><li>pod template：pod 定义</li></ol><p>如果某个 pod 发生了故障，可以将它从 rc 的管理范围里面移除（例如通过修改 label，增加一个 enable=true 选项），让控制器替换为新的 pod，这个旧的 pod 就任你处置了，用完后删除就可以了。</p></blockquote><p>TODO：测试一下通过修改 label 从 rc，rs，deploy 里面移除 pod。</p><blockquote><p>KUBE_EDITOR 环境变量用来指定执行 kubectl edit 命令的时候使用的编辑器，如果没设置，会使用 EDITOR 环境变量。</p></blockquote><blockquote><p>使用 kubectl delete rc 删除 rc 的时候，可以使用 –cascade=false 来保留 pod 继续运行。</p></blockquote><blockquote><p>节点可以被设置为不可以调度，防止 pod 被部署到节点。但是 DeamonSet 甚至会将 pod 部署到这些节点，因为无法调度的属性只会被调度器使用，DeaemonSet 管理的 pod 则完全绕过调度器。这是符合预期的，因为 DaemonSet 的目的是运行系统服务，即使在不可调度的节点上，系统服务通常也是需要运行的。</p></blockquote><blockquote><p>job 的 restartPolicy 只能是 OnFailure 或者 Never，不能是 Always。</p><p>可以通过 completions 和 parallelism 指定需要运行的总数和同时运行的数量。</p></blockquote><blockquote><p>service 允许通过 sessionAffinity 来指定会话亲和性。可选值有 None 和 ClientIP。因为 service 不是工作在 http 层面，所以不能基于 cookie 来做。</p><p>前面提到的 pod 模版里面给端口命名的格式在 service 里面有用了，可以通过端口名称引用定义的端口，这样好处是即使更换端口号也无需更改服务 spec。</p><p>当前端 pod 需要访问后端数据库服务 pod 时，可以通过名为 backend-database 的 service 将后端 pod 暴露出来</p><ol><li>前端 pod 可以通过环境变量去获取服务的 IP 地址和端口。</li><li>通过 FQDN 连接，backend-database.default.svc.cluster.local 。</li></ol></blockquote><p>也可以使用 static service 包装外部资源（比如和其他公司合作，对方提供的服务）</p><ol><li>只有ip：自定义 endpoint 指向外部 ip。</li><li>域名：通过 service.spec.externalName 新建一个 cname。</li></ol><p>这样例如以后有需要的时候，可以把外部服务迁移到内部，而内部代码不用做任何改变。（似乎有点蛋疼。。。可能只有当服务够多的时候有意义吧，例如如果有 10 个服务使用到了这个 service 。。）</p><p>一般情况下，node 上面会通过 iptables 把对 service 的请求随机转发到 pod 上面。把 externalTrafficPolicy 字段设置为 Local 可以避免多余的转发，只会到本地的 pod。这样会带来一些问题，没有 pod 的机器上面将不能访问通，负载将可能不再均衡，例如一个机器上面有多个 pod 的时候。</p><p>TODO: 对于 headless 服务，没有 clusterIP，可以通过域名访问，那么对于有 clusterIP 的，是不是也可以通过域名访问？</p><p>需要测试网络的时候，可以使用 tutum/dnsutils 容器，里面包括了 nslookup 和 dig。</p><p>设置 emptyDir 的属性 midium: Memory 可以建立内存文件系统。可以使用 gitRepo 建立 gitrepo 类型的 vol，会自动获取代码，私有服务需要配置对应的凭证（imagePullSecrets）。</p><p>可以使用 sidecar 容器配合主容器做一些事情，例如自动同步更新 git 代码，建立访问 API 的代理等。</p><p>TODO: 可以使用 awsElasticBlockStore 创建 aws 的磁盘挂载，需要测试一下例如新建删除是如何管理的，通过什么来识别的。</p><p>PV 持久卷可以设置 accessModes 例如 ReadWriteOnce, readOnlyMany 等，可以设置 persistentVolumeReclaimPolicy 为 Retain 保留数据。</p><p>PV 需要提前声明，才能被 PVC 使用。在云服务里面，可以事先定义 StorageClass 来提供给 PVC 使用，定义好 provisioner 提供商即可。</p><p>Dockerfile 里面 ENTRYPOINT 的两种形式，区别在于 pid 1 的进程是什么，1 是 /bin/sh。</p><ol><li>shell 形式：ENTRYPOINT node app.js</li><li>exec 形式：ENTRYPOINT ["node", "app.js"]</li></ol><p>Dockerfile 里面的配置和 kubernates 里面的对应：</p><ol><li>ENTRYPOINT: command 可执行文件</li><li>CMD: args 传递的参数，参数里面字符串不用引号，数值需要引号。</li></ol><p>ConfigMap 数据可以通过环境变量或者卷文件的形式传递给容器。</p><ol><li>–from-file=bar=foobar.conf：bar 的值为文件内容</li><li>–from-file=foo.json：相当于 –from-file=foo.json=foo.json</li><li>–from-file-config-opts/：config-opts 目录里面的每个文件都会用文件名和文件内容创建键值对。</li><li>–from-literal=some=thing：创建 some=thing</li></ol><p>把 ConfigMap 引入环境变量:</p><ol><li>通过 spec.containers.env.valueFrom.configMapKeyRef.{name,key} 引用名为 name 的 configmap 里面的 key。设置 configMapKeyRef.optional: true 可以设置为可选。</li><li>通过 spec.containers.envFrom.prefix: pre_ 设置引入所有 pre_ 开头的变量。</li><li>如果 ConfigMap 里面有键名格式不正确，创建环境变量的时候会被忽略而不会报错。例如 CONFIG_FOO-BAR 这样的。</li></ol><p>可以使用 volumeMounts.subPath 只挂载部分卷而不是全部的，例如只挂载里面某个文件，某个子目录。</p><ol><li>这样有一个问题，据说是这么挂载的时候，更新 ConfigMap 不会更新文件。TODO: 检查是不是这样的。</li></ol><p>通过 defaultMode 可以改变挂载属性。</p><p>ConfigMap 更新之后，卷会自动更新，但是卷对应的文件更新可能会花一些时间（例如数分钟）。</p><ol><li>文件更新之后需要你的程序重新读入才能真正产生影响。</li><li>如果不支持自动读入，那可能会导致新建的 pod 用的是新的 ConfigMap，旧的依然用的是旧的。</li><li>并且自动更新在各个 pod 出现的时间也有区别，可能会有先后。</li></ol><p>Secret 和 ConfigMap 类似，也可以使用环境变量或者卷的形式传递给 pod。Secret 只会存在于内存中。</p><ol><li>采用 ConfigMap 存储非敏感的文本配置数据。</li><li>采用 Secret 存储天生敏感的数据，如果配置文件同时存在敏感和不敏感的，那应该用 Secret。</li></ol><p>可以使用 Downward API 获取 pod 的元信息。</p><ol><li>pod 名称</li><li>pod ip</li><li>pod 所在的 ns</li><li>pod 运行的 node 名称</li><li>pod 运行的所属账户的名称</li><li>每个容器请求的 CPU 和内存的使用量</li><li>每个容器可以使用的 CPU 和内存的限制</li><li>pod 的标签</li><li>pod 的注解</li></ol><p>可以通过 spec.containters.env.valueFrom.fieldRef.fieldPath: metadata.name 引用 metadata 的数据。也可以使用 Downward API 卷获取这些数据。</p><p>还可以通过和 API 服务交互获取数据，token 卷会自动 mount 到 pod 里面，也可以通过一个 kubectl proxy sidecar 容器来转发。</p><p>Docker image 的 tag 是版本号，需要能保证某个 tag 固定指向某个 image 版本，最好不要覆盖已经发布的 tag 对应的 image，否则容易出现不一致的情况。对于 latest（或者不指定） tag，imagePullPolicy 默认是 Always，如果指定来其他 tag，默认策略是 IfNotPresent。</p><p>可以使用 kubectl rolling-update kubia-v1 kubia-v2 –image-luksa/kubia:v2 来升级 RC replicationcontroller。执行的时候，会创建一个 kubia-v2 的 rc，然后通过给 rc 和 pod 增加 label 并通过修改 replicas 数量逐渐用新的代替旧的。执行升级过程中，如果 kubectl 失去网络，可能会导致 rc 和 pod 处于中间状态。</p><blockquote><p>使用 Deployment 的时候，实际的 pod 是由 Deployment 和 ReplicaSet 共同管理的。</p><p>Deployment 升级的时候，只需要修改 deploy 的定义即可。升级有两种策略</p><ol><li>Recreate：旧的全部删除之后才开始创建新的。</li><li>RollingUpdate：渐进式替代，升级过程中会有新旧版本共存状态。</li></ol><p>使用 spec.minReadySeconds 指定新 pod 最小存活时间。</p><p>使用 kubectl set image deployment kubia nodejs=luksa/kubia:v2 修改为新版本的 image 进行升级。</p></blockquote><p>TODO: 可以通过 kubectl 命令直接操作修改，也可以通过 yaml 方式修改，那么如何保证双方状态一致？要不下次执行 yaml 的时候可能会把一些 kubectl 的操作回滚。</p><blockquote><p>更改 ConfigMap 资源不会触发升级操作，如果需要通过修改配置触发更新，那可以新建一个新的 ConfigMap，然后修改 pod 模版使用这个新的。</p><p>使用 kubectl rollout undo deployment kubia 可以回滚到上一个版本。</p><p>undo 命令也可以在滚动升级过程中执行，并直接停止滚动升级。升级过程中创建的新的 pod 会被删除并被老版本替代。</p><p>使用 kubectl rollout history deployment kubia 可以查看旧版本。使用 –to-revision=1 可以回滚到特定版本。创建 deploy 时使用 –record 记录 CHANGE-CAUSE。</p><p>不应该手动删除 ReplicaSet，如果这么做可能会丢失 Deploy 的历史版本记录而导致无法回滚。</p><p>revisionHistoryLimit 属性可以限制历史版本数量。</p><p>使用 kubectl rollout status 可以查看升级过程。</p><p>使用 maxSurge 和 maxUnavailable 控制升级的速度。</p><p>使用 kubectl rollout pause deployment kubia 可以暂停升级，这个时候可以做金丝雀测试。使用 kubectl rollout resume deploy kubia 恢复。</p><p>默认情况下，如果 10 分钟内不能完成升级会被视为失败。可以设置 spec.progressDeadlineSeconds 来设置这个时间。</p></blockquote><blockquote><p>StatefulSet 最初被叫做 PetSet，因为 pet 是有名字的。。。。无状态的类似牛，都没名字。。</p><p>StatefulSet 做缩容一次只会操作一个节点，在有实例不健康的情况下是不允许做缩容操作的。</p><p>Kubernates 必须保证两个拥有相同标记和绑定相同持久卷声明的有状态的 pod 实例不会同时。一个 StatefulSet 必须保证有状态的 pod 实例的 at-most-one 语义。也就是说一个 StatefulSet 必须在准确确认一个 pod 不在运行后，才会去创建它的替换 pod。</p></blockquote><p>yaml 文件里面可以使用 — 来区分多个资源，也可以使用 kind: List 创建多个资源。</p><p>StatefulSet 里面，每个节点挂载的数据卷有两个方式实现：</p><ol><li>使用 volumeClaimTemplates 挂载不同的卷。</li><li>使用 PVC 挂载相同的卷，但是在卷里面使用不同的目录区分各节点的数据。</li></ol><p>节点失败的时候，普通 pod 会被如何处理：</p><ol><li>节点会被标记为 NotReady。上面运行的 pod 状态变成 Unknown。</li><li>pod Unknown 一段时间之后，kubernates 标记这些 pod 为删除，同时安排其他节点新建对应的 pod。</li><li>节点重新加入后会知道需要删除上面的 pod，执行删除。</li></ol><p>对于 StatefulSet：</p><ol><li>pod 会被标记为 Unknown。</li><li>执行手动强制删除 kubectl delete po kubia-0 –force –grace-period 0</li><li>kubernates 会调度其他节点新建 pod。</li></ol><p>可以使用 kubectl get pods –watch 观察 pod 事件。使用 kubectl get events –watch 观察控制器发出的事件。</p><p>kubernates 调度器的作用是为 pod 找到可用节点，然后选择最优节点。可以通过 spec.schedulerName 来指定调度器。</p><p>跨 pod 的网络是通过 Container Network Interface(CNI) 插件建立的。跨整个集群的 pod 的 IP 地址必须是唯一的，所以跨节点的网桥必须使用非重叠的地址段，防止不同的 pod 拿到同一个 IP。例如不同节点分别使用 10.1.1.0/24 和 10.1.2.0/24 。</p><blockquote><p>让你的应用变得高可用：</p><ol><li>运行多实例来减少宕机可能性。</li><li>对不能水平扩展的应用使用领导选举机制。可以通过 sidecar 容器做选举的逻辑，选举完毕之后通知主容器结果即可。这样的 sidecar 可以复用。</li></ol><p>kube-schedular 容器的选举结果可以观察 holderIdentity 字段，还可以看看 acquireTime 和 renewTime。</p></blockquote><blockquote><p>serviceaccount 的缩写是 sa。每个 pod 都与一个 sa 相关联。pod 只能使用同一个命名空间的 ServiceAccount。</p><p>pod 的 manifest 文件里面，可以指定账户名称。不指定会使用这个命名空间里面默认的。</p><p>不需要读取任何集群元数据的 pod 应该运行在一个受限制的账户下。</p></blockquote><blockquote><p>将 spec.hostNetwork 设置为 true 可以使用宿主节点的网络命名空间。</p><p>不要混淆使用 hostPort 的 pod 和通过 NodePort 服务暴露的 pod。</p><ol><li>NodePort 服务会把到达宿主机的请求随机转发到 service 里面的 pod 。</li><li>hostPort 只会在运行了这个 pod 的节点绑定这个端口，NodePort 会在集群所有节点上面绑定这个端口。</li></ol><p>hostPort 最初是用于暴露 DeamonSet 部署在每个节点的系统服务的，也用于保证一个 pod 的两个副本不会被调度到同一个节点。</p><p>pod spec 里面的 hostPID 和 hostIPC 可以让容器使用宿主节点的 PID 和 IPC 命名空间，允许容器看到宿主的全部进程并与他们进行 IPC 通信。</p><p>securityContext 的一些设置：</p><ol><li>runAsUser 指定容器运行的用户。runAsAny 允许任何用户和组运行。</li><li>runAsNonRoot 可以阻止容器使用 root 运行。</li><li>privileged 可以允许 pod 在特权模式下运行。</li><li>通过 capabilities 可以允许或者禁止容器进行特定的系统调用。</li><li>通过 fsGroup 和 supplementalGroups 可以设置挂载卷的一些权限。</li></ol></blockquote><blockquote><p>通过 PodSecurityPolicy 可以设置默认的安全配置。通过 NetworkPolicy 可以设置 pod 间网络规则。</p></blockquote><blockquote><p>调度器在调度时并不关注各类资源在当前时刻的实际使用量，而只是关心节点上部署的所有 pod 的资源申请量之和。调度算法必须要保证这些 pod 需要这些用量的时候可以提供。</p><p>内存不足时哪个进程会被杀死？BestEffort 等级的 pod 会首先被杀掉，其次是 Burstable 的 pod，最后是 Guaranteed 的 pod。</p></blockquote><blockquote><p>可以通过调整 rc, rs, deploy 等可伸缩资源的 replicas 字段来手动实现 pod 中应用的横向扩容。</p><p>集群必须运行了 Heapster 才能实现自动伸缩。</p><p>自动伸缩大致逻辑是，设置目标用量，例如 cpu 使用率，qps 之类，然后由 Autoscaler 根据目前的 pod 数量和各自的运行情况，计算达成目标的 pod 数量，然后调整可伸缩资源来做扩缩容。</p><p>使用 kubectl get hpa 显示 HPA 资源。</p><p>如果增加副本数量不能导致被观测度量的平均值线性（或者接近线性）下降，那么 autoscaler 就不能正常工作。</p><p>Cluster Autoscaler 负责在节点资源不足的时候，自动增加节点。它也会在节点长时间使用率比较低的情况下下线节点。</p><ol><li>只有当 Cluster Autoscaler 知道节点上面运行的 pod 能够重新调度到其他节点的时候节点才会被归还。</li></ol><p>节点也可以被手动标记为不可调度，并排空节点</p><ol><li>kubectl cordon &lt;node> 标记节点为不可调度（但不会对其上 pod 做任何事）</li><li>kubectl drain &lt;node> 标记节点为不可调度，随后疏散其上所有 pod</li></ol></blockquote><blockquote><p>主节点有一个污点，污点包含一个 key，value，以及一个 effect，格式是 &lt;key>=&lt;value>:&lt;effect>。主节点包含一个 node-role.kubernates.io/master:NoSchedule 的污点(value为空)。除非有 pod 指定可以容忍这个污点，否则 pod 不会调度到这个节点。</p><p>pod 的 Tolerations 字段会说明可以容忍的污点，例如 node-role.kubernates.io/master=:NoSchedule 。注意污点和容忍度这里的区别，差了一个 = 。</p><p>使用 kubectl taint node node1.k8s node-type=production:NoSchedule 增加污点.</p><p>pod 定义里面增加对应的 tolerations 才能把 pod 部署上去。</p><p>tolerations:</p><ul><li>key: node-type
operator: Euqal
value: production
effect: NoSchedule</li></ul></blockquote><blockquote><p>使用节点亲缘性 node affinity 将 pod 调度到特定节点上。</p><p>通过 spec.affinity.nodeAffinity 可以实现比 nodeSelector 复杂的调度规则。还有 spec.affinity.podAffinity 和 podAntiAffinity 。</p></blockquote><blockquote><p>应用必须预料到会被杀死或者重新调度</p><ol><li>预料到本地 IP 和主机名会变化。</li><li>预料到写入磁盘的数据会消失。使用存储卷来跨容器持久化数据。</li></ol><p>rs 本身不关心 pod 是否处于死亡状态，只关心 pod 的数量是否匹配期望的数量。crash 的时候也不会重新调度 pod，因为通常调度到其他 node 也是这么个情况，一般认为这些 node 都是一样的。</p><p>可以给 pod 增加 pre-stop 和 post-start hook。</p><ol><li>post-start hook 是和主进程并行执行的。在钩子执行完毕之前，容器会一直停留在 Waiting 状态，其原因是 ContainerCreating 。因此 pod 的状态是 Pending 而不是 Running。如果钩子失败或者返回了非 0 的状态码，主容器会被杀死。</li><li>钩子程序失败的话，不好 debug，容器重启的话日志就没有了，不过可以通过写入到一个 emptyDir 的卷里面，让钩子程序向这个存储写入内容来解决。</li><li>pre-stop 钩子是在容器被终止之前执行的。并且会在执行完钩子程序之后才向容器进程发送 SIGTERM 信号。</li><li>pre-stop 钩子无论执行成功失败都不会阻止容器被停止。</li></ol><p>将重要的关闭流程替换为专注关闭流程的 pod。</p></blockquote><blockquote><p>当且仅当你的应用准备好处理进来的请求的时候，才去让就绪探针返回成功。</p></blockquote><blockquote><p>给所有资源都打上标签，而不仅仅是 pod。标签可以包含如下的内容：</p><ul><li>资源所属的应用（或者微服务）的名称</li><li>应用层级（前端，后端，等等）</li><li>运行环境（开发，测试，预发布，生产等等）</li><li>版本号</li><li>发布类型（稳定版，金丝雀，蓝绿开发中的绿色或者蓝色等等）</li><li>租户（如果你在每个租户中运行不同的 pod 而不是使用命名空间）</li><li>分片（带分片的系统）</li></ul><p>资源应该至少包括一个描述资源的注解和一个描述资源负责人的注解。在微服务框架中，pod 应该包含一个注解来描述该 pod 依赖的其他服务的名称。</p></blockquote><p>可以指定 spec.containers.terminationMessagePath 路径，将来 pod 有问题会读取这个文件里面的内容显示在 describe 结果里面。</p><p>通过自定义 CustomResourceDefinitions CRD 对象，可以做到类似 deploy 那样，自动帮你建立好 rs 和 pod，并且还可以避免重复的写冗长的 pod 定义之类。</p><p>实现思路是，需要配合建立一个自定义控制器，监听 API 上面的 CRD 对象的事件，例如有新建的时候，像 API 提交对应的 deploy pod 等新建请求。删除 CRD 的时候，删除相关联的资源。</p><p>其他资源：</p><ol><li><a href=https://github.com/box/kube-applier>https://github.com/box/kube-applier</a> 可以做到自动检出 yaml 执行 apply。</li><li><a href=https://ksonnet.io/docs/>https://ksonnet.io/docs/</a> 可以方便的复用 yaml 文件的配置，让你随意组合他们。</li><li><a href=https://fabric8.io/>https://fabric8.io/</a> 也是一个自动部署的工具。</li><li><a href=https://helm.sh/>https://helm.sh/</a> 是一个 kubernates 包管理器，可以类似装包一样部署 pod。其实就是他们事先写好了一堆的 pod 定义。有需要自己写的时候可以先来这里看看。</li></ol></div></article><div id=footer-post-container><div id=footer-post><div id=nav-footer style=display:none><ul><li><a href=/>Home</a></li><li><a href=/posts>Posts</a></li><li><a href=/tags>Tags</a></li><li><a href="https://www.google.com.hk/search?sitesearch=https%3A%2F%2Fwdicc.com%2F&amp;q=">Search</a></li><li><a href=/atom.xml>Subscribe</a></li></ul></div><div id=share-footer style=display:none><ul><li><a class=icon href="http://www.facebook.com/sharer.php?u=https%3a%2f%2fwdicc.com%2fbook-review-of-kubernates-in-action%2f" aria-label=Facebook><i class="fab fa-facebook fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://twitter.com/share?url=https%3a%2f%2fwdicc.com%2fbook-review-of-kubernates-in-action%2f&text=Book%20Review%20of%20Kubernates%20in%20Action" aria-label=Twitter><i class="fab fa-twitter fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2fwdicc.com%2fbook-review-of-kubernates-in-action%2f&title=Book%20Review%20of%20Kubernates%20in%20Action" aria-label=Linkedin><i class="fab fa-linkedin fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2fwdicc.com%2fbook-review-of-kubernates-in-action%2f&is_video=false&description=Book%20Review%20of%20Kubernates%20in%20Action" aria-label=Pinterest><i class="fab fa-pinterest fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="mailto:?subject=Book%20Review%20of%20Kubernates%20in%20Action&body=Check out this article: https%3a%2f%2fwdicc.com%2fbook-review-of-kubernates-in-action%2f" aria-label=Email><i class="fas fa-envelope fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://getpocket.com/save?url=https%3a%2f%2fwdicc.com%2fbook-review-of-kubernates-in-action%2f&title=Book%20Review%20of%20Kubernates%20in%20Action" aria-label=Pocket><i class="fab fa-get-pocket fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://reddit.com/submit?url=https%3a%2f%2fwdicc.com%2fbook-review-of-kubernates-in-action%2f&title=Book%20Review%20of%20Kubernates%20in%20Action" aria-label=reddit><i class="fab fa-reddit fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.tumblr.com/share/link?url=https%3a%2f%2fwdicc.com%2fbook-review-of-kubernates-in-action%2f&name=Book%20Review%20of%20Kubernates%20in%20Action&description=%e8%bf%99%e5%87%a0%e5%a4%a9%e7%9c%8b%e4%ba%86%e4%b8%80%e4%b8%8b%20Kubernates%20in%20action%20%e8%bf%99%e6%9c%ac%e4%b9%a6%ef%bc%8c%e7%9c%8b%e7%9a%84%e6%98%af%e4%b8%ad%e6%96%87%e7%89%88%e6%9c%ac%e3%80%82%e6%8a%8a%e8%87%aa%e5%b7%b1%e8%a7%89%e5%be%97%e6%9c%89%e7%94%a8%e7%9a%84%e8%ae%b0%e5%bd%95%e4%b8%80%e4%b8%8b%e3%80%82%20%e6%80%8e%e4%b9%88%e5%86%b3%e5%ae%9a%e4%b8%80%e4%b8%aa%20pod%20%e9%87%8c%e9%9d%a2%e5%8c%85%e5%90%ab%e5%a4%9a%e5%b0%91%e5%ae%b9%e5%99%a8" aria-label=Tumblr><i class="fab fa-tumblr fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2fwdicc.com%2fbook-review-of-kubernates-in-action%2f&t=Book%20Review%20of%20Kubernates%20in%20Action" aria-label="Hacker News"><i class="fab fa-hacker-news fa-lg" aria-hidden=true></i></a></li></ul></div><div id=actions-footer><a id=menu-toggle class=icon href=# onclick='return $("#nav-footer").toggle(),!1' aria-label=Menu><i class="fas fa-bars fa-lg" aria-hidden=true></i> Menu</a>
<a id=share-toggle class=icon href=# onclick='return $("#share-footer").toggle(),!1' aria-label=Share><i class="fas fa-share-alt fa-lg" aria-hidden=true></i> share</a>
<a id=top style=display:none class=icon href=# onclick='$("html, body").animate({scrollTop:0},"fast")' aria-label="Top of Page"><i class="fas fa-chevron-up fa-lg" aria-hidden=true></i> Top</a></div></div></div><footer id=footer><div class=footer-left>Copyright &copy; 2024 wd and cc</div><div class=footer-right><nav><ul><li><a href=/>Home</a></li><li><a href=/posts>Posts</a></li><li><a href=/tags>Tags</a></li><li><a href="https://www.google.com.hk/search?sitesearch=https%3A%2F%2Fwdicc.com%2F&amp;q=">Search</a></li><li><a href=/atom.xml>Subscribe</a></li></ul></nav></div></footer></div></body><link rel=stylesheet href=/lib/font-awesome/css/all.min.css><script src=/lib/jquery/jquery.min.js></script><script src=/js/main.js></script><script src=/js/code-copy.js></script></html>