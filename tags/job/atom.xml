<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Job on wd and cc</title>
    <link>https://wdicc.com/tags/job/atom/index.xml</link>
    <description>Recent content in Job on wd and cc</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <atom:link href="https://wdicc.com/tags/job/atom/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>使用 org-mode 来做自己的 job tracker</title>
      <link>https://wdicc.com/use-org-mode-as-a-job-tracker/</link>
      <pubDate>Fri, 23 Jul 2010 00:00:00 +0000</pubDate>
      
      <guid>https://wdicc.com/use-org-mode-as-a-job-tracker/</guid>
      <description>用 emacs 的应该都知道 org-mode 这个大杀器，一直以来都想在工作里面用上他，可总是习惯不了。&lt;br /&gt;

这几天尝试把 org-mode 打造成了我的一个 job tracker，用来记录自己的 todo 和完成情况。&lt;br /&gt;

&lt;pre class=&#34;prettyprint lang-lisp&#34;&gt;
;;
;; org-mode
;;

;; (setq org-agenda-files &#39;(&#34;~/org&#34;))
(setq org-agenda-files (file-expand-wildcards &#34;~/org/*.org&#34;))  ;; 把 ~/org/*.org 都加入到 agenda 里面，使用 C-c a a 看 agenda 的时候，会从这些文件里面读
(add-to-list &#39;auto-mode-alist &#39;(&#34;\\.org$&#34; . org-mode))
(define-key global-map &#34;\C-cl&#34; &#39;org-store-link)
(define-key global-map &#34;\C-ca&#34; &#39;org-agenda)
(setq org-log-done t) ;; 变到 done 状态的时候，记录一下时间

(add-hook &#39;org-mode-hook
          (lambda ()
            (org-set-local &#39;yas/trigger-key [tab])
            (define-key yas/keymap [tab] &#39;yas/next-field-group)))

(setq org-todo-keywords
      &#39;((sequence &#34;TODO(t)&#34; &#34;WAIT(w@/!)&#34; &#34;|&#34; &#34;DONE(d!)&#34; &#34;CANCELED(c@)&#34;)))  ;; 设置一下 todo 的关键字，| 左边的是未完成状态，右边是 done 的状态


(setq org-default-notes-file &#34;~/org/todo.org&#34;) ;; 设置 remember 的默认文件 

;;;  Load Org Remember Stuff
(require &#39;remember)
(org-remember-insinuate)

;; Start clock in a remember buffer and switch back to previous clocking task on save
;; (add-hook &#39;remember-mode-hook &#39;org-clock-in &#39;append)
;; (add-hook &#39;org-remember-before-finalize-hook &#39;bh/clock-in-interrupted-task)

;; I use C-M-r to start org-remember
(global-set-key (kbd &#34;C-c m r&#34;) &#39;org-remember)
;; (define-key global-map &#34;\C-cr&#34; &#39;org-remember)

;; Keep clocks running
(setq org-remember-clock-out-on-exit nil)

;; C-c C-c stores the note immediately
(setq org-remember-store-without-prompt t)

;; I don&#39;t use this -- but set it in case I forget to specify a location in a future template
(setq org-remember-default-headline &#34;Tasks&#34;) ;; 设置默认 remember 添加的 headline

;; 3 remember templates for TODO tasks, Notes, and Phone calls
(setq org-remember-templates (quote ((&#34;todo&#34; ?t &#34;** TODO %?\nCREATED: %U&#34; nil nil nil)
                                     ;; (&#34;note&#34; ?n &#34;* %?                                                                            :NOTE:\n  %U\n  %a\n  :CLOCK:\n  :END:&#34; nil bottom nil)
                                     ;; (&#34;appointment&#34; ?a &#34;* %?\n  %U&#34; &#34;~/git/org/todo.org&#34; &#34;Appointments&#34; nil)
                                     ;; (&#34;org-protocol&#34; ?w &#34;* TODO Review %c%!\n  %U&#34; nil bottom nil))))
                                     ))) ;;设置 todo 的模板，里面第三个参数是模板，里面的变量的意思 google 下


&lt;/pre&gt;&lt;br /&gt;

在 todo.org 里面有两个 headline，一个是 * Tasks ，一个是 * Done。&lt;br /&gt;

配置好后，在任意的 buffer 按 C-c m r 就可以打开个 buffer，输入 todo 信息，然后按 C-c C-c 就可以把 todo 添加到 todo.org 里面去了，会添加到 * Tasks 这个 headline 下面。&lt;br /&gt;

完成一个任务的时候，在那上面按 C-c C-t 然后选择 done 就可以设置完成。手动（还不会自动。。。）把完成的任务挪到 Done 里面。&lt;br /&gt;

如果想看看有完成情况的统计，可以在 agenda 里面看，C-c a a，然后按 v，选择不同的模式看。每周的工作情况在那里面一目了然，呵呵。&lt;br /&gt;

&lt;pre class=&#34;prettyprint&#34;&gt;
Week-agenda (W29):
Monday     19 July 2010 W29
Tuesday    20 July 2010
Wednesday  21 July 2010
  todo:       17:33...... [ TODO 多看看 org-mode 的 agenda
Thursday   22 July 2010
  todo:       15:18...... Closed:     DONE a test
  todo:       15:18...... [ DONE a test
Friday     23 July 2010
  todo:       14:50...... [ TODO 梳理一下
  todo:       17:08...... [ TODO 了解下
  todo:       22:49...... [ TODO 申请
Saturday   24 July 2010
Sunday     25 July 2010
&lt;/pre&gt;&lt;br /&gt;
</description>
    </item>
    
    <item>
      <title>oracle 的 job 又遇到问题了</title>
      <link>https://wdicc.com/oracle-jobs/</link>
      <pubDate>Fri, 29 Jun 2007 00:00:00 +0000</pubDate>
      
      <guid>https://wdicc.com/oracle-jobs/</guid>
      <description>&lt;p&gt;还是高级复制的问题，这次可能是因为job执行过程中，对方机器刚好重启导致的。反正job是卡在那里了，都10多天了。&lt;/p&gt; &lt;p&gt;查看 dba_jobs_running 表，可以看到卡住的job的 job_id 和 sid 。查看 dba_jobs 表，可以看到相应 job 的信息，this_date 如果有数据的话，表示的是 job 开始执行的时间，next_date 是下次执行 job 的时间，如果 job 正常执行完毕，那么 this_date 应该是空的。根据 sid 还可以查看 v$session_wait 和 v$session 里面的这个 job 的一些状态。&lt;/p&gt; &lt;p&gt;尝试了下面的方法来重新运行job，当时好像不好用，不过今天来看的时候，job是执行了。现在也不清楚是不是我这个操作起作用了，真晕。&lt;/p&gt; &lt;p&gt;&lt;pre lang=&#34;txt&#34;&gt;SQL&amp;gt; exec dbms_job.broken(109,true);&lt;br /&gt;

PL/SQL procedure successfully completed.&lt;br /&gt;

SQL&amp;gt; commit;&lt;br /&gt;

Commit complete.&lt;br /&gt;

SQL&amp;gt; select job,sid from dba_jobs_running;&lt;br /&gt;

       JOB        SID&lt;br /&gt;
---------- ----------&lt;br /&gt;
       109        656&lt;br /&gt;

SQL&amp;gt; select saddr,sid,serial#,paddr,username,status from v$session where username = &#39;REPADMIN&#39;;&lt;br /&gt;

SADDR           SID    SERIAL# PADDR    USERNAME                       STATUS&lt;br /&gt;
-------- ---------- ---------- -------- ------------------------------ --------&lt;br /&gt;
973CF8C4        626         27 98F96BB8 REPADMIN                       ACTIVE&lt;br /&gt;
973D2E7C        629         10 98F88670 REPADMIN                       ACTIVE&lt;br /&gt;
973F11F4        656         10 98F88174 REPADMIN                       ACTIVE&lt;br /&gt;

SQL&amp;gt; alter system kill session &#39;656,10&#39;;&lt;br /&gt;

System altered.&lt;br /&gt;

SQL&amp;gt; select saddr,sid,serial#,paddr,username,status from v$session where username = &#39;REPADMIN&#39;;&lt;br /&gt;

no rows selected&lt;br /&gt;

SQL&amp;gt; select job,sid from dba_jobs_running;&lt;br /&gt;

no rows selected&lt;br /&gt;

SQL&amp;gt; select job,log_user,last_date,next_date from dba_jobs where log_user=&#39;REPADMIN&#39;;&lt;br /&gt;

       JOB LOG_USER                       LAST_DATE&lt;br /&gt;
---------- ------------------------------ -------------------&lt;br /&gt;
NEXT_DATE&lt;br /&gt;
-------------------&lt;br /&gt;
       106 REPADMIN                       2007-06-28 16:25:43&lt;br /&gt;
2007-06-28 16:35:43&lt;br /&gt;

       109 REPADMIN                       2007-06-28 16:07:38&lt;br /&gt;
4000-01-01 00:00:00&lt;br /&gt;

       110 REPADMIN                       2007-06-28 16:25:43&lt;br /&gt;
2007-06-28 16:35:43&lt;br /&gt;


SQL&amp;gt; exec dbms_job.broken(109,false,sysdate);&lt;br /&gt;

PL/SQL procedure successfully completed.&lt;br /&gt;

SQL&amp;gt; commit;&lt;br /&gt;

Commit complete.&lt;br /&gt;

SQL&amp;gt; select job,log_user,last_date,next_date from dba_jobs where log_user=&#39;REPADMIN&#39;;&lt;br /&gt;

       JOB LOG_USER                       LAST_DATE&lt;br /&gt;
---------- ------------------------------ -------------------&lt;br /&gt;
NEXT_DATE&lt;br /&gt;
-------------------&lt;br /&gt;
       106 REPADMIN                       2007-06-28 16:25:43&lt;br /&gt;
2007-06-28 16:35:43&lt;br /&gt;

       109 REPADMIN                       2007-06-28 16:07:38&lt;br /&gt;
2007-06-28 16:28:40&lt;br /&gt;

       110 REPADMIN                       2007-06-28 16:25:43&lt;br /&gt;
2007-06-28 16:35:43&lt;br /&gt;
&lt;/pre&gt;&lt;br /&gt;
&lt;p&gt;此后就我所知道的，就只能等着了。dbms_job.run(job_id) 也可以让 job 立即执行。关键是看 this_date ，他的值就是开始执行 job 的时间，job 如果执行时间太长，而下次执行又太快的话，可能也会导致问题。所以还可以尝试手动执行 job 看看。 dba_jobs 的 waht 字段就是对于的语句。&lt;/p&gt;&lt;br /&gt;
</description>
    </item>
    
  </channel>
</rss>