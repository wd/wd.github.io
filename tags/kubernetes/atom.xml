<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Kubernetes on wd and cc</title><link>https://wdicc.com/tags/kubernetes/</link><description>Recent content in Kubernetes on wd and cc</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Wed, 23 Nov 2022 19:51:18 +0800</lastBuildDate><atom:link href="https://wdicc.com/tags/kubernetes/atom.xml" rel="self" type="application/rss+xml"/><item><title>Make DNS Service in K8s Stable</title><link>https://wdicc.com/make-dns-service-in-k8s-stable/</link><pubDate>Wed, 23 Nov 2022 19:51:18 +0800</pubDate><guid>https://wdicc.com/make-dns-service-in-k8s-stable/</guid><description>&lt;p>我们用的 k8s 是通过 rancher 管理的。rancher 又是使用 rke 这个 engine 来创建集群的。我们使用的 CNI 是 calico，DNS 是 coredns。按说 DNS 服务是核心服务，如果这个玩意不稳定或者有问题，那么整个集群都不安宁。coredns 按说挺有名气来，按说没问题。。吧？&lt;/p></description></item><item><title>Use Kubeconform to Validate Manifests Locally</title><link>https://wdicc.com/use-kubeconform-to-validate-manifests-locally/</link><pubDate>Sat, 29 Oct 2022 17:58:39 +0800</pubDate><guid>https://wdicc.com/use-kubeconform-to-validate-manifests-locally/</guid><description>&lt;p>
&lt;a href="https://github.com/yannh/kubeconform">kubeconform&lt;/a> is a tool that allows us to validate Kubernetes manifests.&lt;/p>
&lt;div id="outline-container-headline-1" class="outline-3">
&lt;h3 id="headline-1">
Retrieve open API specification from Kubernetes
&lt;/h3>
&lt;div id="outline-text-headline-1" class="outline-text-3">
&lt;p>
Use this command to retrieve the open API specifications from Kubernetes.&lt;/p>
&lt;div class="src src-bash">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>k get --raw &lt;span style="color:#e6db74">&amp;#39;/openapi/v2&amp;#39;&lt;/span> &amp;gt; /tmp/specs.json&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-2" class="outline-3">
&lt;h3 id="headline-2">
Generate JSON schema file
&lt;/h3>
&lt;div id="outline-text-headline-2" class="outline-text-3">
&lt;p>
Use &lt;a href="https://github.com/wd/openapi2jsonschema">openapi2jsonschema&lt;/a> to generate the JSON schemas.&lt;/p>
&lt;div class="src src-bash">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ python openapi2jsonschema/command.py -o /tmp/json-schemas/v1.20.11-standalone-strict &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>--kubernetes --stand-alone &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>--expanded --strict &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>/tmp/specs.json
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Downloading schema
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Parsing schema
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Generating shared definitions
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Generating individual schemas
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Processing alertmanager-monitoring-v1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Generating alertmanager-monitoring-v1.json
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Processing alertmanagerlist-monitoring-v1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Generating alertmanagerlist-monitoring-v1.json
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Processing prometheus-monitoring-v1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Generating prometheus-monitoring-v1.json
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Processing prometheuslist-monitoring-v1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>....
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Processing networksetlist-crd-v1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Generating networksetlist-crd-v1.json
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Generating schema &lt;span style="color:#66d9ef">for&lt;/span> all types&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
The command will report some errors like the one below which is fine since the tool does not support `customresourcedefinition`.&lt;/p></description></item><item><title>Webhooks in Kubernetes</title><link>https://wdicc.com/webhooks-in-kubernetes/</link><pubDate>Sun, 28 Aug 2022 09:38:59 +0800</pubDate><guid>https://wdicc.com/webhooks-in-kubernetes/</guid><description>&lt;p>
Kubernetes allows us to hook on API request chain to do some specific checks or modifies.&lt;/p>
&lt;div id="outline-container-headline-1" class="outline-2">
&lt;h2 id="headline-1">
Kubernetes API access control
&lt;/h2>
&lt;div id="outline-text-headline-1" class="outline-text-2">
&lt;p>
There are two types of control. One is to control which user(token, group) is allowed to access, the other one is to control which resource a user could access. The kube-apiserver has two arguments to allow users to define that.&lt;/p></description></item><item><title>DNS Request in Alpine Image</title><link>https://wdicc.com/dns-request-in-alpine-image/</link><pubDate>Thu, 25 Nov 2021 20:15:39 +0800</pubDate><guid>https://wdicc.com/dns-request-in-alpine-image/</guid><description>&lt;p>
Alpine 镜像可以带来很小的镜像体积，所以大家比较热衷于使用这个镜像做基础镜像。但是实际上因为一些系统库是阉割版本，可能会导致一些意想不到的问题。例如这里想说的 DNS 的问题。&lt;/p></description></item><item><title>Local Persistent Volume vs HostPath</title><link>https://wdicc.com/local-persist-volume-vs-hostpath/</link><pubDate>Sun, 28 Feb 2021 14:52:23 +0800</pubDate><guid>https://wdicc.com/local-persist-volume-vs-hostpath/</guid><description>&lt;p>Kubernetes 可以用 Local persistent volume 来使用本机的磁盘。那和 hostPath volume 有啥区别呢？ &lt;a href="https://kubernetes.io/blog/2019/04/04/kubernetes-1.14-local-persistent-volumes-ga/">这篇文档&lt;/a>有说明，大致翻译下。&lt;/p>
&lt;p>
一般来说 Persistent volume 都是通过远程文件系统实现的。远程文件系统可以不依赖 kubernetes 节点而保存数据。但是远程文件系统往往不能提供本地文件系统一样的性能。&lt;/p></description></item><item><title>Use Datadog to Monitor Your Cluster Build by Rke</title><link>https://wdicc.com/use-datadog-to-monitor-your-cluster-build-by-rke/</link><pubDate>Mon, 27 Jul 2020 15:47:33 +0800</pubDate><guid>https://wdicc.com/use-datadog-to-monitor-your-cluster-build-by-rke/</guid><description>&lt;p>There are many tools you can choose when you want to build your kubernetes cluster, we use Rancher Kubernetes Engine (RKE) to build our kubernetes cluster.&lt;/p>
&lt;p>
We run datadog as daemonset in our cluster, and datadog has auto discovery feature to discovery pods/containers need to check. When we deployed a redis database, datadog will notice that and run checks against the redis pods, we didn&amp;#39;t need to do any configurations.&lt;/p></description></item><item><title>10 Most Common Mistakes Using Kubernetes</title><link>https://wdicc.com/10-most-common-mistakes-using-kubernetes/</link><pubDate>Sun, 24 May 2020 09:45:20 +0800</pubDate><guid>https://wdicc.com/10-most-common-mistakes-using-kubernetes/</guid><description>&lt;p>
翻译自 &lt;a href="https://blog.pipetail.io/posts/2020-05-04-most-common-mistakes-k8s/">10 most common mistakes using kubernetes&lt;/a>&lt;/p>
&lt;div id="outline-container-headline-1" class="outline-3">
&lt;h3 id="headline-1">
resources - requests and limits
&lt;/h3>
&lt;div id="outline-text-headline-1" class="outline-text-3">
&lt;p>
这个绝对值得一开始就讲。&lt;/p>
&lt;p>
CPU 限制通常都是 not set（没设置）或者 set very low（设置很低）（因此可以一次在一个节点放很多 pod），节点因此就会容易被过度使用。在需求旺盛的情况下，节点的 CPU 会被充分利用。我们的工作负载仅会获得“要求的算力”，会得到 CPU 使用限制，一般会导致应用程序延迟和超时增加，等等。&lt;/p></description></item><item><title>RBAC in Kubernetes</title><link>https://wdicc.com/rbac-in-kubernetes/</link><pubDate>Mon, 18 May 2020 17:14:58 +0800</pubDate><guid>https://wdicc.com/rbac-in-kubernetes/</guid><description>&lt;p>How to give a pod the access to run kubectl to create pods or configmaps? It&amp;#39;s very simple.&lt;/p>
&lt;p>
Every pods has to bind to a service account, it will be &lt;code class="verbatim">default&lt;/code>, if you haven&amp;#39;t specify one. And by default, this account didn&amp;#39;t have any access to the kubernetes API.&lt;/p>
&lt;p>
First, create a service account.&lt;/p></description></item></channel></rss>