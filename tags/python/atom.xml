<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>python on wd and cc</title><link>https://wdicc.com/tags/python/</link><description>Recent content in python on wd and cc</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 12 Dec 2019 13:33:15 +0800</lastBuildDate><atom:link href="https://wdicc.com/tags/python/atom.xml" rel="self" type="application/rss+xml"/><item><title>Add an Force Sync Button in Django Admin</title><link>https://wdicc.com/add-an-force-sync-button-in-django-admin/</link><pubDate>Thu, 12 Dec 2019 13:33:15 +0800</pubDate><guid>https://wdicc.com/add-an-force-sync-button-in-django-admin/</guid><description>我们的系统里面需要和外部的系统同步一些数据，为了保证数据正确处理，增加了一个队列。队列是通过一个 celery 里面的定时任务同步的。定时任务设置是 5 分钟一次，那有时候测试的时候或者出错的时候就可能会想要立刻执行下同步，好看看执行结果，要不很有可能等到下次执行的时候还是有问题，这就有点浪费时间了。 自然就想在 Django admin 后台增加一个按钮，点一下就执行一下同步功能。Django 提供了一个 admin.ModelAdmin.change_list_template 变量来让你自己定义 list 模版，我们就用这个实现了。 admin.py 的代码如下。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class TestAdmin(admin.ModelAdmin): change_list_template = &amp;#34;test/change_list.html&amp;#34; def get_urls(self): urls = super().get_urls() my_urls = [ url(r&amp;#39;^$&amp;#39;, self.force_sync), ] return my_urls + urls def force_sync(self, request): force_sync = request.GET.get(&amp;#39;force_sync&amp;#39;) if force_sync: logger.info(&amp;#39;Force sync start&amp;#39;) ret = manual_syn_task() logger.</description></item><item><title>Learning Python Coroutine</title><link>https://wdicc.com/learning-python-coroutine/</link><pubDate>Thu, 17 Oct 2019 10:49:40 +0800</pubDate><guid>https://wdicc.com/learning-python-coroutine/</guid><description>看了一个视频 OSB 2015 - How Do Python Coroutines Work?，从头开始讲 coroutine 是怎么抽象出来的，感觉好厉害。自己写了一点程序学习了一下。之前写的关于 coroutine 的帖子。 先准备一个 server.py ，可以接受客户端请求。要注意的是要使用 Threading ，或者 fork 的 server，要不服务端执行并不支持并发，需要处理完一个才能处理下一个，这样会发现虽然客户端那边请求是并发的，但是返回结果的时候是顺序的。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import socketserver from time import sleep HOST = &amp;#39;127.0.0.1&amp;#39; PORT = 2045 class MyTCPHandler(socketserver.BaseRequestHandler): def handle(self): data = self.request.recv(1024) sleep(1) self.request.sendall(&amp;#39;{} ok&amp;#39;.format(data.decode()).encode()) def run(): server = socketserver.ThreadingTCPServer((HOST, PORT), MyTCPHandler) server.</description></item><item><title>ASGI</title><link>https://wdicc.com/asgi/</link><pubDate>Tue, 15 Oct 2019 14:52:47 +0800</pubDate><guid>https://wdicc.com/asgi/</guid><description>Django 3.0 要支持 ASGI 了，全称 Asynchronous Server Gateway Interface，使用了 coroutines 异步。WSGI 是目前普遍使用的，把进来的请求标准化处理之后，交给 WSGI 程序，这个支持的是请求来了，处理完毕，返回结果这样的模型。对于像 websockt 这样的就不太友好了，websockt 实际是建立连接之后会持续发送请求和接收结果，所以有了 ASGI。 ASGI 不同的地方在于，他有一个 scope，表示一个连接，这个会一直存在直到用户断开连接。然后通过一个一个的 event 和应用交互，event 是个字典，必定包含一个 type 指明类型。ASGI 还支持了 coroutine。 这样对于 http 请求，一个请求就一个 scope， 所需要的数据基本就全了，除了 body 对应一个 event。对于 websockt 请求，一个 scope 会持续到直到用户断开，期间通过 event 发送详细消息。Application 不能和客户端在 scope 阶段交互，必须等进入 event loop 才可以，而且取决于协议规定，可能还需要等一些初始化的 event 之后才可以。 然后目前实现的 ASGI server 我看有 daphne，简单看了一下源码。 这个一般是命令行执行 daphne 这个命令，入口是在 setup.py 里面指定的 daphne.cli:CommandLineInterface.entrypoin ，这里面实例化了一个 cli 然后执行了 run。run 里面主要是处理命令行参数，找到我们指定的 application 然后 import 。 这里我们的用法是通过 get_channel_layer() 初始化了一个，这里面主要是通过配置文件里面的配置，把 backend 和 routing 初始化了一下。 1 2 3 4 5 6 asgi_layer = backend_class(**config) return ChannelLayerWrapper( channel_layer=asgi_layer, alias=name, routing=routing, ) cli.</description></item><item><title>Notes for CPython Internals</title><link>https://wdicc.com/notes-for-cpython-internals/</link><pubDate>Thu, 05 Sep 2019 12:43:42 +0800</pubDate><guid>https://wdicc.com/notes-for-cpython-internals/</guid><description>视频地址这里。 Python 源码 Include/opcode.h 里面定义了所有 opcode。 Modules 里面是一些 c 实现的模块， Lib 里面是用 python 实现的模块。 Objects 里面是部分 python 对象对应的 c 实现。 Python 目录里面是 python core， Python/ceval.c 里面定义了 python interpreter 主要的循环，找那个 for(;;) 就可以，这个循环里面有一个巨长的 switch (opcode) 。 Opcode 和 interpreter 循环 test.py 1 2 3 x = 1 y = 2 print(x + y) 使用内置的 compile(source, filename, &amp;#39;exec&amp;#39;) 函数可以把代码编译成 code object , code object 有一个 co_code 属性，里面包含了代码的 bytecode。 1 2 3 4 5 6 7 8 9 &amp;gt;&amp;gt; c = compile(open(&amp;#39;test.</description></item><item><title>Python Coroutine</title><link>https://wdicc.com/python-coroutine/</link><pubDate>Tue, 27 Aug 2019 10:49:51 +0800</pubDate><guid>https://wdicc.com/python-coroutine/</guid><description>协程 coroutine 不知道是从什么时候开始的，感觉我第一次看到是 lua 里面支持 yield 。后面看到就是 javascript 里面的 Promise，async 和 await。 以前写 Javascript 的时候容易会遇到 callback hell，似乎 Promise 就是出来解决这个问题的，让你可以用同步的方式写异步程序。例如你有三个异步请求可以同时发出去，而后面的结果又需要这三个的结果都回来才能继续，那就可以用类似下面的伪代码，整体执行时间是最长的那个。 1 2 3 res1 = await test1 res2 = await test2 console.log(res1, res2) Python 里面似乎也类似。我目前理解主要就是让程序可以「同步」执行，但是又避免了需要维护锁的问题，没有锁就不会有死锁了吧。。。 解释下同步，主要是针对对于 cpu 资源的占用。对于计算型的程序，实际上每时每刻都在利用 cpu 做计算，这样就算把计算拆分成了多个计算程序，让他们同时运行，那同一时刻还是只有一个程序在利用 cpu 资源执行，这样并行实际并不能提升效率。所以对于纯计算型任务，可以通过多进程利用多个 cpu。 但是实际我们的程序执行的时候，并不全是 cpu 计算，有时候会需要等网络 io，文件 io 等，做这些事情的时候实际上 cpu 是空闲的。协程就是让这些程序在等待的时候，把控制权交出来，让其他程序运行。那个 yield 关键字就是做这个事情的， yield 很像 return ，遇到的时候就会返回，暂停程序的执行，等到适当的时候又可以从暂停的地方继续执行。 以前是使用 @asyncio.coroutine 和 yield from 来创建协程，似乎 3.</description></item><item><title>Book Review of Effective Python: 59 Specific Ways to Write Better Python</title><link>https://wdicc.com/book-review-of-effective-python/</link><pubDate>Mon, 26 Aug 2019 09:53:26 +0800</pubDate><guid>https://wdicc.com/book-review-of-effective-python/</guid><description>书名是《Effective Python：编写高质量 Python 代码的 59 个方法》这本书买了大概 2 年，一直没看完，前几天找了一些时间看完了。 这书是针对中级 Python 程序员的，里面没有对于语法什么的讲解，也没有对 c 代码实现的讲解，针对中级程序员。 用 Python 方式来思考 Python 3 里面包含两种表示字符串的类型：bytes 和 str。前者是二进制形式，后者是 Unicode 编码（比如使用 utf8）之后的形式。想要把 bytes 表示为 str 形式，需要使用 decode ，反之是 encode 。 切割列表的时候，start 和 end 可以越界，这样可以用来限制列表最大长度。 a=[0,1,2]; a[:10] 可以限制最大是 10 个。 可以使用列表推导式 [x*2 for x in a] 类似这样的形式，代替 map 和 filter 。 字典推导 {k: v for k, v in a.</description></item><item><title>Run Command Through Python</title><link>https://wdicc.com/run-command-through-python/</link><pubDate>Tue, 13 Aug 2019 14:53:34 +0800</pubDate><guid>https://wdicc.com/run-command-through-python/</guid><description>通过 python 执行命令有很多方法。 最简单的 os.system(command) , command 是要执行的命令，一个包括命令和参数的字符串。产生的输出会直接打印到 stdout 。返回值是命令执行的退出值。 然后就是 os.spawn* ，这个我感觉有点丧心病狂了。 os.spawnl(mode, path, …) os.spawnle(mode, path, …, env) os.spawnlp(mode, file, …) os.spawnlpe(mode, file, …, env) os.spawnv(mode, path, args) os.spawnve(mode, path, args, env) os.spawnvp(mode, file, args) os.spawnvpe(mode, file, args, env) 这些主要是命令输入的方式，和环境变量的控制不一样， l 是类似 os.</description></item><item><title>An Interesting Python Function</title><link>https://wdicc.com/an-interesting-python-function/</link><pubDate>Wed, 07 Aug 2019 16:53:09 +0800</pubDate><guid>https://wdicc.com/an-interesting-python-function/</guid><description> 这里看到的，感觉挺有意思的，记录一下。题目来自这里。 如何让下面这个函数返回 True ？ 1 2 3 4 5 def check(x): if x+1 is 1+x: return False if x+2 is not 2+x: return True 解法1: 自定义类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def check(x): if x+1 is 1+x: return False if x+2 is not 2+x: return False return True class Test(int): def __add__(self, v): if v == 1: return 0 else: return v print(check(Test())) # output: True 如果一个对象是在 + 的左侧，那会调用 __add__ ，如果在右侧，会调用 __radd__ 。上面的 Test 类继承自 int，重写了其中的 __add__ 方法，但是保留了 __radd__ ，所以上面的例子里面， Test()+1 会返回 0， 1+test() 会返回 1。 Test()+2 会返回 2， 2+Test() 也会返回 2。 解法2:特殊的整数 1 2 3 4 5 6 7 8 9 def check(x): if x+1 is 1+x: return False if x+2 is not 2+x: return False return True print(check(-7)) # output: True 只有 -7 可以。python 里面对于 -5 - 256 这些整数会提前生成，这些都是单例。所以 -7+1 is 1-7 是 False ，以及 -7+2 is not 2-7 是 False ，两个 if 条件都不成立。</description></item><item><title>Emacs as python IDE</title><link>https://wdicc.com/emacs-as-python-ide/</link><pubDate>Fri, 30 Jun 2017 20:47:56 +0800</pubDate><guid>https://wdicc.com/emacs-as-python-ide/</guid><description>最近 python 写的比较多，比较了几个编辑器，最后还是留下了 emacs。 主要比较了 emacs 和 pycharm。pycharm 绝对是一个很强的 IDE，几乎可以补全任何东西，写代码各种提示。比如 Django 里面定义一个 model User 之后，就可以 User. 之后提示 objects ，这个是依据 metaclass 来补全的。另外还有比如写 User.objects.get(|) 的时候，光标在竖线那个位置，会提示 User 的字段，这个相当好用。这两个只是皮毛，实在是太好用了。 但是为什么还要用 emacs 呢？emacs 的编辑器功能太好用了。比如 &amp;lt; 到页首， &amp;gt; 到页尾， C-x b 切换 buffer，还有切换 frame，等等快捷键非常舒服，完全不用鼠标。不过也可能是我习惯了 emacs 的快捷键了。在 pycharm 里面时不时就不行，比如选择一段文字，纯键盘需要按 -&amp;gt; 配合才可以，那还不如用鼠标算了。 其实如果一上手就用 pycharm，那绝对会觉得很爽。 emacs 写 python 在原生的 python-mode 基础上有两个好用的选择，一个是 anaconda-mode，一个是 elpy。 anaconda-mode 相对来说比较简陋一点，但是补全什么的没问题，缺少重构功能。两个的工作模式都是会启动一个补全用的进程，然后通过 lisp 和这个进程交互获取补全信息。 anaconda-mode 遇到的问题和解决 anaconda-mode 我遇到一个问题，为了下载 emacs 的 package 方便，我设置了代理，这个代理导致 anaconda-mode 和补全进程交互的时候，连接不能断开，就会不停的新建连接，一会就打开文件数满了，可以参观这个 issue。主要是设置了 no_proxy 解决。 1 2 3 4 (setq url-proxy-services &amp;#39;((&amp;#34;no_proxy&amp;#34; .</description></item><item><title>Python __new__</title><link>https://wdicc.com/python-new/</link><pubDate>Mon, 16 Jan 2017 15:47:59 +0800</pubDate><guid>https://wdicc.com/python-new/</guid><description>翻译一点 https://www.python.org/download/releases/2.2/descrintro/#__new__ 有些感觉还是挺生硬的，方便自己理解吧。
__new__ 的一些规则:
__new__ 是一个静态方法。定义它的时候并不需要执行 __new__ = staticmethod(__new__)，因为它的名字就包含了这个含义（这个对于类构造方法来说是个特殊的函数） __new__ 的第一个参数，必须是一个类，其余的参数是留给构造方法的。 覆盖了基类的 __new__ 方法的类有可能会调用基类的 __new__ 方法。传递给基类的 __new__ 方法的第一个参数，应该是覆盖基类的 __new__ 方法的类，而不是基类，如果传递了基类，你得到的将是基类的示例。 除非你想要按照后面两条描述的方法来使用，否则 __new__ 方法必须要调用基类的 __new__ 方法，这个是创建你的对象的实例的唯一方法。子类的 __new__ 方法可以从两个方面影响产生的实例：传递不同的参数给基类的 __new__，以及修改基类产生的对象（例如初始化一些实例变量） __new__ 方法必须返回一个对象。并不一定必须返回一个新的对象，虽然通常都那么做。如果你返回一个已经存在的对象，依然会有对于 __init__ 构造函数的调用。如果你返回一个其他函数的对象，那个对象的 __init__ 也会被调用。如果忘记返回，python 会给你返回 None，你程序的调用方也许会觉得很奇怪。 对于不可变对象，__new__ 可以返回一个之前缓存的对象。对于一些比较小的 int, str, tuple 类型就是这么做的。这也是为什么他们的 __init__ 什么都没做：否则之前缓存的对象会被 init 很多次。（另外一个原因是本身页没有东西可以给 __init__ 初始化的了，__new__ 返回的就是一个已经初始化的对象）。 如果你想要给一个内置的不可变类型增加一些可变的状态（例如给 string 类型增加一个默认的转换方法），最好是在 __init__ 方法里面初始化可变状态，而不要在 __new__ 里面。 如果你想要修改构造方法的签名，一般需要覆盖 __new__ 和 __init__ 方法来接受心的签名。然而，大部分内置类型都会忽视自己不用的参数，尤其是不可变类型（int，long，float，complex，str，unicode，tuple）都有一个假的 __init__，而可变类型（dict，list，file，super，classmethod，staticmethd，property）有一个假的 __new__。内置类型 object 有假的 __init__ 和 __new__ （给其他对象继承）。内置类型 type 在很多方面都很特别，请参考 metaclasses。 （这条和 __new__ 没关系，但是页应该了解一下）如果新建一个 type 的子类，实例会自动给 __dict__ 和 __weakrefs__ 预留空间（ __dict__ 在你使用前不会初始化，所以你不需要担心创建的所有实例被一个空的字典所占用的空间）。如果不需要这个多余的空间，可以给你的类设置 __slots__ = []（更多信息可以参考 __slots__。 Factoid: __new__ 是一个静态方法，不是类方法。我开始的时候觉得他应该是一个类方法，and that&amp;rsquo;s why I added the classmethod primitive。不幸的是，对于一个类方法，在这种情况下面 upcalls 不工作，所以我只好把他设计成一个第一个参数是一个 class 的静态方法。讽刺的是，there are now no known uses for class methods in the Python distribution (other than in the test suite).</description></item><item><title>Python inherit and super</title><link>https://wdicc.com/python-inherit-and-super/</link><pubDate>Mon, 16 Jan 2017 11:53:04 +0800</pubDate><guid>https://wdicc.com/python-inherit-and-super/</guid><description>又学习了一个 python 的继承。有很多帖子都有介绍，比如理解 Python super，python super()。
先看一个例子，这个是第一个文章里面的。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class Root(object): def __init__(self): print(&amp;#34;this is Root&amp;#34;) class B(Root): def __init__(self): print(&amp;#34;enter B&amp;#34;) super(B, self).__init__() print(&amp;#34;leave B&amp;#34;) class C(Root): def __init__(self): print(&amp;#34;enter C&amp;#34;) super(C, self).</description></item><item><title>Python metaclass</title><link>https://wdicc.com/python-metaclass/</link><pubDate>Thu, 12 Jan 2017 18:26:22 +0800</pubDate><guid>https://wdicc.com/python-metaclass/</guid><description>又理解了一下 python 的 metaclass 可以做什么，尝试记录一下。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Meta(type): register = [] def __new__(cls, class_name, parrent_class, params): print(&amp;#34;In meta new: {}, {}, {}, {}&amp;#34;.format(cls, class_name, parrent_class, params)) cls.register.append(class_name) params[&amp;#39;test_prop&amp;#39;] = True # return super(Meta, cls).__new__(cls, class_name, parrent_class, params) # return type.</description></item><item><title>python 的 decorator 学习</title><link>https://wdicc.com/decorator-in-python/</link><pubDate>Fri, 21 Oct 2016 18:50:59 +0800</pubDate><guid>https://wdicc.com/decorator-in-python/</guid><description>最近学习了一下 python 的 decorator（装饰器），看的是这篇，Python修饰器的函数式编程， 觉得挺有意思的，写点东西记录一下。
装饰器简单讲就是返回一个函数的函数/类。看个简单的例子。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #!/usr/bin/python # -*- coding: utf-8 -*- def dec1(fn): print(&amp;#39;inside dec1&amp;#39;) def wrapper(): print(&amp;#39;inside wrapper&amp;#39;) return fn() return wrapper @dec1 def f1(): print(&amp;#39;inside f1&amp;#39;) if __name__ == &amp;#39;__main__&amp;#39;: print(&amp;#39;begin exec&amp;#39;) f1() print(&amp;#39;end exec&amp;#39;) # 执行结果: # inside dec1 # begin exec # inside wrapper # inside f1 # end exec 看上面例子能看到，装饰器生效有 2 个步骤，第一个是装饰，第二个是执行。上面装饰器的效果，和下面的代码的效果是一样。</description></item><item><title>把 emacs 做为 python ide</title><link>https://wdicc.com/use-emacs-as-python-ide/</link><pubDate>Mon, 13 Jul 2009 00:00:00 +0000</pubDate><guid>https://wdicc.com/use-emacs-as-python-ide/</guid><description>emacs 用的其实不是很多，不过他实在是个好东西，各种 mode，用熟了肯定能帮你提升不少工作速度。
我用 emacs-cvs , ropemacs( dev 版， 0.6 ）, rope ( 0.9.2 ), company-mode ( 0.4.2 ) 这几个软件在 gentoo 里面都还没有，我自己写了几个 ebuild。
装好之后，基本就是 require 一下就好，我没做什么设置，效果如下。
here</description></item><item><title>改良的 fetion.py</title><link>https://wdicc.com/modified-fetion-py/</link><pubDate>Mon, 06 Jul 2009 00:00:00 +0000</pubDate><guid>https://wdicc.com/modified-fetion-py/</guid><description>这个 fetion.py 来自 这里。
不修改的情况下，-t 可以是 sip, uid, mobile_no 这几个。
我修改了下，不加 -t 参数会打印联系人列表。另外还能用 nickname 来发（没测试，我没几个好友，没好意思发）。
在这里。</description></item><item><title>asm 和 python的扯淡 zz</title><link>https://wdicc.com/asm-and-python/</link><pubDate>Thu, 14 May 2009 00:00:00 +0000</pubDate><guid>https://wdicc.com/asm-and-python/</guid><description>python: 兄弟，最近我手头紧，能借点不？
asm: 行，不过怎么你以前不是过得还滋润的，怎么现在混这么差，
python: 不知道啊，现在根本接不到什么项目，听说还有风声要收回我的开发资质。
asm: 你要改变观念，才会有市场。
python: 什么观念？
asm: 现在流行的是软件的要有科学性
python: 什么是软件的科学性？
asm: 我自己也不清楚，不知道哪位大神定义的科学的软件就是要有bug，现在的人们认为软件不可能没有bug，
否则就不是软件，所以bug越多越好，我就非常适合创造bug。搞好点三步一回头，搞不好一步三回头。
python：我不行啊，我开发的东西bug相对少得很多。
asm: 难怪别人不找你做项目。通常别人都认为软件这个东西啊就是通过不断消灭bug，不断创造bug，最终走
向稳定成熟的。你bug要是少了，客户会认为你蒙它，不科学。
python: 太阳啊，我设计出来就是为了减少软件开发少出bug的，这样不是要我的命？
那你开发项目时候弄出那么多bug,进度不是很慢，成本也很高？客户能接受？
asm: 这你不懂,这里的人就是人傻，钱多，你不这样干，他们还认为你是在蒙它，哪里有这么轻易就作出来的东西，
我的特点就是能把简单的东西弄复杂，而你呢，把复杂的东西简单化，显然不受常人的欢迎，人都是好奇的动物，
喜欢复杂的事情，越花花绿绿越好。你还不错了，看Lisp兄弟那惨样。
python: 那项目要是复杂了，规模大了你能应付？
asm: 管他，我也知道我对付不了大规模的项目，用人堆，人月算得高高的，到那个程度，我自己也糊涂了，
不知道要怎么整合了，bug比太平洋里头的珊瑚虫还多，根本做不下去。就给客户说目前技术水平只能达到
这个程度就行了，他们能接受，能将就用就用，不能用就宣告失败。
python: 不会吧，这种规模的东西在我看来并不难啊，项目失败他们不去告你？
asm: 也有告的，不过现在法律有规定，只要你能列出你开发时候的所有设计过程和调试信息，能证明你尽力了，
系统确实复杂到技术是无法解决的，就没事。
python: 你怎么提供?
asm: 我开发的特点你还不知道，代码量本身巨大，调试信息非常多，而且清楚得很，动不动就扔N个core出来，上次那个
破搜索项目我扔了几十T的core给客户，他们还屁颠地当宝一样永久保存
python: 搜索～～，太阳！这些家伙为什么就是不找我？
asm: 现在的人不懂你那套，太玄，你的log绝大部分只记录你逻辑上的东西，现在的客户要求太高了，每一步都要知道CPU各寄存器的状态，
总线电压高低，内存的实时快照，多了。你还自动类型定义，自动类型转换，谁信。什么高阶函数，闭包都冒出来。
你的设计思想不错，我都想学习，不过很难学，至于客户，他们更搞不懂，云里雾里。上次Lisp大兄弟去接个基因分析项目被
人轰了出来，说什么一堆乱七八糟的括号太神秘，什么抽象语法树，语法还能自定义，简直胡扯，就是巫术，内存管理更
不透明。那些客户喜欢看到分配释放内存，很具体，很直观，Python兄弟你这个连内存管理都不给客户看的，也很难混日子。
pyton: 我自己带了gc，又不要他们考虑。
asm: 他们不会吃你gc这套的，你不明确给他们说分配多少字节内存出来，什么时候释放，他们不卖帐。
python: 我太阳，又不是所有项目都要这么控制精细的。
asm: 看我，我每一段代码都很明确，和机器结合得很紧密，写磁盘发个IO指令，让他们看得实在。你那个write太玄乎，到最后写盘还不知道隔了多少层
他们不放心。现在的人认死理，一个问题只能有一个答案，一种解决方法。你看你变化多端，谁都能搞得糊。不过不要紧，我做不下去的时候可以介
绍他们过来给你继续做。
python: 那真的很感谢，最近真的没米下锅，你是帮了我的大忙了。
asm: 没什么，不过我要告诉你的就是这类客户的开发经费被我榨得差不多了，到你那可能没多少钱付给你了。
python: 没关系，再少总比没有好。（哭）
asm: 最后告诉你一个秘密，人的弱点就是天生有奴性，贱，喜欢复杂的东西，好奇，盲从，注重眼前，捡芝麻丢西瓜。</description></item><item><title>写了一个 kde plasma applet</title><link>https://wdicc.com/writing-a-kde-plasma-applet/</link><pubDate>Fri, 23 Jan 2009 00:00:00 +0000</pubDate><guid>https://wdicc.com/writing-a-kde-plasma-applet/</guid><description>用 gnome 的时候，对 panel 上面的 cpu 等 applet 情有独钟。这个东西能让我对自己的系统有第一手信息，有时候某个程序出问题了 cpu 100% 了，这个时候系统反应不一定会变慢的，但是这个程序是必须要被干掉的，有了这个 applet 我就能知道第一时间知道出问题了。还有的时候看 firefox 里面的 flash 的时候也会出类似的情况，这时会导致看别的网页很慢，那就干掉他。
第一次装 kde 的时候发现没有那些东西，让我很失望。后来看到 ob 在 openbox 里面把 panel 设的短一点，然后用 conky 在空出来的地方显示一些信息，感觉豁然开朗啊，呵呵。
这次装好 kde，就弄了一个 conky，可是发现他的风格和系统不兼容。有点不爽，就琢磨自己能不能弄一个，因为需求实在太简单了。
昨天花了一个下午，总算弄好了。参考的文档 qt的类, pyqt4 turtorial,plasma python .
效果就这样。电池旁边那个就是。
代码
from PyQt4.QtCore import * from PyQt4.QtGui import * from PyKDE4.plasma import Plasma from PyKDE4 import plasmascript import time class Cpuinfo(plasmascript.Applet): def __init__(self,parent,args=None): plasmascript.Applet.__init__(self,parent) def init(self): self.freqnow = '' self.</description></item></channel></rss>