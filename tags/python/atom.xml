<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Python on wd and cc</title><link>https://wdicc.com/tags/python/</link><description>Recent content in Python on wd and cc</description><generator>Hugo</generator><language>en</language><copyright>wd © 2025</copyright><lastBuildDate>Sun, 02 Feb 2020 16:20:21 +0800</lastBuildDate><atom:link href="https://wdicc.com/tags/python/atom.xml" rel="self" type="application/rss+xml"/><item><title>Google Python Style Guide</title><link>https://wdicc.com/google-python-style-guide/</link><pubDate>Sun, 02 Feb 2020 16:20:21 +0800</pubDate><guid>https://wdicc.com/google-python-style-guide/</guid><description>&lt;p>
来自&lt;a href="https://google.github.io/styleguide/pyguide.html">这里&lt;/a>。翻译的目的是为了方便快速理解，所以没有太纠结很准确，最好是和英文对应看。&lt;/p>
&lt;div id="outline-container-headline-1" class="outline-3">
&lt;h3 id="headline-1">
1 Background
&lt;/h3>
&lt;div id="outline-text-headline-1" class="outline-text-3">
&lt;p>
Google 的 python 代码风格指导。&lt;/p>
&lt;p>
有一个 vim 的配置。 Emacs 默认的似乎就可以。&lt;/p>
&lt;p>
还有团队使用 yapf 自动格式化代码来避免对格式产生争论。&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-2" class="outline-3">
&lt;h3 id="headline-2">
2 Python Language Rules
&lt;/h3>
&lt;div id="outline-text-headline-2" class="outline-text-3">
&lt;div id="outline-container-headline-3" class="outline-4">
&lt;h4 id="headline-3">
2.1 Lint
&lt;/h4>
&lt;div id="outline-text-headline-3" class="outline-text-4">
&lt;p>
使用 pylint 检查代码。&lt;/p>
&lt;p>
可以通过行内注释关闭一些 warning&lt;/p>
&lt;div class="src src-python">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>dict &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;something awful&amp;#39;&lt;/span> &lt;span style="color:#75715e"># Bad Idea... pylint: disable=redefined-builtin&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-4" class="outline-4">
&lt;h4 id="headline-4">
2.2 Imports
&lt;/h4>
&lt;div id="outline-text-headline-4" class="outline-text-4">
&lt;ul>
&lt;li>&lt;code>import x&lt;/code> 引入包或者模块&lt;/li>
&lt;li>&lt;code>from x import y&lt;/code> x 是包前缀，y 是模块名称&lt;/li>
&lt;li>&lt;code>from x import y as z&lt;/code> 如果有两个模块都叫 y 或者 y 的名字太长了&lt;/li>
&lt;li>&lt;code>import y as z&lt;/code> 只有在 z 是个比较常见的缩写（例如 np 作为 numpy 的缩写）&lt;/li>
&lt;/ul>
&lt;p>例如 &lt;code>sound.effects.echo&lt;/code>&lt;/p></description></item><item><title>Add an Force Sync Button in Django Admin</title><link>https://wdicc.com/add-an-force-sync-button-in-django-admin/</link><pubDate>Thu, 12 Dec 2019 13:33:15 +0800</pubDate><guid>https://wdicc.com/add-an-force-sync-button-in-django-admin/</guid><description>&lt;p>我们的系统里面需要和外部的系统同步一些数据，为了保证数据正确处理，增加了一个队列。队列是通过一个 celery 里面的定时任务同步的。定时任务设置是 5 分钟一次，那有时候测试的时候或者出错的时候就可能会想要立刻执行下同步，好看看执行结果，要不很有可能等到下次执行的时候还是有问题，这就有点浪费时间了。&lt;/p></description></item><item><title>Learning Python Coroutine</title><link>https://wdicc.com/learning-python-coroutine/</link><pubDate>Thu, 17 Oct 2019 10:49:40 +0800</pubDate><guid>https://wdicc.com/learning-python-coroutine/</guid><description>&lt;p>看了一个视频 &lt;a href="https://www.youtube.com/watch?time_continue=1780&amp;amp;v=GSk0tIjDT10">OSB 2015 - How Do Python Coroutines Work?&lt;/a>，从头开始讲 coroutine 是怎么抽象出来的，感觉好厉害。自己写了一点程序学习了一下。之前写的关于 &lt;a href="https://wdicc.com/python-coroutine/">coroutine&lt;/a> 的帖子。&lt;/p>
&lt;p>
先准备一个 &lt;code>server.py&lt;/code> ，可以接受客户端请求。要注意的是要使用 &lt;code>Threading&lt;/code> ，或者 &lt;code>fork&lt;/code> 的 server，要不服务端执行并不支持并发，需要处理完一个才能处理下一个，这样会发现虽然客户端那边请求是并发的，但是返回结果的时候是顺序的。&lt;/p></description></item><item><title>ASGI</title><link>https://wdicc.com/asgi/</link><pubDate>Tue, 15 Oct 2019 14:52:47 +0800</pubDate><guid>https://wdicc.com/asgi/</guid><description>&lt;p>Django 3.0 要支持 ASGI 了，全称 Asynchronous Server Gateway Interface，使用了 coroutines 异步。WSGI 是目前普遍使用的，把进来的请求标准化处理之后，交给 WSGI 程序，这个支持的是请求来了，处理完毕，返回结果这样的模型。对于像 websockt 这样的就不太友好了，websockt 实际是建立连接之后会持续发送请求和接收结果，所以有了 ASGI。&lt;/p></description></item><item><title>Notes for CPython Internals</title><link>https://wdicc.com/notes-for-cpython-internals/</link><pubDate>Thu, 05 Sep 2019 12:43:42 +0800</pubDate><guid>https://wdicc.com/notes-for-cpython-internals/</guid><description>&lt;p>视频地址&lt;a href="https://www.youtube.com/watch?list=PLzV58Zm8FuBL6OAv1Yu6AwXZrnsFbbR0S&amp;amp;index=1">这里&lt;/a>。&lt;/p>
&lt;div id="outline-container-headline-1" class="outline-3">
&lt;h3 id="headline-1">
Python 源码
&lt;/h3>
&lt;div id="outline-text-headline-1" class="outline-text-3">
&lt;p>
&lt;code>Include/opcode.h&lt;/code> 里面定义了所有 opcode。 &lt;code>Modules&lt;/code> 里面是一些 c 实现的模块， &lt;code>Lib&lt;/code> 里面是用 python 实现的模块。 &lt;code>Objects&lt;/code> 里面是部分 python 对象对应的 c 实现。&lt;/p>
&lt;p>
&lt;code>Python&lt;/code> 目录里面是 python core， &lt;code>Python/ceval.c&lt;/code> 里面定义了 python interpreter 主要的循环，找那个 &lt;code>for(;;)&lt;/code> 就可以，这个循环里面有一个巨长的 &lt;code>switch (opcode)&lt;/code> 。&lt;/p></description></item><item><title>Python Coroutine</title><link>https://wdicc.com/python-coroutine/</link><pubDate>Tue, 27 Aug 2019 10:49:51 +0800</pubDate><guid>https://wdicc.com/python-coroutine/</guid><description>&lt;p>
协程 coroutine 不知道是从什么时候开始的，感觉我第一次看到是 lua 里面支持 yield 。后面看到就是 javascript 里面的 Promise，async 和 await。&lt;/p>
&lt;p>
以前写 Javascript 的时候容易会遇到 callback hell，似乎 Promise 就是出来解决这个问题的，让你可以用同步的方式写异步程序。例如你有三个异步请求可以同时发出去，而后面的结果又需要这三个的结果都回来才能继续，那就可以用类似下面的伪代码，整体执行时间是最长的那个。&lt;/p></description></item><item><title>Book Review of Effective Python: 59 Specific Ways to Write Better Python</title><link>https://wdicc.com/book-review-of-effective-python/</link><pubDate>Mon, 26 Aug 2019 09:53:26 +0800</pubDate><guid>https://wdicc.com/book-review-of-effective-python/</guid><description>&lt;p>书名是《Effective Python：编写高质量 Python 代码的 59 个方法》这本书买了大概 2 年，一直没看完，前几天找了一些时间看完了。&lt;/p>
&lt;p>
这书是针对中级 Python 程序员的，里面没有对于语法什么的讲解，也没有对 c 代码实现的讲解，针对中级程序员。&lt;/p></description></item><item><title>Run Command Through Python</title><link>https://wdicc.com/run-command-through-python/</link><pubDate>Tue, 13 Aug 2019 14:53:34 +0800</pubDate><guid>https://wdicc.com/run-command-through-python/</guid><description>&lt;p>
通过 python 执行命令有很多方法。&lt;/p>
&lt;p>
最简单的 &lt;code class="verbatim">os.system(command)&lt;/code> , command 是要执行的命令，一个包括命令和参数的字符串。产生的输出会直接打印到 stdout 。返回值是命令执行的退出值。&lt;/p>
&lt;p>
然后就是 &lt;code class="verbatim">os.spawn*&lt;/code> ，这个我感觉有点丧心病狂了。&lt;/p>
&lt;ul>
&lt;li>os.spawnl(mode, path, …)&lt;/li>
&lt;li>os.spawnle(mode, path, …, env)&lt;/li>
&lt;li>os.spawnlp(mode, file, …)&lt;/li>
&lt;li>os.spawnlpe(mode, file, …, env)&lt;/li>
&lt;li>os.spawnv(mode, path, args)&lt;/li>
&lt;li>os.spawnve(mode, path, args, env)&lt;/li>
&lt;li>os.spawnvp(mode, file, args)&lt;/li>
&lt;li>os.spawnvpe(mode, file, args, env)&lt;/li>
&lt;/ul>
&lt;p>这些主要是命令输入的方式，和环境变量的控制不一样， &lt;code class="verbatim">l&lt;/code> 是类似 os.spawnlp(os.P_WAIT, &lt;code class="verbatim">&amp;#39;cp&amp;#39;, &amp;#39;cp&amp;#39;, &amp;#39;index.html&amp;#39;, &amp;#39;/dev/null&amp;#39;&lt;/code> ) 这样的模式设置命令, &lt;code class="verbatim">v&lt;/code> 是类似 os.spawnvp(os.P_WAIT, &amp;#39;cp&amp;#39;, &lt;code class="verbatim">[&amp;#39;cp&amp;#39;, &amp;#39;index.html&amp;#39;, &amp;#39;/dev/null&amp;#39;]&lt;/code> ) 这样的模式。 &lt;code class="verbatim">l&lt;/code> 适合命令参数固定的模式， &lt;code class="verbatim">v&lt;/code> 适合不固定的。&lt;/p></description></item><item><title>An Interesting Python Function</title><link>https://wdicc.com/an-interesting-python-function/</link><pubDate>Wed, 07 Aug 2019 16:53:09 +0800</pubDate><guid>https://wdicc.com/an-interesting-python-function/</guid><description>&lt;p>
&lt;a href="https://pythontips.com/2019/07/30/python-mind-teaser-make-the-function-return-true/">这里&lt;/a>看到的，感觉挺有意思的，记录一下。题目来自&lt;a href="https://www.reddit.com/r/Python/comments/cje5yh/short_python_challenge_make_this_return_true/">这里&lt;/a>。&lt;/p>
&lt;p>
如何让下面这个函数返回 &lt;code class="verbatim">True&lt;/code> ？&lt;/p>
&lt;div class="src src-python">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">check&lt;/span>(x):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> x&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">is&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">+&lt;/span>x:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">False&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> x&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">is&lt;/span> &lt;span style="color:#f92672">not&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#f92672">+&lt;/span>x:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">True&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-1" class="outline-3">
&lt;h3 id="headline-1">
解法1: 自定义类
&lt;/h3>
&lt;div id="outline-text-headline-1" class="outline-text-3">
&lt;div class="src src-python">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">check&lt;/span>(x):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> x&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">is&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">+&lt;/span>x:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">False&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> x&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">is&lt;/span> &lt;span style="color:#f92672">not&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#f92672">+&lt;/span>x:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">False&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">True&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Test&lt;/span>(int):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> __add__(self, v):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> v &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> v
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(check(Test()))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># output: True&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
如果一个对象是在 &lt;code class="verbatim">+&lt;/code> 的左侧，那会调用 &lt;code class="verbatim">__add__&lt;/code> ，如果在右侧，会调用 &lt;code class="verbatim">__radd__&lt;/code> 。上面的 &lt;code class="verbatim">Test&lt;/code> 类继承自 int，重写了其中的 &lt;code class="verbatim">__add__&lt;/code> 方法，但是保留了 &lt;code class="verbatim">__radd__&lt;/code> ，所以上面的例子里面， &lt;code class="verbatim">Test()+1&lt;/code> 会返回 0， &lt;code class="verbatim">1+test()&lt;/code> 会返回 1。 &lt;code class="verbatim">Test()+2&lt;/code> 会返回 2， &lt;code class="verbatim">2+Test()&lt;/code> 也会返回 2。&lt;/p></description></item><item><title>Emacs as python IDE</title><link>https://wdicc.com/emacs-as-python-ide/</link><pubDate>Fri, 30 Jun 2017 20:47:56 +0800</pubDate><guid>https://wdicc.com/emacs-as-python-ide/</guid><description>&lt;p>
最近 python 写的比较多，比较了几个编辑器，最后还是留下了 emacs。&lt;/p>
&lt;p>
主要比较了 emacs 和 pycharm。pycharm 绝对是一个很强的 IDE，几乎可以补全任何东西，写代码各种提示。比如 Django 里面定义一个 model User 之后，就可以 &lt;code class="verbatim">User.&lt;/code> 之后提示 &lt;code class="verbatim">objects&lt;/code> ，这个是依据 metaclass 来补全的。另外还有比如写 &lt;code class="verbatim">User.objects.get(|)&lt;/code> 的时候，光标在竖线那个位置，会提示 &lt;code class="verbatim">User&lt;/code> 的字段，这个相当好用。这两个只是皮毛，实在是太好用了。&lt;/p></description></item><item><title>Python __new__</title><link>https://wdicc.com/python-new/</link><pubDate>Mon, 16 Jan 2017 15:47:59 +0800</pubDate><guid>https://wdicc.com/python-new/</guid><description>&lt;p>翻译一点 &lt;a href="https://www.python.org/download/releases/2.2/descrintro/#__new">https://www.python.org/download/releases/2.2/descrintro/#__new&lt;/a>__ 有些感觉还是挺生硬的，方便自己理解吧。&lt;/p>
&lt;p>&lt;code>__new__&lt;/code> 的一些规则:&lt;/p>
&lt;ul>
&lt;li>&lt;code>__new__&lt;/code> 是一个静态方法。定义它的时候并不需要执行 &lt;code>__new__ = staticmethod(__new__)&lt;/code>，因为它的名字就包含了这个含义（这个对于类构造方法来说是个特殊的函数）&lt;/li>
&lt;li>&lt;code>__new__&lt;/code> 的第一个参数，必须是一个类，其余的参数是留给构造方法的。&lt;/li>
&lt;li>覆盖了基类的 &lt;code>__new__&lt;/code> 方法的类有可能会调用基类的 &lt;code>__new__&lt;/code> 方法。传递给基类的 &lt;code>__new__&lt;/code> 方法的第一个参数，应该是覆盖基类的 &lt;code>__new__&lt;/code> 方法的类，而不是基类，如果传递了基类，你得到的将是基类的示例。&lt;/li>
&lt;li>除非你想要按照后面两条描述的方法来使用，否则 &lt;code>__new__&lt;/code> 方法必须要调用基类的 &lt;code>__new__&lt;/code> 方法，这个是创建你的对象的实例的唯一方法。子类的 &lt;code>__new__&lt;/code> 方法可以从两个方面影响产生的实例：传递不同的参数给基类的 &lt;code>__new__&lt;/code>，以及修改基类产生的对象（例如初始化一些实例变量）&lt;/li>
&lt;li>&lt;code>__new__&lt;/code> 方法必须返回一个对象。并不一定必须返回一个新的对象，虽然通常都那么做。如果你返回一个已经存在的对象，依然会有对于 &lt;code>__init__&lt;/code> 构造函数的调用。如果你返回一个其他函数的对象，那个对象的 &lt;code>__init__&lt;/code> 也会被调用。如果忘记返回，python 会给你返回 None，你程序的调用方也许会觉得很奇怪。&lt;/li>
&lt;li>对于不可变对象，&lt;code>__new__&lt;/code> 可以返回一个之前缓存的对象。对于一些比较小的 int, str, tuple 类型就是这么做的。这也是为什么他们的 &lt;code>__init__&lt;/code> 什么都没做：否则之前缓存的对象会被 init 很多次。（另外一个原因是本身页没有东西可以给 &lt;code>__init__&lt;/code> 初始化的了，&lt;code>__new__&lt;/code> 返回的就是一个已经初始化的对象）。&lt;/li>
&lt;li>如果你想要给一个内置的不可变类型增加一些可变的状态（例如给 string 类型增加一个默认的转换方法），最好是在 &lt;code>__init__&lt;/code> 方法里面初始化可变状态，而不要在 &lt;code>__new__&lt;/code> 里面。&lt;/li>
&lt;li>如果你想要修改构造方法的签名，一般需要覆盖 &lt;code>__new__&lt;/code> 和 &lt;code>__init__&lt;/code> 方法来接受心的签名。然而，大部分内置类型都会忽视自己不用的参数，尤其是不可变类型（int，long，float，complex，str，unicode，tuple）都有一个假的 &lt;code>__init__&lt;/code>，而可变类型（dict，list，file，super，classmethod，staticmethd，property）有一个假的 &lt;code>__new__&lt;/code>。内置类型 &lt;code>object&lt;/code> 有假的 &lt;code>__init__&lt;/code> 和 &lt;code>__new__&lt;/code> （给其他对象继承）。内置类型 &lt;code>type&lt;/code> 在很多方面都很特别，请参考 metaclasses。&lt;/li>
&lt;li>（这条和 &lt;code>__new__&lt;/code> 没关系，但是页应该了解一下）如果新建一个 &lt;code>type&lt;/code> 的子类，实例会自动给 &lt;code>__dict__&lt;/code> 和 &lt;code>__weakrefs__&lt;/code> 预留空间（ &lt;code>__dict__&lt;/code> 在你使用前不会初始化，所以你不需要担心创建的所有实例被一个空的字典所占用的空间）。如果不需要这个多余的空间，可以给你的类设置 &lt;code>__slots__ = []&lt;/code>（更多信息可以参考 &lt;code>__slots__&lt;/code>。&lt;/li>
&lt;li>Factoid: &lt;code>__new__&lt;/code> 是一个静态方法，不是类方法。我开始的时候觉得他应该是一个类方法，and that&amp;rsquo;s why I added the classmethod primitive。不幸的是，对于一个类方法，在这种情况下面 upcalls 不工作，所以我只好把他设计成一个第一个参数是一个 class 的静态方法。讽刺的是，there are now no known uses for class methods in the Python distribution (other than in the test suite). I might even get rid of classmethod in a future release if no good use for it can be found!&lt;/li>
&lt;/ul></description></item><item><title>Python inherit and super</title><link>https://wdicc.com/python-inherit-and-super/</link><pubDate>Mon, 16 Jan 2017 11:53:04 +0800</pubDate><guid>https://wdicc.com/python-inherit-and-super/</guid><description>&lt;p>又学习了一个 python 的继承。有很多帖子都有介绍，比如&lt;a href="https://laike9m.com/blog/li-jie-python-super,70/">理解 Python super&lt;/a>，&lt;a href="http://www.cnblogs.com/lovemo1314/archive/2011/05/03/2035005.html">python super()&lt;/a>。&lt;/p>
&lt;p>先看一个例子，这个是第一个文章里面的。&lt;/p>
&lt;pre tabindex="0">&lt;code>class Root(object):
 def __init__(self):
 print(&amp;#34;this is Root&amp;#34;)


class B(Root):
 def __init__(self):
 print(&amp;#34;enter B&amp;#34;)
 super(B, self).__init__()
 print(&amp;#34;leave B&amp;#34;)


class C(Root):
 def __init__(self):
 print(&amp;#34;enter C&amp;#34;)
 super(C, self).__init__()
 print(&amp;#34;leave C&amp;#34;)


class D(C):
 def __init__(self):
 print(&amp;#34;enter D&amp;#34;)
 super(D, self).__init__()
 print(&amp;#34;leave D&amp;#34;)


class E(D, B):
 def __init__(self):
 print(&amp;#34;enter E&amp;#34;)
 super(E, self).__init__()
 print(&amp;#34;leave E&amp;#34;)

e = E()
print(e.__class__.mro())

# results:
# enter E
# enter D
# enter C
# enter B
# this is Root
# leave B
# leave C
# leave D
# leave E
# [&amp;lt;class &amp;#39;__main__.E&amp;#39;&amp;gt;, &amp;lt;class &amp;#39;__main__.D&amp;#39;&amp;gt;, &amp;lt;class &amp;#39;__main__.C&amp;#39;&amp;gt;, &amp;lt;class &amp;#39;__main__.B&amp;#39;&amp;gt;, &amp;lt;class &amp;#39;__main__.Root&amp;#39;&amp;gt;, &amp;lt;class &amp;#39;object&amp;#39;&amp;gt;]
&lt;/code>&lt;/pre>&lt;p>没有什么问题，所有的类都做了初始化，很完美。接着再看一个例子，这个例子其实是上面第二篇文章里面的。&lt;/p></description></item><item><title>Python metaclass</title><link>https://wdicc.com/python-metaclass/</link><pubDate>Thu, 12 Jan 2017 18:26:22 +0800</pubDate><guid>https://wdicc.com/python-metaclass/</guid><description>&lt;p>又理解了一下 python 的 metaclass 可以做什么，尝试记录一下。&lt;/p>
&lt;pre tabindex="0">&lt;code>class Meta(type):
 register = []

 def __new__(cls, class_name, parrent_class, params):
 print(&amp;#34;In meta new: {}, {}, {}, {}&amp;#34;.format(cls, class_name, parrent_class, params))
 cls.register.append(class_name)
 params[&amp;#39;test_prop&amp;#39;] = True
 # return super(Meta, cls).__new__(cls, class_name, parrent_class, params)
 # return type.__new__(cls, class_name, parrent_class, params)
 # return super(Meta, cls).__new__(type, class_name, parrent_class, params)
 # return type.__new__(type, class_name, parrent_class, params)
 return type(class_name, parrent_class, params)

 def __init__(self, class_name, parrent_class, params):
 print(&amp;#34;In meta init: {}, {}, {}&amp;#34;.format(class_name, parrent_class, params))
 super(Meta, self).__init__(class_name, parrent_class, params)


class A(object, metaclass=Meta):
 pass

print(&amp;#34;register: {}&amp;#34;.format(Meta.register))
print(&amp;#34;prop: {}&amp;#34;.format(A.test_prop))
print(&amp;#34;register: {}&amp;#34;.format(A.register)) # Error

# outputs:
# In meta new: &amp;lt;class &amp;#39;__main__.Meta&amp;#39;&amp;gt;, A, (&amp;lt;class &amp;#39;object&amp;#39;&amp;gt;,), {&amp;#39;__module__&amp;#39;: &amp;#39;__main__&amp;#39;, &amp;#39;__qualname__&amp;#39;: &amp;#39;A&amp;#39;}
# In meta init: A, (&amp;lt;class &amp;#39;object&amp;#39;&amp;gt;,), {&amp;#39;__module__&amp;#39;: &amp;#39;__main__&amp;#39;, &amp;#39;__qualname__&amp;#39;: &amp;#39;A&amp;#39;}
# register: [&amp;#39;A&amp;#39;]
# prop: True
# AttributeError: type object &amp;#39;A&amp;#39; has no attribute &amp;#39;register&amp;#39;
&lt;/code>&lt;/pre>&lt;p>可以看到，在构造 &lt;code>A&lt;/code> 的时候，&lt;code>Meta&lt;/code> 这个类里面，&lt;code>__new__&lt;/code> 和 &lt;code>__init__&lt;/code> 都会被调用到。上面代码往 &lt;code>A&lt;/code> 里面塞了一个属性。&lt;/p></description></item><item><title>python 的 decorator 学习</title><link>https://wdicc.com/decorator-in-python/</link><pubDate>Fri, 21 Oct 2016 18:50:59 +0800</pubDate><guid>https://wdicc.com/decorator-in-python/</guid><description>&lt;p>最近学习了一下 python 的 decorator（装饰器），看的是这篇，&lt;a href="http://coolshell.cn/articles/11265.html">Python修饰器的函数式编程&lt;/a>， 觉得挺有意思的，写点东西记录一下。&lt;/p>
&lt;p>装饰器简单讲就是返回一个函数的函数/类。看个简单的例子。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/usr/bin/python&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># -*- coding: utf-8 -*-&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">dec1&lt;/span>(fn):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(&lt;span style="color:#e6db74">&amp;#39;inside dec1&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">wrapper&lt;/span>():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(&lt;span style="color:#e6db74">&amp;#39;inside wrapper&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> fn()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> wrapper
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@dec1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">f1&lt;/span>():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(&lt;span style="color:#e6db74">&amp;#39;inside f1&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> __name__ &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;__main__&amp;#39;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(&lt;span style="color:#e6db74">&amp;#39;begin exec&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> f1()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(&lt;span style="color:#e6db74">&amp;#39;end exec&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 执行结果:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># inside dec1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># begin exec&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># inside wrapper&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># inside f1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># end exec&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>看上面例子能看到，装饰器生效有 2 个步骤，第一个是装饰，第二个是执行。上面装饰器的效果，和下面的代码的效果是一样。&lt;/p></description></item><item><title>把 emacs 做为 python ide</title><link>https://wdicc.com/use-emacs-as-python-ide/</link><pubDate>Mon, 13 Jul 2009 00:00:00 +0000</pubDate><guid>https://wdicc.com/use-emacs-as-python-ide/</guid><description>emacs 用的其实不是很多，不过他实在是个好东西，各种 mode，用熟了肯定能帮你提升不少工作速度。&lt;br />

我用 emacs-cvs , ropemacs( dev 版， > 0.6 ）, rope ( > 0.9.2 ), company-mode ( > 0.4.2 ) 这几个软件在 gentoo 里面都还没有，我自己写了几个 ebuild。&lt;br />

装好之后，基本就是 require 一下就好，我没做什么设置，效果如下。&lt;br />

&lt;a href="http://twitpic.com/a70je">here&lt;/a>&lt;br /></description></item><item><title>改良的 fetion.py</title><link>https://wdicc.com/modified-fetion-py/</link><pubDate>Mon, 06 Jul 2009 00:00:00 +0000</pubDate><guid>https://wdicc.com/modified-fetion-py/</guid><description>这个 fetion.py 来自 &lt;a href="http://blog.lazytech.info/2008/11/05/python-fetion/">这里&lt;/a>。&lt;br />

不修改的情况下，-t 可以是 sip, uid, mobile_no 这几个。&lt;br />

我修改了下，不加 -t 参数会打印联系人列表。另外还能用 nickname 来发（没测试，我没几个好友，没好意思发）。&lt;br />

在&lt;a href="http://github.com/wd/work/tree/aa559b6b3ee1c15ccfcbf9ce45d1f7aa2208b953/fetion_py">这里&lt;/a>。&lt;br /></description></item><item><title>asm 和 python的扯淡 zz</title><link>https://wdicc.com/asm-and-python/</link><pubDate>Thu, 14 May 2009 00:00:00 +0000</pubDate><guid>https://wdicc.com/asm-and-python/</guid><description>&lt;p>python: 兄弟，最近我手头紧，能借点不？&lt;br />&lt;br />asm: 行，不过怎么你以前不是过得还滋润的，怎么现在混这么差，&lt;br />&lt;br />python: 不知道啊，现在根本接不到什么项目，听说还有风声要收回我的开发资质。&lt;br />&lt;br />asm: 你要改变观念，才会有市场。&lt;br />&lt;br />python: 什么观念？&lt;br />&lt;br />asm: 现在流行的是软件的要有科学性&lt;br />&lt;br />python: 什么是软件的科学性？&lt;br />&lt;br />asm: 我自己也不清楚，不知道哪位大神定义的科学的软件就是要有bug，现在的人们认为软件不可能没有bug，&lt;br />否则就不是软件，所以bug越多越好，我就非常适合创造bug。搞好点三步一回头，搞不好一步三回头。&lt;br />&lt;br />python：我不行啊，我开发的东西bug相对少得很多。&lt;br />&lt;br />asm: 难怪别人不找你做项目。通常别人都认为软件这个东西啊就是通过不断消灭bug，不断创造bug，最终走&lt;br />向稳定成熟的。你bug要是少了，客户会认为你蒙它，不科学。&lt;br />&lt;br />python: 太阳啊，我设计出来就是为了减少软件开发少出bug的，这样不是要我的命？&lt;br />那你开发项目时候弄出那么多bug,进度不是很慢，成本也很高？客户能接受？&lt;br />&lt;br />asm: 这你不懂,这里的人就是人傻，钱多，你不这样干，他们还认为你是在蒙它，哪里有这么轻易就作出来的东西，&lt;br />我的特点就是能把简单的东西弄复杂，而你呢，把复杂的东西简单化，显然不受常人的欢迎，人都是好奇的动物，&lt;br />喜欢复杂的事情，越花花绿绿越好。你还不错了，看Lisp兄弟那惨样。&lt;br />&lt;br />python: 那项目要是复杂了，规模大了你能应付？&lt;br />&lt;br />asm: 管他，我也知道我对付不了大规模的项目，用人堆，人月算得高高的，到那个程度，我自己也糊涂了，&lt;br />不知道要怎么整合了，bug比太平洋里头的珊瑚虫还多，根本做不下去。就给客户说目前技术水平只能达到&lt;br />这个程度就行了，他们能接受，能将就用就用，不能用就宣告失败。&lt;br />&lt;br />python: 不会吧，这种规模的东西在我看来并不难啊，项目失败他们不去告你？&lt;br />&lt;br />asm: 也有告的，不过现在法律有规定，只要你能列出你开发时候的所有设计过程和调试信息，能证明你尽力了，&lt;br />系统确实复杂到技术是无法解决的，就没事。&lt;br />python: 你怎么提供?&lt;br />&lt;br />asm: 我开发的特点你还不知道，代码量本身巨大，调试信息非常多，而且清楚得很，动不动就扔N个core出来，上次那个&lt;br />破搜索项目我扔了几十T的core给客户，他们还屁颠地当宝一样永久保存&lt;br />&lt;br />python: 搜索～～，太阳！这些家伙为什么就是不找我？&lt;br />&lt;br />asm: 现在的人不懂你那套，太玄，你的log绝大部分只记录你逻辑上的东西，现在的客户要求太高了，每一步都要知道CPU各寄存器的状态，&lt;br />总线电压高低，内存的实时快照，多了。你还自动类型定义，自动类型转换，谁信。什么高阶函数，闭包都冒出来。&lt;br />你的设计思想不错，我都想学习，不过很难学，至于客户，他们更搞不懂，云里雾里。上次Lisp大兄弟去接个基因分析项目被&lt;br />人轰了出来，说什么一堆乱七八糟的括号太神秘，什么抽象语法树，语法还能自定义，简直胡扯，就是巫术，内存管理更&lt;br />不透明。那些客户喜欢看到分配释放内存，很具体，很直观，Python兄弟你这个连内存管理都不给客户看的，也很难混日子。&lt;br />&lt;br />pyton: 我自己带了gc，又不要他们考虑。&lt;br />&lt;br />asm: 他们不会吃你gc这套的，你不明确给他们说分配多少字节内存出来，什么时候释放，他们不卖帐。&lt;br />&lt;br />python: 我太阳，又不是所有项目都要这么控制精细的。&lt;br />&lt;br />asm: 看我，我每一段代码都很明确，和机器结合得很紧密，写磁盘发个IO指令，让他们看得实在。你那个write太玄乎，到最后写盘还不知道隔了多少层&lt;br />他们不放心。现在的人认死理，一个问题只能有一个答案，一种解决方法。你看你变化多端，谁都能搞得糊。不过不要紧，我做不下去的时候可以介&lt;br />绍他们过来给你继续做。&lt;br />&lt;br />python: 那真的很感谢，最近真的没米下锅，你是帮了我的大忙了。&lt;br />&lt;br />asm: 没什么，不过我要告诉你的就是这类客户的开发经费被我榨得差不多了，到你那可能没多少钱付给你了。&lt;br />&lt;br />python: 没关系，再少总比没有好。（哭）&lt;br />&lt;br />asm: 最后告诉你一个秘密，人的弱点就是天生有奴性，贱，喜欢复杂的东西，好奇，盲从，注重眼前，捡芝麻丢西瓜。&lt;br />对简洁的东西不感兴趣。因为他们通常认为简洁就是简单。书从薄读到厚，又从厚读到薄 的人没几个的。太相信&lt;br />自己的眼睛，不相信自己的心。我猜可能是猪油吃太多了的缘故。 表面的东西他们非常热衷，看得到，实在。喜欢&lt;br />追涨杀跌，所以股市里头为什么那么多人输钱，就是这样，你弄得越火热，价格越高，越多人买，生怕赶不上末班车，&lt;br />价格越掉越不买，持币待购。我早期玩股票，学了点技术，觉得自己无所不能了，也来搞一把，也是整天盯着盘，&lt;br />那个实时价格跳得我心都肿了，输得去穿strip，后来学乖了，抓住趋势，买入，中间不看了细节了，趋势没了就抛了，&lt;br />最后挣钱了。前几年房价疯涨，多少人怕涨到天上去，砸锅卖铁，把下辈子的养老钱都预支出来去买，看现在，傻了吧。&lt;br />所以有些复杂的东西，你越想从细节控制它，它越不听你的话，你和它对抗没用，早晚死它手里，要顺势。&lt;br />明白了，今后你要挣这些人的钱，要抓他们的弱点。&lt;br />&lt;/p></description></item><item><title>写了一个 kde plasma applet</title><link>https://wdicc.com/writing-a-kde-plasma-applet/</link><pubDate>Fri, 23 Jan 2009 00:00:00 +0000</pubDate><guid>https://wdicc.com/writing-a-kde-plasma-applet/</guid><description>用 gnome 的时候，对 panel 上面的 cpu 等 applet 情有独钟。这个东西能让我对自己的系统有第一手信息，有时候某个程序出问题了 cpu 100% 了，这个时候系统反应不一定会变慢的，但是这个程序是必须要被干掉的，有了这个 applet 我就能知道第一时间知道出问题了。还有的时候看 firefox 里面的 flash 的时候也会出类似的情况，这时会导致看别的网页很慢，那就干掉他。&lt;br />

第一次装 kde 的时候发现没有那些东西，让我很失望。后来看到 ob 在 openbox 里面把 panel 设的短一点，然后用 conky 在空出来的地方显示一些信息，感觉豁然开朗啊，呵呵。&lt;br />

这次装好 kde，就弄了一个 conky，可是发现他的风格和系统不兼容。有点不爽，就琢磨自己能不能弄一个，因为需求实在太简单了。&lt;br />

昨天花了一个下午，总算弄好了。参考的文档 &lt;a href="http://www.qtopia.org.cn/doc/qiliang.net/qt/classes.html">qt的类&lt;/a>, &lt;a href="http://www.zetcode.com/tutorials/pyqt4/">pyqt4 turtorial&lt;/a>,&lt;a href="http://techbase.kde.org/Development/Tutorials/Plasma/Python/GettingStarted">plasma python&lt;/a> .&lt;br />

效果就这样。电池旁边那个就是。&lt;br />

&lt;a href="http://img339.imageshack.us/img339/6986/200901231045132304x1024oo0.png" target="_blank">&lt;img src="http://img339.imageshack.us/img339/6986/200901231045132304x1024oo0.png" alt="" width="300" />&lt;/a>&lt;br />

代码&lt;br />
&lt;pre class="prettyprint lang-python">
from PyQt4.QtCore import *
from PyQt4.QtGui import *
from PyKDE4.plasma import Plasma
from PyKDE4 import plasmascript
import time 

class Cpuinfo(plasmascript.Applet):
 def __init__(self,parent,args=None):
 plasmascript.Applet.__init__(self,parent)

 def init(self):
 self.freqnow = ''
 self.freqmax = ''
 self.temp = ''
 self.text = '' 

 self.getCurrentFreq()
 self.getMaxFreq()
 self.getTemp() 

 self.setHasConfigurationInterface(False)
 self.setMinimumWidth(100)
 self.setAspectRatioMode(Plasma.Square)
 self.startTimer(1000)

 def getCurrentFreq (self):
 line = open ('/sys/devices/system/cpu/cpu0/cpufreq/scaling_cur_freq', 'r').read().rstrip('\n')
 line = int(line) / 1000 /1000.0
 self.freqnow = line

 def getMaxFreq (self):
 line = file('/sys/devices/system/cpu/cpu0/cpufreq/scaling_max_freq', 'r').read().rstrip('\n')
 line = int(line) / 1000 /1000.0
 self.freqmax = line

 def getTemp (self):
 line = file('/proc/acpi/thermal_zone/TZ1/temperature', 'r').read().rstrip('\n')
 line = " ".join(line.split()[1:])
 self.temp = line

 def timerEvent(self, event):
 self.getCurrentFreq()
 self.getTemp()
 self.text = "%s\n%.2f %d%%" % (self.temp, self.freqnow, self.freqnow / self.freqmax * 100)
 self.update() 

 def paintInterface(self, painter, option, rect):
 painter.save()
 painter.setPen(Qt.white)
 #painter.setFont(QFont('Consolas',11))
 painter.drawText(rect, Qt.AlignVCenter | Qt.AlignHCenter, self.text)
 painter.restore()

def CreateApplet(parent):
 return Cpuinfo(parent)

if __name__ == '__main__':
 a = Cpuinfo(None)
 a.init()
 print a.freqnow&lt;/pre></description></item></channel></rss>