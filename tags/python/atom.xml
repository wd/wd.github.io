<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python on wd and cc</title>
    <link>https://wdicc.com/tags/python/atom/index.xml</link>
    <description>Recent content in Python on wd and cc</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <atom:link href="https://wdicc.com/tags/python/atom/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Python __new__</title>
      <link>https://wdicc.com/Python-new/</link>
      <pubDate>Mon, 16 Jan 2017 15:47:59 +0800</pubDate>
      
      <guid>https://wdicc.com/Python-new/</guid>
      <description>&lt;p&gt;翻译一点 &lt;a href=&#34;https://www.python.org/download/releases/2.2/descrintro/#__new__&#34;&gt;https://www.python.org/download/releases/2.2/descrintro/#__new__&lt;/a&gt; 有些感觉还是挺生硬的，方便自己理解吧。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;__new__&lt;/code&gt; 的一些规则:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;__new__&lt;/code&gt; 是一个静态方法。定义它的时候并不需要执行 &lt;code&gt;__new__ = staticmethod(__new__)&lt;/code&gt;，因为它的名字就包含了这个含义（这个对于类构造方法来说是个特殊的函数）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__new__&lt;/code&gt; 的第一个参数，必须是一个类，其余的参数是留给构造方法的。&lt;/li&gt;
&lt;li&gt;覆盖了基类的 &lt;code&gt;__new__&lt;/code&gt; 方法的类有可能会调用基类的 &lt;code&gt;__new__&lt;/code&gt; 方法。传递给基类的 &lt;code&gt;__new__&lt;/code&gt; 方法的第一个参数，应该是覆盖基类的 &lt;code&gt;__new__&lt;/code&gt; 方法的类，而不是基类，如果传递了基类，你得到的将是基类的示例。&lt;/li&gt;
&lt;li&gt;除非你想要按照后面两条描述的方法来使用，否则 &lt;code&gt;__new__&lt;/code&gt; 方法必须要调用基类的 &lt;code&gt;__new__&lt;/code&gt; 方法，这个是创建你的对象的实例的唯一方法。子类的 &lt;code&gt;__new__&lt;/code&gt; 方法可以从两个方面影响产生的实例：传递不同的参数给基类的 &lt;code&gt;__new__&lt;/code&gt;，以及修改基类产生的对象（例如初始化一些实例变量）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__new__&lt;/code&gt; 方法必须返回一个对象。并不一定必须返回一个新的对象，虽然通常都那么做。如果你返回一个已经存在的对象，依然会有对于 &lt;code&gt;__init__&lt;/code&gt; 构造函数的调用。如果你返回一个其他函数的对象，那个对象的 &lt;code&gt;__init__&lt;/code&gt; 也会被调用。如果忘记返回，python 会给你返回 None，你程序的调用方也许会觉得很奇怪。&lt;/li&gt;
&lt;li&gt;对于不可变对象，&lt;code&gt;__new__&lt;/code&gt; 可以返回一个之前缓存的对象。对于一些比较小的 int, str, tuple 类型就是这么做的。这也是为什么他们的 &lt;code&gt;__init__&lt;/code&gt; 什么都没做：否则之前缓存的对象会被 init 很多次。（另外一个原因是本身页没有东西可以给 &lt;code&gt;__init__&lt;/code&gt; 初始化的了，&lt;code&gt;__new__&lt;/code&gt; 返回的就是一个已经初始化的对象）。&lt;/li&gt;
&lt;li&gt;如果你想要给一个内置的不可变类型增加一些可变的状态（例如给 string 类型增加一个默认的转换方法），最好是在 &lt;code&gt;__init__&lt;/code&gt; 方法里面初始化可变状态，而不要在 &lt;code&gt;__new__&lt;/code&gt; 里面。&lt;/li&gt;
&lt;li&gt;如果你想要修改构造方法的签名，一般需要覆盖 &lt;code&gt;__new__&lt;/code&gt; 和 &lt;code&gt;__init__&lt;/code&gt; 方法来接受心的签名。然而，大部分内置类型都会忽视自己不用的参数，尤其是不可变类型（int，long，float，complex，str，unicode，tuple）都有一个假的 &lt;code&gt;__init__&lt;/code&gt;，而可变类型（dict，list，file，super，classmethod，staticmethd，property）有一个假的 &lt;code&gt;__new__&lt;/code&gt;。内置类型 &lt;code&gt;object&lt;/code&gt; 有假的 &lt;code&gt;__init__&lt;/code&gt; 和 &lt;code&gt;__new__&lt;/code&gt; （给其他对象继承）。内置类型 &lt;code&gt;type&lt;/code&gt; 在很多方面都很特别，请参考 metaclasses。&lt;/li&gt;
&lt;li&gt;（这条和 &lt;code&gt;__new__&lt;/code&gt; 没关系，但是页应该了解一下）如果新建一个 &lt;code&gt;type&lt;/code&gt; 的子类，实例会自动给 &lt;code&gt;__dict__&lt;/code&gt; 和 &lt;code&gt;__weakrefs__&lt;/code&gt; 预留空间（ &lt;code&gt;__dict__&lt;/code&gt; 在你使用前不会初始化，所以你不需要担心创建的所有实例被一个空的字典所占用的空间）。如果不需要这个多余的空间，可以给你的类设置 &lt;code&gt;__slots__ = []&lt;/code&gt;（更多信息可以参考 &lt;code&gt;__slots__&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;Factoid: &lt;code&gt;__new__&lt;/code&gt; 是一个静态方法，不是类方法。我开始的时候觉得他应该是一个类方法，and that&amp;rsquo;s why I added the classmethod primitive。不幸的是，对于一个类方法，在这种情况下面 upcalls 不工作，所以我只好把他设计成一个第一个参数是一个 class 的静态方法。讽刺的是，there are now no known uses for class methods in the Python distribution (other than in the test suite). I might even get rid of classmethod in a future release if no good use for it can be found!&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Python inherit and super</title>
      <link>https://wdicc.com/Python-inherit-and-super/</link>
      <pubDate>Mon, 16 Jan 2017 11:53:04 +0800</pubDate>
      
      <guid>https://wdicc.com/Python-inherit-and-super/</guid>
      <description>&lt;p&gt;又学习了一个 python 的继承。有很多帖子都有介绍，比如&lt;a href=&#34;https://laike9m.com/blog/li-jie-python-super,70/&#34;&gt;理解 Python super&lt;/a&gt;，&lt;a href=&#34;http://www.cnblogs.com/lovemo1314/archive/2011/05/03/2035005.html&#34;&gt;python super()&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;先看一个例子，这个是第一个文章里面的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Root(object):
    def __init__(self):
        print(&amp;quot;this is Root&amp;quot;)


class B(Root):
    def __init__(self):
        print(&amp;quot;enter B&amp;quot;)
        super(B, self).__init__()
        print(&amp;quot;leave B&amp;quot;)


class C(Root):
    def __init__(self):
        print(&amp;quot;enter C&amp;quot;)
        super(C, self).__init__()
        print(&amp;quot;leave C&amp;quot;)


class D(C):
    def __init__(self):
        print(&amp;quot;enter D&amp;quot;)
        super(D, self).__init__()
        print(&amp;quot;leave D&amp;quot;)


class E(D, B):
    def __init__(self):
        print(&amp;quot;enter E&amp;quot;)
        super(E, self).__init__()
        print(&amp;quot;leave E&amp;quot;)

e = E()
print(e.__class__.mro())

# results:
# enter E
# enter D
# enter C
# enter B
# this is Root
# leave B
# leave C
# leave D
# leave E
# [&amp;lt;class &#39;__main__.E&#39;&amp;gt;, &amp;lt;class &#39;__main__.D&#39;&amp;gt;, &amp;lt;class &#39;__main__.C&#39;&amp;gt;, &amp;lt;class &#39;__main__.B&#39;&amp;gt;, &amp;lt;class &#39;__main__.Root&#39;&amp;gt;, &amp;lt;class &#39;object&#39;&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;没有什么问题，所有的类都做了初始化，很完美。接着再看一个例子，这个例子其实是上面第二篇文章里面的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class A(object):
    def __init__(self):
        print(&amp;quot;enter A&amp;quot;)
        print(&amp;quot;leave A&amp;quot;)


class B(object):
    def __init__(self):
        print(&amp;quot;enter B&amp;quot;)
        print(&amp;quot;leave B&amp;quot;)


class C(A):
    def __init__(self):
        print(&amp;quot;enter C&amp;quot;)
        super(C, self).__init__()
        print(&amp;quot;leave C&amp;quot;)


class D(A):
    def __init__(self):
        print(&amp;quot;enter D&amp;quot;)
        super(D, self).__init__()
        print(&amp;quot;leave D&amp;quot;)


class E(B, C):
    def __init__(self):
        print(&amp;quot;enter E&amp;quot;)
        super(E, self).__init__()
        print(&amp;quot;leave E&amp;quot;)


class F(E, D):
    def __init__(self):
        print(&amp;quot;enter F&amp;quot;)
        super(F, self).__init__()
        print(&amp;quot;leave F&amp;quot;)


f = F()
print(f.__class__.mro())

# results:
# enter F
# enter E
# enter B
# leave B
# leave E
# leave F
# [&amp;lt;class &#39;__main__.F&#39;&amp;gt;, &amp;lt;class &#39;__main__.E&#39;&amp;gt;, &amp;lt;class &#39;__main__.B&#39;&amp;gt;, &amp;lt;class &#39;__main__.C&#39;&amp;gt;, &amp;lt;class &#39;__main__.D&#39;&amp;gt;, &amp;lt;class &#39;__main__.A&#39;&amp;gt;, &amp;lt;class &#39;object&#39;&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我发现和文章里面贴的结果不一样，里面缺少对 C，D，A 的初始化。琢磨半天才弄明白，主要原因就是，&lt;code&gt;A&lt;/code&gt;，&lt;code&gt;B&lt;/code&gt; 其实也是继承自 &lt;code&gt;object&lt;/code&gt;，然而我们并没有调用 &lt;code&gt;super&lt;/code&gt; 来初始化，所以只需要加上就可以了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class A(object):
    def __init__(self):
        print(&amp;quot;enter A&amp;quot;)
        super(A, self).__init__()
        print(&amp;quot;leave A&amp;quot;)


class B(object):
    def __init__(self):
        print(&amp;quot;enter B&amp;quot;)
        super(B, self).__init__()
        print(&amp;quot;leave B&amp;quot;)


class C(A):
    def __init__(self):
        print(&amp;quot;enter C&amp;quot;)
        super(C, self).__init__()
        print(&amp;quot;leave C&amp;quot;)


class D(A):
    def __init__(self):
        print(&amp;quot;enter D&amp;quot;)
        super(D, self).__init__()
        print(&amp;quot;leave D&amp;quot;)


class E(B, C):
    def __init__(self):
        print(&amp;quot;enter E&amp;quot;)
        super(E, self).__init__()
        print(&amp;quot;leave E&amp;quot;)


class F(E, D):
    def __init__(self):
        print(&amp;quot;enter F&amp;quot;)
        super(F, self).__init__()
        print(&amp;quot;leave F&amp;quot;)


f = F()
print(f.__class__.mro())

# results:
# enter F
# enter E
# enter B
# enter C
# enter D
# enter A
# leave A
# leave D
# leave C
# leave B
# leave E
# leave F
# [&amp;lt;class &#39;__main__.F&#39;&amp;gt;, &amp;lt;class &#39;__main__.E&#39;&amp;gt;, &amp;lt;class &#39;__main__.B&#39;&amp;gt;, &amp;lt;class &#39;__main__.C&#39;&amp;gt;, &amp;lt;class &#39;__main__.D&#39;&amp;gt;, &amp;lt;class &#39;__main__.A&#39;&amp;gt;, &amp;lt;class &#39;object&#39;&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就完美了。目测这个会是一个隐藏的坑。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Python metaclass</title>
      <link>https://wdicc.com/Python-metaclass/</link>
      <pubDate>Thu, 12 Jan 2017 18:26:22 +0800</pubDate>
      
      <guid>https://wdicc.com/Python-metaclass/</guid>
      <description>&lt;p&gt;又理解了一下 python 的 metaclass 可以做什么，尝试记录一下。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Meta(type):
    register = []

    def __new__(cls, class_name, parrent_class, params):
        print(&amp;quot;In meta new: {}, {}, {}, {}&amp;quot;.format(cls, class_name, parrent_class, params))
        cls.register.append(class_name)
        params[&#39;test_prop&#39;] = True
        # return super(Meta, cls).__new__(cls, class_name, parrent_class, params)
        # return type.__new__(cls, class_name, parrent_class, params)
        # return super(Meta, cls).__new__(type, class_name, parrent_class, params)
        # return type.__new__(type, class_name, parrent_class, params)
        return type(class_name, parrent_class, params)

    def __init__(self, class_name, parrent_class, params):
        print(&amp;quot;In meta init: {}, {}, {}&amp;quot;.format(class_name, parrent_class, params))
        super(Meta, self).__init__(class_name, parrent_class, params)


class A(object, metaclass=Meta):
    pass

print(&amp;quot;register: {}&amp;quot;.format(Meta.register))
print(&amp;quot;prop: {}&amp;quot;.format(A.test_prop))
print(&amp;quot;register: {}&amp;quot;.format(A.register))  # Error

# outputs:
# In meta new: &amp;lt;class &#39;__main__.Meta&#39;&amp;gt;, A, (&amp;lt;class &#39;object&#39;&amp;gt;,), {&#39;__module__&#39;: &#39;__main__&#39;, &#39;__qualname__&#39;: &#39;A&#39;}
# In meta init: A, (&amp;lt;class &#39;object&#39;&amp;gt;,), {&#39;__module__&#39;: &#39;__main__&#39;, &#39;__qualname__&#39;: &#39;A&#39;}
# register: [&#39;A&#39;]
# prop: True
# AttributeError: type object &#39;A&#39; has no attribute &#39;register&#39;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，在构造 &lt;code&gt;A&lt;/code&gt; 的时候，&lt;code&gt;Meta&lt;/code&gt; 这个类里面，&lt;code&gt;__new__&lt;/code&gt; 和 &lt;code&gt;__init__&lt;/code&gt; 都会被调用到。上面代码往 &lt;code&gt;A&lt;/code&gt; 里面塞了一个属性。&lt;/p&gt;

&lt;p&gt;在 &lt;code&gt;__new__&lt;/code&gt; 里面，有几个注释，可以去掉注释看看不同的效果。目前还有点疑惑，传给 &lt;code&gt;__new__&lt;/code&gt; 第一个参数到底是什么。另外，开始对 &lt;code&gt;super&lt;/code&gt; 也有点疑惑了，还在学习。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>python 的 decorator 学习</title>
      <link>https://wdicc.com/decorator-in-python/</link>
      <pubDate>Fri, 21 Oct 2016 18:50:59 +0800</pubDate>
      
      <guid>https://wdicc.com/decorator-in-python/</guid>
      <description>&lt;p&gt;最近学习了一下 python 的 decorator（装饰器），看的是这篇，&lt;a href=&#34;http://coolshell.cn/articles/11265.html&#34;&gt;Python修饰器的函数式编程&lt;/a&gt;， 觉得挺有意思的，写点东西记录一下。&lt;/p&gt;

&lt;p&gt;装饰器简单讲就是返回一个函数的函数/类。看个简单的例子。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/python
# -*- coding: utf-8 -*-


def dec1(fn):
    print(&#39;inside dec1&#39;)

    def wrapper():
        print(&#39;inside wrapper&#39;)
        return fn()
    return wrapper


@dec1
def f1():
    print(&#39;inside f1&#39;)

if __name__ == &#39;__main__&#39;:
    print(&#39;begin exec&#39;)
    f1()
    print(&#39;end exec&#39;)

# 执行结果:
# inside dec1
# begin exec
# inside wrapper
# inside f1
# end exec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看上面例子能看到，装饰器生效有 2 个步骤，第一个是装饰，第二个是执行。上面装饰器的效果，和下面的代码的效果是一样。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/python
# -*- coding: utf-8 -*-


def dec1(fn):
    print(&#39;inside dec1&#39;)

    def wrapper():
        print(&#39;inside wrapper&#39;)
        return fn()
    return wrapper


# @dec1
def f1():
    print(&#39;inside f1&#39;)

if __name__ == &#39;__main__&#39;:
    print(&#39;begin exec&#39;)
    dec1(f1)()
    print(&#39;end exec&#39;)

# 执行结果:
# begin exec
# inside dec1
# inside wrapper
# inside f1
# end exec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到除了 「begin/end exec」，其他部分执行结果是一样的。所以理解装饰器，就把 &lt;code&gt;@dec1&lt;/code&gt; 换成 &lt;code&gt;dec1(fn)()&lt;/code&gt; 这么理解就可以了。&lt;/p&gt;

&lt;p&gt;有时候会看到类也可以作为装饰器使用。其实理解起来也类似。举个例子。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/python
# -*- coding: utf-8 -*-


class dec1(object):
    def __init__(self, fn):
        print(&#39;inside dec1&#39;)
        self.fn = fn

    def __call__(self):
        print(&#39;inside wrapper&#39;)
        return self.fn()


@dec1
def f1():
    print(&#39;inside f1&#39;)

if __name__ == &#39;__main__&#39;:
    print(&#39;begin exec&#39;)
    f1()
    print(&#39;end exec&#39;)

# 执行结果:
# inside dec1
# begin exec
# inside wrapper
# inside f1
# end exec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里和上面类似，把 &lt;code&gt;@dec1&lt;/code&gt; 理解成 &lt;code&gt;dec1(fn)()&lt;/code&gt;，不过是这里的 &lt;code&gt;dec1&lt;/code&gt; 是个类，那么 &lt;code&gt;dec1(fn)&lt;/code&gt; 其实是调用的 &lt;code&gt;dec1.__init__(fn)&lt;/code&gt;，那么后续的 &lt;code&gt;dec1(fn)()&lt;/code&gt; 就是调用产生的对象的 &lt;code&gt;dec1.__call__()&lt;/code&gt; 了。&lt;/p&gt;

&lt;p&gt;有时候还能看到加了参数的装饰器。加了参数的是怎么回事呢。再看下面的例子。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/python
# -*- coding: utf-8 -*-


def dec1(name):
    print(&#39;inside dec1&#39;)

    def real_dec1(fn):
        def wrapper():
            print(&#39;inside wrapper&#39;)
            return fn()
        return wrapper
    return real_dec1


@dec1(name=&#39;1&#39;)
def f1():
    print(&#39;inside f1&#39;)

if __name__ == &#39;__main__&#39;:
    print(&#39;begin exec&#39;)
    f1()
    print(&#39;end exec&#39;)

# 执行结果:
# inside dec1
# begin exec
# inside wrapper
# inside f1
# end exec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看懂了没有，就是多了个嵌套而已。遇到加了参数的，那就是把之前的没有参数的部分返回回来就可以了。等价的例子就不贴了，这个等价于 &lt;code&gt;dec1(name=&#39;1&#39;)(fn)()&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;如果是类装饰器，并且有参数，那等价于 &lt;code&gt;dec1(name=&#39;1&#39;)(fn)()&lt;/code&gt;，其中 &lt;code&gt;__init__(self, name)&lt;/code&gt; 先处理第一层参数，然后 &lt;code&gt;__call__(fn)&lt;/code&gt; 处理第二层，然后需要在 &lt;code&gt;__call__&lt;/code&gt; 里面再定义一个 wrapper 返回。&lt;/p&gt;

&lt;p&gt;说明白没有？呵呵。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>把 emacs 做为 python ide</title>
      <link>https://wdicc.com/use-emacs-as-python-ide/</link>
      <pubDate>Mon, 13 Jul 2009 00:00:00 +0000</pubDate>
      
      <guid>https://wdicc.com/use-emacs-as-python-ide/</guid>
      <description>emacs 用的其实不是很多，不过他实在是个好东西，各种 mode，用熟了肯定能帮你提升不少工作速度。&lt;br /&gt;

我用 emacs-cvs , ropemacs( dev 版， &gt; 0.6 ）, rope ( &gt; 0.9.2 ), company-mode ( &gt; 0.4.2 ) 这几个软件在 gentoo  里面都还没有，我自己写了几个 ebuild。&lt;br /&gt;

装好之后，基本就是 require 一下就好，我没做什么设置，效果如下。&lt;br /&gt;

&lt;a href=&#34;http://twitpic.com/a70je&#34;&gt;here&lt;/a&gt;&lt;br /&gt;
</description>
    </item>
    
    <item>
      <title>改良的 fetion.py</title>
      <link>https://wdicc.com/modified-fetion-py/</link>
      <pubDate>Mon, 06 Jul 2009 00:00:00 +0000</pubDate>
      
      <guid>https://wdicc.com/modified-fetion-py/</guid>
      <description>这个 fetion.py 来自 &lt;a href=&#34;http://blog.lazytech.info/2008/11/05/python-fetion/&#34;&gt;这里&lt;/a&gt;。&lt;br /&gt;

不修改的情况下，-t 可以是 sip, uid, mobile_no 这几个。&lt;br /&gt;

我修改了下，不加 -t 参数会打印联系人列表。另外还能用 nickname 来发（没测试，我没几个好友，没好意思发）。&lt;br /&gt;

在&lt;a href=&#34;http://github.com/wd/work/tree/aa559b6b3ee1c15ccfcbf9ce45d1f7aa2208b953/fetion_py&#34;&gt;这里&lt;/a&gt;。&lt;br /&gt;
</description>
    </item>
    
    <item>
      <title>asm 和 python的扯淡 zz</title>
      <link>https://wdicc.com/asm-and-python/</link>
      <pubDate>Thu, 14 May 2009 00:00:00 +0000</pubDate>
      
      <guid>https://wdicc.com/asm-and-python/</guid>
      <description>&lt;p&gt;python: 兄弟，最近我手头紧，能借点不？&lt;br /&gt;&lt;br /&gt;asm: 行，不过怎么你以前不是过得还滋润的，怎么现在混这么差，&lt;br /&gt;&lt;br /&gt;python: 不知道啊，现在根本接不到什么项目，听说还有风声要收回我的开发资质。&lt;br /&gt;&lt;br /&gt;asm: 你要改变观念，才会有市场。&lt;br /&gt;&lt;br /&gt;python: 什么观念？&lt;br /&gt;&lt;br /&gt;asm: 现在流行的是软件的要有科学性&lt;br /&gt;&lt;br /&gt;python: 什么是软件的科学性？&lt;br /&gt;&lt;br /&gt;asm: 我自己也不清楚，不知道哪位大神定义的科学的软件就是要有bug，现在的人们认为软件不可能没有bug，&lt;br /&gt;否则就不是软件，所以bug越多越好，我就非常适合创造bug。搞好点三步一回头，搞不好一步三回头。&lt;br /&gt;&lt;br /&gt;python：我不行啊，我开发的东西bug相对少得很多。&lt;br /&gt;&lt;br /&gt;asm: 难怪别人不找你做项目。通常别人都认为软件这个东西啊就是通过不断消灭bug，不断创造bug，最终走&lt;br /&gt;向稳定成熟的。你bug要是少了，客户会认为你蒙它，不科学。&lt;br /&gt;&lt;br /&gt;python: 太阳啊，我设计出来就是为了减少软件开发少出bug的，这样不是要我的命？&lt;br /&gt;那你开发项目时候弄出那么多bug,进度不是很慢，成本也很高？客户能接受？&lt;br /&gt;&lt;br /&gt;asm: 这你不懂,这里的人就是人傻，钱多，你不这样干，他们还认为你是在蒙它，哪里有这么轻易就作出来的东西，&lt;br /&gt;我的特点就是能把简单的东西弄复杂，而你呢，把复杂的东西简单化，显然不受常人的欢迎，人都是好奇的动物，&lt;br /&gt;喜欢复杂的事情，越花花绿绿越好。你还不错了，看Lisp兄弟那惨样。&lt;br /&gt;&lt;br /&gt;python: 那项目要是复杂了，规模大了你能应付？&lt;br /&gt;&lt;br /&gt;asm: 管他，我也知道我对付不了大规模的项目，用人堆，人月算得高高的，到那个程度，我自己也糊涂了，&lt;br /&gt;不知道要怎么整合了，bug比太平洋里头的珊瑚虫还多，根本做不下去。就给客户说目前技术水平只能达到&lt;br /&gt;这个程度就行了，他们能接受，能将就用就用，不能用就宣告失败。&lt;br /&gt;&lt;br /&gt;python: 不会吧，这种规模的东西在我看来并不难啊，项目失败他们不去告你？&lt;br /&gt;&lt;br /&gt;asm: 也有告的，不过现在法律有规定，只要你能列出你开发时候的所有设计过程和调试信息，能证明你尽力了，&lt;br /&gt;系统确实复杂到技术是无法解决的，就没事。&lt;br /&gt;python: 你怎么提供?&lt;br /&gt;&lt;br /&gt;asm: 我开发的特点你还不知道，代码量本身巨大，调试信息非常多，而且清楚得很，动不动就扔N个core出来，上次那个&lt;br /&gt;破搜索项目我扔了几十T的core给客户，他们还屁颠地当宝一样永久保存&lt;br /&gt;&lt;br /&gt;python: 搜索～～，太阳！这些家伙为什么就是不找我？&lt;br /&gt;&lt;br /&gt;asm: 现在的人不懂你那套，太玄，你的log绝大部分只记录你逻辑上的东西，现在的客户要求太高了，每一步都要知道CPU各寄存器的状态，&lt;br /&gt;总线电压高低，内存的实时快照，多了。你还自动类型定义，自动类型转换，谁信。什么高阶函数，闭包都冒出来。&lt;br /&gt;你的设计思想不错，我都想学习，不过很难学，至于客户，他们更搞不懂，云里雾里。上次Lisp大兄弟去接个基因分析项目被&lt;br /&gt;人轰了出来，说什么一堆乱七八糟的括号太神秘，什么抽象语法树，语法还能自定义，简直胡扯，就是巫术，内存管理更&lt;br /&gt;不透明。那些客户喜欢看到分配释放内存，很具体，很直观，Python兄弟你这个连内存管理都不给客户看的，也很难混日子。&lt;br /&gt;&lt;br /&gt;pyton: 我自己带了gc，又不要他们考虑。&lt;br /&gt;&lt;br /&gt;asm: 他们不会吃你gc这套的，你不明确给他们说分配多少字节内存出来，什么时候释放，他们不卖帐。&lt;br /&gt;&lt;br /&gt;python: 我太阳，又不是所有项目都要这么控制精细的。&lt;br /&gt;&lt;br /&gt;asm: 看我，我每一段代码都很明确，和机器结合得很紧密，写磁盘发个IO指令，让他们看得实在。你那个write太玄乎，到最后写盘还不知道隔了多少层&lt;br /&gt;他们不放心。现在的人认死理，一个问题只能有一个答案，一种解决方法。你看你变化多端，谁都能搞得糊。不过不要紧，我做不下去的时候可以介&lt;br /&gt;绍他们过来给你继续做。&lt;br /&gt;&lt;br /&gt;python: 那真的很感谢，最近真的没米下锅，你是帮了我的大忙了。&lt;br /&gt;&lt;br /&gt;asm: 没什么，不过我要告诉你的就是这类客户的开发经费被我榨得差不多了，到你那可能没多少钱付给你了。&lt;br /&gt;&lt;br /&gt;python: 没关系，再少总比没有好。（哭）&lt;br /&gt;&lt;br /&gt;asm: 最后告诉你一个秘密，人的弱点就是天生有奴性，贱，喜欢复杂的东西，好奇，盲从，注重眼前，捡芝麻丢西瓜。&lt;br /&gt;对简洁的东西不感兴趣。因为他们通常认为简洁就是简单。书从薄读到厚，又从厚读到薄 的人没几个的。太相信&lt;br /&gt;自己的眼睛，不相信自己的心。我猜可能是猪油吃太多了的缘故。 表面的东西他们非常热衷，看得到，实在。喜欢&lt;br /&gt;追涨杀跌，所以股市里头为什么那么多人输钱，就是这样，你弄得越火热，价格越高，越多人买，生怕赶不上末班车，&lt;br /&gt;价格越掉越不买，持币待购。我早期玩股票，学了点技术，觉得自己无所不能了，也来搞一把，也是整天盯着盘，&lt;br /&gt;那个实时价格跳得我心都肿了，输得去穿strip，后来学乖了，抓住趋势，买入，中间不看了细节了，趋势没了就抛了，&lt;br /&gt;最后挣钱了。前几年房价疯涨，多少人怕涨到天上去，砸锅卖铁，把下辈子的养老钱都预支出来去买，看现在，傻了吧。&lt;br /&gt;所以有些复杂的东西，你越想从细节控制它，它越不听你的话，你和它对抗没用，早晚死它手里，要顺势。&lt;br /&gt;明白了，今后你要挣这些人的钱，要抓他们的弱点。&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;
</description>
    </item>
    
    <item>
      <title>写了一个 kde plasma applet</title>
      <link>https://wdicc.com/writing-a-kde-plasma-applet/</link>
      <pubDate>Fri, 23 Jan 2009 00:00:00 +0000</pubDate>
      
      <guid>https://wdicc.com/writing-a-kde-plasma-applet/</guid>
      <description>用 gnome 的时候，对 panel 上面的 cpu 等 applet 情有独钟。这个东西能让我对自己的系统有第一手信息，有时候某个程序出问题了 cpu 100% 了，这个时候系统反应不一定会变慢的，但是这个程序是必须要被干掉的，有了这个 applet 我就能知道第一时间知道出问题了。还有的时候看 firefox 里面的 flash 的时候也会出类似的情况，这时会导致看别的网页很慢，那就干掉他。&lt;br /&gt;

第一次装 kde 的时候发现没有那些东西，让我很失望。后来看到 ob 在 openbox 里面把 panel 设的短一点，然后用 conky 在空出来的地方显示一些信息，感觉豁然开朗啊，呵呵。&lt;br /&gt;

这次装好 kde，就弄了一个 conky，可是发现他的风格和系统不兼容。有点不爽，就琢磨自己能不能弄一个，因为需求实在太简单了。&lt;br /&gt;

昨天花了一个下午，总算弄好了。参考的文档 &lt;a href=&#34;http://www.qtopia.org.cn/doc/qiliang.net/qt/classes.html&#34;&gt;qt的类&lt;/a&gt;, &lt;a href=&#34;http://www.zetcode.com/tutorials/pyqt4/&#34;&gt;pyqt4 turtorial&lt;/a&gt;,&lt;a href=&#34;http://techbase.kde.org/Development/Tutorials/Plasma/Python/GettingStarted&#34;&gt;plasma python&lt;/a&gt; .&lt;br /&gt;

效果就这样。电池旁边那个就是。&lt;br /&gt;

&lt;a href=&#34;http://img339.imageshack.us/img339/6986/200901231045132304x1024oo0.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://img339.imageshack.us/img339/6986/200901231045132304x1024oo0.png&#34; alt=&#34;&#34; width=&#34;300&#34; /&gt;&lt;/a&gt;&lt;br /&gt;

代码&lt;br /&gt;
&lt;pre class=&#34;prettyprint lang-python&#34;&gt;
from PyQt4.QtCore import *
from PyQt4.QtGui import *
from PyKDE4.plasma import Plasma
from PyKDE4 import plasmascript
import time                                      

class Cpuinfo(plasmascript.Applet):
        def __init__(self,parent,args=None):
                plasmascript.Applet.__init__(self,parent)

        def init(self):
                self.freqnow = &#39;&#39;
                self.freqmax = &#39;&#39;
                self.temp = &#39;&#39;
                self.text = &#39;&#39;   

                self.getCurrentFreq()
                self.getMaxFreq()
                self.getTemp()       

                self.setHasConfigurationInterface(False)
                self.setMinimumWidth(100)
                self.setAspectRatioMode(Plasma.Square)
                self.startTimer(1000)

        def getCurrentFreq (self):
                line = open (&#39;/sys/devices/system/cpu/cpu0/cpufreq/scaling_cur_freq&#39;, &#39;r&#39;).read().rstrip(&#39;\n&#39;)
                line = int(line) / 1000 /1000.0
                self.freqnow = line

        def getMaxFreq (self):
                line = file(&#39;/sys/devices/system/cpu/cpu0/cpufreq/scaling_max_freq&#39;, &#39;r&#39;).read().rstrip(&#39;\n&#39;)
                line = int(line) / 1000 /1000.0
                self.freqmax = line

        def getTemp (self):
                line = file(&#39;/proc/acpi/thermal_zone/TZ1/temperature&#39;, &#39;r&#39;).read().rstrip(&#39;\n&#39;)
                line = &#34; &#34;.join(line.split()[1:])
                self.temp = line

        def timerEvent(self, event):
                self.getCurrentFreq()
                self.getTemp()
                self.text = &#34;%s\n%.2f %d%%&#34; % (self.temp, self.freqnow, self.freqnow / self.freqmax * 100)
                self.update() 

        def paintInterface(self, painter, option, rect):
                painter.save()
                painter.setPen(Qt.white)
                #painter.setFont(QFont(&#39;Consolas&#39;,11))
                painter.drawText(rect, Qt.AlignVCenter | Qt.AlignHCenter, self.text)
                painter.restore()

def CreateApplet(parent):
                return Cpuinfo(parent)

if __name__ == &#39;__main__&#39;:
        a = Cpuinfo(None)
        a.init()
        print a.freqnow&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>