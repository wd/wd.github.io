<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ASGI on wd and cc</title><link>https://wdicc.com/tags/asgi/</link><description>Recent content in ASGI on wd and cc</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 15 Oct 2019 14:52:47 +0800</lastBuildDate><atom:link href="https://wdicc.com/tags/asgi/atom.xml" rel="self" type="application/rss+xml"/><item><title>ASGI</title><link>https://wdicc.com/asgi/</link><pubDate>Tue, 15 Oct 2019 14:52:47 +0800</pubDate><guid>https://wdicc.com/asgi/</guid><description>Django 3.0 要支持 ASGI 了，全称 Asynchronous Server Gateway Interface，使用了 coroutines 异步。WSGI 是目前普遍使用的，把进来的请求标准化处理之后，交给 WSGI 程序，这个支持的是请求来了，处理完毕，返回结果这样的模型。对于像 websockt 这样的就不太友好了，websockt 实际是建立连接之后会持续发送请求和接收结果，所以有了 ASGI。 ASGI 不同的地方在于，他有一个 scope，表示一个连接，这个会一直存在直到用户断开连接。然后通过一个一个的 event 和应用交互，event 是个字典，必定包含一个 type 指明类型。ASGI 还支持了 coroutine。 这样对于 http 请求，一个请求就一个 scope， 所需要的数据基本就全了，除了 body 对应一个 event。对于 websockt 请求，一个 scope 会持续到直到用户断开，期间通过 event 发送详细消息。Application 不能和客户端在 scope 阶段交互，必须等进入 event loop 才可以，而且取决于协议规定，可能还需要等一些初始化的 event 之后才可以。 然后目前实现的 ASGI server 我看有 daphne，简单看了一下源码。 这个一般是命令行执行 daphne 这个命令，入口是在 setup.py 里面指定的 daphne.cli:CommandLineInterface.entrypoin ，这里面实例化了一个 cli 然后执行了 run。run 里面主要是处理命令行参数，找到我们指定的 application 然后 import 。 这里我们的用法是通过 get_channel_layer() 初始化了一个，这里面主要是通过配置文件里面的配置，把 backend 和 routing 初始化了一下。 1 2 3 4 5 6 asgi_layer = backend_class(**config) return ChannelLayerWrapper( channel_layer=asgi_layer, alias=name, routing=routing, ) cli.</description></item></channel></rss>