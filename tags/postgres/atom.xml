<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Postgres on wd and cc</title>
    <link>https://wdicc.com/tags/postgres/atom/index.xml</link>
    <description>Recent content in Postgres on wd and cc</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <atom:link href="https://wdicc.com/tags/postgres/atom/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>使用 pgrepup 跨版本升级 pg</title>
      <link>https://wdicc.com/use-pgrepup-to-upgrade-your-postgres/</link>
      <pubDate>Thu, 08 Dec 2016 11:55:33 +0800</pubDate>
      
      <guid>https://wdicc.com/use-pgrepup-to-upgrade-your-postgres/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://gasparin.net/2016/11/pgrepup-upgrade-postgresql-using-logical-replication/&#34;&gt;pgrepup&lt;/a&gt; 其实是一个支持 pg 跨版本复制的工具。而 pg 大版本升级需要停机是个比较郁闷的事情，如果能通过这个解决就实在太好了。下面测试了一下。&lt;/p&gt;

&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;

&lt;p&gt;需要安装 &lt;code&gt;pgrepup&lt;/code&gt; 和 &lt;code&gt;pglogical&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&#34;安装-pgrepup&#34;&gt;安装 pgrepup&lt;/h3&gt;

&lt;p&gt;pgrepup 官方说是支持 python &amp;gt;= 2.7 的版本，我自己测试的结果，python 3.5 里面执行有点问题，需要修改几个地方。但是在 python 2.7 里面，不需要做任何修改，所以建议使用 python 2.7。安装很简单，执行 &lt;code&gt;pip install pgprepup&lt;/code&gt; 就可以了。&lt;/p&gt;

&lt;h3 id=&#34;安装-pglogical&#34;&gt;安装 pglogical&lt;/h3&gt;

&lt;p&gt;需要给你的 pg 安装这个扩展。高版本的和低版本的都需要安装。&lt;/p&gt;

&lt;p&gt;安装也很简单，下载源码，执行 &lt;code&gt;PATH=/opt/pg96/bin:$PATH make USE_PGXS=1 install&lt;/code&gt; 就好了。如果是给 pg95 装，那就把路径改成 pg95。&lt;/p&gt;

&lt;p&gt;可以参考&lt;a href=&#34;https://2ndquadrant.com/it/resources/pglogical/pglogical-installation-instructions/&#34;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;配置&#34;&gt;配置&lt;/h2&gt;

&lt;h3 id=&#34;配置-db&#34;&gt;配置 db&lt;/h3&gt;

&lt;p&gt;先给几个 db 定义一下角色。db1 假设为 9.5 版本，db2 假设为 9.6 版本。&lt;/p&gt;

&lt;p&gt;pgrepup 允许 db1, db2 和执行 pgrepup 所在的机器分别在不同的机器，也可以在相同的机器，看机器情况。&lt;/p&gt;

&lt;p&gt;对于 db，最小配置的 postgres.conf 修改如下，我测试的时候两个 db 在一台机器上面，只需要修改 port 不一样就可以了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;listen_addresses = &#39;*&#39;          # what IP address(es) to listen on;
port = 5495
wal_level = logical # minimal, archive, hot_standby, or logical
max_wal_senders = 3             # max number of walsender processes
max_replication_slots = 3       # max number of replication slots
shared_preload_libraries = &#39;pglogical&#39;          # (change requires restart)

## 下面几个参数不是必须设置的
logging_collector = on          # Enable capturing of stderr and csvlog
log_filename = &#39;postgresql-%Y-%m-%d.log&#39;        # log file name pattern,
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;pg_hba.conf 如下，修改其中的 client_ip 和 db_ip 为对应的真实 ip。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;host all all client_ip/32 md5
host replication pgrepup_replication db_ip/32 md5
host all pgrepup_replication db_ip/32 md5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置好之后，启动 db1 和 db2 看看是不是可以正常连接。&lt;/p&gt;

&lt;p&gt;还需要建立用户。如果已经存在一个 super 的用户，那也可以直接用那个用户，没有的话，就建一个。db1 和 db2 都需要建立，可以是不同的用户。&lt;/p&gt;

&lt;h4 id=&#34;hint&#34;&gt;hint&lt;/h4&gt;

&lt;p&gt;当然，如果我们在生产环境里面做这个事情，那肯定会是 db1 已经是一个存在的 db，只需要增加原来没有的配置就好了。db2 会是一个全新的 db，使用 initdb 初始化，之后配置上面的配置项（当然，如果是将来要给生产用，那应该是复制 db1 的配置文件过来，修改端口就可以了，其他都一样）。&lt;/p&gt;

&lt;h3 id=&#34;配置-pgrepup&#34;&gt;配置 pgrepup&lt;/h3&gt;

&lt;p&gt;执行一下 &lt;code&gt;pgrepup config&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;❯❯❯ pgrepup config
Pgrepup 0.3.7
Create a new pgrepup config
Configuration filename [~/.pgrepup] ./pgrepup.config
Security
Do you want to encrypt database credentials using a password? [Y/n] n
Folder where pgrepup store temporary dumps and pgpass file [/tmp] ./tmp
Source Database configuration
Ip address or Dns name: db_ip
Port: 5495
Connect Database: [template1]
Username: wd
Password:
Destination Database configuration
Ip address or Dns name: db_ip
Port: 5496
Connect Database: [template1]
Username: wd
Password:
Configuration saved to ./pgrepup.config.
You can now use the check command to verify setup of source and destination databases
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后会产生一个配置文件 pgrepup.config，有修改的话，可以打开再次编辑。&lt;/p&gt;

&lt;p&gt;之后，可以执行一下 &lt;code&gt;pgrepup check&lt;/code&gt; 来检查一下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;❯❯❯ pgrepup -c pgrepup.config check
Pgrepup 0.3.7
Global checkings...
 &amp;gt;  Folder ./tmp exists and is writable ..........................................OK
Checking Source...
 &amp;gt;  Connection PostgreSQL connection to db_ip:5495 with user wd OK
 &amp;gt;  pglogical installation .......................................................KO

    Hint: Install docs at https://2ndquadrant.com/it/resources/pglogical/pglogical-installation-instructions/

 &amp;gt;  Needed wal_level setting .....................................................OK
 &amp;gt;  Needed max_worker_processes setting ..........................................OK
 &amp;gt;  Needed max_replication_slots setting .........................................OK
 &amp;gt;  Needed max_wal_senders setting ...............................................OK
 &amp;gt;  pg_hba.conf settings .........................................................KO
    Hint: Add the following lines to /home/wd/data95/pg_hba.conf:
        host replication pgrepup_replication db_ip/32 md5
        host all pgrepup_replication db_ip/32 md5
    After adding the lines, remember to reload postgreSQL
 &amp;gt;  Local pg_dumpall version .....................................................OK
 &amp;gt;  Source cluster tables without primary keys
 &amp;gt;      template1 ................................................................OK
 &amp;gt;      testdb
 &amp;gt;          public.t1 ............................................................OK
 &amp;gt;      postgres .................................................................OK
Checking Destination...
 &amp;gt;  Connection PostgreSQL connection to db_ip:5496 with user wd OK
 &amp;gt;  pglogical installation .......................................................KO

    Hint: Install docs at https://2ndquadrant.com/it/resources/pglogical/pglogical-installation-instructions/

 &amp;gt;  Needed wal_level setting .....................................................KO
    Hint: Set wal_level to logical
 &amp;gt;  Needed max_worker_processes setting ..........................................OK
 &amp;gt;  Needed max_replication_slots setting .........................................KO
    Hint: Increase max_replication_slots to 3
 &amp;gt;  Needed max_wal_senders setting ...............................................OK
 &amp;gt;  pg_hba.conf settings .........................................................KO
    Hint: Add the following lines to /home/wd/data96/pg_hba.conf:
        host replication pgrepup_replication db_ip/32 md5
        host all pgrepup_replication db_ip/32 md5
    After adding the lines, remember to reload postgreSQL
 &amp;gt;  Local pg_dumpall version .....................................................OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面是我第一次执行 check 的结果，可以看到很多红色的 &lt;code&gt;KO&lt;/code&gt;，有些下面还有 hint 提示告诉你怎么修复，针对红色的信息进行修复就好了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;❯❯❯ pgrepup -c pgrepup.config check
Pgrepup 0.3.7
Global checkings...
 &amp;gt;  Folder ./tmp exists and is writable ..........................................OK
Checking Source...
 &amp;gt;  Connection PostgreSQL connection to db_ip:5495 with user wd ...OK
 &amp;gt;  pglogical installation .......................................................OK
 &amp;gt;  Needed wal_level setting .....................................................OK
 &amp;gt;  Needed max_worker_processes setting ..........................................OK
 &amp;gt;  Needed max_replication_slots setting .........................................OK
 &amp;gt;  Needed max_wal_senders setting ...............................................OK
 &amp;gt;  pg_hba.conf settings .........................................................OK
 &amp;gt;  Local pg_dumpall version .....................................................OK
 &amp;gt;  Source cluster tables without primary keys
 &amp;gt;      template1 ................................................................OK
 &amp;gt;      testdb
 &amp;gt;          public.t1 ............................................................OK
 &amp;gt;      postgres .................................................................OK
Checking Destination...
 &amp;gt;  Connection PostgreSQL connection to db_ip:5496 with user wd ...OK
 &amp;gt;  pglogical installation .......................................................OK
 &amp;gt;  Needed wal_level setting .....................................................OK
 &amp;gt;  Needed max_worker_processes setting ..........................................OK
 &amp;gt;  Needed max_replication_slots setting .........................................OK
 &amp;gt;  Needed max_wal_senders setting ...............................................OK
 &amp;gt;  pg_hba.conf settings .........................................................OK
 &amp;gt;  Local pg_dumpall version .....................................................OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面是我修复之后执行的结果。其中会提示会被同步的 db（上面是 template1, testdb, postgres）。之后执行 setup&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;❯❯❯ pgrepup -c pgrepup.config setup
Pgrepup 0.3.7
Check if there are active subscriptions in Destination nodes .....................OK
Global tasks
 &amp;gt;  Remove nodes from Destination cluster
 &amp;gt;      postgres .................................................................OK
 &amp;gt;      template1 ................................................................OK
 &amp;gt;      testdb ...................................................................OK
 &amp;gt;  Create temp pgpass file ......................................................OK
 &amp;gt;  Drop pg_logical extension in all databases of Source cluster
 &amp;gt;      template1 ................................................................OK
 &amp;gt;      postgres .................................................................OK
 &amp;gt;      testdb ...................................................................OK
 &amp;gt;  Drop pg_logical extension in all databases of Destination cluster
 &amp;gt;      postgres .................................................................OK
 &amp;gt;      template1 ................................................................OK
 &amp;gt;      testdb ...................................................................OK
Setup Source
 &amp;gt;  Create user for replication ..................................................OK
 &amp;gt;  Dump globals and schema of all databases .....................................OK
 &amp;gt;  Setup pglogical replication sets on Source node name
 &amp;gt;      template1 ................................................................OK
 &amp;gt;      postgres .................................................................OK
 &amp;gt;      testdb ...................................................................OK
Setup Destination
 &amp;gt;  Create and import source globals and schema ..................................OK
 &amp;gt;  Setup pglogical Destination node name
 &amp;gt;      postgres .................................................................OK
 &amp;gt;      testdb ...................................................................OK
 &amp;gt;      template1 ................................................................OK
Cleaning up
 &amp;gt;  Remove temporary pgpass file .................................................OK
 &amp;gt;  Remove other temporary files .................................................OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后执行 start&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;❯❯❯ pgrepup -c pgrepup.config start
Pgrepup 0.3.7
Start replication and upgrade
 &amp;gt;  postgres .................................................................OK
 &amp;gt;  template1 ................................................................OK
 &amp;gt;  testdb ...................................................................OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以通过 status 看同步状态&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;❯❯❯ pgrepup -c pgrepup.config status
Pgrepup 0.3.7
Configuration
 &amp;gt;  Source database cluster ......................................................OK
 &amp;gt;  Destination database cluster .................................................OK
Pglogical setup
 &amp;gt;  Source database cluster
 &amp;gt;      template1 ................................................................OK
 &amp;gt;      postgres .................................................................OK
 &amp;gt;      testdb ...................................................................OK
 &amp;gt;  Destination database cluster
 &amp;gt;      postgres .................................................................OK
 &amp;gt;      testdb ...................................................................OK
 &amp;gt;      template1 ................................................................OK
Replication status
 &amp;gt;  Database postgres
 &amp;gt;      Replication status ..............................................replicating
 &amp;gt;  Database testdb
 &amp;gt;      Replication status ..............................................replicating
 &amp;gt;  Database template1
 &amp;gt;      Replication status ..............................................replicating
 &amp;gt;  Xlog difference (bytes) ...................................................57816
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到三个 db 都在同步。这个时候在 db1 上面插入数据，能在 db2 上面看到会同步过去。&lt;/p&gt;

&lt;p&gt;状态有三种情况
* initializing: pglogical 正在 copy 数据
* replication: 同步状态
* down: 同步断开了，需要检查日志修复&lt;/p&gt;

&lt;h2 id=&#34;需要注意的问题&#34;&gt;需要注意的问题&lt;/h2&gt;

&lt;h3 id=&#34;db-里面的表都需要有主键&#34;&gt;db 里面的表都需要有主键&lt;/h3&gt;

&lt;p&gt;如果存在没有主键的表，执行 check 的时候会看到下面的信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; &amp;gt;  Source cluster tables without primary keys
 &amp;gt;      template1 ................................................................OK
 &amp;gt;      testdb
 &amp;gt;          public.t2 ............................................................KO
    Hint: Add a primary key or unique index or use the pgrepup fix command
 &amp;gt;          public.t1 ............................................................OK
 &amp;gt;      postgres .................................................................OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果不解决就执行 setup，会提示下面的信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Setup Source ........................................Skipped, configuration problems
Setup Destination
 &amp;gt;  Create and import source globals and schema .............................Skipped
 &amp;gt;  Setup pglogical Destination node name
 &amp;gt;      postgres .................................................................OK
 &amp;gt;      template1 ................................................................OK
 &amp;gt;      testdb ...................................................................OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以自己创建一个主键重新 check，也可以执行 fix 来修复，然后再次执行 setup。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ❯❯❯ pgrepup -c pgrepup.config fix
Pgrepup 0.3.7
Find Source cluster&#39;s databases with tables without primary key/unique index...
 &amp;gt;  template1 ....................................................................OK
 &amp;gt;  postgres .....................................................................OK
 &amp;gt;  testdb
 &amp;gt;      Found public.t2 without primary key ................Added __pgrepup_id field
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过 fix 加的主键，在 uninstall 的时候会被删除。&lt;/p&gt;

&lt;h3 id=&#34;replication-status-down&#34;&gt;Replication status .. down&lt;/h3&gt;

&lt;p&gt;有时候会遇到有的 db 的状态是好的，有的 db 是 down 的情况&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Replication status
 &amp;gt;  Database postgres
 &amp;gt;      Replication status ..............................................replicating
 &amp;gt;  Database testdb
 &amp;gt;      Replication status .....................................................down
 &amp;gt;  Database template1
 &amp;gt;      Replication status ..............................................replicating
 &amp;gt;  Xlog difference (bytes) ..................................................614096
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在同步状态下面，如果给某个 db 加一个没有主键的表，就会导致同步断掉。修复方法是先 stop，然后执行 check，按照提示修复，然后执行 setup，然后 start 就可以了。&lt;/p&gt;

&lt;h3 id=&#34;官方列出来的几个问题&#34;&gt;官方列出来的几个问题&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;DDL 命令。不会同步 DDL 命令，可以在 db1 试试看 &lt;code&gt;pglogical.replicate_ddl_command&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;seq 序列。执行 stop 命令的时候，会在目标 db 的 seq 上面加 1000。&lt;/li&gt;
&lt;li&gt;有大量的 db。执行 start 命令之后，pglogical 会每个 db 启动一个 worker 来同步数据，要是 db 比较多会导致比较高的负载。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因为这个是基于 pglogical 的，所以还需要关注 pglogical 列出来的一些&lt;a href=&#34;https://2ndquadrant.com/it/resources/pglogical/pglogical-docs/&#34;&gt;限制&lt;/a&gt; 第 4 部分 Limitations and Restrictions。
* 4.1 Superuser is required
* 4.2 UNLOGGED and TEMPORARY not replicated
* 4.3 One database at a time
* 4.4 PRIMARY KEY or REPLICA IDENTITY required
* 4.5 Only one unique index/constraint/PK
* 4.6 DDL
* 4.7 No replication queue flush
* 4.8 FOREIGN KEYS
* 4.9 TRUNCATE
* 4.10 Sequences
* 4.11 Triggers
* 4.12 PostgreSQL Version differences
* 4.13 Doesn&amp;rsquo;t replicate DDL&lt;/p&gt;

&lt;h3 id=&#34;pgrepup-uninstall&#34;&gt;pgrepup uninstall&lt;/h3&gt;

&lt;p&gt;uninstall 会清理 pgrepup 创建的一些信息，比如安装的 pglogical 扩展，创建用来同步的用户，和通过 fix 命令添加的 seq。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;❯❯❯ pgrepup -c pgrepup.config uninstall
Pgrepup 0.3.7
Check active subscriptions in Destination nodes
 &amp;gt;  template1 ...............................................................Stopped
 &amp;gt;  testdb ..................................................................Stopped
 &amp;gt;  postgres ................................................................Stopped
Uninstall operations
 &amp;gt;  Remove nodes from Destination cluster
 &amp;gt;      postgres .................................................................OK
 &amp;gt;      testdb ...................................................................OK
 &amp;gt;      template1 ................................................................OK
 &amp;gt;  Drop pg_logical extension in all databases
 &amp;gt;      Source
 &amp;gt;          template1 ............................................................OK
 &amp;gt;          postgres .............................................................OK
 &amp;gt;          testdb ...............................................................OK
 &amp;gt;      Destination
 &amp;gt;          postgres .............................................................OK
 &amp;gt;          testdb ...............................................................OK
 &amp;gt;          template1 ............................................................OK
 &amp;gt;  Drop user for replication ....................................................OK
 &amp;gt;  Drop unique fields added by fix command
 &amp;gt;          template1
 &amp;gt;          postgres
 &amp;gt;          testdb
 &amp;gt;              public.t1 ........................................................OK
 &amp;gt;              public.t2 ........................................................OK
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;升级&#34;&gt;升级&lt;/h2&gt;

&lt;p&gt;如果前面配置好了同步状态，那剩下的事情就简单了。
* 停止应用链接 db1
* 确保 db1 已经没有任何链接
* 使用 &lt;code&gt;pgrepup stop&lt;/code&gt; 停止 replication
* 修改应用链接到 db2
* 启动应用
* 剩下的就是处理掉停止的 db1&lt;/p&gt;

&lt;h2 id=&#34;参考文档&#34;&gt;参考文档&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://qiita.com/yteraoka/items/e82e4d28f6a23915d190&#34;&gt;http://qiita.com/yteraoka/items/e82e4d28f6a23915d190&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>postgres sql 调优一例</title>
      <link>https://wdicc.com/analyse-and-vacuum-in-postgres/</link>
      <pubDate>Sat, 03 Mar 2012 00:00:00 +0000</pubDate>
      
      <guid>https://wdicc.com/analyse-and-vacuum-in-postgres/</guid>
      <description>&lt;p&gt;前几天发现有个 sql 跑的超慢，第一次拿到 sql 大家简单分析了一下，觉得是写的有问题，里面有对一个大表的查询，数据量大概 800 万，结果还和好几个小表做了 join，而且还是 left join，速度可想而知了。单独对那个大表查询，其实也就是几分钟的事情。&lt;br /&gt;
&lt;/p&gt;&lt;br /&gt;
&lt;p&gt;&lt;br /&gt;
所以建议就是先对小表做 join，然后再和大表做一次 join。不过结果并不理想，时间依然还是那么长。这个时候就得仔细看执行计划了，如下。&lt;br /&gt;
&lt;/p&gt;&lt;br /&gt;
&lt;p&gt;&lt;br /&gt;
能看到虽然人肉对 sql 做了一些优化，但是 sql 并没有按照我们的期望去执行，执行计划里面还是首选去查 fact_tuan_rank_detail 这个大表，速度肯定慢了。&lt;br /&gt;
&lt;/p&gt;&lt;br /&gt;


&lt;pre class=&#34;prettyprint lang-text&#34;&gt;
 Nested Loop Left Join  (cost=447.90..1003.43 rows=2 width=620)
   Join Filter: (team.id = team_arrive_city.team_id)
   -&gt;  Nested Loop  (cost=77.62..85.98 rows=1 width=588)
         -&gt;  HashAggregate  (cost=77.62..77.68 rows=1 width=71)
               -&gt;  Index Scan using date_idx on fact_tuan_rank_detail  (cost=0.00..77.60 rows=1 width=71)
                     Index Cond: ((thedate &gt;= &#39;2012-02-25&#39;::date) AND (thedate &lt;= &#39;2012-02-27&#39;::date))
                     Filter: (((source)::text ~~ &#39;%team%&#39;::text) AND ((source)::text !~~ &#39;%today%&#39;::text) AND ((source)::text !~~ &#39;%ongoing%&#39;::text) AND ((s
ource)::text !~~ &#39;%special%&#39;::text))
         -&gt;  Index Scan using team_pkey on team  (cost=0.00..8.28 rows=1 width=32)
               Index Cond: (team.id = fact_tuan_rank_detail.team_id)
               Filter: ((to_timestamp((team.end_time)::double precision))::date &gt; &#39;2012-02-27&#39;::date)
   -&gt;  HashAggregate  (cost=370.29..589.15 rows=14591 width=15)
         -&gt;  Seq Scan on team_arrive_city  (cost=0.00..288.19 rows=16419 width=15)
(12 rows)
&lt;/pre&gt;&lt;br /&gt;

&lt;p&gt;&lt;br /&gt;
仔细研究之后，发现了 rows=1 这个信息。这就是为什么查询分析器先对这个表做查询了，因为他认为这个表最小。&lt;br /&gt;
&lt;/p&gt;&lt;br /&gt;
&lt;p&gt;&lt;br /&gt;
此后对这个表执行了一下 &lt;a href=&#34;http://www.postgresql.org/docs/9.1/static/sql-analyze.html&#34;&gt;analyse&lt;/a&gt; 命令，更新了一些统计信息。然后再看执行计划如下。&lt;br /&gt;
&lt;/p&gt;&lt;br /&gt;


&lt;pre class=&#34;prettyprint lang-text&#34;&gt;
 Hash Join  (cost=1210761.12..1326052.45 rows=2282704 width=620)
   Hash Cond: (fact_tuan_rank_detail.team_id = team.id)
   -&gt;  HashAggregate  (cost=1203912.40..1265555.26 rows=1027381 width=71)
         -&gt;  Index Scan using date_idx on fact_tuan_rank_detail  (cost=0.00..1075489.81 rows=10273807 width=71)
               Index Cond: ((thedate &gt;= &#39;2012-02-25&#39;::date) AND (thedate &lt;= &#39;2012-02-27&#39;::date))
               Filter: (((source)::text ~~ &#39;%team%&#39;::text) AND ((source)::text !~~ &#39;%today%&#39;::text) AND ((source)::text !~~ &#39;%ongoing%&#39;::text) AND ((source)
::text !~~ &#39;%special%&#39;::text))
   -&gt;  Hash  (cost=6666.33..6666.33 rows=14591 width=64)
         -&gt;  Merge Left Join  (cost=6414.63..6666.33 rows=14591 width=64)
               Merge Cond: (team.id = b.team_id)
               -&gt;  Sort  (cost=4670.40..4686.82 rows=6567 width=32)
                     Sort Key: team.id
                     -&gt;  Seq Scan on team  (cost=0.00..4254.02 rows=6567 width=32)
                           Filter: ((to_timestamp((end_time)::double precision))::date &gt; &#39;2012-02-27&#39;::date)
               -&gt;  Sort  (cost=1744.23..1780.71 rows=14591 width=40)
                     Sort Key: b.team_id
                     -&gt;  Subquery Scan on b  (cost=370.29..735.06 rows=14591 width=40)
                           -&gt;  HashAggregate  (cost=370.29..589.15 rows=14591 width=15)
                                 -&gt;  Seq Scan on team_arrive_city  (cost=0.00..288.19 rows=16419 width=15)
(18 rows)
&lt;/pre&gt;&lt;br /&gt;

&lt;p&gt;&lt;br /&gt;
可以看到执行计划已经变了，先做其他表的 join，最后再和大表 join。并且提示的执行时间也大致靠谱。&lt;br /&gt;
&lt;/p&gt;&lt;br /&gt;
&lt;p&gt;&lt;br /&gt;
从这里面引申一下，时常会听到有人说 explain 命令执行后得出的执行时间不靠谱，需要使用 explain analyse。可是为什么不靠谱呢，其实 explain analyse 需要的时间和实际执行时间一样，explain 不靠谱的原因是因为数据库对那个表的统计信息不及时导致的。&lt;br /&gt;
&lt;/p&gt;&lt;br /&gt;
&lt;p&gt;&lt;br /&gt;
再进一步了解，postgres 里面这个统计信息为什么不靠谱呢？难道还总是需要我维护这些信息啊？&lt;br /&gt;
&lt;/p&gt;&lt;br /&gt;
&lt;p&gt;&lt;br /&gt;
其实 postgres 里面有个 autovacuum 进程就是做这个事情的。autovacuum 进程默认是启用的。他会在数据库空闲的时候，对数据库做 vavcuum 和 analyse。具体多久执行一次，&lt;a href=&#34;http://www.postgresql.org/docs/9.1/static/routine-vacuuming.html&#34;&gt;文档&lt;/a&gt; 里面都有写，建议多看看这个页面里面的信息。&lt;br /&gt;
&lt;/p&gt;&lt;br /&gt;
&lt;p&gt;&lt;br /&gt;
此外，还发现 postgres 还提供了很多 &lt;a href=&#34;http://www.postgresql.org/docs/9.1/static/monitoring-stats.html&#34;&gt;数据库状态查询函数&lt;/a&gt; ，使用这里面函数可以查到每个表最后一次 analyse 的时间，vacuum 的时&lt;br /&gt;
间，里面索引被使用的情况等等，好多信息。&lt;br /&gt;
&lt;/p&gt;&lt;br /&gt;

ps: 使用 analyse 之后，那个 sql 好用了，可是发现过两天又不行了，查看 explain select * from t1 好像没问题，那怎么回事呢？开始没想明白，只好继续 analyse 一下，又好了。可过了两天又不行了。这次得细看了。最后发现是因为真实的 sql 是有 where 条件的，日期条件限定的那部分数据查询分析器认为很少导致了问题。没办法后面只好每次导数都 analyse 一下了。发现 pg_bulkload 导数的方式有点问题。&lt;br /&gt;
</description>
    </item>
    
  </channel>
</rss>