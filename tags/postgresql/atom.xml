<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Postgresql on wd and cc</title><link>https://wdicc.com/tags/postgresql/</link><description>Recent content in Postgresql on wd and cc</description><generator>Hugo</generator><language>en</language><copyright>wd © 2025</copyright><lastBuildDate>Sun, 02 Feb 2020 11:04:47 +0800</lastBuildDate><atom:link href="https://wdicc.com/tags/postgresql/atom.xml" rel="self" type="application/rss+xml"/><item><title>PostgreSQL at Low Level</title><link>https://wdicc.com/postgresql-at-low-level/</link><pubDate>Sun, 02 Feb 2020 11:04:47 +0800</pubDate><guid>https://wdicc.com/postgresql-at-low-level/</guid><description>&lt;p&gt;总结一下这篇文章 &lt;a href="https://erthalion.info/2019/12/06/postgresql-stay-curious/"&gt;PostgreSQL at low level: stay curious!&lt;/a&gt;&lt;/p&gt;
&lt;div id="outline-container-headline-1" class="outline-3"&gt;
&lt;h3 id="headline-1"&gt;
Introduction
&lt;/h3&gt;
&lt;div id="outline-text-headline-1" class="outline-text-3"&gt;
&lt;p&gt;
我们之前使用数据库的时候，生产环境都只在实体机上面使用，测试和开发为了资源复用会在虚拟机 vm 上面使用。&lt;/p&gt;
&lt;p&gt;
但是现在不少在 vm k8s 或者 aws 上面使用 db 数据库的，实际这里面可能有很多潜在的问题。以前是 pg - OS 这样两层结构，现在是 pg - os - cg - vm - k8s 这样多层结构，这里面任何一层出现问题实际都会导致你的查询变慢。我们以前虚拟机上面跑服务的时候，有时候就会被同物理机其他虚拟机上面的服务影响，例如突然的高 io。这样即使怎么看那个执行计划估计也没用，你必须去研究更底层可能的影响。&lt;/p&gt;</description></item><item><title>ST_Buffer in Postgis</title><link>https://wdicc.com/st_buffer_in_postgis/</link><pubDate>Wed, 04 Dec 2019 10:33:20 +0800</pubDate><guid>https://wdicc.com/st_buffer_in_postgis/</guid><description>&lt;p&gt;
Postgis 一直没仔细用过，总是临到用时看看文档，这不又遇到问题了，折腾半天。&lt;/p&gt;
&lt;p&gt;
我们最近有一个需求是，需要把一些原有的多边形范围扩大 50 公里，然后和其他的图形比较看是否有包含关系。是否有包含这个不用看也知道，gis 肯定有现成的函数，那么问题就在于怎么扩大一个多边形的范围。&lt;/p&gt;</description></item><item><title>Bloat and Query Speed in PostgreSQL</title><link>https://wdicc.com/bloat-and-query-speed-in-postgresql/</link><pubDate>Fri, 09 Dec 2016 12:12:21 +0800</pubDate><guid>https://wdicc.com/bloat-and-query-speed-in-postgresql/</guid><description>&lt;p&gt;内容反义自 &lt;a href="https://www.citusdata.com/blog/2016/11/04/autovacuum-not-the-enemy/"&gt;https://www.citusdata.com/blog/2016/11/04/autovacuum-not-the-enemy/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;pg 的 mvcc 会导致表索引的 bloat 就不多说了。说一下不合理处理这种 bloat 害处是啥。&lt;/p&gt;
&lt;p&gt;首先肯定是会浪费空间。然后也会影响查询速度。表和索引存储的时候都是 8kB 一个 page，如果一个查询一些行，数据库会加载这些 pages 到内存。一个 page 里面的 dead rows 越多，在加载的时候就越浪费 I/O。例如全表扫描会加载所有的 dead rows。&lt;/p&gt;</description></item><item><title>Full page write in PostgreSQL</title><link>https://wdicc.com/full-page-write-in-postgresql/</link><pubDate>Thu, 08 Dec 2016 18:02:14 +0800</pubDate><guid>https://wdicc.com/full-page-write-in-postgresql/</guid><description>&lt;p&gt;读了一篇&lt;a href="http://blog.2ndquadrant.com/on-the-impact-of-full-page-writes/"&gt;文章&lt;/a&gt;，简单翻译总结下。&lt;/p&gt;
&lt;h2 id="partial-writes--torn-pages"&gt;Partial Writes / Torn Pages&lt;/h2&gt;
&lt;p&gt;pg 默认是 8kB 一个 page。linux 文件系统一般是 4kB（x86 里面最大是 4kB)，老设备驱动一般是 512B 一个扇区，新的设备有些支持 4kB 或者 8kB。&lt;/p&gt;
&lt;p&gt;当 pg 写入一个 page 8kB 的时候，系统的底层会拆分小一点块，这里涉及到写入的原子性。8kB 的 pg page，会被文件系统拆分成 4kB 的块，然后拆分成 512B 扇区大小。这个时候如果系统崩溃（比如停电，内核 bug）会发生什么？&lt;/p&gt;</description></item><item><title>Built in sharding in PostgreSQL</title><link>https://wdicc.com/built-in-sharding-in-postgresql/</link><pubDate>Wed, 07 Dec 2016 16:54:59 +0800</pubDate><guid>https://wdicc.com/built-in-sharding-in-postgresql/</guid><description>&lt;p&gt;PostgreSQL 内建 sharding 支持，粗略翻译自 &lt;a href="https://wiki.postgresql.org/wiki/Built-in_Sharding"&gt;https://wiki.postgresql.org/wiki/Built-in_Sharding&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;p&gt;内建支持 sharding 最大的挑战是，如何用最小的代码修改实现。大部分社区的 sharding 修改支持都修改了很多 PostgreSQL 的代码，这也导致这些不能被 Postgres 社区那些不需要 sharding 的人接受。有了 FDW 之后，就有了在有限代码修改情况下实现内建 sharding 支持的可能。&lt;/p&gt;</description></item><item><title>postgresql transaction isolation</title><link>https://wdicc.com/postgresql-transaction-isolation/</link><pubDate>Sun, 10 May 2015 23:20:49 +0800</pubDate><guid>https://wdicc.com/postgresql-transaction-isolation/</guid><description>&lt;p&gt;翻译自 &lt;a href="http://www.postgresql.org/docs/current/static/transaction-iso.html"&gt;http://www.postgresql.org/docs/current/static/transaction-iso.html&lt;/a&gt;， 内容没翻译全，供参考。&lt;/p&gt;
&lt;h2 id="并发控制"&gt;并发控制&lt;/h2&gt;
&lt;h3 id="132-事务隔离级别"&gt;13.2 事务隔离级别&lt;/h3&gt;
&lt;p&gt;SQL 标准定义了四个事务隔离级别。最严格的就是串行化(Serializable)，根据标准定义，任何并发的串行化事务如果在相同的时间使用相同的顺序执行，那么需要有相同的执行结果。其他的三个隔离级别，都定义了在并发事务互相影响的情况下，在各隔离级别下不允许出现的一些现象。根据标准，这些现象都不允许出现在串行化这个级别。(这并不令人惊讶 &amp;ndash; 如果为了事务的结果一致只允许同时运行一个事务，那怎么可能会出现因为事务互相影响产生的现象)。&lt;/p&gt;</description></item><item><title>Postgresql 里面连接其他数据库</title><link>https://wdicc.com/fdw-in-postgresql/</link><pubDate>Sun, 06 May 2012 00:00:00 +0000</pubDate><guid>https://wdicc.com/fdw-in-postgresql/</guid><description>&lt;p&gt;PG 9.x 引入了 fdw，可以通过 pg 去连接其他 db，不仅限于其他 pg，还可以是 mysql，oracle，文件等。按照设计，fdw 还应该提供给查询规划器一些对方 db 的索引等信息，这样在查询过程中可以提升查询速度。&lt;br /&gt;
&lt;/p&gt;</description></item><item><title>postgresql 里面的 generate_series</title><link>https://wdicc.com/generate_series-function-in-postgresql/</link><pubDate>Fri, 14 Oct 2011 00:00:00 +0000</pubDate><guid>https://wdicc.com/generate_series-function-in-postgresql/</guid><description>&lt;p&gt;有个报表需要把几天的记录按照小时 join 起来，最开始的作法是通过 js 来 join 数据。后来遇到了问题，就是某天某个小时可能会没有记录，然后想破头了，在 js 里面循环的时候设置每天循环到的当前的小时。可崩溃的是还会出现有的是这两小时没有，有的是另外的，用 js 搞不定了，就尝试用 sql 搞定。&lt;br /&gt;
&lt;/p&gt;</description></item></channel></rss>