<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Postgresql on wd and cc</title><link>https://wdicc.com/tags/postgresql/</link><description>Recent content in Postgresql on wd and cc</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Sun, 02 Feb 2020 11:04:47 +0800</lastBuildDate><atom:link href="https://wdicc.com/tags/postgresql/atom.xml" rel="self" type="application/rss+xml"/><item><title>PostgreSQL at Low Level</title><link>https://wdicc.com/postgresql-at-low-level/</link><pubDate>Sun, 02 Feb 2020 11:04:47 +0800</pubDate><guid>https://wdicc.com/postgresql-at-low-level/</guid><description>&lt;p>总结一下这篇文章 &lt;a href="https://erthalion.info/2019/12/06/postgresql-stay-curious/">PostgreSQL at low level: stay curious!&lt;/a>&lt;/p>
&lt;div id="outline-container-headline-1" class="outline-3">
&lt;h3 id="headline-1">
Introduction
&lt;/h3>
&lt;div id="outline-text-headline-1" class="outline-text-3">
&lt;p>
我们之前使用数据库的时候，生产环境都只在实体机上面使用，测试和开发为了资源复用会在虚拟机 vm 上面使用。&lt;/p></description></item><item><title>ST_Buffer in Postgis</title><link>https://wdicc.com/st_buffer_in_postgis/</link><pubDate>Wed, 04 Dec 2019 10:33:20 +0800</pubDate><guid>https://wdicc.com/st_buffer_in_postgis/</guid><description>&lt;p>
Postgis 一直没仔细用过，总是临到用时看看文档，这不又遇到问题了，折腾半天。&lt;/p>
&lt;p>
我们最近有一个需求是，需要把一些原有的多边形范围扩大 50 公里，然后和其他的图形比较看是否有包含关系。是否有包含这个不用看也知道，gis 肯定有现成的函数，那么问题就在于怎么扩大一个多边形的范围。&lt;/p></description></item><item><title>Bloat and Query Speed in PostgreSQL</title><link>https://wdicc.com/bloat-and-query-speed-in-postgresql/</link><pubDate>Fri, 09 Dec 2016 12:12:21 +0800</pubDate><guid>https://wdicc.com/bloat-and-query-speed-in-postgresql/</guid><description>&lt;p>内容反义自 &lt;a href="https://www.citusdata.com/blog/2016/11/04/autovacuum-not-the-enemy/">https://www.citusdata.com/blog/2016/11/04/autovacuum-not-the-enemy/&lt;/a>&lt;/p>
&lt;p>pg 的 mvcc 会导致表索引的 bloat 就不多说了。说一下不合理处理这种 bloat 害处是啥。&lt;/p>
&lt;p>首先肯定是会浪费空间。然后也会影响查询速度。表和索引存储的时候都是 8kB 一个 page，如果一个查询一些行，数据库会加载这些 pages 到内存。一个 page 里面的 dead rows 越多，在加载的时候就越浪费 I/O。例如全表扫描会加载所有的 dead rows。&lt;/p></description></item><item><title>Full page write in PostgreSQL</title><link>https://wdicc.com/full-page-write-in-postgresql/</link><pubDate>Thu, 08 Dec 2016 18:02:14 +0800</pubDate><guid>https://wdicc.com/full-page-write-in-postgresql/</guid><description>&lt;p>读了一篇&lt;a href="http://blog.2ndquadrant.com/on-the-impact-of-full-page-writes/">文章&lt;/a>，简单翻译总结下。&lt;/p>
&lt;h2 id="partial-writes--torn-pages">Partial Writes / Torn Pages&lt;/h2>
&lt;p>pg 默认是 8kB 一个 page。linux 文件系统一般是 4kB（x86 里面最大是 4kB)，老设备驱动一般是 512B 一个扇区，新的设备有些支持 4kB 或者 8kB。&lt;/p></description></item><item><title>Built in sharding in PostgreSQL</title><link>https://wdicc.com/built-in-sharding-in-postgresql/</link><pubDate>Wed, 07 Dec 2016 16:54:59 +0800</pubDate><guid>https://wdicc.com/built-in-sharding-in-postgresql/</guid><description>&lt;p>PostgreSQL 内建 sharding 支持，粗略翻译自 &lt;a href="https://wiki.postgresql.org/wiki/Built-in_Sharding">https://wiki.postgresql.org/wiki/Built-in_Sharding&lt;/a>&lt;/p>
&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>内建支持 sharding 最大的挑战是，如何用最小的代码修改实现。大部分社区的 sharding 修改支持都修改了很多 PostgreSQL 的代码，这也导致这些不能被 Postgres 社区那些不需要 sharding 的人接受。有了 FDW 之后，就有了在有限代码修改情况下实现内建 sharding 支持的可能。&lt;/p></description></item><item><title>postgresql transaction isolation</title><link>https://wdicc.com/postgresql-transaction-isolation/</link><pubDate>Sun, 10 May 2015 23:20:49 +0800</pubDate><guid>https://wdicc.com/postgresql-transaction-isolation/</guid><description>&lt;p>翻译自 &lt;a href="http://www.postgresql.org/docs/current/static/transaction-iso.html">http://www.postgresql.org/docs/current/static/transaction-iso.html&lt;/a>， 内容没翻译全，供参考。&lt;/p>
&lt;h2 id="并发控制">并发控制&lt;/h2>
&lt;h3 id="132-事务隔离级别">13.2 事务隔离级别&lt;/h3>
&lt;p>SQL 标准定义了四个事务隔离级别。最严格的就是串行化(Serializable)，根据标准定义，任何并发的串行化事务如果在相同的时间使用相同的顺序执行，那么需要有相同的执行结果。其他的三个隔离级别，都定义了在并发事务互相影响的情况下，在各隔离级别下不允许出现的一些现象。根据标准，这些现象都不允许出现在串行化这个级别。(这并不令人惊讶 &amp;ndash; 如果为了事务的结果一致只允许同时运行一个事务，那怎么可能会出现因为事务互相影响产生的现象)。&lt;/p></description></item><item><title>Postgresql 里面连接其他数据库</title><link>https://wdicc.com/fdw-in-postgresql/</link><pubDate>Sun, 06 May 2012 00:00:00 +0000</pubDate><guid>https://wdicc.com/fdw-in-postgresql/</guid><description>&lt;p>PG 9.x 引入了 fdw，可以通过 pg 去连接其他 db，不仅限于其他 pg，还可以是 mysql，oracle，文件等。按照设计，fdw 还应该提供给查询规划器一些对方 db 的索引等信息，这样在查询过程中可以提升查询速度。&lt;br />
&lt;/p></description></item><item><title>postgresql 里面的 generate_series</title><link>https://wdicc.com/generate_series-function-in-postgresql/</link><pubDate>Fri, 14 Oct 2011 00:00:00 +0000</pubDate><guid>https://wdicc.com/generate_series-function-in-postgresql/</guid><description>&lt;p>有个报表需要把几天的记录按照小时 join 起来，最开始的作法是通过 js 来 join 数据。后来遇到了问题，就是某天某个小时可能会没有记录，然后想破头了，在 js 里面循环的时候设置每天循环到的当前的小时。可崩溃的是还会出现有的是这两小时没有，有的是另外的，用 js 搞不定了，就尝试用 sql 搞定。&lt;br />
&lt;/p></description></item></channel></rss>