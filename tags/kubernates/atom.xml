<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>kubernates on wd and cc</title><link>https://wdicc.com/tags/kubernates/</link><description>Recent content in kubernates on wd and cc</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 07 Mar 2020 09:58:33 +0800</lastBuildDate><atom:link href="https://wdicc.com/tags/kubernates/atom.xml" rel="self" type="application/rss+xml"/><item><title>Dont Need Kubernates</title><link>https://wdicc.com/dont-need-kubernates/</link><pubDate>Sat, 07 Mar 2020 09:58:33 +0800</pubDate><guid>https://wdicc.com/dont-need-kubernates/</guid><description>翻译自 “Let’s use Kubernetes!” Now you have 8 problems ，这个东西和所谓什么中台，微服务类似，小公司弄这些东西就是瞎折腾。 如果你使用 Docker，那正常来说下一步会考虑 kubernates (aka k8s)：生产环境就应该这样，对吧？ 这个，可能吧。针对 500 个软件工程师开发一个软件和 50 个工程师的方案会有比较大的不同。也和 5 个工程师的团队的方案不一样。 如果你是个小团队，kubernates 可能并不适合你：弊大于利。 下面看看为啥这么说。 Everyone loves moving parts 大家都喜欢组件化？ Kubernates 有很多组件，概念，子系统，进程，服务器，代码，这些也意味着更多的问题。 Multiple machines Kubernates 是个分布式系统：有主服务器控制工作服务器。工作会分配到不同的工作服务器上面。每个服务器在容器里面完成这些工作。 所以，你可能已经使用2台服务器或者虚拟机把事情都解决了。And that just gives you … one machine. If you’re going to scale (the whole point of the exercise) you need three or four or seventeen VMs.</description></item><item><title>Book Review of Kubernates in Action</title><link>https://wdicc.com/book-review-of-kubernates-in-action/</link><pubDate>Thu, 05 Mar 2020 16:02:50 +0800</pubDate><guid>https://wdicc.com/book-review-of-kubernates-in-action/</guid><description>这几天看了一下 Kubernates in action 这本书，看的是中文版本。把自己觉得有用的记录一下。 怎么决定一个 pod 里面包含多少容器？基本上更倾向于分开。 它们必须要一起运行还是可以在不同主机运行？ 他们代表的是一个整体还是相互独立的组件？ 他们必须一起进行扩缩容还是可以分别进行？ pod 定义中的端口是展示性的，有没有设置不影响是否可以被连接，明确定义的 pod 端口可以方便查看，另外为端口命名还可以方便引用。 可以使用 kubectl explain pod.spec 查看具体字段的定义 可以使用 kubectl port-forward kubi-manual 8888:8080 把本地 8888 的请求转发到对应的 kubi-manual pod 里面。 使用标签组织 pod 可以方便的管理。 app：指定 pod 属于哪个应用，组件，或者微服务。 rel：指定 pod 中运行的程序是版本是 stable，beta，canary。 可以在 pod.</description></item></channel></rss>