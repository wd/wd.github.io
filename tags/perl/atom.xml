<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Perl on wd and cc</title>
    <link>https://wdicc.com/tags/perl/</link>
    <description>Recent content in Perl on wd and cc</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 08 May 2011 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://wdicc.com/tags/perl/atom.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>alarm 使用不当遇到的问题</title>
      <link>https://wdicc.com/alarm-%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sun, 08 May 2011 00:00:00 +0000</pubDate>
      
      <guid>https://wdicc.com/alarm-%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>前段时间发现有个程序总是运行一段时间就挂掉，看各种日志里面都没有错误信息，感觉就是莫名其妙突然进程就没了。

大概流程是有个 perl 程序 a.pl
..... my $pid = fork(); if ( !$pid ) { my $cmdRet = `b.pl 2&amp;1`; print FILE $cmdRet; if ( $status ) { warn &#34;task failed&#34;; } else { warn &#34;task success&#34;; } exit; } waitpid ........ 

b.pl 里面会执行 rsync 去获取一些文件，他会循环到几个机器上面去 rsync
for ( @hosts ) { my $result = `rsync xxxxx 2&amp;1`; if ( $? ) { log($result); log(&#34;failed&#34;); } else { log($result); log(&#34;</description>
    </item>
    
    <item>
      <title>解析纯真 ip 库</title>
      <link>https://wdicc.com/%E8%A7%A3%E6%9E%90%E7%BA%AF%E7%9C%9F-ip-%E5%BA%93/</link>
      <pubDate>Thu, 10 Mar 2011 00:00:00 +0000</pubDate>
      
      <guid>https://wdicc.com/%E8%A7%A3%E6%9E%90%E7%BA%AF%E7%9C%9F-ip-%E5%BA%93/</guid>
      <description>纯真的 ip 库应用比较广泛，就那个 qqwry.dat。以前尝试过解析，死活弄不明白那写地址和 pack/unpack 啥的，晕的不行。这两天需要解析下，就尝试用 perl 写一个。
开始用 sysread/sysseek 很多都读不出来，看了n遍程序，没觉得有啥问题。后来全部改成了 read/seek 就好了，也不知道怎么回事。画了一个图说明下，参考了 http://lumaqq.linuxsir.org/article/qqwry_format_detail.html 。
发件人 2011-3-10
读来的3字节地址需要加 &#34;\0&#34; 才能 unpack，不知道怎么回事，对这些问题弄不明白。对了，网上还有个 perl 版的，也能用，需要的话可以搜一下。</description>
    </item>
    
    <item>
      <title>perl 里面的信号处理</title>
      <link>https://wdicc.com/perl-%E9%87%8C%E9%9D%A2%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/</link>
      <pubDate>Sat, 01 Jan 2011 00:00:00 +0000</pubDate>
      
      <guid>https://wdicc.com/perl-%E9%87%8C%E9%9D%A2%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/</guid>
      <description>perl 里面的信号处理很简单，就是给 %SIG 这个 hash 赋值就好了。前几天遇到个问题，处理 SIG{CHLD} 的时候，我本来只起一个 child 进程，可是发现这个信号会被触发多次，开始弄不明白，后来偶然想到是不是 system，exec 之类的函数弄出来的，搜了下果然。
perl 里面调用外部命令是会 fork 一个子进程的，所以也会触发那个信号，想避免可以设置局部变量，例如
$SIG{CHLD} = sub { print &#34;main\n&#34;; }; ..... { local $SIG{CHLD} = undef; # 注意调用外部命令的时候，如果 IGNORE 就捕捉不了结果了 `mv xxx yyy`; system(xxxxx); } ..... 
使用 {} 来构造局部变量的方法有时候会让问题变的非常简单。
另外，信号触发的时候，会把 sleep 中断，这个在 sleep 的 doc 里面说的很明白。如果还是想 sleep 到足够的时间，可以用下面的方法。
my $timeLeft = 10; while ( 1 ) { last if $timeLeft 越来越感觉写 perl 还是很给力的，很多的奇技淫巧，不过我现在也是属于没弄明白多少，瞎写。</description>
    </item>
    
    <item>
      <title>无聊又写一个用来发邮件的 pm..</title>
      <link>https://wdicc.com/%E6%97%A0%E8%81%8A%E5%8F%88%E5%86%99%E4%B8%80%E4%B8%AA%E7%94%A8%E6%9D%A5%E5%8F%91%E9%82%AE%E4%BB%B6%E7%9A%84-pm../</link>
      <pubDate>Fri, 09 Jul 2010 00:00:00 +0000</pubDate>
      
      <guid>https://wdicc.com/%E6%97%A0%E8%81%8A%E5%8F%88%E5%86%99%E4%B8%80%E4%B8%AA%E7%94%A8%E6%9D%A5%E5%8F%91%E9%82%AE%E4%BB%B6%E7%9A%84-pm../</guid>
      <description>继使用 perl 发中文标题邮件，和中文附件邮件后，又把他们整合了一下写了一个 pm 干这个事。
其实发带附件的邮件应该是有现成的 pm 干这个事的，比如 MIME::Lite 之类，没特殊需求还是用那个吧，这个纯属无聊写的。
文件前面有使用方法。。
package SendMail; use strict; use warnings; use Data::Dumper; use Encode; use MIME::Base64; =head1 Examples use SendMail; my $sm = SendMail-new( { To = &#39;you@foo.com, other@bar.com&#39;, Subject = &#39;just a test 中文&#39;, }); -- or -- my $sm = SendMail-new( { From = &#39;me@abc.com&#39;, To = &#39;you@foo.com, other@bar.com&#39;, Subject = &#39;just a test 中文&#39;, } ); -- or -- my $sm = SendMail-new( { From = &#39;me@abc.</description>
    </item>
    
    <item>
      <title>使用 perl 发带附件的邮件</title>
      <link>https://wdicc.com/%E4%BD%BF%E7%94%A8-perl-%E5%8F%91%E5%B8%A6%E9%99%84%E4%BB%B6%E7%9A%84%E9%82%AE%E4%BB%B6/</link>
      <pubDate>Mon, 05 Jul 2010 00:00:00 +0000</pubDate>
      
      <guid>https://wdicc.com/%E4%BD%BF%E7%94%A8-perl-%E5%8F%91%E5%B8%A6%E9%99%84%E4%BB%B6%E7%9A%84%E9%82%AE%E4%BB%B6/</guid>
      <description>继 上篇 使用 perl 发带中文标题的邮件后，又研究了下发带附件的。
基本差别不大，主要是那个 Content-type 要变一下。那个 boundary 可以自己随便写，和后面的统一就行了。
my $title = encode_base64(&#34;标题&#34;, &#34;&#34;); my $body = encode_base64(&#34;邮件正文&#34;); my $attach = encode_base64(&#34;附件内容&#34;); my $filename = encode(&#39;MIME-B&#39;, decode(&#39;utf8&#39;, &#34;文件中文.txt&#34;)) open(MAIL, &#39;|/usr/sbin/sendmail -t&#39;); print MAIL &#34;From: test\@abs.com\r\n&#34;; print MAIL &#34;To: test\@abs.com\r\n&#34;; print MAIL &#34;Subject: =?UTF-8?B?$title?=\r\n&#34;; print MAIL &#34;MIME-Version: 1.0\r\n&#34;; # print MAIL &#34;Content-type: text/plain; charset=utf-8\r\n&#34;; print MAIL </description>
    </item>
    
    <item>
      <title>使用 perl 发送中文邮件标题乱码</title>
      <link>https://wdicc.com/%E4%BD%BF%E7%94%A8-perl-%E5%8F%91%E9%80%81%E4%B8%AD%E6%96%87%E9%82%AE%E4%BB%B6%E6%A0%87%E9%A2%98%E4%B9%B1%E7%A0%81/</link>
      <pubDate>Wed, 30 Jun 2010 00:00:00 +0000</pubDate>
      
      <guid>https://wdicc.com/%E4%BD%BF%E7%94%A8-perl-%E5%8F%91%E9%80%81%E4%B8%AD%E6%96%87%E9%82%AE%E4%BB%B6%E6%A0%87%E9%A2%98%E4%B9%B1%E7%A0%81/</guid>
      <description>代码如下面，解决乱码的方法是使用 base64 编码。
use MIME::Base64::Perl; open(MAIL, &#39;|/usr/sbin/sendmail -t&#39;); my $recver = &#39;wangdong@abc.com&#39;; my $alertTitle = &#34;中文 asdfsdf sdfsdf sdf sdf s df sd fsd f sd fsd f sdf sdf sdf&#34;; my $alertText = &#34;body &#34;; my $encoded = encode_base64($alertTitle, &#34;&#34;); print MAIL &#34;From: alert\@abc.com\r\n&#34;; print MAIL &#34;To: $recver\r\n&#34;; print MAIL &#34;Subject: =?UTF-8?B?&#34; . $encoded . &#34;?=\r\n&#34;; print MAIL &#34;MIME-Version: 1.0\r\n&#34;; print MAIL &#34;Content-type: text/plain; charset=utf-8\r\n&#34;; print MAIL &#34;\n&#34;; print MAIL &#34;</description>
    </item>
    
    <item>
      <title>perl and fork</title>
      <link>https://wdicc.com/perl-and-fork/</link>
      <pubDate>Sat, 07 Mar 2009 00:00:00 +0000</pubDate>
      
      <guid>https://wdicc.com/perl-and-fork/</guid>
      <description>最近写程序用到了 fork ，记一下。
我在 perl 里面某个地方开始，fork 多个进程去操作 db，主进程等子进程完事后，再继续后面的操作。
use POSIX &#34;:sys_wait_h&#34;; my $thread_num = 5; my %pids = (); # $dbi-{InactiveDestroy} = 1 用到 dbi 的话还要设置这个，要不子进程exit后，dbi # 连接就断了 # .....前面的程序 for ( 1..$thread_num ) { my $pid = fork; if (not $pid) { # 子进程 $pids{$pid} = 1; # blalbalbla... 子进程去干活 eixt 0; # 要记得 exit ，要不子进程还会继续执行后面的。 } else { # 主进程 # balbalbal ... 如果没事做也可以不写 } } while( keys( %pids ) ) { my $kid = waitpid(-1,WNOHANG); if ($kid 0) { delete $pids{$kid}; print &#34;</description>
    </item>
    
    <item>
      <title>使用 perl 来登录网页</title>
      <link>https://wdicc.com/%E4%BD%BF%E7%94%A8-perl-%E6%9D%A5%E7%99%BB%E5%BD%95%E7%BD%91%E9%A1%B5/</link>
      <pubDate>Tue, 06 Jan 2009 00:00:00 +0000</pubDate>
      
      <guid>https://wdicc.com/%E4%BD%BF%E7%94%A8-perl-%E6%9D%A5%E7%99%BB%E5%BD%95%E7%BD%91%E9%A1%B5/</guid>
      <description>应该不能用。。。只是为了记录
使用 LWP::UserAgent 可以简单的去访问网页，获取页面内容。例如
use LWP::UserAgent; my $ua = LWP::UserAgent-new(); $ua-timeout(10); $ua-agent(&#39;mozilla&#39;); my $r = $ua-get(&#39;http::/www.google.com&#39;); print $r-content; # or $r-decoded-content 
$r 的其它属性可以去 cpan 看看。这样就获取到了内容。但是，如果一个网页是需要登录的怎么办？可以用保存 cookie 的方式。
use LWP::UserAgent; use HTTP::Cookies; use Digest::MD5 qw(md5 md5_hex); # 用来生成 md5 的 use JSON; # 用来在 json 串和 perl 的 hash 串之间转换 use Data::Dumper; my $cookie_jar = HTTP::Cookies-new( file = &#34;lw.dat&#34;, autosave = 1 ); my $ua = LWP::UserAgent-new(); $ua-timeout(10); $ua-agent(&#39;mozilla&#39;); my(@rest) = (&#34;</description>
    </item>
    
  </channel>
</rss>