<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Fork on wd and cc</title>
    <link>https://wdicc.com/tags/fork/atom/index.xml</link>
    <description>Recent content in Fork on wd and cc</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <atom:link href="https://wdicc.com/tags/fork/atom/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>perl and fork</title>
      <link>https://wdicc.com/perl-and-fork/</link>
      <pubDate>Sat, 07 Mar 2009 00:00:00 +0000</pubDate>
      
      <guid>https://wdicc.com/perl-and-fork/</guid>
      <description>最近写程序用到了 fork ，记一下。&lt;br /&gt;

我在 perl 里面某个地方开始，fork 多个进程去操作 db，主进程等子进程完事后，再继续后面的操作。&lt;br /&gt;

&lt;pre class=&#34;prettyprint lang-perl&#34;&gt;
use POSIX &#34;:sys_wait_h&#34;;
my $thread_num = 5;
my %pids = ();

# $dbi-&gt;{InactiveDestroy} = 1 用到 dbi 的话还要设置这个，要不子进程exit后，dbi
# 连接就断了

# .....前面的程序
for ( 1..$thread_num ) {
	my $pid = fork;
	if (not $pid) { # 子进程
		$pids{$pid} = 1;
		# blalbalbla... 子进程去干活
		eixt 0; # 要记得 exit ，要不子进程还会继续执行后面的。
	} else { # 主进程
		# balbalbal ... 如果没事做也可以不写
	}
}

while( keys( %pids ) ) {
	my $kid = waitpid(-1,WNOHANG);
	if ($kid &gt;0) {
		delete $pids{$kid};
		print &#34;$kid end.\n&#34;;
	} else {
		sleep 1; # 继续等，如果有时间限制，可以在这里去 kill 子进程
	}
}

# ....继续后面的程序

&lt;/pre&gt;&lt;br /&gt;

还可以参考这个 http://www.perlmonks.org/?node_id=619722&lt;br /&gt;
</description>
    </item>
    
  </channel>
</rss>