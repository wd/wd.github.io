<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>fork on wd and cc</title>
    <link>https://wdicc.com/tags/fork/</link>
    <description>Recent content in fork on wd and cc</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 07 Mar 2009 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://wdicc.com/tags/fork/atom.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>perl and fork</title>
      <link>https://wdicc.com/perl-and-fork/</link>
      <pubDate>Sat, 07 Mar 2009 00:00:00 +0000</pubDate>
      
      <guid>https://wdicc.com/perl-and-fork/</guid>
      <description>最近写程序用到了 fork ，记一下。
我在 perl 里面某个地方开始，fork 多个进程去操作 db，主进程等子进程完事后，再继续后面的操作。
use POSIX &#34;:sys_wait_h&#34;; my $thread_num = 5; my %pids = (); # $dbi-{InactiveDestroy} = 1 用到 dbi 的话还要设置这个，要不子进程exit后，dbi # 连接就断了 # .....前面的程序 for ( 1..$thread_num ) { my $pid = fork; if (not $pid) { # 子进程 $pids{$pid} = 1; # blalbalbla... 子进程去干活 eixt 0; # 要记得 exit ，要不子进程还会继续执行后面的。 } else { # 主进程 # balbalbal ... 如果没事做也可以不写 } } while( keys( %pids ) ) { my $kid = waitpid(-1,WNOHANG); if ($kid 0) { delete $pids{$kid}; print &#34;</description>
    </item>
    
  </channel>
</rss>