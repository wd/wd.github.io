<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>decorator on wd and cc</title>
    <link>https://wdicc.com/tags/decorator/</link>
    <description>Recent content in decorator on wd and cc</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 21 Oct 2016 18:50:59 +0800</lastBuildDate>
    
	<atom:link href="https://wdicc.com/tags/decorator/atom.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>python 的 decorator 学习</title>
      <link>https://wdicc.com/decorator-in-python/</link>
      <pubDate>Fri, 21 Oct 2016 18:50:59 +0800</pubDate>
      
      <guid>https://wdicc.com/decorator-in-python/</guid>
      <description>最近学习了一下 python 的 decorator（装饰器），看的是这篇，Python修饰器的函数式编程， 觉得挺有意思的，写点东西记录一下。
装饰器简单讲就是返回一个函数的函数/类。看个简单的例子。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  #!/usr/bin/python # -*- coding: utf-8 -*- def dec1(fn): print(&amp;#39;inside dec1&amp;#39;) def wrapper(): print(&amp;#39;inside wrapper&amp;#39;) return fn() return wrapper @dec1 def f1(): print(&amp;#39;inside f1&amp;#39;) if __name__ == &amp;#39;__main__&amp;#39;: print(&amp;#39;begin exec&amp;#39;) f1() print(&amp;#39;end exec&amp;#39;) # 执行结果: # inside dec1 # begin exec # inside wrapper # inside f1 # end exec   看上面例子能看到，装饰器生效有 2 个步骤，第一个是装饰，第二个是执行。上面装饰器的效果，和下面的代码的效果是一样。</description>
    </item>
    
  </channel>
</rss>