<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Decorator on wd and cc</title>
    <link>https://wdicc.com/tags/decorator/</link>
    <description>Recent content in Decorator on wd and cc</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 21 Oct 2016 18:50:59 +0800</lastBuildDate>
    
	<atom:link href="https://wdicc.com/tags/decorator/atom.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>python 的 decorator 学习</title>
      <link>https://wdicc.com/decorator-in-python/</link>
      <pubDate>Fri, 21 Oct 2016 18:50:59 +0800</pubDate>
      
      <guid>https://wdicc.com/decorator-in-python/</guid>
      <description>最近学习了一下 python 的 decorator（装饰器），看的是这篇，Python修饰器的函数式编程， 觉得挺有意思的，写点东西记录一下。
装饰器简单讲就是返回一个函数的函数/类。看个简单的例子。
#!/usr/bin/python # -*- coding: utf-8 -*- def dec1(fn): print(&#39;inside dec1&#39;) def wrapper(): print(&#39;inside wrapper&#39;) return fn() return wrapper @dec1 def f1(): print(&#39;inside f1&#39;) if __name__ == &#39;__main__&#39;: print(&#39;begin exec&#39;) f1() print(&#39;end exec&#39;) # 执行结果: # inside dec1 # begin exec # inside wrapper # inside f1 # end exec  看上面例子能看到，装饰器生效有 2 个步骤，第一个是装饰，第二个是执行。上面装饰器的效果，和下面的代码的效果是一样。
#!/usr/bin/python # -*- coding: utf-8 -*- def dec1(fn): print(&#39;inside dec1&#39;) def wrapper(): print(&#39;inside wrapper&#39;) return fn() return wrapper # @dec1 def f1(): print(&#39;inside f1&#39;) if __name__ == &#39;__main__&#39;: print(&#39;begin exec&#39;) dec1(f1)() print(&#39;end exec&#39;) # 执行结果: # begin exec # inside dec1 # inside wrapper # inside f1 # end exec  可以看到除了 「begin/end exec」，其他部分执行结果是一样的。所以理解装饰器，就把 @dec1 换成 dec1(fn)() 这么理解就可以了。</description>
    </item>
    
  </channel>
</rss>