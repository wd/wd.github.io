<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>django on wd and cc</title>
    <link>https://wdicc.com/tags/django/</link>
    <description>Recent content in django on wd and cc</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 19 Jun 2019 15:38:56 +0800</lastBuildDate>
    
	<atom:link href="https://wdicc.com/tags/django/atom.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Django Testing</title>
      <link>https://wdicc.com/django-testing/</link>
      <pubDate>Wed, 19 Jun 2019 15:38:56 +0800</pubDate>
      
      <guid>https://wdicc.com/django-testing/</guid>
      <description>Django 自己的 unittest 支持的挺好，一般只需要在 app 下面加一个 tests.py 在里面写 case 就可以了。case 对应的类继承 django.test.TestCase 就好。
每一个测试类里面，都可以有一个 setUp 方法，是在 case 方法执行前执行，例如一些准备工作，和一个 tearDown 方法，在 case 执行之后执行，例如一些清理工作。还可以有若干个使用 test 开头的测试用例。
case 我觉得一般可以分两种，方法测试，和接口测试。
方法测试指针对一些工具方法什么的测试，当然这个说法并不严谨，将就理解吧。我把这些归类为不涉及到数据库操作的测试。
接口测试，一般会涉及到数据库操作，需要验证登录啊，参数什么的。
Django 里面，每个测试用例之间是通过事务互相隔离的，所以不用担心互相之间会有影响。
接口测试可以通过 django.test.Client 来访问你的接口，然后比对返回结果，或者比对数据库的数据来验证。
有时候一些接口是依赖已有数据的，比如一个返回所有用户的接口，那测试的时候数据库是需要有用户才能返回的。这个可以通过 fixture 来 moke 数据。
fixture 就是一些 json 文件，里面放的是和 model 的数据，这样一个测试如果需要某几个 model 对应的表里面事先有数据，那可以把他们放到 fixture 文件里面，让 django 在运行之前先 load 到数据库就可以了。
这些 json 文件自己编写会死，Django 提供了 manage.py dumpdata --indent 4 [app_label[.ModelName] [app_label[.ModelName] 功能，可以方便你导出数据库里面已有的数据。不指定 app_label 和 modelname 就会导出全部的，一般只导出自己需要的就好。注意 json 文件是可以支持缩进的。
如果从比如开发库之类的倒数据，会觉得数据有点乱，从测试库倒数据似乎比较清净，因为每次测试都是一个空的数据库。有一个方法是在测试用例里面创建依赖的数据，但是测试执行完了再执行 manage.</description>
    </item>
    
    <item>
      <title>Debuging Django</title>
      <link>https://wdicc.com/debuging-django/</link>
      <pubDate>Mon, 29 Apr 2019 14:41:12 +0800</pubDate>
      
      <guid>https://wdicc.com/debuging-django/</guid>
      <description>起初 hackernews 看到一个文章 PySnooper: Never use print for debugging again，觉得挺有意思的，结果把 hackernews 的讨论看了一下发现有意思东西更多一点，总结一下。
 [https://github.com/cool-RR/pysnooper][PySnooper]]: Never use print for debugging again，只需要给函数加一个装时期，就可以把函数执行的每一步的结果都打印出来。 [https://django-extensions.readthedocs.io/en/latest/runserver_plus.html][django-extensions]] 的 runserver-plus 配合 Werkzeug 可以实现在遇到异常的时候，支持在 web 上面调试代码，打印异常的时候的上下文内容什么的。 Python 自己的 breakpoint 函数，执行到的时候默认会进入 pdb.set_trace() 状态方便你进行上下文调试。 [https://github.com/gruns/icecream][icecream]] 提供了一个方便的 ic 函数，可以无感的加入到你的代码里面，不影响你的代码的执行结果，但是会打印传给它的参数和执行结果。 [https://github.com/robdmc/behold][Behold]]: A debugging tool for large Python projects，可以替代你写冗长的打印命令。不过感觉它自己的语法似乎也并不方便。。。 VS Code 提供的 Logpoints 和 Visual Studio 提供的 Break When Value Changes。 [https://github.com/cknd/stackprinter][stackprinter]] 可以让你的堆栈打印更友好，打印堆栈的时候还可以输出上下文的取值。 pdb, epdb，ipdb, 应该都是类似的东西，其中 pdb 是自带的。通过给代码增加 import ipdb ipdb.set_trace() 调试。 [https://github.com/tylerwince/pydbg][pydbg]] 替代 print 的。  </description>
    </item>
    
    <item>
      <title>How to Create an Index in Django Without Downtime</title>
      <link>https://wdicc.com/how-to-create-an-index-in-django-without-downtime/</link>
      <pubDate>Fri, 26 Apr 2019 11:46:27 +0800</pubDate>
      
      <guid>https://wdicc.com/how-to-create-an-index-in-django-without-downtime/</guid>
      <description>django 自己带了一个 ORM 实现，基本可以通过 ORM 管理数据库，这样用户可以在不会 SQL 的情况下使用数据库。在对 model 的属性（字段）做了修改之后，通过执行 makemigrations 可以生成一个 migrate 文件，然后执行 migrate 命令可以把这些修改应用到数据库。同时在数据库里面，也会记录当前 migrate 执行的状态，这样能保证数据库的状态和 django 自己认为的数据库的状态是一致的。
但是这里可能会有一个问题，我们有多个数据库环境，也有多个人一起开发，这样就会导致这个有点混乱，多个人修改 model 后都执行了 makemigrations 的话，可能会有冲突和问题（实际上 django 已经考虑过这个问题的，migrate 文件都是按照时间戳来命名的，冲突可能性也不大，但是为了避免新手加入弄不好，所以我们采取了另外一个方法做这个事情）。
下面的内容翻译自 https://realpython.com/create-django-index-without-downtime/ ，我们使用了里面提到的 sqlmigrate 的方式。
管理数据库变更在软件开发中是一个比较大的挑战。幸运的是，从 django 1.7 开始有了内置的数据库变更处理框架。这个框架对于处理数据库变更来说很强大很好用。但是为了保证框架提供的灵活性，有一些妥协在里面。为了理解 django 数据库变更框架的限制，我们将解决一个有名的问题：如何在不停机情况下通过 django 创建索引。
 在这个教程里面，你将学习到： django 是什么时候和如何产生数据库变更的 django 是如何执行变更的 如何按照需要编辑这些变更  这篇文章面向的是对 django 数据库变更（migrations）已经有所了解的人的。如果对这些还不了解，那可以先看看 Django Migrations: A Primer 。
在 django 里面创建索引存在的问题 一个常见的变更是当你的数据增加的时候会需要建索引。索引可以查询的速度和应用的响应速度。
大部分数据库里面增加索引需要在表上面加一个排它锁。当索引创建的时候，排它锁不允许进行数据修改（DML）操作，例如 UPDATE, INSERT, 和 DELETE 。
当数据库执行这些操作的时候，会立刻加锁。例如如果一个用户登录的时候，django 会更新 auth_user 表的 last_login 字段。为了执行这个操作，数据库会先请求一个行锁，如果这行被其他连接加了锁，那你可能会得到一个数据库异常。</description>
    </item>
    
    <item>
      <title>Django middleware</title>
      <link>https://wdicc.com/django-middleware/</link>
      <pubDate>Wed, 05 Jul 2017 18:07:50 +0800</pubDate>
      
      <guid>https://wdicc.com/django-middleware/</guid>
      <description>Django 提供了 middleware 来让你 hack Request 和 Response。用的时候有几个问题需要注意一下。
__call__ 方法 __call__ 方法实际上就是最早收到 request 的地方，如果不关心 view，那么就可以在这里做你想要做的事情。比如认证用户啥的。这个实际上应该就是早期的 process_request 。
process_view 方法 process_view 方法会接收到 view_func 和其参数，如果想要针对这些东西处理，可以在这里动作。比如我们所有 api 请求的 POST 的 body 里面都是固定格式的 json 数据，我就在这里检查了 json 的格式，并把解析结果给到了 view_func。
如果不打算对 view_func 做什么事情，那就最好做完想做的事情，直接返回 None 就可以。否则处理完毕之后，返回一个 response 对象。
要注意的是，这里最好不要产生 exception，产生了会把逻辑跑到 Middleware 的 exception 逻辑里面。所以最好对自己的代码段加上 try-except 逻辑。
另外，这里可以对 view_func 做调用，直接返回 view_func 的结果或者处理之后的结果，只要保证是个 response 对象就可以了。也可以不做调用，返回 None ，后续 django 也会调用。要注意的是，如果你对 view_func 做了调用，那么在捕捉到错误的时候，except 里面应该也需要返回一个 response 对象，不能返回 None 了，否则 djangon 还会再次调用这个 view_func 。</description>
    </item>
    
  </channel>
</rss>