<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Django on wd and cc</title><link>https://wdicc.com/tags/django/</link><description>Recent content in Django on wd and cc</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Sat, 28 Dec 2019 14:11:19 +0800</lastBuildDate><atom:link href="https://wdicc.com/tags/django/atom.xml" rel="self" type="application/rss+xml"/><item><title>Django Channels2</title><link>https://wdicc.com/django-channels2/</link><pubDate>Sat, 28 Dec 2019 14:11:19 +0800</pubDate><guid>https://wdicc.com/django-channels2/</guid><description>&lt;p>Django 3.0.1 has released for sometime. We still use Django 1.11 in one of our project, with Channels 1.1.8, I think it&amp;#39;s the time to upgrade to newest Django and Channels.&lt;/p>
&lt;p>
According this &lt;a href="https://channels.readthedocs.io/en/latest/one-to-two.html#how-to-upgrade">upgrade guide&lt;/a>, Channels 2 is a fully rewritten, lots of things has changed. This post is just a record about the upgrade I&amp;#39;ve done.&lt;/p></description></item><item><title>Add an Force Sync Button in Django Admin</title><link>https://wdicc.com/add-an-force-sync-button-in-django-admin/</link><pubDate>Thu, 12 Dec 2019 13:33:15 +0800</pubDate><guid>https://wdicc.com/add-an-force-sync-button-in-django-admin/</guid><description>&lt;p>我们的系统里面需要和外部的系统同步一些数据，为了保证数据正确处理，增加了一个队列。队列是通过一个 celery 里面的定时任务同步的。定时任务设置是 5 分钟一次，那有时候测试的时候或者出错的时候就可能会想要立刻执行下同步，好看看执行结果，要不很有可能等到下次执行的时候还是有问题，这就有点浪费时间了。&lt;/p></description></item><item><title>Best Pratice for Celery</title><link>https://wdicc.com/best-pratice-for-celery/</link><pubDate>Wed, 17 Jul 2019 15:27:48 +0800</pubDate><guid>https://wdicc.com/best-pratice-for-celery/</guid><description>&lt;div id="outline-container-headline-1" class="outline-3">
&lt;h3 id="headline-1">
Celery beat and worker
&lt;/h3>
&lt;div id="outline-text-headline-1" class="outline-text-3">
&lt;p>
Celery works with two separate parts, the beat and the worker. The beat is the control center which determine when and where to send the tasks, there should be only one beat in each celery network. The worker is the one who runs the tasks and send the results back to the beat, there could be lots of works in each network.&lt;/p></description></item><item><title>Logging in Celery and Django</title><link>https://wdicc.com/logging-in-celery-and-django/</link><pubDate>Fri, 05 Jul 2019 14:26:24 +0800</pubDate><guid>https://wdicc.com/logging-in-celery-and-django/</guid><description>&lt;div id="outline-container-headline-1" class="outline-3">
&lt;h3 id="headline-1">
Get celery work with django
&lt;/h3>
&lt;div id="outline-text-headline-1" class="outline-text-3">
&lt;p>
Celery can work with django, it&amp;#39;s very simple.&lt;/p>
&lt;div class="src src-python">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">from&lt;/span> __future__ &lt;span style="color:#f92672">import&lt;/span> absolute_import
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> os
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">from&lt;/span> celery &lt;span style="color:#f92672">import&lt;/span> Celery
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">from&lt;/span> django.conf &lt;span style="color:#f92672">import&lt;/span> settings
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># set the default Django settings module for the &amp;#39;celery&amp;#39; program.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>os&lt;span style="color:#f92672">.&lt;/span>environ&lt;span style="color:#f92672">.&lt;/span>setdefault(&lt;span style="color:#e6db74">&amp;#39;DJANGO_SETTINGS_MODULE&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;your_app.settings&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>app &lt;span style="color:#f92672">=&lt;/span> Celery(&lt;span style="color:#e6db74">&amp;#39;you_app&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Using a string here means the worker will not have to&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># pickle the object when using Windows.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>app&lt;span style="color:#f92672">.&lt;/span>config_from_object(&lt;span style="color:#e6db74">&amp;#39;django.conf:settings&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>app&lt;span style="color:#f92672">.&lt;/span>autodiscover_tasks(&lt;span style="color:#66d9ef">lambda&lt;/span>: settings&lt;span style="color:#f92672">.&lt;/span>INSTALLED_APPS)&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
Then write some task files named &lt;code>tasks.py&lt;/code> under your apps directory, celery will auto discovery and run these tasks.&lt;/p></description></item><item><title>Django Testing</title><link>https://wdicc.com/django-testing/</link><pubDate>Wed, 19 Jun 2019 15:38:56 +0800</pubDate><guid>https://wdicc.com/django-testing/</guid><description>&lt;p>Django 自己的 unittest 支持的挺好，一般只需要在 app 下面加一个 tests.py 在里面写 case 就可以了。case 对应的类继承 &lt;code class="verbatim">django.test.TestCase&lt;/code> 就好。&lt;/p>
&lt;p>
这个 &lt;code class="verbatim">django.test.TestCase&lt;/code> 继承自 &lt;code class="verbatim">unittest.TestCase&lt;/code> ，django 这个多了一个自动使用事务的功能，所以用 django 这个的话，每个测试用例执行前后会自动回滚数据库操作，这样不用你自己 cleanup 数据，还比较方便。&lt;/p></description></item><item><title>Debuging Django</title><link>https://wdicc.com/debuging-django/</link><pubDate>Mon, 29 Apr 2019 14:41:12 +0800</pubDate><guid>https://wdicc.com/debuging-django/</guid><description>&lt;p>起初 hackernews 看到一个文章 &lt;a href="https://news.ycombinator.com/item?id=19717786">PySnooper: Never use print for debugging again&lt;/a>，觉得挺有意思的，结果把 hackernews 的讨论看了一下发现有意思东西更多一点，总结一下。&lt;/p></description></item><item><title>How to Create an Index in Django Without Downtime</title><link>https://wdicc.com/how-to-create-an-index-in-django-without-downtime/</link><pubDate>Fri, 26 Apr 2019 11:46:27 +0800</pubDate><guid>https://wdicc.com/how-to-create-an-index-in-django-without-downtime/</guid><description>&lt;p>
django 自己带了一个 ORM 实现，基本可以通过 ORM 管理数据库，这样用户可以在不会 SQL 的情况下使用数据库。在对 model 的属性（字段）做了修改之后，通过执行 &lt;code class="verbatim">makemigrations&lt;/code> 可以生成一个 migrate 文件，然后执行 &lt;code class="verbatim">migrate&lt;/code> 命令可以把这些修改应用到数据库。同时在数据库里面，也会记录当前 migrate 执行的状态，这样能保证数据库的状态和 django 自己认为的数据库的状态是一致的。&lt;/p></description></item><item><title>Django middleware</title><link>https://wdicc.com/django-middleware/</link><pubDate>Wed, 05 Jul 2017 18:07:50 +0800</pubDate><guid>https://wdicc.com/django-middleware/</guid><description>&lt;p>
Django 提供了 &lt;a href="https://docs.djangoproject.com/en/1.11/topics/http/middleware/">middleware&lt;/a> 来让你 hack Request 和 Response。用的时候有几个问题需要注意一下。&lt;/p>
&lt;div id="outline-container-headline-1" class="outline-2">
&lt;h2 id="headline-1">
&lt;code class="verbatim">__call__&lt;/code> 方法
&lt;/h2>
&lt;div id="outline-text-headline-1" class="outline-text-2">
&lt;p>
&lt;code class="verbatim">__call__&lt;/code> 方法实际上就是最早收到 request 的地方，如果不关心 view，那么就可以在这里做你想要做的事情。比如认证用户啥的。这个实际上应该就是早期的 &lt;code class="verbatim">process_request&lt;/code> 。&lt;/p></description></item></channel></rss>