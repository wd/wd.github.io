<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>django on wd and cc</title><link>https://wdicc.com/tags/django/</link><description>Recent content in django on wd and cc</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><copyright>Copyright © 2020 wd. All Rights Reserved</copyright><lastBuildDate>Sat, 28 Dec 2019 14:11:19 +0800</lastBuildDate><atom:link href="https://wdicc.com/tags/django/atom.xml" rel="self" type="application/rss+xml"/><item><title>Django Channels2</title><link>https://wdicc.com/django-channels2/</link><pubDate>Sat, 28 Dec 2019 14:11:19 +0800</pubDate><guid>https://wdicc.com/django-channels2/</guid><description>Django 3.0.1 has released for sometime. We still use Django 1.11 in one of our project, with Channels 1.1.8, I think it&amp;#39;s the time to upgrade to newest Django and Channels.
According this upgrade guide, Channels 2 is a fully rewritten, lots of things has changed. This post is just a record about the upgrade I&amp;#39;ve done.</description></item><item><title>Add an Force Sync Button in Django Admin</title><link>https://wdicc.com/add-an-force-sync-button-in-django-admin/</link><pubDate>Thu, 12 Dec 2019 13:33:15 +0800</pubDate><guid>https://wdicc.com/add-an-force-sync-button-in-django-admin/</guid><description>我们的系统里面需要和外部的系统同步一些数据，为了保证数据正确处理，增加了一个队列。队列是通过一个 celery 里</description></item><item><title>Best Pratice for Celery</title><link>https://wdicc.com/best-pratice-for-celery/</link><pubDate>Wed, 17 Jul 2019 15:27:48 +0800</pubDate><guid>https://wdicc.com/best-pratice-for-celery/</guid><description>Celery beat and worker Celery works with two separate parts, the beat and the worker. The beat is the control center which determine when and where to send the tasks, there should be only one beat in each celery network. The worker is the one who runs the tasks and send the results back to the beat, there could be lots of works in each network.</description></item><item><title>Logging in Celery and Django</title><link>https://wdicc.com/logging-in-celery-and-django/</link><pubDate>Fri, 05 Jul 2019 14:26:24 +0800</pubDate><guid>https://wdicc.com/logging-in-celery-and-django/</guid><description>Get celery work with django Celery can work with django, it&amp;#39;s very simple.
from __future__ import absolute_import import os from celery import Celery from django.conf import settings # set the default Django settings module for the &amp;#39;celery&amp;#39; program. os.environ.setdefault(&amp;#39;DJANGO_SETTINGS_MODULE&amp;#39;, &amp;#39;your_app.settings&amp;#39;) app = Celery(&amp;#39;you_app&amp;#39;) # Using a string here means the worker will not have to # pickle the object when using Windows.</description></item><item><title>Django Testing</title><link>https://wdicc.com/django-testing/</link><pubDate>Wed, 19 Jun 2019 15:38:56 +0800</pubDate><guid>https://wdicc.com/django-testing/</guid><description>Django 自己的 unittest 支持的挺好，一般只需要在 app 下面加一个 tests.py 在里面写 case 就可以了。case 对应的类继承 django.test.TestCase 就好。 这个</description></item><item><title>Debuging Django</title><link>https://wdicc.com/debuging-django/</link><pubDate>Mon, 29 Apr 2019 14:41:12 +0800</pubDate><guid>https://wdicc.com/debuging-django/</guid><description>起初 hackernews 看到一个文章 PySnooper: Never use print for debugging again，觉得挺有意思的，结果把 hackernews 的讨论看了一下发现有意思东西更多一</description></item><item><title>How to Create an Index in Django Without Downtime</title><link>https://wdicc.com/how-to-create-an-index-in-django-without-downtime/</link><pubDate>Fri, 26 Apr 2019 11:46:27 +0800</pubDate><guid>https://wdicc.com/how-to-create-an-index-in-django-without-downtime/</guid><description>django 自己带了一个 ORM 实现，基本可以通过 ORM 管理数据库，这样用户可以在不会 SQL 的情况下使用数据库。在对 model 的属性</description></item><item><title>Django middleware</title><link>https://wdicc.com/django-middleware/</link><pubDate>Wed, 05 Jul 2017 18:07:50 +0800</pubDate><guid>https://wdicc.com/django-middleware/</guid><description>Django 提供了 middleware 来让你 hack Request 和 Response。用的时候有几个问题需要注意一下。 __call__ 方法 __call__ 方法实际上就是最早收</description></item></channel></rss>