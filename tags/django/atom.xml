<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>django on wd and cc</title>
    <link>https://wdicc.com/tags/django/</link>
    <description>Recent content in django on wd and cc</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 19 Jun 2019 15:38:56 +0800</lastBuildDate>
    
	<atom:link href="https://wdicc.com/tags/django/atom.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Django Testing</title>
      <link>https://wdicc.com/django-testing/</link>
      <pubDate>Wed, 19 Jun 2019 15:38:56 +0800</pubDate>
      
      <guid>https://wdicc.com/django-testing/</guid>
      <description>Django 自己的 unittest 支持的挺好，一般只需要在 app 下面加一个 tests.py 在里面写 case 就可以了。case 对应的类继承 django.test.TestCase 就好。  这个 django.test.TestCase 继承自 unittest.TestCase ，django 这个多了一个自动使用事务的功能，所以用 django 这个的话，每个测试用例执行前后会自动回滚数据库操作，这样不用你自己 cleanup 数据，还比较方便。 setUp 和 tearDown   每一个测试类里面，都可以有一个 setUp 方法，是在 case 方法执行前执行，例如一些准备工作，和一个 tearDown 方法，在 case 执行之后执行，例如一些清理工作。还可以有若干个使用 test_ 开头的测试用例，这些 setUp 其实类似于把每个测试用例里面共同的部分提取出来一样，不过是不用你在每个 case 里面单独调用了，会自动处理。 setUpClass 和 tearDownClass   django 还提供了 setUpClass 和 tearDownClass ，类似上面的 setUp 方法，不过这个是每个 class 只会执行一次。另外按照这里的说法， setUpClass 不会使用事务，不过我看源码(django 2.1.4) 好像是会的，我没测试。。 @classmethod def setUpClass(cls): super().setUpClass() if not connections_support_transactions(): return cls.</description>
    </item>
    
    <item>
      <title>Debuging Django</title>
      <link>https://wdicc.com/debuging-django/</link>
      <pubDate>Mon, 29 Apr 2019 14:41:12 +0800</pubDate>
      
      <guid>https://wdicc.com/debuging-django/</guid>
      <description>起初 hackernews 看到一个文章 PySnooper: Never use print for debugging again，觉得挺有意思的，结果把 hackernews 的讨论看了一下发现有意思东西更多一点，总结一下。    PySnooper: Never use print for debugging again，只需要给函数加一个装时期，就可以把函数执行的每一步的结果都打印出来。    django-extensions 的 runserver-plus 配合 Werkzeug 可以实现在遇到异常的时候，支持在 web 上面调试代码，打印异常的时候的上下文内容什么的。    Python 自己的 breakpoint 函数，执行到的时候默认会进入 pdb.set_trace() 状态方便你进行上下文调试。    icecream 提供了一个方便的 ic 函数，可以无感的加入到你的代码里面，不影响你的代码的执行结果，但是会打印传给它的参数和执行结果。    Behold: A debugging tool for large Python projects，可以替代你写冗长的打印命令。不过感觉它自己的语法似乎也并不方便。。。    VS Code 提供的 Logpoints 和 Visual Studio 提供的 Break When Value Changes。    stackprinter 可以让你的堆栈打印更友好，打印堆栈的时候还可以输出上下文的取值。    pdb, epdb，ipdb, 应该都是类似的东西，其中 pdb 是自带的。通过给代码增加 import ipdb ipdb.</description>
    </item>
    
    <item>
      <title>How to Create an Index in Django Without Downtime</title>
      <link>https://wdicc.com/how-to-create-an-index-in-django-without-downtime/</link>
      <pubDate>Fri, 26 Apr 2019 11:46:27 +0800</pubDate>
      
      <guid>https://wdicc.com/how-to-create-an-index-in-django-without-downtime/</guid>
      <description>django 自己带了一个 ORM 实现，基本可以通过 ORM 管理数据库，这样用户可以在不会 SQL 的情况下使用数据库。在对 model 的属性（字段）做了修改之后，通过执行 makemigrations 可以生成一个 migrate 文件，然后执行 migrate 命令可以把这些修改应用到数据库。同时在数据库里面，也会记录当前 migrate 执行的状态，这样能保证数据库的状态和 django 自己认为的数据库的状态是一致的。  但是这里可能会有一个问题，我们有多个数据库环境，也有多个人一起开发，这样就会导致这个有点混乱，多个人修改 model 后都执行了 makemigrations 的话，可能会有冲突和问题（实际上 django 已经考虑过这个问题的，migrate 文件都是按照时间戳来命名的，冲突可能性也不大，但是为了避免新手加入弄不好，所以我们采取了另外一个方法做这个事情）。  下面的内容翻译自 https://realpython.com/create-django-index-without-downtime/ ，我们使用了里面提到的 sqlmigrate 的方式。  管理数据库变更在软件开发中是一个比较大的挑战。幸运的是，从 django 1.7 开始有了内置的数据库变更处理框架。这个框架对于处理数据库变更来说很强大很好用。但是为了保证框架提供的灵活性，有一些妥协在里面。为了理解 django 数据库变更框架的限制，我们将解决一个有名的问题：如何在不停机情况下通过 django 创建索引。  在这个教程里面，你将学习到：    django 是什么时候和如何产生数据库变更的    django 是如何执行变更的    如何按照需要编辑这些变更    这篇文章面向的是对 django 数据库变更（migrations）已经有所了解的人的。如果对这些还不了解，那可以先看看 Django Migrations: A Primer 。 在 django 里面创建索引存在的问题   一个常见的变更是当你的数据增加的时候会需要建索引。索引可以查询的速度和应用的响应速度。  大部分数据库里面增加索引需要在表上面加一个排它锁。当索引创建的时候，排它锁不允许进行数据修改（DML）操作，例如 UPDATE, INSERT, 和 DELETE 。  当数据库执行这些操作的时候，会立刻加锁。例如如果一个用户登录的时候，django 会更新 auth_user 表的 last_login 字段。为了执行这个操作，数据库会先请求一个行锁，如果这行被其他连接加了锁，那你可能会得到一个数据库异常。  锁表会让系统在做变更的时候不可用。表越大，创建索引的时间越长，系统不可用时间越长。  一些数据库提供了不锁表建索引的方法。例如，在 PostgreSQL 里面可以使用 CONCURRENTLY 关键字： CREATE INDEX CONCURRENTLY ix ON table (column);  在 Oracle 里面，有一个 ONLINE 选项允许在创建索引的时候执行 DML 操作： CREATE INDEX ix ON table (column) ONLINE;  在生成数据库变更的时候，django 不会使用这些关键字。执行这些变更创建索引会导致数据库增加表的排他锁，而阻止 DML 操作。  异步创建索引也有一些潜在的问题。最好提前了解一下自己数据库可能存在的问题。例如，在 PostgreSQL 里面异步创建索引的时候时间会比较长，因为它需要对表做一些额外的扫描。  这篇文章里面，会使用 django 的数据库变更在一个大表上面创建索引而不会带来停机时间。 配置   这里将在一个叫 app 的应用里面使用一个 Sale 模型。在真实世界，类似 Sale 这样的模型一般是数据库的主要的表，会存储大量的数据。 # models.</description>
    </item>
    
    <item>
      <title>Django middleware</title>
      <link>https://wdicc.com/django-middleware/</link>
      <pubDate>Wed, 05 Jul 2017 18:07:50 +0800</pubDate>
      
      <guid>https://wdicc.com/django-middleware/</guid>
      <description>  Django 提供了 middleware 来让你 hack Request 和 Response。用的时候有几个问题需要注意一下。 __call__ 方法   __call__ 方法实际上就是最早收到 request 的地方，如果不关心 view，那么就可以在这里做你想要做的事情。比如认证用户啥的。这个实际上应该就是早期的 process_request 。 process_view 方法   process_view 方法会接收到 view_func 和其参数，如果想要针对这些东西处理，可以在这里动作。比如我们所有 api 请求的 POST 的 body 里面都是固定格式的 json 数据，我就在这里检查了 json 的格式，并把解析结果给到了 view_func。  如果不打算对 view_func 做什么事情，那就最好做完想做的事情，直接返回 None 就可以。否则处理完毕之后，返回一个 response 对象。  要注意的是，这里最好不要产生 exception，产生了会把逻辑跑到 Middleware 的 exception 逻辑里面。所以最好对自己的代码段加上 try-except 逻辑。  另外，这里可以对 view_func 做调用，直接返回 view_func 的结果或者处理之后的结果，只要保证是个 response 对象就可以了。也可以不做调用，返回 None ，后续 django 也会调用。要注意的是，如果你对 view_func 做了调用，那么在捕捉到错误的时候，except 里面应该也需要返回一个 response 对象，不能返回 None 了，否则 djangon 还会再次调用这个 view_func 。 process_exception 方法   process_exception 方法是在 view 报错的情况下会调用。我在这里统一返回了 server error 的 json，http 状态是 200 的。 </description>
    </item>
    
  </channel>
</rss>