<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>javascript on wd and cc</title>
    <link>https://wdicc.com/tags/javascript/</link>
    <description>Recent content in javascript on wd and cc</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 01 Nov 2018 12:56:20 +0800</lastBuildDate>
    
	<atom:link href="https://wdicc.com/tags/javascript/atom.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Fear, trust and JavaScript: When types and functional programming fail</title>
      <link>https://wdicc.com/fear-trust-and-javascript/</link>
      <pubDate>Thu, 01 Nov 2018 12:56:20 +0800</pubDate>
      
      <guid>https://wdicc.com/fear-trust-and-javascript/</guid>
      <description>翻译自 Fear, trust and JavaScript: When types and functional programming fail , 最早是 hacker news 看到的。  只是翻译大意。  作为开发人员，我们需要减少对代码执行失败的恐惧，增强对代码的信心。很多 javascript 开发人员从函数式编程语言和强类型语言里面借鉴思路来将信任交给工具和代码来减少恐惧。类似可选类型，函数转换，和只读化这些思想可以帮助写出更好的 javascript 代码。当把这些想法都加入到 javascript 里面，会有一些妥协，协作起来比较差，并且最终会导致将信任从开发人员交给代码和工具的想法失败。  举例来看看 javascript 里面是如何在两种观点下面处理数据的：理解数据的结构和修改数据。 Fear and the shape of data   在类似 javascript 的动态语言里面，很难知道你数据的结构。默认的方式是依赖公约(convention)。相信其它程序员和其它系统按照协议给你正确的数据。 fetchUser(id).then( user =&amp;gt; { // Got my user! }) // Later render(user.name) // He has a name   我一般管这种方式叫「假装这是你要的」。在高可信的环境下，这个会工作的挺好。  但是恐惧会悄悄的到来。代码的复杂度会增加。代码会是不同开发人员基于不同的公约(convention)开发的。你收到的数据来自于不可控的上游以及不稳定的格式。会开始看到空指针错误。对代码的信任会崩塌，对数据格式的疑问会引起焦虑而不是信任。    这个数据里面到底有什么值？    我可以删除里面的数据而不产生影响吗？    我可以把这个数据传入这个函数吗？    例如下面这个。 fetchUser(id).</description>
    </item>
    
    <item>
      <title>Upgrade to React 16.3</title>
      <link>https://wdicc.com/upgrade-to-react-16.3/</link>
      <pubDate>Mon, 22 Oct 2018 16:21:30 +0800</pubDate>
      
      <guid>https://wdicc.com/upgrade-to-react-16.3/</guid>
      <description>随着 React native 升级，React 也升级到了 16.5 了。原来的改成新的生命周期了。 class ExampleComponent extends React.Component { static getDerivedStateFromProps(nextProps, prevState) { // Called after a component is instantiated or before it receives new props.  // Return an object to update state in response to prop changes.  // Return null to indicate no change to state.  } UNSAFE_componentWillMount() { // New name for componentWillMount()  // Indicates that this method can be unsafe for async rendering.</description>
    </item>
    
    <item>
      <title>Geodesy</title>
      <link>https://wdicc.com/geodesy/</link>
      <pubDate>Sun, 01 Jul 2018 08:10:05 +0800</pubDate>
      
      <guid>https://wdicc.com/geodesy/</guid>
      <description>坐标点之间的距离角度计算不能简单的用平面几何来算，得按照球面计算，PostgreSQL 提供了 gis 数据的计算支持，各种图形关系判断，距离计算等等。但是我们有时候也需要在 js 里面计算，开始的时候尝试自己按照公式写来着，写了一些发现太蛋疼了，因为只是单纯的看公式，缺少空间概念，算的对不对啥的都不知道。后来发现了这个 js 库，简直太贴心了。  提供了我用过的几个功能    度数表示转换，小数点形式到度分秒形式的互转。在 utm.js 里面。    计算线的真北角。point1.bearingTo(point2)，真北角计算是和线的方向有关系的。    和当前点夹角是 x，距离是 y 的点，point1.destinationPoint(y, x)。    两点之间的距离，point1.distanceTo(point2)    然后顺便记录一些东西。 // 两条线的夹角的一半，普通角度 let angle = (360 + 180 + bearing1 - bearing2) % 360 // 360 保证只有正的 let halfAngle = angle &amp;gt; 180 ? (360 - angle)/2 : angle/2 // 只要锐角  // 计算两条线夹角中线的真北角 // left,right bearing 需要是真北角 let rightBearing = 90 + (bearing1 + bearing2)/2 let leftBearing = 180 + rightBearing // Math.</description>
    </item>
    
    <item>
      <title>介绍下 openresty</title>
      <link>https://wdicc.com/intro-openresty/</link>
      <pubDate>Sun, 23 Oct 2011 00:00:00 +0000</pubDate>
      
      <guid>https://wdicc.com/intro-openresty/</guid>
      <description>一直没有时间使用 ngx_lua，上周算是真正使用了下，总结下，也算是帮忙推广下 openresty。
什么是 openresty
openresty 的主力作者是 @agentzh 它的网页在 这里，上面有介绍。按我的理解，他是介于客户端浏览器 js 和数据库之间的一层。
在 ajex 还没有盛行的时代，数据库的数据需要展现在浏览器的时候，一般都是使用 php/jsp 之类读取数据，然后拼表格/图表这些。在客户端机器越来越牛逼之后，把部分运算放在浏览器里面开始盛行，ajex 也越来越流行。这个时候通常还需要有个服务器端的程序来配合从数据库获取并提供数据，应该也有不少类似的程序来提供这个数据。
老版本的 openresty 是基于 perl 做的，可以上 cpan 上面 搜到 (不知道为啥这页面我打不开了)。agentzh 还专门为他写了一个 admin site，纯 js + oprensty 来实现的，可以直接在上面配置接口，很方便。目前老版本应该没人用了。
新版本的 openresty 基本上等于是 nginx 和一些 nginx 模块的集合，大部分模块都是 agentzh 和 chaoslawful 完成的，目前 agentzh 离职在家全职开发 openresty 相关，chaoslawful 还在淘宝 量子统计 。
这大概就是我了解的 openresty 的起源和目前的情况。写的比较简单，里面的曲折就不多说了，可以找上面提到的大牛聊天。


怎么使用 openresty
我下面用一个简单的例子来描述下，我是怎么使用 openresty 的，从中应该能看出来 openresty 能干啥，怎么用。

需求
在 postgresql 数据库有张网站日访问流量表，包含两个字段 thedate 和 pv。需要把里面的数据展现出来，画出来流量曲线。</description>
    </item>
    
  </channel>
</rss>