<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,viewport-fit=cover,initial-scale=1"><title>Dont Do This in PostgreSQL | wd and cc</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css><header><nav><ul><li class=pull-left><a href=https://wdicc.com/>/home/wd and cc</a></li><li class=pull-left><a href=/tags/>~/tags</a></li><li class=pull-left><a href="https://www.google.com.hk/search?sitesearch=https%3A%2F%2Fwdicc.com%2F&q=">~/search</a></li><li class=pull-right><a href=/atom.xml>~/subscribe</a></li></ul></nav></header></head><body><br><div class=article-meta><h1><span class=title>Dont Do This in PostgreSQL</span></h1><h2 class=date>2020/02/01</h2><p class=terms>Tags: <a href=/tags/pgsql>pgsql</a></p></div><main><p>前几天看见个<a href="https://wiki.postgresql.org/wiki/Don't_Do_This">这个</a>，翻译一下。</p><h3 id=headline-1>不要使用 SQL_ASCII</h3><p>可以看德哥<a href=https://billtian.github.io/digoal.blog/2013/03/15/01.html>这篇文章</a>，使用这个编码后就是给啥存啥，如果 db 用户瞎用，里面 gbk utf8 都往里放，那将来用的时候会比较麻烦，而且这样舍弃了数据库提供的数据检查功能，不是浪费么。</p><h3 id=headline-2>不要使用 psql -W or –password</h3><p>主要就是 psql 实际会自动处理这个事情的，如果需要密码会找你要的。不用强制让他提示你输入密码。</p><h3 id=headline-3>不要使用 rules</h3><p>可以使用 trigger 代替。</p><h4 id=headline-4>depesz 讲的 <a href=https://www.depesz.com/2010/06/15/to-rule-or-not-to-rule-that-is-the-question/>To rule or not to rule that is the question</a></h4><p>depesz 的意思是不要使用 rule。即使是多年的 dba 也可能会用错。</p><p>rule 主要是通过修改 sql 来实现逻辑，而不是通过一定规则来执行另一个 sql。</p><h4 id=headline-5>PG 文档里面讲的 <a href=https://www.postgresql.org/docs/12/rules-triggers.html>rules-triggers</a></h4><p>用 rule 可以做很多 trigger 可以做的事情。一些约束，特别是外键不能使用 rule 完成。当一列里面的值在其他表里面不存在的时候可以使用 rule 重写命令为什么都不做，但是这样的话数据就丢掉了，这并不是个好主意。如果需要检查数据是否有效，在无效的时候还需要报个错什么的，那只能使用 trigger 完成。</p><p>这一章会讨论如何使用 rule 来更新 view。本例里面所有的 rule 都可以使用 view 的 trigger 代替。使用 trigger 会比 rule 简单一点，尤其那些在更新的时候逻辑比较复杂的。</p><p>当两个方法都可以的时候，哪种好取决于数据库的使用。trigger 会针对影响到的行每行触发一次。rule 通过修改 query 或者添加一些查询来完成。所以如果一条语句里面多条数据被影响，rule 会触发一条额外的命令，比 trigger 每行都执行一次快，并且这里可能还有很多重复性的计算好决定需要做什么。然而，trigger 概念上比 rule 简单，新手也不容易犯错。</p><p>举个例子：</p><div class="src src-sql"><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#080;font-weight:700>CREATE</span> <span style=color:#080;font-weight:700>TABLE</span> computer (
    hostname        <span style=color:#007020>text</span>,    <span style=color:#888>-- indexed
</span><span style=color:#888></span>    manufacturer    <span style=color:#007020>text</span>     <span style=color:#888>-- indexed
</span><span style=color:#888></span>);

<span style=color:#080;font-weight:700>CREATE</span> <span style=color:#080;font-weight:700>TABLE</span> software (
    software        <span style=color:#007020>text</span>,    <span style=color:#888>-- indexed
</span><span style=color:#888></span>    hostname        <span style=color:#007020>text</span>     <span style=color:#888>-- indexed
</span><span style=color:#888></span>);</code></pre></td></tr></table></div></div></div><p>每个表都有几千数据，hostname 是唯一键。rule 或者 trigger 需要实现一个约束，从 computer 表删除数据的时候，同时从 software 表删除。trigger 会使用下面的命令</p><div class="src src-sql"><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#080;font-weight:700>DELETE</span> <span style=color:#080;font-weight:700>FROM</span> software <span style=color:#080;font-weight:700>WHERE</span> hostname <span style=color:#333>=</span> <span style=color:red;background-color:#faa>$</span><span style=color:#00d;font-weight:700>1</span>;</code></pre></td></tr></table></div></div></div><p>因为 trigger 在每行删除的时候都会执行，所以数据库可以保存执行计划传递一个 hostname 作为参数就行。rule 需要使用下面的命令</p><div class="src src-sql"><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#080;font-weight:700>CREATE</span> <span style=color:#080;font-weight:700>RULE</span> computer_del <span style=color:#080;font-weight:700>AS</span> <span style=color:#080;font-weight:700>ON</span> <span style=color:#080;font-weight:700>DELETE</span> <span style=color:#080;font-weight:700>TO</span> computer
    <span style=color:#080;font-weight:700>DO</span> <span style=color:#080;font-weight:700>DELETE</span> <span style=color:#080;font-weight:700>FROM</span> software <span style=color:#080;font-weight:700>WHERE</span> hostname <span style=color:#333>=</span> <span style=color:#080;font-weight:700>OLD</span>.hostname;</code></pre></td></tr></table></div></div></div><p>看看不同的删除情况。</p><div class="src src-sql"><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#080;font-weight:700>DELETE</span> <span style=color:#080;font-weight:700>FROM</span> computer <span style=color:#080;font-weight:700>WHERE</span> hostname <span style=color:#333>=</span> <span style=background-color:#fff0f0>&#39;mypc.local.net&#39;</span>;</code></pre></td></tr></table></div></div></div><p>数据库会使用索引查询，trigger 也会使用索引，所以都挺快。rule 增加额外的命令之后如下</p><div class="src src-sql"><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#080;font-weight:700>DELETE</span> <span style=color:#080;font-weight:700>FROM</span> software <span style=color:#080;font-weight:700>WHERE</span> computer.hostname <span style=color:#333>=</span> <span style=background-color:#fff0f0>&#39;mypc.local.net&#39;</span>
                       <span style=color:#080;font-weight:700>AND</span> software.hostname <span style=color:#333>=</span> computer.hostname;</code></pre></td></tr></table></div></div></div><p>根据前面的表定义，执行计划如下</p><div class="src src-sql"><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql>Nestloop
  <span style=color:#333>-&gt;</span>  <span style=color:#080;font-weight:700>Index</span> Scan <span style=color:#080;font-weight:700>using</span> comp_hostidx <span style=color:#080;font-weight:700>on</span> computer
  <span style=color:#333>-&gt;</span>  <span style=color:#080;font-weight:700>Index</span> Scan <span style=color:#080;font-weight:700>using</span> soft_hostidx <span style=color:#080;font-weight:700>on</span> software</code></pre></td></tr></table></div></div></div><p>所以实际执行的时候 trigger 和 rule 实现并没有啥区别。</p><p>下面的删除命令会匹配 2000 条 computer 表里面 hostname 开头是 'old' 的数据，一种删除的方法如下：</p><div class="src src-sql"><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#080;font-weight:700>DELETE</span> <span style=color:#080;font-weight:700>FROM</span> computer <span style=color:#080;font-weight:700>WHERE</span> hostname <span style=color:#333>&gt;=</span> <span style=background-color:#fff0f0>&#39;old&#39;</span>
                       <span style=color:#080;font-weight:700>AND</span> hostname <span style=color:#333>&lt;</span>  <span style=background-color:#fff0f0>&#39;ole&#39;</span></code></pre></td></tr></table></div></div></div><p>rule 修改增加之后的命令如下：</p><div class="src src-sql"><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#080;font-weight:700>DELETE</span> <span style=color:#080;font-weight:700>FROM</span> software <span style=color:#080;font-weight:700>WHERE</span> computer.hostname <span style=color:#333>&gt;=</span> <span style=background-color:#fff0f0>&#39;old&#39;</span> <span style=color:#080;font-weight:700>AND</span> computer.hostname <span style=color:#333>&lt;</span> <span style=background-color:#fff0f0>&#39;ole&#39;</span>
                       <span style=color:#080;font-weight:700>AND</span> software.hostname <span style=color:#333>=</span> computer.hostname;</code></pre></td></tr></table></div></div></div><p>执行计划</p><div class="src src-sql"><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql>Hash <span style=color:#080;font-weight:700>Join</span>
  <span style=color:#333>-&gt;</span>  Seq Scan <span style=color:#080;font-weight:700>on</span> software
  <span style=color:#333>-&gt;</span>  Hash
    <span style=color:#333>-&gt;</span>  <span style=color:#080;font-weight:700>Index</span> Scan <span style=color:#080;font-weight:700>using</span> comp_hostidx <span style=color:#080;font-weight:700>on</span> computer</code></pre></td></tr></table></div></div></div><p>另外一种删除的方法：</p><div class="src src-sql"><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#080;font-weight:700>DELETE</span> <span style=color:#080;font-weight:700>FROM</span> computer <span style=color:#080;font-weight:700>WHERE</span> hostname <span style=color:#333>~</span> <span style=background-color:#fff0f0>&#39;^old&#39;</span>;</code></pre></td></tr></table></div></div></div><p>rule 修改之后的执行计划</p><div class="src src-sql"><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql>Nestloop
  <span style=color:#333>-&gt;</span>  <span style=color:#080;font-weight:700>Index</span> Scan <span style=color:#080;font-weight:700>using</span> comp_hostidx <span style=color:#080;font-weight:700>on</span> computer
  <span style=color:#333>-&gt;</span>  <span style=color:#080;font-weight:700>Index</span> Scan <span style=color:#080;font-weight:700>using</span> soft_hostidx <span style=color:#080;font-weight:700>on</span> software</code></pre></td></tr></table></div></div></div><p>查询规划器并没有意识到使用 AND 组合多个条件组合的时候也可以使用索引，而做类似正则表达式那条一样的处理。trigger 每 200 个匹配要删除的 computer 会执行一次，会对 software 表执行一次索引查询。使用 rule 的第二个实现会执行使用索引的命令。rule 使用全表扫描的方法是否会比较快取决于 software 表的大小。trigger 通过 SPI 管理器执行的 2000 次命令总归还是需要一些时间的，即使索引都会在内存里面缓存。</p><p>最后看一条命令</p><div class="src src-sql"><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#080;font-weight:700>DELETE</span> <span style=color:#080;font-weight:700>FROM</span> computer <span style=color:#080;font-weight:700>WHERE</span> manufacturer <span style=color:#333>=</span> <span style=background-color:#fff0f0>&#39;bim&#39;</span>;</code></pre></td></tr></table></div></div></div><p>这会删除 computer 里面很多行。所以 trigger 还是会执行很多次。rule 执行的命令如下</p><div class="src src-sql"><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#080;font-weight:700>DELETE</span> <span style=color:#080;font-weight:700>FROM</span> software <span style=color:#080;font-weight:700>WHERE</span> computer.manufacturer <span style=color:#333>=</span> <span style=background-color:#fff0f0>&#39;bim&#39;</span>
                       <span style=color:#080;font-weight:700>AND</span> software.hostname <span style=color:#333>=</span> computer.hostname;</code></pre></td></tr></table></div></div></div><p>执行计划是个 nestloop 两个索引查询</p><div class="src src-sql"><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql>Nestloop
  <span style=color:#333>-&gt;</span>  <span style=color:#080;font-weight:700>Index</span> Scan <span style=color:#080;font-weight:700>using</span> comp_manufidx <span style=color:#080;font-weight:700>on</span> computer
  <span style=color:#333>-&gt;</span>  <span style=color:#080;font-weight:700>Index</span> Scan <span style=color:#080;font-weight:700>using</span> soft_hostidx <span style=color:#080;font-weight:700>on</span> software</code></pre></td></tr></table></div></div></div><p>在上面这些情况里面，rule 额外增加的命令不太依赖于影响的数据量。</p><p>总结下就是，rule 在数据量比较大并且是比较糟糕的 join 导致了查询规划器失败的情况下会比 trigger 明显的慢。</p><h3 id=headline-6>不要使用表继承</h3><p>使用外键来代替表继承。</p><p>现在表分区已经是 native 支持了，不用使用表继承来实现了。在维护某些历史表的情况下使用表继承可以避免使用 union all 获得全部数据，但是也有一些坑，比如查询的时候可能会需要特别指定是不是需要子表的数据，要不即使只想查父表里面的数据的时候也可能会触发子表的扫描，浪费时间。</p><h3 id=headline-7>不要使用 Not In</h3><ol><li><p>not in 语句里面如果有 null 那会导致一行数据都不能返回。</p></li><li><p>会导致查询规划器无法很好的执行 sql。一般会有两种情况，一种是哈希子查询(hashed subplan)，一种是一般子查询(plain subplan)。哈希子查询比较快，但是限于数据了不能太大。一般子查询就很糟糕了，是个 O(n^2) 复杂度的操作。</p></li></ol><h3 id=headline-8>不要用驼峰方式给表取名，使用下划线方式</h3><p>就是不要用 NamesLikeThis 使用 names_like_this。</p><p>pg 里面会使用小写字母做表名，除非使用了 "" ，例如 Foo 会创建 foo，"Bar" 会创建 Bar 。这样查的时候对于 "Foo", Bar, bar 这几个名字都会报找不到表（那个 Bar 找不到是因为每家引号）。</p><p>有时候在报表里面可能想要名字显示的好看一点，那可以使用 as 来起个别名。</p><h3 id=headline-9>不要使用 between，特别是针对时间戳类型</h3><p>例如下面这个</p><div class="src src-sql"><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#080;font-weight:700>SELECT</span> <span style=color:#333>*</span> <span style=color:#080;font-weight:700>FROM</span> blah <span style=color:#080;font-weight:700>WHERE</span> timestampcol <span style=color:#080;font-weight:700>BETWEEN</span> <span style=background-color:#fff0f0>&#39;2018-06-01&#39;</span> <span style=color:#080;font-weight:700>AND</span> <span style=background-color:#fff0f0>&#39;2018-06-08&#39;</span></code></pre></td></tr></table></div></div></div><p>对于 2018-06-08 00:00:00.000000 也是符合的。使用下面的查询会好一点</p><div class="src src-sql"><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#080;font-weight:700>SELECT</span> <span style=color:#333>*</span> <span style=color:#080;font-weight:700>FROM</span> blah <span style=color:#080;font-weight:700>WHERE</span> timestampcol <span style=color:#333>&gt;=</span> <span style=background-color:#fff0f0>&#39;2018-06-01&#39;</span> <span style=color:#080;font-weight:700>AND</span> timestampcol <span style=color:#333>&lt;</span> <span style=background-color:#fff0f0>&#39;2018-06-08&#39;</span></code></pre></td></tr></table></div></div></div><p>对于 int 和 date 类型可能问题不大。</p><h3 id=headline-10>不要使用 timestamp 类型（就是不加时区的）</h3><p>使用 timestamptz 来存时间。不带时区的一旦涉及到时区相关的运算就会比较麻烦了，你总是需要指定你时间的时区。如果你不打算进行什么运算，只是存一下，也可以使用 timestamp.</p><h3 id=headline-11>不要使用 tempstamp 类型存放 UTC 时间</h3><p>和上面那个类似吧。</p><h3 id=headline-12>不要使用 timetz</h3><p>使用 timestamptz 代替。</p><h3 id=headline-13>不要使用 CURRENT_TIME</h3><p>使用下面的代替：</p><ol><li><p>带时区的 timestamp：CURRENT_TIMESTAMP 或者 now()</p></li><li><p>不带时区的：LOCALTIMESTAMP</p></li><li><p>只需要日期：CURRENT_DATE</p></li><li><p>只需要时间：LOCALTIME</p></li></ol><p>因为 CURRENT_TIME 会返回一个 timetz 类型的数据。</p><h3 id=headline-14>不要使用 timestamp(0) 或者 timestamptz(0)</h3><p>不要指定精度，尤其是 0。使用 date_trunc('second', xxx) 来代替。</p><p>因为指定精度会使用 round 方式而不是通常认为的 truncate 方式来处理，例如你使用 now() 的时候可能会产生一个未来半秒之后的时间。</p><h3 id=headline-15>不要使用 char(n)</h3><p>使用 text 代替。</p><p>char(n) 对于不足的部分会使用空数据不足，这会浪费空间，并且也并不会让查询变快。并且 char(n) 还不是个固定长度的类型，不同的字符的 byte 长度不同。</p><h3 id=headline-16>对于固定长度的标识符也不用使用 char(n)</h3><p>即使是定长的字符串也不要用 char(n)，例如国家代码，hash 值，标识符啥的。使用 text 或者 domain over text，加约束 <code>CHECK(length(VALUE)=3)</code> 或者 <code>CHECK(VALUE ~ '^[[[[:alpha:]]]]{3}$')</code> 或者其他类似的。</p><p>因为 char(n) 并不检查长度，只是会补齐。使用 char(n) 并不会比 varchar(n) 有什么性能上面的提升。反过来反而是会提升。另外，如果查询的时候传入的数据类型是个 text 或者 varchar 的话就用不上索引了。</p><h3 id=headline-17>不要使用 varchar(n)</h3><p>使用不指定长度的 varchar() 或者 text 代替。</p><p>varchar(n) 在插入长度超过 n 的字符的时候会报错。varchar() 或者 text 没有长度限制。存相同长度的字符的时候，他们三个占用的空间是一样的，性能也没区别。</p><p>如果你确实需要长度限制，那么 varchar(n) 也挺好的，但是比如你用 varchar(20) 来存名字，某天可能一个名字巨长的人来了，他就不能注册了。</p><p>如果你需要限制长度，那通常不止需要最大长度，也会需要限制最小长度，那使用 check 约束比较好。</p><h3 id=headline-18>不要使用 money 类型</h3><p>只处理一种货币类型，也不要处理分级别的 cents，并且只加减操作的话，可以试试看。</p><p>这个我补充下：一般有建议是把金额放大成整数，只操作整数。这样可以避免无意义的小数，比如 0.011 元这个钱在现实世界里面是不存在的，只有 0.01 是有意义的。另外计算机世界里面浮点数的乘法和除法可能会出来 0.010000008 这样的金额的，也是无意义的。所以有一个建议就是把金额映射成 100 倍，存成整数，比如 0.01 元，存成 1。按说未来只有通货膨胀了，紧缩出现更小面额的可能性也不大，或者也可以考虑放大 1000 倍什么的。。。</p><h3 id=headline-19>不要使用 serial</h3><p>10 增加了 <a href=https://www.postgresql.org/docs/12/sql-createtable.html>identity</a> 类型，</p><div class="src src-sql"><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#080;font-weight:700>GENERATED</span> <span style=color:red;background-color:#faa>{</span> ALWAYS <span style=color:#333>|</span> <span style=color:#080;font-weight:700>BY</span> <span style=color:#080;font-weight:700>DEFAULT</span> <span style=color:red;background-color:#faa>}</span> <span style=color:#080;font-weight:700>AS</span> <span style=color:#080;font-weight:700>IDENTITY</span> [ ( sequence_options ) ]</code></pre></td></tr></table></div></div></div><p>类似原来的 serial， 会创建一个 sequence 关联到这个字段，新插入的行会自动产生值。</p><p>ALWAYS 和 BY DEFAULT 用来指定用户如果指定了一个值的时候怎么处理。设置成 ALWAYS 的话只有在 INSERT 的时候指定 overriding system value 才能。对于 BY DEFAULT，用户指定的优先。对于 COPY 命令总是会使用用户指定的。</p><p>新的 identity 符合 sql 标准。老的 serial 类型有一些小问题，导致管理稍微有些麻烦。比如你需要单独给对应的 sequance 权限之后，用户才能真的对这个表插入。具体可以看<a href=https://www.2ndquadrant.com/en/blog/postgresql-10-identity-columns/>这个</a>。</p><h3 id=headline-20>不要使用 trust 允许 tcp/ip 方式连接</h3><p>特别是这样，会允许网络上的其他人连接你的数据库，还可以使用超级用户。</p><div class="src src-text"><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>host all all 0.0.0.0/0 trust</code></pre></td></tr></table></div></div></div></main><section id=comment><h2 class=title>Comments</h2><div id=disqus_thread aria-live=polite><noscript>Please enable JavaScript to view the <a href=//disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></div></section><script type=text/javascript>var disqus_config=function(){this.page.url='';this.page.identifier='';};(function(){var d=document,s=d.createElement('script');s.src='//wdicc.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><footer style=clear:both><hr>Theme from <a href=https://github.com/wd/hugo-classic>hugo-classic</a> fork from <a href=https://github.com/goodroot/hugo-classic>Github</a></footer></body></html>