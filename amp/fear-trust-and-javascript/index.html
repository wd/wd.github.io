<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Fear, trust and JavaScript: When types and functional programming fail - wd and cc</title><link rel=icon type=image/png href=/favicon.ico><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:title" content="Fear, trust and JavaScript: When types and functional programming fail"><meta property="og:description" content="翻译自 Fear, trust and JavaScript: When types and functional programming fail , 最早是 hacker news 看到的。 只是翻译大意。 作为开发人员，我们需要减少对代码执行失败"><meta property="og:type" content="article"><meta property="og:url" content="https://wdicc.com/amp/fear-trust-and-javascript/"><meta property="article:published_time" content="2018-11-01T12:56:20+08:00"><meta property="article:modified_time" content="2018-11-01T12:56:20+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Fear, trust and JavaScript: When types and functional programming fail"><meta name=twitter:description content="翻译自 Fear, trust and JavaScript: When types and functional programming fail , 最早是 hacker news 看到的。 只是翻译大意。 作为开发人员，我们需要减少对代码执行失败"><link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,300italic,400italic|Raleway:200,300" rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://wdicc.com/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://wdicc.com/css/main.css><link rel=stylesheet type=text/css href=https://wdicc.com//light-syntax.css media="(prefers-color-scheme: light)"><link rel=stylesheet type=text/css href=https://wdicc.com/css/dark.css media="(prefers-color-scheme: dark)"><link rel=stylesheet type=text/css href=https://wdicc.com//dark-syntax.css media="(prefers-color-scheme: dark)"><script src=https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js></script><script src=https://wdicc.com/js/main.js></script></head><body><div class="container wrapper post"><div class=header><base href=https://wdicc.com/><h1 class=site-title><a href=https://wdicc.com/>wd and cc</a></h1><div class=site-description><h2>&mdash; Happy every day</h2><nav class="nav social"><ul class=flat><a href=https://github.com/wd title=Github><i data-feather=github></i></a><a href=https://twitter.com/wd title=Twitter><i data-feather=twitter></i></a></ul></nav></div><nav class=nav><ul class=flat><li><a href=/>Home</a></li><li><a href=/post>All posts</a></li><li><a href=/tags>Tags</a></li><li><a href="https://www.google.com.hk/search?sitesearch=https%3A%2F%2Fwdicc.com%2F&q=">Search</a></li><li><a href=/atom.xml>Subscribe</a></li></ul></nav></div><div class=post-header><h1 class=title>Fear, trust and JavaScript: When types and functional programming fail</h1><div class=meta>Posted at &mdash; Nov 1, 2018</div></div><div class=post-header><nav id=TableOfContents><ul><li><a href=#headline-1>Fear and the shape of data</a><ul><li><a href=#headline-2>Optional types: Pretend really hard</a></li><li><a href=#headline-3>Validation: Trust but validate</a></li><li><a href=#headline-4>Optional types + validation</a></li></ul></li><li><a href=#headline-5>Fear and changing data</a><ul><li><a href=#headline-6>Convention: Pretend immutability</a></li><li><a href=#headline-7>Libraries: Pretend really hard</a></li></ul></li><li><a href=#headline-8>Trusting JavaScript</a><ul><li><a href=#headline-9>Optional types give a false sense of security</a></li><li><a href=#headline-10>Functional programming. Types. JavaScript. Pick two</a></li><li><a href=#headline-11>Why we can’t have nice things in JavaScript</a></li></ul></li><li><a href=#headline-12>Learning to code with fear</a></li></ul></nav></div><div class=markdown><p>翻译自 <a href=https://www.reaktor.com/blog/fear-trust-and-javascript/>Fear, trust and JavaScript: When types and functional programming fail</a> , 最早是 <a href="https://news.ycombinator.com/item?id=18314628">hacker news</a> 看到的。</p><p>只是翻译大意。</p><p>作为开发人员，我们需要减少对代码执行失败的恐惧，增强对代码的信心。很多 javascript 开发人员从函数式编程语言和强类型语言里面借鉴思路来将信任交给工具和代码来减少恐惧。类似可选类型，函数转换，和只读化这些思想可以帮助写出更好的 javascript 代码。当把这些想法都加入到 javascript 里面，会有一些妥协，协作起来比较差，并且最终会导致将信任从开发人员交给代码和工具的想法失败。</p><p>举例来看看 javascript 里面是如何在两种观点下面处理数据的：理解数据的结构和修改数据。</p><div id=outline-container-headline-1 class=outline-2><h2 id=headline-1>Fear and the shape of data</h2><div id=outline-text-headline-1 class=outline-text-2><p>在类似 javascript 的动态语言里面，很难知道你数据的结构。默认的方式是依赖公约(convention)。相信其它程序员和其它系统按照协议给你正确的数据。</p><div class="src src-javascript"><div class=highlight><pre class=chroma><code class=language-javascript data-lang=javascript><span class=nx>fetchUser</span><span class=p>(</span><span class=nx>id</span><span class=p>).</span><span class=nx>then</span><span class=p>(</span> <span class=nx>user</span> <span class=p>=&gt;</span> <span class=p>{</span>
 <span class=c1>// Got my user!
</span><span class=c1></span><span class=p>})</span>

<span class=c1>// Later
</span><span class=c1></span><span class=nx>render</span><span class=p>(</span><span class=nx>user</span><span class=p>.</span><span class=nx>name</span><span class=p>)</span> <span class=c1>// He has a name
</span></code></pre></div></div><p>我一般管这种方式叫「假装这是你要的」。在高可信的环境下，这个会工作的挺好。</p><p>但是恐惧会悄悄的到来。代码的复杂度会增加。代码会是不同开发人员基于不同的公约(convention)开发的。你收到的数据来自于不可控的上游以及不稳定的格式。会开始看到空指针错误。对代码的信任会崩塌，对数据格式的疑问会引起焦虑而不是信任。</p><ul><li><p>这个数据里面到底有什么值？</p></li><li><p>我可以删除里面的数据而不产生影响吗？</p></li><li><p>我可以把这个数据传入这个函数吗？</p></li></ul><p>例如下面这个。</p><div class="src src-javascript"><div class=highlight><pre class=chroma><code class=language-javascript data-lang=javascript><span class=nx>fetchUser</span><span class=p>(</span><span class=nx>id</span><span class=p>).</span><span class=nx>then</span><span class=p>(</span> <span class=nx>user</span> <span class=p>=&gt;</span> <span class=p>{</span>
 <span class=c1>// Got my user!
</span><span class=c1></span> <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=nx>user</span> <span class=o>||</span> <span class=o>!</span><span class=nx>user</span><span class=p>.</span><span class=nx>name</span><span class=p>)</span> <span class=p>{</span>
   <span class=k>throw</span> <span class=k>new</span> <span class=nb>Error</span><span class=p>(</span><span class=s1>&#39;wat&#39;</span><span class=p>)</span>
 <span class=p>}</span>
<span class=p>})</span>

<span class=c1>// Later
</span><span class=c1></span><span class=k>if</span><span class=p>(</span><span class=nx>user</span> <span class=o>&amp;&amp;</span> <span class=nx>user</span><span class=p>.</span><span class=nx>name</span><span class=p>)</span> <span class=p>{</span>
  <span class=nx>render</span><span class=p>(</span><span class=nx>user</span><span class=p>.</span><span class=nx>name</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></div></div><p>这是防御性编程(defensive programming)。在你不再信任你的代码会在适当的时候提供你期望的数据的时候会这么写。漂亮的代码会因为这些检查变得乱七八糟的，失去可读性，代码变得脆弱和很难改变。恐惧会增加，会越来越难相信代码会工作的很好。</p><div id=outline-container-headline-2 class=outline-3><h3 id=headline-2>Optional types: Pretend really hard</h3><div id=outline-text-headline-2 class=outline-text-3><p>有一种消除恐惧的方法是通过 <a href=https://www.typescriptlang.org/>TypeScript</a> 或者 <a href=https://flow.org/>Flow</a> 引入可选的类型检查。接收到一个 user 之后，声明这是 User 类型，这以后只当作 User 类型用。</p><div class="src src-javascript"><div class=highlight><pre class=chroma><code class=language-javascript data-lang=javascript><span class=kr>interface</span> <span class=nx>User</span><span class=p>{</span>
  <span class=nx>id</span><span class=o>:</span> <span class=nx>number</span>
  <span class=nx>name</span><span class=o>:</span> <span class=nx>string</span>
  <span class=nx>email</span><span class=o>?:</span> <span class=nx>string</span>
<span class=p>}</span>

<span class=nx>fetchUser</span><span class=p>(</span><span class=nx>id</span><span class=p>).</span><span class=nx>then</span><span class=p>((</span><span class=nx>user</span><span class=o>:</span> <span class=nx>User</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
 <span class=c1>// Got my User!
</span><span class=c1></span><span class=p>})</span>

<span class=c1>// Later
</span><span class=c1></span><span class=nx>render</span><span class=p>(</span><span class=nx>user</span><span class=p>.</span><span class=nx>name</span><span class=p>)</span> <span class=c1>// Compiler says he has a name
</span></code></pre></div></div><p>这样假装其实挺难的。你把你的信任转移到其它地方了。你依然相信其它系统会给你正确的数据结构。在代码里面，你信任你给那个数据赋予的类型，在你使用不当的时候，编译器会报错。代替相信开发人员知道数据的结构并且正确的使用它，你信任开发人员会写出正确的类型，信任编译器不会对这些类型撒谎。</p><p>增加类型设定并没有解决潜在的问题，它会提升数据在代码里面的一致性，但是对于外来数据没有任何限制。</p></div></div><div id=outline-container-headline-3 class=outline-3><h3 id=headline-3>Validation: Trust but validate</h3><div id=outline-text-headline-3 class=outline-text-3><p>在一个互相不太信任的环境里面，你或者需要在各种地方做数据校验。</p><div class="src src-javascript"><div class=highlight><pre class=chroma><code class=language-javascript data-lang=javascript><span class=nx>fetchUser</span><span class=p>(</span><span class=nx>id</span><span class=p>).</span><span class=nx>then</span><span class=p>(</span><span class=nx>user</span> <span class=p>=&gt;{</span>
  <span class=kr>const</span> <span class=nx>validationErrors</span> <span class=o>=</span> <span class=nx>validate</span><span class=p>(</span><span class=nx>user</span><span class=p>)</span>
  <span class=k>if</span> <span class=p>(</span><span class=nx>validationErrors</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>throw</span> <span class=k>new</span> <span class=nb>Error</span><span class=p>(</span><span class=s1>&#39;wat&#39;</span><span class=p>)</span>
  <span class=p>}</span>
 <span class=c1>// got my User!
</span><span class=c1></span><span class=p>})</span>

<span class=c1>// Later
</span><span class=c1></span><span class=nx>render</span><span class=p>(</span><span class=nx>user</span><span class=p>.</span><span class=nx>name</span><span class=p>)</span> <span class=c1>//He has a name
</span></code></pre></div></div><p>你可以手动做这些，不过这些验证可能是临时的（应该是说不太通用），费力的，并且容易出错的。或者，你可以使用 <a href=http://json-schema.org/>JSON schema</a> 定义和 <a href=https://github.com/epoberezkin/ajv>ajv</a> 或者其它工具来验证数据是不是符合 schema 定义。这么做可以让其它用户复用，例如生成文档，但是这个似乎不那么明确也容易出错，因为你需要手动写这样的定义。</p><div class="src src-javascript"><div class=highlight><pre class=chroma><code class=language-javascript data-lang=javascript><span class=p>{</span>
  <span class=s2>&#34;title&#34;</span><span class=o>:</span> <span class=s2>&#34;user&#34;</span><span class=p>,</span>
  <span class=s2>&#34;type&#34;</span><span class=o>:</span> <span class=s2>&#34;object&#34;</span><span class=p>,</span>
  <span class=s2>&#34;properties&#34;</span><span class=o>:</span> <span class=p>{</span>
    <span class=s2>&#34;id&#34;</span><span class=o>:</span> <span class=p>{</span>
      <span class=s2>&#34;type&#34;</span><span class=o>:</span> <span class=s2>&#34;integer&#34;</span>
    <span class=p>},</span>
    <span class=s2>&#34;name&#34;</span><span class=o>:</span> <span class=p>{</span>
      <span class=s2>&#34;type&#34;</span><span class=o>:</span> <span class=s2>&#34;string&#34;</span>
    <span class=p>},</span>
    <span class=s2>&#34;age&#34;</span><span class=o>:</span> <span class=p>{</span>
      <span class=s2>&#34;type&#34;</span><span class=o>:</span> <span class=s2>&#34;integer&#34;</span>
    <span class=p>}</span>
  <span class=p>},</span>
  <span class=s2>&#34;required&#34;</span><span class=o>:</span> <span class=p>[</span><span class=s2>&#34;id&#34;</span><span class=p>,</span> <span class=s2>&#34;name&#34;</span><span class=p>]</span>
<span class=p>}</span>
</code></pre></div></div></div></div><div id=outline-container-headline-4 class=outline-3><h3 id=headline-4>Optional types + validation</h3><div id=outline-text-headline-4 class=outline-text-3><p>或者你也可以同时使用类型检查和数据验证。类型检查减少内部对数据的恐惧，数据校验建立对外来数据的信任。</p><div class="src src-javascript"><div class=highlight><pre class=chroma><code class=language-javascript data-lang=javascript><span class=kr>interface</span> <span class=nx>User</span><span class=p>{</span>
  <span class=nx>id</span><span class=o>:</span> <span class=nx>number</span>
  <span class=nx>name</span><span class=o>:</span> <span class=nx>string</span>
  <span class=nx>email</span><span class=o>?:</span> <span class=nx>string</span>
<span class=p>}</span>

<span class=nx>fetchUser</span><span class=p>(</span><span class=nx>id</span><span class=p>).</span><span class=nx>then</span><span class=p>((</span><span class=nx>user</span><span class=o>:</span> <span class=nx>User</span><span class=p>)</span> <span class=p>=&gt;{</span>
  <span class=kr>const</span> <span class=nx>validationErrors</span> <span class=o>=</span> <span class=nx>validate</span><span class=p>(</span><span class=nx>user</span><span class=p>)</span>
  <span class=k>if</span> <span class=p>(</span><span class=nx>validationErrors</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>throw</span> <span class=k>new</span> <span class=nb>Error</span><span class=p>(</span><span class=s1>&#39;wat I trusted you&#39;</span><span class=p>)</span>
  <span class=p>}</span>
 <span class=c1>// got my User!
</span><span class=c1></span><span class=p>})</span>

<span class=c1>// Later
</span><span class=c1></span><span class=nx>render</span><span class=p>(</span><span class=nx>user</span><span class=p>.</span><span class=nx>name</span><span class=p>)</span> <span class=c1>//He has a name
</span></code></pre></div></div><p>为了避免同时写两套类型定义给数据验证和类型检查，你可以使用 Typescript 和 Flow 或者使用类似 <a href=https://github.com/pelotom/runtypes>runtypes</a>(TS), <a href=https://github.com/seanhess/runtime-types>runtime-types</a>(Flow) 或者 <a href=https://github.com/YousefED/typescript-json-schema>typescript-json-schema</a>(TS) 这样的库。经过这几步之后，你可能开始信任你的数据了。但是这里还有更深的问题，等一会会说。</p></div></div></div></div><div id=outline-container-headline-5 class=outline-2><h2 id=headline-5>Fear and changing data</h2><div id=outline-text-headline-5 class=outline-text-2><p>那么当改变数据的时候呢？默认情况下，javascript 里面的数据可以随意改变。举个例子，这个函数接收一个文档，然后改变了一个字段的格式，增加了一个字段。</p><div class="src src-javascript"><div class=highlight><pre class=chroma><code class=language-javascript data-lang=javascript><span class=kd>function</span> <span class=nx>formatDocument</span><span class=p>(</span><span class=nx>doc</span><span class=p>,</span> <span class=nx>source</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>if</span><span class=p>(</span><span class=nx>doc</span><span class=p>.</span><span class=nx>creationDate</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>doc</span><span class=p>.</span><span class=nx>creationDate</span> <span class=o>=</span> <span class=nx>convertTimeToUtc</span><span class=p>(</span><span class=nx>doc</span><span class=p>.</span><span class=nx>creationDate</span><span class=p>)</span>
  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
    <span class=nx>doc</span><span class=p>.</span><span class=nx>creationDate</span> <span class=o>=</span> <span class=kc>null</span>
  <span class=p>}</span>
  <span class=nx>doc</span><span class=p>.</span><span class=nx>source</span> <span class=o>=</span> <span class=nx>source</span>
<span class=p>}</span>
</code></pre></div></div><p>但是在这种风格下，数据流就很难掌控了，恐惧会开始出现。如果我们的数据在很多地方都用了呢？数据在我这里是什么值？如何才能相信数据在此时此刻是我期望的？这个例子比较无聊，但是问题在大量代码或者同步系统里面会变得更严重。</p><p>你想要依赖类型检查，但是这些类型定义也救不了你。在 typescript 和 flow 里面，下面的函数有相同的类型定义。</p><div class="src src-javascript"><div class=highlight><pre class=chroma><code class=language-javascript data-lang=javascript><span class=kd>function</span> <span class=nx>formatDocument</span><span class=p>(</span><span class=nx>doc</span><span class=o>:</span> <span class=nx>Document</span><span class=p>,</span> <span class=nx>source</span><span class=o>:</span> <span class=nb>String</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>if</span><span class=p>(</span><span class=nx>doc</span><span class=p>.</span><span class=nx>creationDate</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>doc</span><span class=p>.</span><span class=nx>creationDate</span> <span class=o>=</span> <span class=nx>convertTimeToUtc</span><span class=p>(</span><span class=nx>doc</span><span class=p>.</span><span class=nx>creationDate</span><span class=p>)</span>
  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
    <span class=nx>doc</span><span class=p>.</span><span class=nx>creationDate</span> <span class=o>=</span> <span class=kc>null</span>
  <span class=p>}</span>
  <span class=nx>doc</span><span class=p>.</span><span class=nx>source</span> <span class=o>=</span> <span class=nx>source</span>
<span class=p>}</span>
</code></pre></div></div><div class="src src-javascript"><div class=highlight><pre class=chroma><code class=language-javascript data-lang=javascript><span class=kd>function</span> <span class=nx>formatDocument</span><span class=p>(</span><span class=nx>doc</span><span class=o>:</span> <span class=nx>Document</span><span class=p>,</span> <span class=nx>source</span><span class=o>:</span> <span class=nb>String</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>if</span><span class=p>(</span><span class=nx>doc</span><span class=p>.</span><span class=nx>creationDate</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>doc</span><span class=p>.</span><span class=nx>creationDate</span> <span class=o>=</span> <span class=nx>convertTimeToUtc</span><span class=p>(</span><span class=nx>doc</span><span class=p>.</span><span class=nx>creationDate</span><span class=p>)</span>
  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
    <span class=nx>doc</span><span class=p>.</span><span class=nx>creationDate</span> <span class=o>=</span> <span class=kc>null</span>
  <span class=p>}</span>
  <span class=nx>doc</span><span class=p>.</span><span class=nx>source</span> <span class=o>=</span> <span class=nx>source</span>
  <span class=nx>child_process</span><span class=p>.</span><span class=nx>exec</span><span class=p>(</span><span class=s2>&#34;sudo rm -rf /&#34;</span><span class=p>)</span>
  <span class=nx>launchRocket</span><span class=p>()</span>
<span class=p>}</span>
</code></pre></div></div><p>其中一个是你想要的，另一个会把城市炸飞。类型检查对这些无能为力。</p><div id=outline-container-headline-6 class=outline-3><h3 id=headline-6>Convention: Pretend immutability</h3><div id=outline-text-headline-6 class=outline-text-3><p>为了写更好的代码，你们团队决定使用只读风格来写代码。</p><div class="src src-javascript"><div class=highlight><pre class=chroma><code class=language-javascript data-lang=javascript><span class=kd>function</span> <span class=nx>formatDocument</span><span class=p>(</span><span class=nx>doc</span><span class=o>:</span> <span class=nx>Document</span><span class=p>,</span> <span class=nx>source</span><span class=o>:</span> <span class=nb>String</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>return</span> <span class=p>{</span>
    <span class=nx>creationDate</span><span class=o>:</span> <span class=nx>sanitizeDate</span><span class=p>(</span><span class=nx>doc</span><span class=p>.</span><span class=nx>creationDate</span><span class=p>),</span>
    <span class=nx>source</span><span class=o>:</span> <span class=nx>source</span><span class=p>,</span>
    <span class=nx>text</span><span class=o>:</span> <span class=nx>doc</span><span class=p>.</span><span class=nx>text</span>
  <span class=p>}</span>
  <span class=c1>// Not mutating data
</span><span class=c1></span>  <span class=c1>// Not deleting root dir
</span><span class=c1></span>  <span class=c1>// Not launching rocket
</span><span class=c1></span><span class=p>}</span>

<span class=kd>function</span> <span class=nx>sanitizeDate</span><span class=p>(</span><span class=nx>date</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>return</span> <span class=nx>date</span> <span class=o>?</span> <span class=nx>convertTimeToUtc</span><span class=p>(</span><span class=nx>date</span><span class=p>)</span> <span class=o>:</span> <span class=kc>null</span>
<span class=p>}</span>
</code></pre></div></div><p>你赞同使用 const 而不是 var，使用复制修改而不是直接修改。使用赋值来表示修改。开始使用三目运算符(ternary operator) 来代替 if 语句。函数返回新的值而不是修改。使用 map，filter，reduce 以及其它函数式的方法产生新的数据，而不是直接修改。</p><p>不可改变的数据约定在 javascript 世界里面会带来便利，在 javascript 生态里面工作的挺好。但是这个严重依赖于开发人员的自律和互相信任。你相信开发人员会按照协议例如避免直接修改数据或者在数据发生改变的时候明确的指出来。你可能需要更健壮一点的东西。</p></div></div><div id=outline-container-headline-7 class=outline-3><h3 id=headline-7>Libraries: Pretend really hard</h3><div id=outline-text-headline-7 class=outline-text-3><p>你可以通过使用数据转换和只读数据结构的辅助工具来把对开发人员的信任转移到工具上。可选的有例如 <a href=http://ramdajs.com/>Ramda</a>，<a href=https://github.com/calmm-js/partial.lenses>partial.lenses</a>，<a href=https://github.com/gcanti/monocle-ts>monocle-ts</a> 以及其它的。</p><div class="src src-javascript"><div class=highlight><pre class=chroma><code class=language-javascript data-lang=javascript><span class=kr>import</span> <span class=o>*</span> <span class=nx>as</span> <span class=nx>R</span> <span class=nx>from</span> <span class=s1>&#39;ramda&#39;</span>
<span class=kd>function</span> <span class=nx>formatDocument</span><span class=p>(</span><span class=nx>doc</span><span class=p>,</span> <span class=nx>source</span><span class=p>)</span> <span class=p>{</span>
  <span class=kr>const</span> <span class=nx>creationDate</span> <span class=o>=</span> <span class=nx>sanitizeDate</span><span class=p>(</span><span class=nx>creationDate</span><span class=p>)</span>
  <span class=c1>// Return a new copy of the data
</span><span class=c1></span>  <span class=k>return</span> <span class=nx>R</span><span class=p>.</span><span class=nx>merge</span><span class=p>(</span><span class=nx>doc</span><span class=p>,</span> <span class=p>{</span><span class=nx>creationDate</span><span class=p>,</span> <span class=nx>source</span><span class=p>})</span>
<span class=p>}</span>
</code></pre></div></div><p>这些工具的一个基本原则是把这些数据当作不可变的。但是 <a href=http://ramdajs.com/0.14/docs/#assoc>Ramda 也只是浅拷贝</a>，不过如果对于不可变数据的约定足够，那大家还是可以假装它是。你可能会得到一点性能影响，但是你会得到对代码的信任。如果我们普遍使用这类工具以及这样的约定，会让这个工作的很好。</p><p>强制使用只读数据结构又想避免性能影响，可以试试看 <a href=https://github.com/facebook/immutable-js>Immutable.js</a>， <a href=https://github.com/rtfeldman/seamless-immutable>seamless-immutable</a> 或者 <a href=http://swannodette.github.io/mori/>Mori</a>。</p><div class="src src-javascript"><div class=highlight><pre class=chroma><code class=language-javascript data-lang=javascript><span class=kr>import</span> <span class=o>*</span> <span class=nx>as</span> <span class=nx>I</span> <span class=nx>from</span> <span class=s1>&#39;Immutablejs&#39;</span>
<span class=kd>function</span> <span class=nx>formatDocument</span><span class=p>(</span><span class=nx>doc</span><span class=p>,</span> <span class=nx>source</span><span class=p>)</span> <span class=p>{</span>
  <span class=kr>const</span> <span class=nx>creationDate</span> <span class=o>=</span> <span class=nx>sanitizeDate</span><span class=p>(</span><span class=nx>creationDate</span><span class=p>)</span>
  <span class=c1>// Cant&#39;t mutate doc
</span><span class=c1></span>  <span class=k>return</span> <span class=nx>doc</span><span class=p>.</span><span class=nx>merge</span><span class=p>({</span><span class=nx>creationDate</span><span class=p>,</span> <span class=nx>source</span><span class=p>})</span>
<span class=p>}</span>
</code></pre></div></div><p>这么做使得数据本身是不可变的，只能通过暴露出来的只读途径去使用数据。但是只会应用到这些数据内部的数据结构。大量的其它 javascript 代码依赖于 javascript 的原生数据结构，你得在这些数据类型间来回转换，对于原生的数据类型不再信任了。</p><p>这些方法都有自己的局限性，但是大部分都和类型检查冲突。</p></div></div></div></div><div id=outline-container-headline-8 class=outline-2><h2 id=headline-8>Trusting JavaScript</h2><div id=outline-text-headline-8 class=outline-text-2><p>前面的例子引入了一些可以写出更高效的 javascript 代码的工具：类型检查，函数式转换，不可变数据结构。但是这些工具都有自己的局限性，很难一起配合。</p><div id=outline-container-headline-9 class=outline-3><h3 id=headline-9>Optional types give a false sense of security</h3><div id=outline-text-headline-9 class=outline-text-3><p>对于 javascript 来说，类型检查设计之初就是可选的，并不是所有东西都被定义了类型，你也没法相信所有东西都有类型。Flow 不可靠，而 <a href=https://www.typescriptlang.org/docs/handbook/type-compatibility.html>typescript 故意不可靠</a>，这意味着有些情况下类型是错误的但是编译器会忽略。</p><p>并且 javascript 的类型检查有时候会撒谎。javascript 有些东西很难或者说不可能通过 typescript 或者 flow 定义类型。</p><ul><li><p>Higher order functions</p><ul><li><p>Ramda 的 <a href=http://ramdajs.com/0.14/docs/#call>call</a>, <a href=http://ramdajs.com/0.14/docs/#compose>compose</a>, <a href=http://ramdajs.com/0.14/docs/#chain>chain</a>, <a href=http://ramdajs.com/0.14/docs/#lift>lift</a>, and <a href=http://ramdajs.com/0.14/docs/#lens>lenses</a></p></li><li><p>partial.lenses 的 <a href=https://github.com/calmm-js/partial.lenses/issues/55>functions</a></p></li></ul></li><li><p>Dynamic functions</p><ul><li><p>Ramda 的 <a href=http://ramdajs.com/0.14/docs/#invert>invert</a>, <a href=http://ramdajs.com/0.14/docs/#dissoc>dissoc</a>, <a href=http://ramdajs.com/0.14/docs/#mergeWith>mergeWith</a></p></li><li><p>Immutable.js 的<a href=https://github.com/facebook/immutable-js/blob/master/type-definitions/Immutable.d.ts>几乎所有内容</a></p></li></ul></li><li><p>Monkey-patched anything</p><ul><li><p>AWS SDK 客户端 <a href=https://docs.aws.amazon.com/sdk-for-javascript/v2/developer-guide/using-promises.html#w2ab1c17c15c14c17>promises</a></p></li><li><p>Bluebird <a href=http://bluebirdjs.com/docs/api/promisification.html>promisified APIs</a></p></li></ul></li><li><p>Highly dynamic data structures</p><ul><li><p>ElasticSearch <a href=https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-get>schemas</a></p></li><li><p>winston <a href=https://github.com/winstonjs/winston#creating-your-own-logger>custom loggers</a></p></li></ul></li></ul><p>想要把这些的类型都痛够 typescript 或者 flow 定义出来，得牺牲下面的原则：</p><ul><li><p>牺牲类型安全，也就使用类型检查的主要原因：使用 any 来定义他们，不对他们进行类型检查。</p></li><li><p>牺牲便利性：让这些方法不那么通用，以便可以定义更加准确的类型。</p></li><li><p>牺牲其它开发人员的时间：让使用这些函数的人提供正确的类型，例如 <code class=verbatim>Ramda.pipe&lt;User, Array&lt;string>, string, int>(..)</code> 。</p></li></ul><p>这样你开始混合使用这些工具，把他们的类型定义混合进来。这样把信任从工具的开发人员转移到了开发人员的类型定义上。这些库部分会包含 any 类型，调用这些方法会悄悄的失去对类型的检查。使用 Flow 的时候，如果一个文件没有 <code class=verbatim>@flow</code> 注解，会默默的关闭类型检查。</p><p>你可以通过广泛的使用类型检查来避免这个问题，不允许使用 any 类型，设置检查工具对没有做类型检查的文件报错，以及其它的一些严格的设置。</p><p>但是这很像是在堵住一艘正在漏水的船的洞一样。问题不仅在于你不相信系统里面的类型，而是你认为可以。你依赖类型检查来告诉你修改有问题，但是因为有时候会使用 any 类型，或者使用某个库，或者某些问题导致类型检查被禁用，而并不会告诉你。JavaScript 里面的类型和其它语言里面的类型不一样：他们不能以相同的方式被信任。</p><p>最终，类型检查的有效性依赖于使用的团队的知识和信念。如果团队有比较高的信念和知识，他们就可以给更高的信任到类型检查上。但这取决于团队维持这个信任的的注意力和纪律性，恐惧会从许多微妙的途径蔓延开。</p></div></div><div id=outline-container-headline-10 class=outline-3><h3 id=headline-10>Functional programming. Types. JavaScript. Pick two</h3><div id=outline-text-headline-10 class=outline-text-3><p>类型检查和基础的函数式编程方法例如 maps，filters，reducers 等可以在 javascript 里面用的还可以。但是当你想要更深入一点的时候就会遇到问题。两个例子：</p><p><a href=https://github.com/facebook/immutable-js>Immutable.js</a> 是一个给 javascript 用的持久的，只读数据结构类型。提供了常用的 javascript 数据结构，不依赖于就地修改数据。包括了内置的用于 <a href=https://github.com/facebook/immutable-js/blob/master/type-definitions/Immutable.d.ts>typescript</a> 和 <a href=https://github.com/facebook/immutable-js/blob/master/type-definitions/immutable.js.flow>flow</a> 的类型定义（可以点过去看看）。里面有数不清的 any 类型，禁用了对这些值的类型检查。这样依赖用户通过其它类型检查提供正确的类型的数据。基本上，你每次用这个库时，要么选择不使用类型检查，要不就需要额外的工作保证类型是正确的。这阻碍了函数式编程的使用。</p><p>Ramda 是另一个给 jvascript 使用的函数式编程工具。一些类型定义可以在<a href=https://github.com/types/npm-ramda#status>这里</a>找到，以及这个评论：</p><p>“注意：很多 Ramda 里面的函数还不是很好定义类型，问题主要集中在偏函数应用(Partial Application)，柯里化(curring) 和 代码组合(composition) 上，尤其在表达通用类型上。是的，这些可能是你最初使用 Ramda 的原因，这些问题导致 Ramda 很难给 typescript 写类型定义。一些关于 TS 的链接在下面可以找到”</p><p>尽管有像 <a href=https://github.com/gcanti>Giulio Canti</a> 这样令人印象深刻的工作，每次你选择高级一点的函数式编程概念的时候，例如不可变数据结构，函数组合，科里化，你基本上需要选择抛弃类型检查或者更多的代码来保证类型检查工作正常。这回阻碍函数式编程。</p></div></div><div id=outline-container-headline-11 class=outline-3><h3 id=headline-11>Why we can’t have nice things in JavaScript</h3><div id=outline-text-headline-11 class=outline-text-3><p>不可变数据结构在广泛被使用的时候工作的会挺好。但是 javascript 生态设计是基于可变数据结构的，<a href=http://tagide.com/blog/research/constraints>你不可能通过一个工具库来强制不可变</a>，javascript 的类型检查也不足以处理作为库工具使用的不可变数据结构。</p><p>类型检查在被广泛使用的时候工作的挺好。但是 javascript 里面的类型检查在设计时就是可选的，为了兼容 javascript 做的一些妥协。</p><p>类型检查，不可变数据结构，以及函数式编程都互相支持，就像他们在其它语言里面一样。类型检查可以用来加强不可变数据，即使内部的数据结构是可变的或者类型在运行时不存在。类型检查可以帮助开发人员可以在使用函数组合或者使用 lenses 转换数据的时候能更好对接。能知道支持类型的时候函数转换会更加简单一点。知道数据是不可变的时候，函数转换会更加有效。</p></div></div></div></div><div id=outline-container-headline-12 class=outline-2><h2 id=headline-12>Learning to code with fear</h2><div id=outline-text-headline-12 class=outline-text-2><p>怎么伴随着恐惧编程？写更好的 javascript。一开始就假设对代码不信任，学习更多的技巧来编写功能化的 javascript 来避免琐碎的部分。有必要的话引入类型检查。使用不可变数据，不过只在有需要的时候或者想要强制约定的时候使用。只在有意义的时候使用类型检查，在功能性数据处理或者不可变类型可以提供更多好处的时候抛弃他们。当不使用类型检查的时候，多使用组合函数或者 lenses(透镜？) 。</p><p>或者改变游戏使用 <a href=http://www.purescript.org/>Purescript</a>。或者 <a href=https://bucklescript.github.io/>ReasonML</a>, <a href=http://elm-lang.org/>Elm</a>, 甚至 <a href=https://clojurescript.org/>ClojureScript</a>。这些现在就可用。如果有需要，这些可以在 javascript 生态系统使用。这些从代码层面提供更高的信任，提供可以互相配合且工作的很好的不可变数据结构，函数式编程，以及类型系统。</p><p>使用其中的任何一个语言都不能解决你的所有问题。这会引入他们自己的一下问题。但是可能会给你更高层面的对代码的信任，以及增加或者减少信任更好的工具。<a href=https://www.reaktor.com/blog/fear-trust-and-purescript>我的下一篇文章，会探讨下如何在 purescript 里面把这些思想结合起来。</a>（这个是这个哥们的另一篇文章，标题叫 Fear, trust and PureScript: Building on trust with types and functional programming，力挺 PureScript）。</p><p>但是在 javascript 里面，恐惧永远都伴随着你。</p></div></div></div><div class=post-tags><nav class="nav tags"><ul class=flat><li><a href=/tags/javascript>javascript</a></li></ul></nav></div><div id=disqus_thread></div><script type=text/javascript>(function(){if(window.location.hostname=="localhost")
return;var dsq=document.createElement('script');dsq.type='text/javascript';dsq.async=true;var disqus_shortname='wdicc';dsq.src='//'+disqus_shortname+'.disqus.com/embed.js';(document.getElementsByTagName('head')[0]||document.getElementsByTagName('body')[0]).appendChild(dsq);})();</script><noscript>Please enable JavaScript to view the <a href=http://disqus.com/?ref_noscript>comments powered by
Disqus.</a></noscript><a href=http://disqus.com/ class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><div class="footer wrapper"><nav class=nav><div>Copyright © 2020 wd. All Rights Reserved | <a href=https://github.com/vividvilla/ezhil>Ezhil theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></nav></div><script>feather.replace()</script></body></html>