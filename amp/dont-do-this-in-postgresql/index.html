<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Dont Do This in PostgreSQL - wd and cc</title><link rel=icon type=image/png href=/favicon.ico><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:title" content="Dont Do This in PostgreSQL"><meta property="og:description" content="前几天看见个这个，翻译一下。 不要使用 SQL_ASCII 可以看德哥这篇文章，使用这个编码后就是给啥存啥，如果 db 用户瞎用"><meta property="og:type" content="article"><meta property="og:url" content="https://wdicc.com/amp/dont-do-this-in-postgresql/"><meta property="article:published_time" content="2020-02-01T14:46:36+08:00"><meta property="article:modified_time" content="2020-02-01T14:46:36+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Dont Do This in PostgreSQL"><meta name=twitter:description content="前几天看见个这个，翻译一下。 不要使用 SQL_ASCII 可以看德哥这篇文章，使用这个编码后就是给啥存啥，如果 db 用户瞎用"><link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,300italic,400italic|Raleway:200,300" rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://wdicc.com/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://wdicc.com/css/main.css><link rel=stylesheet type=text/css href=https://wdicc.com//light-syntax.css media="(prefers-color-scheme: light)"><link rel=stylesheet type=text/css href=https://wdicc.com/css/dark.css media="(prefers-color-scheme: dark)"><link rel=stylesheet type=text/css href=https://wdicc.com//dark-syntax.css media="(prefers-color-scheme: dark)"><script src=https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js></script><script src=https://wdicc.com/js/main.js></script></head><body><div class="container wrapper post"><div class=header><base href=https://wdicc.com/><h1 class=site-title><a href=https://wdicc.com/>wd and cc</a></h1><div class=site-description><h2>&mdash; Happy every day</h2><nav class="nav social"><ul class=flat><a href=https://github.com/wd title=Github><i data-feather=github></i></a><a href=https://twitter.com/wd title=Twitter><i data-feather=twitter></i></a></ul></nav></div><nav class=nav><ul class=flat><li><a href=/>Home</a></li><li><a href=/post>All posts</a></li><li><a href=/tags>Tags</a></li><li><a href="https://www.google.com.hk/search?sitesearch=https%3A%2F%2Fwdicc.com%2F&q=">Search</a></li><li><a href=/atom.xml>Subscribe</a></li></ul></nav></div><div class=post-header><h1 class=title>Dont Do This in PostgreSQL</h1><div class=meta>Posted at &mdash; Feb 1, 2020</div></div><div class=post-header><nav id=TableOfContents><ul><li><a href=#headline-1>不要使用 SQL_ASCII</a></li><li><a href=#headline-2>不要使用 psql -W or –password</a></li><li><a href=#headline-3>不要使用 rules</a><ul><li><a href=#headline-4>depesz 讲的 To rule or not to rule that is the question</a></li><li><a href=#headline-5>PG 文档里面讲的 rules-triggers</a></li></ul></li><li><a href=#headline-6>不要使用表继承</a></li><li><a href=#headline-7>不要使用 Not In</a></li><li><a href=#headline-8>不要用驼峰方式给表取名，使用下划线方式</a></li><li><a href=#headline-9>不要使用 between，特别是针对时间戳类型</a></li><li><a href=#headline-10>不要使用 timestamp 类型（就是不加时区的）</a></li><li><a href=#headline-11>不要使用 tempstamp 类型存放 UTC 时间</a></li><li><a href=#headline-12>不要使用 timetz</a></li><li><a href=#headline-13>不要使用 CURRENT_TIME</a></li><li><a href=#headline-14>不要使用 timestamp(0) 或者 timestamptz(0)</a></li><li><a href=#headline-15>不要使用 char(n)</a></li><li><a href=#headline-16>对于固定长度的标识符也不用使用 char(n)</a></li><li><a href=#headline-17>不要使用 varchar(n)</a></li><li><a href=#headline-18>不要使用 money 类型</a></li><li><a href=#headline-19>不要使用 serial</a></li><li><a href=#headline-20>不要使用 trust 允许 tcp/ip 方式连接</a></li></ul></nav></div><div class=markdown><p>前几天看见个<a href="https://wiki.postgresql.org/wiki/Don't_Do_This">这个</a>，翻译一下。</p><div id=outline-container-headline-1 class=outline-3><h3 id=headline-1>不要使用 SQL_ASCII</h3><div id=outline-text-headline-1 class=outline-text-3><p>可以看德哥<a href=https://billtian.github.io/digoal.blog/2013/03/15/01.html>这篇文章</a>，使用这个编码后就是给啥存啥，如果 db 用户瞎用，里面 gbk utf8 都往里放，那将来用的时候会比较麻烦，而且这样舍弃了数据库提供的数据检查功能，不是浪费么。</p></div></div><div id=outline-container-headline-2 class=outline-3><h3 id=headline-2>不要使用 psql -W or –password</h3><div id=outline-text-headline-2 class=outline-text-3><p>主要就是 psql 实际会自动处理这个事情的，如果需要密码会找你要的。不用强制让他提示你输入密码。</p></div></div><div id=outline-container-headline-3 class=outline-3><h3 id=headline-3>不要使用 rules</h3><div id=outline-text-headline-3 class=outline-text-3><p>可以使用 trigger 代替。</p><div id=outline-container-headline-4 class=outline-4><h4 id=headline-4>depesz 讲的 <a href=https://www.depesz.com/2010/06/15/to-rule-or-not-to-rule-that-is-the-question/>To rule or not to rule that is the question</a></h4><div id=outline-text-headline-4 class=outline-text-4><p>depesz 的意思是不要使用 rule。即使是多年的 dba 也可能会用错。</p><p>rule 主要是通过修改 sql 来实现逻辑，而不是通过一定规则来执行另一个 sql。</p></div></div><div id=outline-container-headline-5 class=outline-4><h4 id=headline-5>PG 文档里面讲的 <a href=https://www.postgresql.org/docs/12/rules-triggers.html>rules-triggers</a></h4><div id=outline-text-headline-5 class=outline-text-4><p>用 rule 可以做很多 trigger 可以做的事情。一些约束，特别是外键不能使用 rule 完成。当一列里面的值在其他表里面不存在的时候可以使用 rule 重写命令为什么都不做，但是这样的话数据就丢掉了，这并不是个好主意。如果需要检查数据是否有效，在无效的时候还需要报个错什么的，那只能使用 trigger 完成。</p><p>这一章会讨论如何使用 rule 来更新 view。本例里面所有的 rule 都可以使用 view 的 trigger 代替。使用 trigger 会比 rule 简单一点，尤其那些在更新的时候逻辑比较复杂的。</p><p>当两个方法都可以的时候，哪种好取决于数据库的使用。trigger 会针对影响到的行每行触发一次。rule 通过修改 query 或者添加一些查询来完成。所以如果一条语句里面多条数据被影响，rule 会触发一条额外的命令，比 trigger 每行都执行一次快，并且这里可能还有很多重复性的计算好决定需要做什么。然而，trigger 概念上比 rule 简单，新手也不容易犯错。</p><p>举个例子：</p><div class="src src-sql"><div class=highlight><pre class=chroma><code class=language-sql data-lang=sql><span class=k>CREATE</span> <span class=k>TABLE</span> <span class=n>computer</span> <span class=p>(</span>
    <span class=n>hostname</span>        <span class=nb>text</span><span class=p>,</span>    <span class=c1>-- indexed
</span><span class=c1></span>    <span class=n>manufacturer</span>    <span class=nb>text</span>     <span class=c1>-- indexed
</span><span class=c1></span><span class=p>);</span>

<span class=k>CREATE</span> <span class=k>TABLE</span> <span class=n>software</span> <span class=p>(</span>
    <span class=n>software</span>        <span class=nb>text</span><span class=p>,</span>    <span class=c1>-- indexed
</span><span class=c1></span>    <span class=n>hostname</span>        <span class=nb>text</span>     <span class=c1>-- indexed
</span><span class=c1></span><span class=p>);</span></code></pre></div></div><p>每个表都有几千数据，hostname 是唯一键。rule 或者 trigger 需要实现一个约束，从 computer 表删除数据的时候，同时从 software 表删除。trigger 会使用下面的命令</p><div class="src src-sql"><div class=highlight><pre class=chroma><code class=language-sql data-lang=sql><span class=k>DELETE</span> <span class=k>FROM</span> <span class=n>software</span> <span class=k>WHERE</span> <span class=n>hostname</span> <span class=o>=</span> <span class=err>$</span><span class=mi>1</span><span class=p>;</span></code></pre></div></div><p>因为 trigger 在每行删除的时候都会执行，所以数据库可以保存执行计划传递一个 hostname 作为参数就行。rule 需要使用下面的命令</p><div class="src src-sql"><div class=highlight><pre class=chroma><code class=language-sql data-lang=sql><span class=k>CREATE</span> <span class=k>RULE</span> <span class=n>computer_del</span> <span class=k>AS</span> <span class=k>ON</span> <span class=k>DELETE</span> <span class=k>TO</span> <span class=n>computer</span>
    <span class=k>DO</span> <span class=k>DELETE</span> <span class=k>FROM</span> <span class=n>software</span> <span class=k>WHERE</span> <span class=n>hostname</span> <span class=o>=</span> <span class=k>OLD</span><span class=p>.</span><span class=n>hostname</span><span class=p>;</span></code></pre></div></div><p>看看不同的删除情况。</p><div class="src src-sql"><div class=highlight><pre class=chroma><code class=language-sql data-lang=sql><span class=k>DELETE</span> <span class=k>FROM</span> <span class=n>computer</span> <span class=k>WHERE</span> <span class=n>hostname</span> <span class=o>=</span> <span class=s1>&#39;mypc.local.net&#39;</span><span class=p>;</span></code></pre></div></div><p>数据库会使用索引查询，trigger 也会使用索引，所以都挺快。rule 增加额外的命令之后如下</p><div class="src src-sql"><div class=highlight><pre class=chroma><code class=language-sql data-lang=sql><span class=k>DELETE</span> <span class=k>FROM</span> <span class=n>software</span> <span class=k>WHERE</span> <span class=n>computer</span><span class=p>.</span><span class=n>hostname</span> <span class=o>=</span> <span class=s1>&#39;mypc.local.net&#39;</span>
                       <span class=k>AND</span> <span class=n>software</span><span class=p>.</span><span class=n>hostname</span> <span class=o>=</span> <span class=n>computer</span><span class=p>.</span><span class=n>hostname</span><span class=p>;</span></code></pre></div></div><p>根据前面的表定义，执行计划如下</p><div class="src src-sql"><div class=highlight><pre class=chroma><code class=language-sql data-lang=sql><span class=n>Nestloop</span>
  <span class=o>-&gt;</span>  <span class=k>Index</span> <span class=n>Scan</span> <span class=k>using</span> <span class=n>comp_hostidx</span> <span class=k>on</span> <span class=n>computer</span>
  <span class=o>-&gt;</span>  <span class=k>Index</span> <span class=n>Scan</span> <span class=k>using</span> <span class=n>soft_hostidx</span> <span class=k>on</span> <span class=n>software</span></code></pre></div></div><p>所以实际执行的时候 trigger 和 rule 实现并没有啥区别。</p><p>下面的删除命令会匹配 2000 条 computer 表里面 hostname 开头是 'old' 的数据，一种删除的方法如下：</p><div class="src src-sql"><div class=highlight><pre class=chroma><code class=language-sql data-lang=sql><span class=k>DELETE</span> <span class=k>FROM</span> <span class=n>computer</span> <span class=k>WHERE</span> <span class=n>hostname</span> <span class=o>&gt;=</span> <span class=s1>&#39;old&#39;</span>
                       <span class=k>AND</span> <span class=n>hostname</span> <span class=o>&lt;</span>  <span class=s1>&#39;ole&#39;</span></code></pre></div></div><p>rule 修改增加之后的命令如下：</p><div class="src src-sql"><div class=highlight><pre class=chroma><code class=language-sql data-lang=sql><span class=k>DELETE</span> <span class=k>FROM</span> <span class=n>software</span> <span class=k>WHERE</span> <span class=n>computer</span><span class=p>.</span><span class=n>hostname</span> <span class=o>&gt;=</span> <span class=s1>&#39;old&#39;</span> <span class=k>AND</span> <span class=n>computer</span><span class=p>.</span><span class=n>hostname</span> <span class=o>&lt;</span> <span class=s1>&#39;ole&#39;</span>
                       <span class=k>AND</span> <span class=n>software</span><span class=p>.</span><span class=n>hostname</span> <span class=o>=</span> <span class=n>computer</span><span class=p>.</span><span class=n>hostname</span><span class=p>;</span></code></pre></div></div><p>执行计划</p><div class="src src-sql"><div class=highlight><pre class=chroma><code class=language-sql data-lang=sql><span class=n>Hash</span> <span class=k>Join</span>
  <span class=o>-&gt;</span>  <span class=n>Seq</span> <span class=n>Scan</span> <span class=k>on</span> <span class=n>software</span>
  <span class=o>-&gt;</span>  <span class=n>Hash</span>
    <span class=o>-&gt;</span>  <span class=k>Index</span> <span class=n>Scan</span> <span class=k>using</span> <span class=n>comp_hostidx</span> <span class=k>on</span> <span class=n>computer</span></code></pre></div></div><p>另外一种删除的方法：</p><div class="src src-sql"><div class=highlight><pre class=chroma><code class=language-sql data-lang=sql><span class=k>DELETE</span> <span class=k>FROM</span> <span class=n>computer</span> <span class=k>WHERE</span> <span class=n>hostname</span> <span class=o>~</span> <span class=s1>&#39;^old&#39;</span><span class=p>;</span></code></pre></div></div><p>rule 修改之后的执行计划</p><div class="src src-sql"><div class=highlight><pre class=chroma><code class=language-sql data-lang=sql><span class=n>Nestloop</span>
  <span class=o>-&gt;</span>  <span class=k>Index</span> <span class=n>Scan</span> <span class=k>using</span> <span class=n>comp_hostidx</span> <span class=k>on</span> <span class=n>computer</span>
  <span class=o>-&gt;</span>  <span class=k>Index</span> <span class=n>Scan</span> <span class=k>using</span> <span class=n>soft_hostidx</span> <span class=k>on</span> <span class=n>software</span></code></pre></div></div><p>查询规划器并没有意识到使用 AND 组合多个条件组合的时候也可以使用索引，而做类似正则表达式那条一样的处理。trigger 每 200 个匹配要删除的 computer 会执行一次，会对 software 表执行一次索引查询。使用 rule 的第二个实现会执行使用索引的命令。rule 使用全表扫描的方法是否会比较快取决于 software 表的大小。trigger 通过 SPI 管理器执行的 2000 次命令总归还是需要一些时间的，即使索引都会在内存里面缓存。</p><p>最后看一条命令</p><div class="src src-sql"><div class=highlight><pre class=chroma><code class=language-sql data-lang=sql><span class=k>DELETE</span> <span class=k>FROM</span> <span class=n>computer</span> <span class=k>WHERE</span> <span class=n>manufacturer</span> <span class=o>=</span> <span class=s1>&#39;bim&#39;</span><span class=p>;</span></code></pre></div></div><p>这会删除 computer 里面很多行。所以 trigger 还是会执行很多次。rule 执行的命令如下</p><div class="src src-sql"><div class=highlight><pre class=chroma><code class=language-sql data-lang=sql><span class=k>DELETE</span> <span class=k>FROM</span> <span class=n>software</span> <span class=k>WHERE</span> <span class=n>computer</span><span class=p>.</span><span class=n>manufacturer</span> <span class=o>=</span> <span class=s1>&#39;bim&#39;</span>
                       <span class=k>AND</span> <span class=n>software</span><span class=p>.</span><span class=n>hostname</span> <span class=o>=</span> <span class=n>computer</span><span class=p>.</span><span class=n>hostname</span><span class=p>;</span></code></pre></div></div><p>执行计划是个 nestloop 两个索引查询</p><div class="src src-sql"><div class=highlight><pre class=chroma><code class=language-sql data-lang=sql><span class=n>Nestloop</span>
  <span class=o>-&gt;</span>  <span class=k>Index</span> <span class=n>Scan</span> <span class=k>using</span> <span class=n>comp_manufidx</span> <span class=k>on</span> <span class=n>computer</span>
  <span class=o>-&gt;</span>  <span class=k>Index</span> <span class=n>Scan</span> <span class=k>using</span> <span class=n>soft_hostidx</span> <span class=k>on</span> <span class=n>software</span></code></pre></div></div><p>在上面这些情况里面，rule 额外增加的命令不太依赖于影响的数据量。</p><p>总结下就是，rule 在数据量比较大并且是比较糟糕的 join 导致了查询规划器失败的情况下会比 trigger 明显的慢。</p></div></div></div></div><div id=outline-container-headline-6 class=outline-3><h3 id=headline-6>不要使用表继承</h3><div id=outline-text-headline-6 class=outline-text-3><p>使用外键来代替表继承。</p><p>现在表分区已经是 native 支持了，不用使用表继承来实现了。在维护某些历史表的情况下使用表继承可以避免使用 union all 获得全部数据，但是也有一些坑，比如查询的时候可能会需要特别指定是不是需要子表的数据，要不即使只想查父表里面的数据的时候也可能会触发子表的扫描，浪费时间。</p></div></div><div id=outline-container-headline-7 class=outline-3><h3 id=headline-7>不要使用 Not In</h3><div id=outline-text-headline-7 class=outline-text-3><ol><li><p>not in 语句里面如果有 null 那会导致一行数据都不能返回。</p></li><li><p>会导致查询规划器无法很好的执行 sql。一般会有两种情况，一种是哈希子查询(hashed subplan)，一种是一般子查询(plain subplan)。哈希子查询比较快，但是限于数据了不能太大。一般子查询就很糟糕了，是个 O(n^2) 复杂度的操作。</p></li></ol></div></div><div id=outline-container-headline-8 class=outline-3><h3 id=headline-8>不要用驼峰方式给表取名，使用下划线方式</h3><div id=outline-text-headline-8 class=outline-text-3><p>就是不要用 NamesLikeThis 使用 names_like_this。</p><p>pg 里面会使用小写字母做表名，除非使用了 "" ，例如 Foo 会创建 foo，"Bar" 会创建 Bar 。这样查的时候对于 "Foo", Bar, bar 这几个名字都会报找不到表（那个 Bar 找不到是因为每家引号）。</p><p>有时候在报表里面可能想要名字显示的好看一点，那可以使用 as 来起个别名。</p></div></div><div id=outline-container-headline-9 class=outline-3><h3 id=headline-9>不要使用 between，特别是针对时间戳类型</h3><div id=outline-text-headline-9 class=outline-text-3><p>例如下面这个</p><div class="src src-sql"><div class=highlight><pre class=chroma><code class=language-sql data-lang=sql><span class=k>SELECT</span> <span class=o>*</span> <span class=k>FROM</span> <span class=n>blah</span> <span class=k>WHERE</span> <span class=n>timestampcol</span> <span class=k>BETWEEN</span> <span class=s1>&#39;2018-06-01&#39;</span> <span class=k>AND</span> <span class=s1>&#39;2018-06-08&#39;</span></code></pre></div></div><p>对于 2018-06-08 00:00:00.000000 也是符合的。使用下面的查询会好一点</p><div class="src src-sql"><div class=highlight><pre class=chroma><code class=language-sql data-lang=sql><span class=k>SELECT</span> <span class=o>*</span> <span class=k>FROM</span> <span class=n>blah</span> <span class=k>WHERE</span> <span class=n>timestampcol</span> <span class=o>&gt;=</span> <span class=s1>&#39;2018-06-01&#39;</span> <span class=k>AND</span> <span class=n>timestampcol</span> <span class=o>&lt;</span> <span class=s1>&#39;2018-06-08&#39;</span></code></pre></div></div><p>对于 int 和 date 类型可能问题不大。</p></div></div><div id=outline-container-headline-10 class=outline-3><h3 id=headline-10>不要使用 timestamp 类型（就是不加时区的）</h3><div id=outline-text-headline-10 class=outline-text-3><p>使用 timestamptz 来存时间。不带时区的一旦涉及到时区相关的运算就会比较麻烦了，你总是需要指定你时间的时区。如果你不打算进行什么运算，只是存一下，也可以使用 timestamp.</p></div></div><div id=outline-container-headline-11 class=outline-3><h3 id=headline-11>不要使用 tempstamp 类型存放 UTC 时间</h3><div id=outline-text-headline-11 class=outline-text-3><p>和上面那个类似吧。</p></div></div><div id=outline-container-headline-12 class=outline-3><h3 id=headline-12>不要使用 timetz</h3><div id=outline-text-headline-12 class=outline-text-3><p>使用 timestamptz 代替。</p></div></div><div id=outline-container-headline-13 class=outline-3><h3 id=headline-13>不要使用 CURRENT_TIME</h3><div id=outline-text-headline-13 class=outline-text-3><p>使用下面的代替：</p><ol><li><p>带时区的 timestamp：CURRENT_TIMESTAMP 或者 now()</p></li><li><p>不带时区的：LOCALTIMESTAMP</p></li><li><p>只需要日期：CURRENT_DATE</p></li><li><p>只需要时间：LOCALTIME</p></li></ol><p>因为 CURRENT_TIME 会返回一个 timetz 类型的数据。</p></div></div><div id=outline-container-headline-14 class=outline-3><h3 id=headline-14>不要使用 timestamp(0) 或者 timestamptz(0)</h3><div id=outline-text-headline-14 class=outline-text-3><p>不要指定精度，尤其是 0。使用 date_trunc('second', xxx) 来代替。</p><p>因为指定精度会使用 round 方式而不是通常认为的 truncate 方式来处理，例如你使用 now() 的时候可能会产生一个未来半秒之后的时间。</p></div></div><div id=outline-container-headline-15 class=outline-3><h3 id=headline-15>不要使用 char(n)</h3><div id=outline-text-headline-15 class=outline-text-3><p>使用 text 代替。</p><p>char(n) 对于不足的部分会使用空数据不足，这会浪费空间，并且也并不会让查询变快。并且 char(n) 还不是个固定长度的类型，不同的字符的 byte 长度不同。</p></div></div><div id=outline-container-headline-16 class=outline-3><h3 id=headline-16>对于固定长度的标识符也不用使用 char(n)</h3><div id=outline-text-headline-16 class=outline-text-3><p>即使是定长的字符串也不要用 char(n)，例如国家代码，hash 值，标识符啥的。使用 text 或者 domain over text，加约束 <code>CHECK(length(VALUE)=3)</code> 或者 <code>CHECK(VALUE ~ '^[[[[:alpha:]]]]{3}$')</code> 或者其他类似的。</p><p>因为 char(n) 并不检查长度，只是会补齐。使用 char(n) 并不会比 varchar(n) 有什么性能上面的提升。反过来反而是会提升。另外，如果查询的时候传入的数据类型是个 text 或者 varchar 的话就用不上索引了。</p></div></div><div id=outline-container-headline-17 class=outline-3><h3 id=headline-17>不要使用 varchar(n)</h3><div id=outline-text-headline-17 class=outline-text-3><p>使用不指定长度的 varchar() 或者 text 代替。</p><p>varchar(n) 在插入长度超过 n 的字符的时候会报错。varchar() 或者 text 没有长度限制。存相同长度的字符的时候，他们三个占用的空间是一样的，性能也没区别。</p><p>如果你确实需要长度限制，那么 varchar(n) 也挺好的，但是比如你用 varchar(20) 来存名字，某天可能一个名字巨长的人来了，他就不能注册了。</p><p>如果你需要限制长度，那通常不止需要最大长度，也会需要限制最小长度，那使用 check 约束比较好。</p></div></div><div id=outline-container-headline-18 class=outline-3><h3 id=headline-18>不要使用 money 类型</h3><div id=outline-text-headline-18 class=outline-text-3><p>只处理一种货币类型，也不要处理分级别的 cents，并且只加减操作的话，可以试试看。</p><p>这个我补充下：一般有建议是把金额放大成整数，只操作整数。这样可以避免无意义的小数，比如 0.011 元这个钱在现实世界里面是不存在的，只有 0.01 是有意义的。另外计算机世界里面浮点数的乘法和除法可能会出来 0.010000008 这样的金额的，也是无意义的。所以有一个建议就是把金额映射成 100 倍，存成整数，比如 0.01 元，存成 1。按说未来只有通货膨胀了，紧缩出现更小面额的可能性也不大，或者也可以考虑放大 1000 倍什么的。。。</p></div></div><div id=outline-container-headline-19 class=outline-3><h3 id=headline-19>不要使用 serial</h3><div id=outline-text-headline-19 class=outline-text-3><p>10 增加了 <a href=https://www.postgresql.org/docs/12/sql-createtable.html>identity</a> 类型，</p><div class="src src-sql"><div class=highlight><pre class=chroma><code class=language-sql data-lang=sql><span class=k>GENERATED</span> <span class=err>{</span> <span class=n>ALWAYS</span> <span class=o>|</span> <span class=k>BY</span> <span class=k>DEFAULT</span> <span class=err>}</span> <span class=k>AS</span> <span class=k>IDENTITY</span> <span class=p>[</span> <span class=p>(</span> <span class=n>sequence_options</span> <span class=p>)</span> <span class=p>]</span></code></pre></div></div><p>类似原来的 serial， 会创建一个 sequence 关联到这个字段，新插入的行会自动产生值。</p><p>ALWAYS 和 BY DEFAULT 用来指定用户如果指定了一个值的时候怎么处理。设置成 ALWAYS 的话只有在 INSERT 的时候指定 overriding system value 才能。对于 BY DEFAULT，用户指定的优先。对于 COPY 命令总是会使用用户指定的。</p><p>新的 identity 符合 sql 标准。老的 serial 类型有一些小问题，导致管理稍微有些麻烦。比如你需要单独给对应的 sequance 权限之后，用户才能真的对这个表插入。具体可以看<a href=https://www.2ndquadrant.com/en/blog/postgresql-10-identity-columns/>这个</a>。</p></div></div><div id=outline-container-headline-20 class=outline-3><h3 id=headline-20>不要使用 trust 允许 tcp/ip 方式连接</h3><div id=outline-text-headline-20 class=outline-text-3><p>特别是这样，会允许网络上的其他人连接你的数据库，还可以使用超级用户。</p><div class="src src-text"><div class=highlight><pre class=chroma><code class=language-text data-lang=text>host all all 0.0.0.0/0 trust</code></pre></div></div></div></div></div><div class=post-tags><nav class="nav tags"><ul class=flat><li><a href=/tags/pgsql>pgsql</a></li></ul></nav></div><div id=disqus_thread></div><script type=text/javascript>(function(){if(window.location.hostname=="localhost")
return;var dsq=document.createElement('script');dsq.type='text/javascript';dsq.async=true;var disqus_shortname='wdicc';dsq.src='//'+disqus_shortname+'.disqus.com/embed.js';(document.getElementsByTagName('head')[0]||document.getElementsByTagName('body')[0]).appendChild(dsq);})();</script><noscript>Please enable JavaScript to view the <a href=http://disqus.com/?ref_noscript>comments powered by
Disqus.</a></noscript><a href=http://disqus.com/ class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><div class="footer wrapper"><nav class=nav><div>Copyright © 2020 wd. All Rights Reserved | <a href=https://github.com/vividvilla/ezhil>Ezhil theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></nav></div><script>feather.replace()</script></body></html>