<!DOCTYPE HTML>
<html>
<head>
	<meta name="generator" content="Hugo 0.19" />
	<meta charset="utf-8">
    
    
    <title>wd and cc</title>
    <meta name="author" content="wd">
    <meta name="description" content="">
    <meta name="keywords" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <link href="https://wdicc.com/index.xml" rel="alternate" title="wd and cc" type="application/atom+xml">
	<link href="/favicon.ico" rel="shortcut icon">
    <link href="/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
    <link href="/css/custom.css" media="screen, projection" rel="stylesheet" type="text/css">

    <link href='//fonts.googleapis.com/css?family=Slackey' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Fjalla+One' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Amethysta' rel='stylesheet' type='text/css'>
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
    

    <script type="text/javascript" src="/js/jquery-tapir.js"></script>

    

    <link rel="stylesheet" href="/css/hljs.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
</head>


<body>
    <div id="wrapper">
        <header id="header" class="inner">
<h1 class="animated bounceInDown">
    <div id="headerbg">
        wd and cc
    </div>
</h1>

<span class="subtitle">happy every day</span>
<br>

<ul id="social-links" style="text-align:center; clear:both;">
    
    
    <li>
    <a href="https://github.com/wd" class="github" title="Github"></a>
    </li>
    
    
    
    
    
    <li>
    <a href="http://www.twitter.com/wd" class="twitter" title="Twitter"></a>
    </li>
    
    
    
    
    
</ul>


<ul id="nav">
	<li id="ajax"><a href="/index.html">Home</a></li>
	<li id="ajax"><a href="/archives/index.html">Archives</a></li>
	<li id="ajax"><a href="/tags/index.html">Tags</a></li>
    <li><a href="/atom.xml">RSS</a></li>
    <li>
    <div id="dark">
        <form action="//www.google.com.hk/search" method="get" accept-charset="UTF-8" id="search">
            <input type="hidden" name="sitesearch" value="https://wdicc.com/" />
            <input type="text" name="q" results="0" placeholder="Search..." x-webkit-speech />
        </form>
    </div>
    </li>
</ul>

</header>

<div id="toload">

    <div id="content" class="inner">
        




    
    <script id="dsq-count-scr" src="//wdicc.disqus.com/count.js" async></script>
    




  <article class="post">
    <h2 class="title"> 
        <a href="/Upgrade-kernel-to-4-9-for-linode/">Upgrade kernel to 4.9 for linode</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2017-01-16T18:37:56.000&#43;08:00' itemprop="datePublished">2017-01-16</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/linode">linode</a>

<a href="/tags/kernel">kernel</a>

<a href="/tags/bbr">bbr</a>


</div>
    </div>
        <p>bbr 那么牛逼，赶紧赶一个潮流。其实我之前用了 kcp，也是类似的东西，不过那个要求服务器端和客户端都需要跑 kcp 服务才可以。bbr 就不用了，只需要服务器配置好就可以了。</p>

<p>Linode 实际上已经提供了 4.9 的内核。打开 <code>Dashboard</code>，然后点击你使用的 profile 右侧的 edit，在出来的界面里面，Kernel 右侧的列表里面，有个 4.9 的选项，不过我测试这个内核并不能打开 bbr，不知道是怎么回事，有兴趣的可以试试看，要注意选对架构（就是 64 还是 32）。</p>

<p>所以还是需要自己装内核。debian 官方已经打包好了 kernel 4.9，访问 <a href="http://mirrors.kernel.org/debian/pool/main/l/linux/">http://mirrors.kernel.org/debian/pool/main/l/linux/</a> ，然后找到适合自己的 linux-image-4.9，我的是 <a href="http://mirrors.kernel.org/debian/pool/main/l/linux/linux-image-4.9.0-1-amd64-unsigned_4.9.2-2_amd64.deb">http://mirrors.kernel.org/debian/pool/main/l/linux/linux-image-4.9.0-1-amd64-unsigned_4.9.2-2_amd64.deb</a> ，下载到 vps 上面。</p>

<p>然后执行 <code>sudo dkpg -i ./linux-image-4.9.0-1-amd64-unsigned_4.9.2-2_amd64.deb</code>，最后应该会提示一个错误，缺少依赖的包。这个时候执行 <code>sudo apt-get -f install</code>，会提示安装缺失的包。</p>

<p>然后，还需要安装 <code>grub</code>。看你的情况。就刚才 profile 编辑的页面里面，kernel 右侧的选项里面，你看看你的是 <code>grub2</code> 还是 <code>pv-grub</code>。</p>

<ul>
<li><p><code>grub2</code>: 参考<a href="https://www.linode.com/docs/tools-reference/custom-kernels-distros/run-a-distribution-supplied-kernel-with-kvm">这个</a></p>

<pre><code>$ sudo apt-get install grub2
$ sudo update-grub
</code></pre></li>

<li><p><code>pv-grub</code>: 参考<a href="https://www.linode.com/docs/tools-reference/custom-kernels-distros/run-a-distributionsupplied-kernel-with-pvgrub">这个</a></p>

<pre><code>$ sudo apt-get install grub
$ sudo mkdir /boot/grub
$ sudo update-grub
</code></pre></li>
</ul>

<p>然后在 profile 编辑页面里面，kernel 右侧选择对应的 grub 选项，重启 vps 就可以了。如果启动失败了，就在这个选项里面，选择之前的选项重启就可以恢复。</p>

    </div>

<div class="meta">
    
    <span class="comments"><a href="/Upgrade-kernel-to-4-9-for-linode/#disqus_thread">Comments</a></span>
    
</div>
</article>

  <article class="post">
    <h2 class="title"> 
        <a href="/Python-new/">Python __new__</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2017-01-16T15:47:59.000&#43;08:00' itemprop="datePublished">2017-01-16</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/python">python</a>


</div>
    </div>
        <p>翻译一点 <a href="https://www.python.org/download/releases/2.2/descrintro/#__new__">https://www.python.org/download/releases/2.2/descrintro/#__new__</a> 有些感觉还是挺生硬的，方便自己理解吧。</p>

<p><code>__new__</code> 的一些规则:</p>

<ul>
<li><code>__new__</code> 是一个静态方法。定义它的时候并不需要执行 <code>__new__ = staticmethod(__new__)</code>，因为它的名字就包含了这个含义（这个对于类构造方法来说是个特殊的函数）</li>
<li><code>__new__</code> 的第一个参数，必须是一个类，其余的参数是留给构造方法的。</li>
<li>覆盖了基类的 <code>__new__</code> 方法的类有可能会调用基类的 <code>__new__</code> 方法。传递给基类的 <code>__new__</code> 方法的第一个参数，应该是覆盖基类的 <code>__new__</code> 方法的类，而不是基类，如果传递了基类，你得到的将是基类的示例。</li>
<li>除非你想要按照后面两条描述的方法来使用，否则 <code>__new__</code> 方法必须要调用基类的 <code>__new__</code> 方法，这个是创建你的对象的实例的唯一方法。子类的 <code>__new__</code> 方法可以从两个方面影响产生的实例：传递不同的参数给基类的 <code>__new__</code>，以及修改基类产生的对象（例如初始化一些实例变量）</li>
<li><code>__new__</code> 方法必须返回一个对象。并不一定必须返回一个新的对象，虽然通常都那么做。如果你返回一个已经存在的对象，依然会有对于 <code>__init__</code> 构造函数的调用。如果你返回一个其他函数的对象，那个对象的 <code>__init__</code> 也会被调用。如果忘记返回，python 会给你返回 None，你程序的调用方也许会觉得很奇怪。</li>
<li>对于不可变对象，<code>__new__</code> 可以返回一个之前缓存的对象。对于一些比较小的 int, str, tuple 类型就是这么做的。这也是为什么他们的 <code>__init__</code> 什么都没做：否则之前缓存的对象会被 init 很多次。（另外一个原因是本身页没有东西可以给 <code>__init__</code> 初始化的了，<code>__new__</code> 返回的就是一个已经初始化的对象）。</li>
<li>如果你想要给一个内置的不可变类型增加一些可变的状态（例如给 string 类型增加一个默认的转换方法），最好是在 <code>__init__</code> 方法里面初始化可变状态，而不要在 <code>__new__</code> 里面。</li>
<li>如果你想要修改构造方法的签名，一般需要覆盖 <code>__new__</code> 和 <code>__init__</code> 方法来接受心的签名。然而，大部分内置类型都会忽视自己不用的参数，尤其是不可变类型（int，long，float，complex，str，unicode，tuple）都有一个假的 <code>__init__</code>，而可变类型（dict，list，file，super，classmethod，staticmethd，property）有一个假的 <code>__new__</code>。内置类型 <code>object</code> 有假的 <code>__init__</code> 和 <code>__new__</code> （给其他对象继承）。内置类型 <code>type</code> 在很多方面都很特别，请参考 metaclasses。</li>
<li>（这条和 <code>__new__</code> 没关系，但是页应该了解一下）如果新建一个 <code>type</code> 的子类，实例会自动给 <code>__dict__</code> 和 <code>__weakrefs__</code> 预留空间（ <code>__dict__</code> 在你使用前不会初始化，所以你不需要担心创建的所有实例被一个空的字典所占用的空间）。如果不需要这个多余的空间，可以给你的类设置 <code>__slots__ = []</code>（更多信息可以参考 <code>__slots__</code>。</li>
<li>Factoid: <code>__new__</code> 是一个静态方法，不是类方法。我开始的时候觉得他应该是一个类方法，and that&rsquo;s why I added the classmethod primitive。不幸的是，对于一个类方法，在这种情况下面 upcalls 不工作，所以我只好把他设计成一个第一个参数是一个 class 的静态方法。讽刺的是，there are now no known uses for class methods in the Python distribution (other than in the test suite). I might even get rid of classmethod in a future release if no good use for it can be found!</li>
</ul>

    </div>

<div class="meta">
    
    <span class="comments"><a href="/Python-new/#disqus_thread">Comments</a></span>
    
</div>
</article>

  <article class="post">
    <h2 class="title"> 
        <a href="/Python-inherit-and-super/">Python inherit and super</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2017-01-16T11:53:04.000&#43;08:00' itemprop="datePublished">2017-01-16</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/python">python</a>

<a href="/tags/super">super</a>

<a href="/tags/inherit">inherit</a>


</div>
    </div>
        <p>又学习了一个 python 的继承。有很多帖子都有介绍，比如<a href="https://laike9m.com/blog/li-jie-python-super,70/">理解 Python super</a>，<a href="http://www.cnblogs.com/lovemo1314/archive/2011/05/03/2035005.html">python super()</a>。</p>

<p>先看一个例子，这个是第一个文章里面的。</p>

<pre><code>class Root(object):
    def __init__(self):
        print(&quot;this is Root&quot;)


class B(Root):
    def __init__(self):
        print(&quot;enter B&quot;)
        super(B, self).__init__()
        print(&quot;leave B&quot;)


class C(Root):
    def __init__(self):
        print(&quot;enter C&quot;)
        super(C, self).__init__()
        print(&quot;leave C&quot;)


class D(C):
    def __init__(self):
        print(&quot;enter D&quot;)
        super(D, self).__init__()
        print(&quot;leave D&quot;)


class E(D, B):
    def __init__(self):
        print(&quot;enter E&quot;)
        super(E, self).__init__()
        print(&quot;leave E&quot;)

e = E()
print(e.__class__.mro())

# results:
# enter E
# enter D
# enter C
# enter B
# this is Root
# leave B
# leave C
# leave D
# leave E
# [&lt;class '__main__.E'&gt;, &lt;class '__main__.D'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.Root'&gt;, &lt;class 'object'&gt;]
</code></pre>

<p>没有什么问题，所有的类都做了初始化，很完美。接着再看一个例子，这个例子其实是上面第二篇文章里面的。</p>

<pre><code>class A(object):
    def __init__(self):
        print(&quot;enter A&quot;)
        print(&quot;leave A&quot;)


class B(object):
    def __init__(self):
        print(&quot;enter B&quot;)
        print(&quot;leave B&quot;)


class C(A):
    def __init__(self):
        print(&quot;enter C&quot;)
        super(C, self).__init__()
        print(&quot;leave C&quot;)


class D(A):
    def __init__(self):
        print(&quot;enter D&quot;)
        super(D, self).__init__()
        print(&quot;leave D&quot;)


class E(B, C):
    def __init__(self):
        print(&quot;enter E&quot;)
        super(E, self).__init__()
        print(&quot;leave E&quot;)


class F(E, D):
    def __init__(self):
        print(&quot;enter F&quot;)
        super(F, self).__init__()
        print(&quot;leave F&quot;)


f = F()
print(f.__class__.mro())

# results:
# enter F
# enter E
# enter B
# leave B
# leave E
# leave F
# [&lt;class '__main__.F'&gt;, &lt;class '__main__.E'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.D'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;]
</code></pre>

<p>我发现和文章里面贴的结果不一样，里面缺少对 C，D，A 的初始化。琢磨半天才弄明白，主要原因就是，<code>A</code>，<code>B</code> 其实也是继承自 <code>object</code>，然而我们并没有调用 <code>super</code> 来初始化，所以只需要加上就可以了。</p>

<pre><code>class A(object):
    def __init__(self):
        print(&quot;enter A&quot;)
        super(A, self).__init__()
        print(&quot;leave A&quot;)


class B(object):
    def __init__(self):
        print(&quot;enter B&quot;)
        super(B, self).__init__()
        print(&quot;leave B&quot;)


class C(A):
    def __init__(self):
        print(&quot;enter C&quot;)
        super(C, self).__init__()
        print(&quot;leave C&quot;)


class D(A):
    def __init__(self):
        print(&quot;enter D&quot;)
        super(D, self).__init__()
        print(&quot;leave D&quot;)


class E(B, C):
    def __init__(self):
        print(&quot;enter E&quot;)
        super(E, self).__init__()
        print(&quot;leave E&quot;)


class F(E, D):
    def __init__(self):
        print(&quot;enter F&quot;)
        super(F, self).__init__()
        print(&quot;leave F&quot;)


f = F()
print(f.__class__.mro())

# results:
# enter F
# enter E
# enter B
# enter C
# enter D
# enter A
# leave A
# leave D
# leave C
# leave B
# leave E
# leave F
# [&lt;class '__main__.F'&gt;, &lt;class '__main__.E'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.D'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;]
</code></pre>

<p>这样就完美了。目测这个会是一个隐藏的坑。</p>

    </div>

<div class="meta">
    
    <span class="comments"><a href="/Python-inherit-and-super/#disqus_thread">Comments</a></span>
    
</div>
</article>

  <article class="post">
    <h2 class="title"> 
        <a href="/Python-metaclass/">Python metaclass</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2017-01-12T18:26:22.000&#43;08:00' itemprop="datePublished">2017-01-12</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/python">python</a>


</div>
    </div>
        <p>又理解了一下 python 的 metaclass 可以做什么，尝试记录一下。</p>

<pre><code>class Meta(type):
    register = []

    def __new__(cls, class_name, parrent_class, params):
        print(&quot;In meta new: {}, {}, {}, {}&quot;.format(cls, class_name, parrent_class, params))
        cls.register.append(class_name)
        params['test_prop'] = True
        # return super(Meta, cls).__new__(cls, class_name, parrent_class, params)
        # return type.__new__(cls, class_name, parrent_class, params)
        # return super(Meta, cls).__new__(type, class_name, parrent_class, params)
        # return type.__new__(type, class_name, parrent_class, params)
        return type(class_name, parrent_class, params)

    def __init__(self, class_name, parrent_class, params):
        print(&quot;In meta init: {}, {}, {}&quot;.format(class_name, parrent_class, params))
        super(Meta, self).__init__(class_name, parrent_class, params)


class A(object, metaclass=Meta):
    pass

print(&quot;register: {}&quot;.format(Meta.register))
print(&quot;prop: {}&quot;.format(A.test_prop))
print(&quot;register: {}&quot;.format(A.register))  # Error

# outputs:
# In meta new: &lt;class '__main__.Meta'&gt;, A, (&lt;class 'object'&gt;,), {'__module__': '__main__', '__qualname__': 'A'}
# In meta init: A, (&lt;class 'object'&gt;,), {'__module__': '__main__', '__qualname__': 'A'}
# register: ['A']
# prop: True
# AttributeError: type object 'A' has no attribute 'register'

</code></pre>

<p>可以看到，在构造 <code>A</code> 的时候，<code>Meta</code> 这个类里面，<code>__new__</code> 和 <code>__init__</code> 都会被调用到。上面代码往 <code>A</code> 里面塞了一个属性。</p>

<p>在 <code>__new__</code> 里面，有几个注释，可以去掉注释看看不同的效果。目前还有点疑惑，传给 <code>__new__</code> 第一个参数到底是什么。另外，开始对 <code>super</code> 也有点疑惑了，还在学习。</p>

    </div>

<div class="meta">
    
    <span class="comments"><a href="/Python-metaclass/#disqus_thread">Comments</a></span>
    
</div>
</article>

  <article class="post">
    <h2 class="title"> 
        <a href="/Reinvent-the-wheel/">Reinvent the wheel</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2017-01-12T16:16:20.000&#43;08:00' itemprop="datePublished">2017-01-12</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/heart">heart</a>

<a href="/tags/tech">tech</a>


</div>
    </div>
        <p><a href="https://en.wikipedia.org/wiki/Reinventing_the_wheel">Reinvent the wheel</a> 估计技术人员都知道这个典故。</p>

<p>刚才突然想谈这个，是看到图拉鼎参加 <a href="https://weex-project.io/">weex</a> 的聚会有感而发。我要是没理解错，这个应该是类似于 React native 的一套实现，我没有仔细看过他的实现，不过说他重复造轮子应该也不为过，毕竟，大家普遍赞成的是在已有的轮子上面添砖加瓦，而不是另起一套。</p>

<p>重复造轮子到底应该不应该支持？</p>

<p>之前我司来了一个发明了 avalon 框架的牛人，之后我看好像就在很多的推介这个，新人来了先学习这个。后来还有很多这种框架，新人来了都是先学习这些框架。</p>

<p>这个事情上面，我看有几个好处
* 发明的人可以在公司内部得到很高的地位，以及相应的奖励。不管好用不好用，推行一版，一波人升天。后人再升级一版，又一波人升天。
* 学会了使用这些框架的人，如果自己本身不太灵活，到了其他公司会发现无法干活，因为使用多了会有一个很深的烙印。这样离职起来就没那么方便。
* 比较好规范和控制公司内部的技术方向。</p>

<p>坏处
* 和最新的技术方向可能有割裂，因为并不一定能及时更新适应。
* 问题解决只能依赖内部的这些人来解决，这种东西想要推广出去毕竟还是难。
* 浪费人力做基础建设。</p>

<p>其实看起来，对于基层员工来看好处还是大于坏处的。毕竟如果老板不关心这个成本或者不清楚可以节约这个成本的话，那些好处还是实实在在的，牛逼有的吹。</p>

<p>在老板关心的方面，可能还有一个点，就是创新有时候是比较难的，但是所谓的微创新其实是简单一些，造轮子的时候，一般多少都会有一些微创新。如果搞的人确实有能力，避免一些原来设计里面的鸡肋冗余的部分，让新的设计更加轻快，其实也算是有好处。</p>

    </div>

<div class="meta">
    
    <span class="comments"><a href="/Reinvent-the-wheel/#disqus_thread">Comments</a></span>
    
</div>
</article>

  <article class="post">
    <h2 class="title"> 
        <a href="/Beansdb-merge-tools/">Beansdb merge tools</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2016-12-26T18:36:11.000&#43;08:00' itemprop="datePublished">2016-12-26</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/beansdb">beansdb</a>


</div>
    </div>
        

<p>Beansdb 是豆瓣开源出来的一个高效的支持 memcached 协议的文件存储 db。按 key 查找的时候，会有索引定位到磁盘位置。不过貌似前段时间看到说他们搞了一个新的替代这个，我找了一下没找到链接。</p>

<p>使用 beansdb 的时候，有 2 个问题需要解决
* 冗余问题
* 数据过期删除问题</p>

<h2 id="数据冗余问题">数据冗余问题</h2>

<p>先说第一个问题。beansdb 本身不提供分布式 hash 逻辑，它就是个单机的程序。冗余需要你自己搞定，如果你使用标准的 memcache 协议，可以有多 server 的配置，读的时候其中一个失败会自动找下一个 server，写的时候就不会了，需要你自己写到多个 server。如果你所有的 server 都是一模一样的，那多写就可以了。如果不一样，你还需要考虑自己的 hash 策略。</p>

<p>豆瓣提供了一个 python 的<a href="https://github.com/douban/beansdb/blob/master/python/dbclient.py">客户端</a>，这个客户端里面其实包含了 hash 策略。通过把 key 和 server 分桶来做 hash。摘一点代码如下</p>

<pre><code>BEANSDBCFG = {
    &quot;localhost:7901&quot;: range(16),
    &quot;localhost:7902&quot;: range(16),
    &quot;localhost:7903&quot;: range(16),
}

db = Beansdb(BEANSDBCFG, 16)
</code></pre>

<p>上面定义了三个 server，每个包含 16 个桶（你可以根据你的需求比如定义第一个 server 只包含某些桶）。</p>

<pre><code>def __init__(self, servers, buckets_count=16, N=3, W=1, R=1):
</code></pre>

<p>这里是定义写入数据的时候的逻辑，那个 <code>buckets_count</code> 是桶的数量，<code>N</code> 和 <code>R</code> 貌似没用。。。，<code>W</code> 是改动的时候要求成功的最小 server 数量，包括删除和写入的时候。</p>

<p>读取的时候，会循环从包含这个 key 的桶的 server 列表里面循环读取，这里还有一个「自愈」的逻辑，循环读取直到遇到一个成功的 server，会同时把前面失败的 server 都写入一份数据。</p>

<p>这样下来基本就解决了读写分布式和故障恢复的逻辑了，非常巧妙。</p>

<p>其实针对这个问题，豆瓣还开源了个 <a href="https://github.com/douban/beanseye">beanseye</a>，具体功能没有仔细研究，不过应该是上面需要客户端处理的事情都不需要考虑了。</p>

<p>我们开始用的时候，不知道有 beanseye，我的场景是在 perl 环境下面使用，把 python 的客户端翻译了一个 perl 的版本出来。[1] 有兴趣可以看看。</p>

<h2 id="数据过期删除问题">数据过期删除问题</h2>

<p>beansdb 设计之初写入用的是 append 模式，就是说，遇到删除也是写入一条新的记录，并不会返回去修改原来的数据，所以能达到合理的 IO 速度。如果场景是大量不会删除的小文件，那么 beansdb 使用起来非常合适。</p>

<p>如果有数据过期或者删除的需求，就需要想办法处理这些数据了，否则的话，beandb 的数据文件里面会慢慢的有大量的无用数据，浪费磁盘空间。</p>

<p>这个删除过期数据的过程，我看豆瓣叫做 merge。思路其实就是把所有数据遍历一次，把有效的数据写入一个新的 data 文件，然后旧的删掉，就可以了。beansdb 的数据文件有 2 种，一种是 <code>xxx.data</code>，这种文件是数据文件，另外一种是 <code>xxx.hint.qlz</code> 这种是索引文件。</p>

<p>针对这个需求，我写了两版程序，第一版就是单纯的解读一下数据文件，把其中的数据的信息读出来，主要是版本号和创建时间，然后根据版本号只写入高版本的，根据创建时间把过期的数据丢弃。生成新的 data 文件之后，要删除 hint 文件，启动的时候会自动产生 hint 文件。然后在 beansdb 的机器上面定期跑这个脚本就好了，注意跑之前应该先关闭 beansdb。</p>

<p>第一个版本的程序只是解读了每个块的数据头，程序用起来也勉强还行，但是主要问题是，每次启动都需要重新产生 hint 文件，导致启动到提供服务很慢，所以就有了第二版程序。第二版包含了第一版的全部功能，还提供了按照文件大小来定义删除时限的功能。</p>

<p>第二个版本程序基本把 data 和 hint 文件产生的逻辑都用 perl 实现了（不过还没有经过太多测试）。下面简单讲讲逻辑。</p>

<h3 id="data-文件">data 文件</h3>

<pre><code class="language-cpp">‌typedef struct data_record
{
    char *value;
    union
    {
        bool free_value;    // free value or not
        uint32_t crc;
    };
    int32_t tstamp;
    int32_t flag;
    int32_t version;
    uint32_t ksz;
    uint32_t vsz;
    char key[0];
‌} DataRecord;
</code></pre>

<p>数据文件里面，每个 key 对应的数据的长度是 <code>4*6 + key_size + value_size + padding</code>。</p>

<pre><code>read($fh, my $header, 4*6);
my ( $crc, $tstamp, $flag, $ver, $ksz, $vsz ) = unpack('I i i i I I', $header);
</code></pre>

<p>头部是 24 个字节，依次包括校验数据，写入时间戳，标记位，版本号，key 的长度，value 的长度。上面 <code>unpack</code> 方法第一个参数里面的含义，可以参考<a href="http://perldoc.perl.org/functions/pack.html">perl 的文档</a>。每个 4 字节，32bit 整数。</p>

<p>然后是读取 <code>$ksz</code> 的长度的 key，读取 <code>$vsz</code> 长度 value。如果 <code>$flag</code> 标记表明 value 有压缩，压缩用的是 QLZ 算法，真实的值需要用 qlz 解压缩之后才能得到。</p>

<p>最后是 padding 部分，整个数据长度需要是 256 的整数倍。不足的部分，会写入 <code>\0</code> 做 padding。</p>

<p>merge 的过程不关心 value 的真实值，所以不需要解压缩，把读取到的原样写回去就可以了。另外就是 merge 的时候遇到同一个 key 多个 version 出现的时候，只保留大的那个就可以了。这样操作之后 data 文件会变小。</p>

<h3 id="hint-文件">hint 文件</h3>

<pre><code class="language-cpp">‌typedef struct hint_record
{
    uint32_t ksize:8;
    uint32_t pos:24;
    int32_t version;
    uint16_t hash;
    char key[NAME_IN_RECORD]; // allign
‌} HintRecord;
</code></pre>

<p>hint 文件比 data 文件稍微复杂一点，每一条记录是 <code>key_size + data_pos + ver + hash + key + padding</code>。</p>

<pre><code>my ( $ksz, $datapos, $ver, $hash ) = unpack(&quot;B8 B24 i B16&quot;, $header);

$ksz = unpack(&quot;I&quot;, pack(&quot;B32&quot;, $ksz));
$datapos = unpack(&quot;I&quot;, pack(&quot;B32&quot;, $datapos));
$datapos = $datapos &lt;&lt; 8;
$hash = unpack(&quot;I&quot;, pack(&quot;B32&quot;, $hash));
</code></pre>

<p>头部的 10 个字节如上面代码，第一个 8 bit 是 key 的长度，接下来 24 个 bit 是这个 key 对应数据在 data 文件里面的位置。然后是 4 字节版本，16 bit 的 hash。</p>

<p>padding 和上面 data 里面的逻辑一样，按照 256 的倍数补全。</p>

<p>hint 文件结尾有个 <code>.qlz</code>，表示整个 hint 里面的数据是压缩的，所以在处理前需要先解压缩一下。（不过我看到我代码里面在读取 hint 的时候，是全部数据解压，写入的时候，是按照 record 压缩的，很奇怪）。</p>

    </div>

<div class="meta">
    
    <span class="comments"><a href="/Beansdb-merge-tools/#disqus_thread">Comments</a></span>
    
</div>
</article>

  <article class="post">
    <h2 class="title"> 
        <a href="/release-some-staff-at-github/">Release some staff at github</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2016-12-13T17:00:31.000&#43;08:00' itemprop="datePublished">2016-12-13</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/hexo">hexo</a>

<a href="/tags/lua">lua</a>

<a href="/tags/ngx_lua">ngx_lua</a>

<a href="/tags/mcrypt">mcrypt</a>


</div>
    </div>
        <p>把 blog 用到的模板整理了一下，放到了 <a href="https://github.com/wd/hexo-fabric">https://github.com/wd/hexo-fabric</a> ，这个最开始是 fork 别人的代码改的，后来发现原来那个人已经不用了，就整理一下，增加了一个 tag 支持，修改了一下字体和背景色，还有代码颜色等，都是一些小修改。同时也提交到了官方的 theme 库，不过 pull request 还没有通过。。</p>

<p>另外，还把之前写的一个给 ngx-lua 用的一个使用 mcrypt 加密解密的库 <a href="https://github.com/wd/lua-resty-mcrypt">https://github.com/wd/lua-resty-mcrypt</a> ，整理出来单独弄了一个模块。代码其实非常简单，这个也能看出来 ngx_lua 里面使用 ffi 调用 C 模块开发多舒服，不过因为 C 知识有限，可能还是会有一些问题，不过至少自己测试是 ok 的，也在线上跑了好久，只能遇到有问题的再说了。这个同时也提交到了春哥的 opm 仓库，那个倒没有审核，提交就被索引了，使用的话应该可以用 opm 命令直接安装。</p>

    </div>

<div class="meta">
    
    <span class="comments"><a href="/release-some-staff-at-github/#disqus_thread">Comments</a></span>
    
</div>
</article>

  <article class="post">
    <h2 class="title"> 
        <a href="/Bloat-and-Query-Speed-in-PostgreSQL/">Bloat and Query Speed in PostgreSQL</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2016-12-09T12:12:21.000&#43;08:00' itemprop="datePublished">2016-12-09</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/postgresql">postgresql</a>


</div>
    </div>
        <p>内容反义自 <a href="https://www.citusdata.com/blog/2016/11/04/autovacuum-not-the-enemy/">https://www.citusdata.com/blog/2016/11/04/autovacuum-not-the-enemy/</a></p>

<p>pg 的 mvcc 会导致表索引的 bloat 就不多说了。说一下不合理处理这种 bloat 害处是啥。</p>

<p>首先肯定是会浪费空间。然后也会影响查询速度。表和索引存储的时候都是 8kB 一个 page，如果一个查询一些行，数据库会加载这些 pages 到内存。一个 page 里面的 dead rows 越多，在加载的时候就越浪费 I/O。例如全表扫描会加载所有的 dead rows。</p>

<p>Bloat 还会导致热门的查询会一下塞满内存。会导致相同的 live rows 需要更多 pages。This causes swapping and makes certain query plans and algorithms ineligible for execution.</p>

<p>还有一个影响是，pg 的系统表也会有可能 bloat，因为他们也是表。导致这个的一种情况是频繁的创建和删除临时表。这个进一步会导致一些管理命令执行变慢，甚至比如 <code>\d</code> 这种命令。</p>

<p>索引也有可能会 bloat。索引是 tuple 标识和数据之间的一个映射。这些标识指向的是某个 page 里面的 offset。每个 tuple 都是一个独立的对象，需要自己的索引条目。更新一行的时候总是会创建这行的新的索引条目。</p>

<p>索引的 bloat 的影响比 table 小一点。索引里面指向 dead tuple 的可以直接标记为 dead. 这会使得索引膨胀，但是不会导致不必要的堆查找。同时更新堆中的 tuples 不影响已经索引的列，使用一种叫做 HOT 的技术来把指向 dead tuples 的指针指向新的。这允许查询可以通过这些指针复用旧的索引条目。(Also updates to tuples in the heap that do not affect the indexed column(s) use a technique called HOT to provide pointers from the dead tuple to its replacement. This allows queries to reuses old index entries by following pointers across the heap.) (没太看明白.)</p>

<p>索引 bloat 的问题还是应该需要重视。例如 btree 索引是由二叉树组成()。叶子节点包含值和 tuple 标识（应该是指在 data file 的 offset）。随机更新因为会重用 page，所以可以保持 btree 维持一个良好的形状。但是，如果是单侧更新，会导致大量的空页。</p>

<p>The size considerations of index bloat are still significant. For instance a btree index consists of binary tree of pages (the same sized pages as you find holding tuples in the heap). The leaf node pages contain values and tuple identifiers. Uniform random table updates tend to keep a btree index in pretty good shape because it can reuse pages. However lopsided inserts/updates affecting one side of the tree while preserving a few straggling entries can lead to lots of mostly empty pages.</p>

    </div>

<div class="meta">
    
    <span class="comments"><a href="/Bloat-and-Query-Speed-in-PostgreSQL/#disqus_thread">Comments</a></span>
    
</div>
</article>

  <article class="post">
    <h2 class="title"> 
        <a href="/Full-page-write-in-PostgreSQL/">Full page write in PostgreSQL</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2016-12-08T18:02:14.000&#43;08:00' itemprop="datePublished">2016-12-08</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/postgresql">postgresql</a>


</div>
    </div>
        

<p>读了一篇<a href="http://blog.2ndquadrant.com/on-the-impact-of-full-page-writes/">文章</a>，简单翻译总结下。</p>

<h2 id="partial-writes-torn-pages">Partial Writes / Torn Pages</h2>

<p>pg 默认是 8kB 一个 page。linux 文件系统一般是 4kB（x86 里面最大是 4kB)，老设备驱动一般是 512B 一个扇区，新的设备有些支持 4kB 或者 8kB。</p>

<p>当 pg 写入一个 page 8kB 的时候，系统的底层会拆分小一点块，这里涉及到写入的原子性。8kB 的 pg page，会被文件系统拆分成 4kB 的块，然后拆分成 512B 扇区大小。这个时候如果系统崩溃（比如停电，内核 bug）会发生什么？</p>

<p>即使系统的存储有针对这种情况的设计（比如 SSD 自带电容器，RAID 控制器自带电池），内核那块也是会拆分成 4kB 的 page，所以还是有一定可能性，pg 写了 8kB，但是只有部分写入成功。</p>

<p>这个时候你可能意识到这就是为啥我们要有事务日志（WAL）。所以当系统崩溃重启之后，数据库会读取 WAL（从最后一次 checkpoint），然后重新写入一遍，以保证数据文件是完整的。</p>

<p>恢复的时候，在修改一个 page 之前，还是会读取一下。</p>

<p>在 checkpoint 之后第一次修改一个 page 的时候，会把整个 page 写入 WAL。这是为了保证在恢复的时候，能保证这些被修改的 page 能完全恢复到他原有的样子。</p>

<h2 id="写放大">写放大</h2>

<p>如果打开 Full page write，很显然会导致 WAL 文件增加，因为就算修改一个字节，也会导致 8kB page 的写入。因为 Full page write 只发生在 checkpoint 之后的第一次写入，所以减少 checkpoint 的发生频率是可以减少写入的。</p>

<h2 id="uuid-vs-bigserial-主键">UUID vs BIGSERIAL 主键</h2>

<p>比较了一下使用 UUID 或者 bigserial 做主键对写入的影响。可以看原链接的图，会发现在 INSERT 语句的情况下 UUID 产生的 WAL 文件量比较多。主要原因是 Btree 索引的情况下，bigserial 是顺序的维护这个索引，UUID 是无顺序的，会导致维护索引产生的数据量不同。</p>

<p>如果是使用 UPDATE 随机修改，那么会发现产生的 WAL 数量就差不多了。</p>

<h2 id="8kb-and-4kb-pages">8kB and 4kB pages</h2>

<p>如果减小 pg 的 page 的大小，可以减小 WAL 数量。从 8kB 减小到 4kB，上面 UUID 那个例子，可以减少大概 35% 的量。</p>

<h2 id="需要-full-page-write-吗">需要 full-page write 吗？</h2>

<p>首先，这个参数是 2005 年 pg 8.1 引入的，那么现代的文件系统是不是已经不用操心部分写入的情况了？作者尝试了一些测试没有测试出来部分写入的情况，当然这不表示不会存在。但是就算是存在，数据的一致性校验也会是有效的保护（虽然并不能修复这个问题，但是至少能让你知道有坏的 page）</p>

<p>其次，现在很多系统都依赖于流式同步，并不会等着有问题的服务器在有硬件问题的时候重启，并且花费很多时间恢复，一般都直接切换到热备服务器上面了。这个时候部分写就不是什么问题了。但是如果我们都推荐这么做，那么「我也不知道为啥数据损坏了，我只是设置了 full_page_writes=off」这种会是 DBA 死前最常见的言论了。(类似于「这种蛇我之前在 reddit 看见过，无毒的」)</p>

<h2 id="总结">总结</h2>

<p>对于 full-page write 你没法直接优化。大部分情况下，full-page write 都是发生在 checkpoint 之后，直到下一次 checkpoint。所以调整 checkpoint 的发生频率不要太频繁很重要。</p>

<p>有些应用层的操作，可能会导致对表或者索引的随机写入的增加，例如上面的 UUID 的值就是随机的，会让简单的 INSERT 也会导致索引的随机 update。使用 Bigserial 做主键(让 UUID 做替代键)可以减少写放大。</p>

    </div>

<div class="meta">
    
    <span class="comments"><a href="/Full-page-write-in-PostgreSQL/#disqus_thread">Comments</a></span>
    
</div>
</article>



  <nav id="pagenavi">
    
    
        <a href="/page/2/" class="next">Next</a>
    
  <div class="center"><a href="/archives/index.html">Blog Archives</a></div>
  </nav>


    </div>
    <footer id="footer">
    <div style="display:inline">
    Copyright &copy; 2017
    
    wd
    . Powered by <a href="http://gohugo.io" target="_blank">Hugo</a> |
    Theme is <a href="https://github.com/wd/hugo-fabric">hugo-fabric</a>, fork from <a href="https://github.com/wd/hexo-fabric">hexo-fabric</a> by <a href="https://wdicc.com">me</a>
</div>

    </footer>
    <script src="/js/fabric.js"></script>


</div>
</div>
<script src="/js/jquery.ui.totop.js" type="text/javascript"></script>
<script type="text/javascript">
 
;(function($){$().UItoTop({easingType:'easeOutCirc'});})(jQuery);
 
</script>
</body>
</html>
