<!DOCTYPE HTML>
<html>
<head>
	<meta name="generator" content="Hugo 0.19" />
	<meta charset="utf-8">
    
    
    <title>wd and cc</title>
    <meta name="author" content="wd">
    <meta name="description" content="">
    <meta name="keywords" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <link href="https://wdicc.com/index.xml" rel="alternate" title="wd and cc" type="application/atom+xml">
	<link href="/favicon.ico" rel="shortcut icon">
    <link href="/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
    <link href="/css/custom.css" media="screen, projection" rel="stylesheet" type="text/css">

    <link href='//fonts.googleapis.com/css?family=Slackey' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Fjalla+One' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Amethysta' rel='stylesheet' type='text/css'>
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
    

    <script type="text/javascript" src="/js/jquery-tapir.js"></script>

    

    <link rel="stylesheet" href="/css/hljs.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
</head>


<body>
    <div id="wrapper">
        <header id="header" class="inner">
<h1 class="animated bounceInDown">
    <div id="headerbg">
        wd and cc
    </div>
</h1>

<span class="subtitle">happy every day</span>
<br>

<ul id="social-links" style="text-align:center; clear:both;">
    
    
    <li>
    <a href="https://github.com/wd" class="github" title="Github"></a>
    </li>
    
    
    
    
    
    <li>
    <a href="http://www.twitter.com/wd" class="twitter" title="Twitter"></a>
    </li>
    
    
    
    
    
</ul>


<ul id="nav">
	<li id="ajax"><a href="/index.html">Home</a></li>
	<li id="ajax"><a href="/archives/index.html">Archives</a></li>
	<li id="ajax"><a href="/tags/index.html">Tags</a></li>
    <li><a href="/atom.xml">RSS</a></li>
    <li>
    <div id="dark">
        <form action="//www.google.com.hk/search" method="get" accept-charset="UTF-8" id="search">
            <input type="hidden" name="sitesearch" value="https://wdicc.com/" />
            <input type="text" name="q" results="0" placeholder="Search..." x-webkit-speech />
        </form>
    </div>
    </li>
</ul>

</header>

<div id="toload">

    <div id="content" class="inner">
        




    
    <script id="dsq-count-scr" src="//wdicc.disqus.com/count.js" async></script>
    




  <article class="post">
    <h2 class="title"> 
        <a href="/Use-org-mode-to-publish-blog/">Use org mode to publish blog</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2017-03-12T08:59:19.000&#43;08:00' itemprop="datePublished">2017-03-12</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/org-mode">org-mode</a>

<a href="/tags/org">org</a>


</div>
    </div>
        <p>a test</p>

<p>啊哈哈哈哈，超棒唉。markdown 里面写代码都没有高亮，org 里面是可以把代码部分高亮的。</p>

<p>效果可以看 <a href="https://goo.gl/photos/E8p1WX34rfAQn31v9" title="这里">这里</a></p>

<h2 id="title1">Title1</h2>

<h3 id="title2">title2</h3>

<ul>
<li>list1</li>
<li>list2</li>
<li>list3</li>
</ul>

<pre><code class="language-python">
import sys

class Hugo(object):
    def __init__(self):
        pass

hugo = Hugo()
print(hugo)
print(&quot;just a test&quot;)
</code></pre>

    </div>

<div class="meta">
    
    <span class="comments"><a href="/Use-org-mode-to-publish-blog/#disqus_thread">Comments</a></span>
    
</div>
</article>

  <article class="post">
    <h2 class="title"> 
        <a href="/Migrate-blog-to-hugo/">Migrate blog to hugo</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2017-03-11T16:29:40.000&#43;08:00' itemprop="datePublished">2017-03-11</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/hugo">hugo</a>

<a href="/tags/hexo">hexo</a>

<a href="/tags/blog">blog</a>


</div>
    </div>
        <p>折腾了好几天，把 blog 从 hexo 迁移到了 <a href="http://gohugo.io/">hugo</a> 上面。hexo 是使用 nodejs 写出来的，hugo 是使用的 go。主要基于下面几个原因吧。</p>

<ul>
<li>个人不太喜欢 nodejs 那一坨依赖。</li>
<li>hugo 也比 nodejs 速度快很多。</li>
<li>hugo 用起来比较简洁。</li>
</ul>

<p>首先写了一个迁移工具 <a href="https://github.com/wd/hexo2hugo">hexo2hugo</a>。网上还有一个 nodejs 版本的<a href="http://nodejh.com/post/Migrate-to-Hugo-from-Hexo/">迁移工具</a>可以参考。其实就是简单的把头部信息处理一下就可以。我还有一些特殊需求，比如把老早以前的一些 html 格式的文档顺道处理一下格式，还有一些小的修正和兼容工作，所以自己写了一个。另外也主要是好久没有写代码了，熟悉下。。</p>

<p>把文档迁移过去之后，找了几个主题看了一下，发现没有很喜欢的，就本着蛋疼的原则，把原来用的主题也<a href="https://github.com/wd/hugo-fabric">迁移过来了</a>，这个花的时间比较长一点。主要还得熟悉 hugo 的模板语法，还得想办法适配 hugo 的体系。比如 hugo 里面没有 archive 一说，不过通过万能的 google 搜索到了一个解决办法，也勉强还好。</p>

<p>目前这个 blog 已经是由 hugo 产生了，和以前外观，访问地址完全一模一样，rss 地址都一样。我测试了 google 里面的搜索结果，是都可以跳转的。今天算是基本都迁移完毕了。</p>

<p>这几天没事也总想记录一点想法，但是无奈新本子上面的 hexo 挂了，又不想搞 nodejs 那一坨依赖，就折腾了这个事情。不过折腾完毕之后发现想记录的事情都忘记了，nnd。</p>

    </div>

<div class="meta">
    
    <span class="comments"><a href="/Migrate-blog-to-hugo/#disqus_thread">Comments</a></span>
    
</div>
</article>

  <article class="post">
    <h2 class="title"> 
        <a href="/Upgrade-kernel-to-4-9-for-linode/">Upgrade kernel to 4.9 for linode</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2017-01-16T18:37:56.000&#43;08:00' itemprop="datePublished">2017-01-16</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/linode">linode</a>

<a href="/tags/kernel">kernel</a>

<a href="/tags/bbr">bbr</a>


</div>
    </div>
        <p>bbr 那么牛逼，赶紧赶一个潮流。其实我之前用了 kcp，也是类似的东西，不过那个要求服务器端和客户端都需要跑 kcp 服务才可以。bbr 就不用了，只需要服务器配置好就可以了。</p>

<p>Linode 实际上已经提供了 4.9 的内核。打开 <code>Dashboard</code>，然后点击你使用的 profile 右侧的 edit，在出来的界面里面，Kernel 右侧的列表里面，有个 4.9 的选项，不过我测试这个内核并不能打开 bbr，不知道是怎么回事，有兴趣的可以试试看，要注意选对架构（就是 64 还是 32）。</p>

<p>所以还是需要自己装内核。debian 官方已经打包好了 kernel 4.9，访问 <a href="http://mirrors.kernel.org/debian/pool/main/l/linux/">http://mirrors.kernel.org/debian/pool/main/l/linux/</a> ，然后找到适合自己的 linux-image-4.9，我的是 <a href="http://mirrors.kernel.org/debian/pool/main/l/linux/linux-image-4.9.0-1-amd64-unsigned_4.9.2-2_amd64.deb">http://mirrors.kernel.org/debian/pool/main/l/linux/linux-image-4.9.0-1-amd64-unsigned_4.9.2-2_amd64.deb</a> ，下载到 vps 上面。</p>

<p>然后执行 <code>sudo dkpg -i ./linux-image-4.9.0-1-amd64-unsigned_4.9.2-2_amd64.deb</code>，最后应该会提示一个错误，缺少依赖的包。这个时候执行 <code>sudo apt-get -f install</code>，会提示安装缺失的包。</p>

<p>然后，还需要安装 <code>grub</code>。看你的情况。就刚才 profile 编辑的页面里面，kernel 右侧的选项里面，你看看你的是 <code>grub2</code> 还是 <code>pv-grub</code>。</p>

<ul>
<li><p><code>grub2</code>: 参考<a href="https://www.linode.com/docs/tools-reference/custom-kernels-distros/run-a-distribution-supplied-kernel-with-kvm">这个</a></p>

<pre><code>$ sudo apt-get install grub2
$ sudo update-grub
</code></pre></li>

<li><p><code>pv-grub</code>: 参考<a href="https://www.linode.com/docs/tools-reference/custom-kernels-distros/run-a-distributionsupplied-kernel-with-pvgrub">这个</a></p>

<pre><code>$ sudo apt-get install grub
$ sudo mkdir /boot/grub
$ sudo update-grub
</code></pre></li>
</ul>

<p>然后在 profile 编辑页面里面，kernel 右侧选择对应的 grub 选项，重启 vps 就可以了。如果启动失败了，就在这个选项里面，选择之前的选项重启就可以恢复。</p>

    </div>

<div class="meta">
    
    <span class="comments"><a href="/Upgrade-kernel-to-4-9-for-linode/#disqus_thread">Comments</a></span>
    
</div>
</article>

  <article class="post">
    <h2 class="title"> 
        <a href="/Python-new/">Python __new__</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2017-01-16T15:47:59.000&#43;08:00' itemprop="datePublished">2017-01-16</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/python">python</a>


</div>
    </div>
        <p>翻译一点 <a href="https://www.python.org/download/releases/2.2/descrintro/#__new__">https://www.python.org/download/releases/2.2/descrintro/#__new__</a> 有些感觉还是挺生硬的，方便自己理解吧。</p>

<p><code>__new__</code> 的一些规则:</p>

<ul>
<li><code>__new__</code> 是一个静态方法。定义它的时候并不需要执行 <code>__new__ = staticmethod(__new__)</code>，因为它的名字就包含了这个含义（这个对于类构造方法来说是个特殊的函数）</li>
<li><code>__new__</code> 的第一个参数，必须是一个类，其余的参数是留给构造方法的。</li>
<li>覆盖了基类的 <code>__new__</code> 方法的类有可能会调用基类的 <code>__new__</code> 方法。传递给基类的 <code>__new__</code> 方法的第一个参数，应该是覆盖基类的 <code>__new__</code> 方法的类，而不是基类，如果传递了基类，你得到的将是基类的示例。</li>
<li>除非你想要按照后面两条描述的方法来使用，否则 <code>__new__</code> 方法必须要调用基类的 <code>__new__</code> 方法，这个是创建你的对象的实例的唯一方法。子类的 <code>__new__</code> 方法可以从两个方面影响产生的实例：传递不同的参数给基类的 <code>__new__</code>，以及修改基类产生的对象（例如初始化一些实例变量）</li>
<li><code>__new__</code> 方法必须返回一个对象。并不一定必须返回一个新的对象，虽然通常都那么做。如果你返回一个已经存在的对象，依然会有对于 <code>__init__</code> 构造函数的调用。如果你返回一个其他函数的对象，那个对象的 <code>__init__</code> 也会被调用。如果忘记返回，python 会给你返回 None，你程序的调用方也许会觉得很奇怪。</li>
<li>对于不可变对象，<code>__new__</code> 可以返回一个之前缓存的对象。对于一些比较小的 int, str, tuple 类型就是这么做的。这也是为什么他们的 <code>__init__</code> 什么都没做：否则之前缓存的对象会被 init 很多次。（另外一个原因是本身页没有东西可以给 <code>__init__</code> 初始化的了，<code>__new__</code> 返回的就是一个已经初始化的对象）。</li>
<li>如果你想要给一个内置的不可变类型增加一些可变的状态（例如给 string 类型增加一个默认的转换方法），最好是在 <code>__init__</code> 方法里面初始化可变状态，而不要在 <code>__new__</code> 里面。</li>
<li>如果你想要修改构造方法的签名，一般需要覆盖 <code>__new__</code> 和 <code>__init__</code> 方法来接受心的签名。然而，大部分内置类型都会忽视自己不用的参数，尤其是不可变类型（int，long，float，complex，str，unicode，tuple）都有一个假的 <code>__init__</code>，而可变类型（dict，list，file，super，classmethod，staticmethd，property）有一个假的 <code>__new__</code>。内置类型 <code>object</code> 有假的 <code>__init__</code> 和 <code>__new__</code> （给其他对象继承）。内置类型 <code>type</code> 在很多方面都很特别，请参考 metaclasses。</li>
<li>（这条和 <code>__new__</code> 没关系，但是页应该了解一下）如果新建一个 <code>type</code> 的子类，实例会自动给 <code>__dict__</code> 和 <code>__weakrefs__</code> 预留空间（ <code>__dict__</code> 在你使用前不会初始化，所以你不需要担心创建的所有实例被一个空的字典所占用的空间）。如果不需要这个多余的空间，可以给你的类设置 <code>__slots__ = []</code>（更多信息可以参考 <code>__slots__</code>。</li>
<li>Factoid: <code>__new__</code> 是一个静态方法，不是类方法。我开始的时候觉得他应该是一个类方法，and that&rsquo;s why I added the classmethod primitive。不幸的是，对于一个类方法，在这种情况下面 upcalls 不工作，所以我只好把他设计成一个第一个参数是一个 class 的静态方法。讽刺的是，there are now no known uses for class methods in the Python distribution (other than in the test suite). I might even get rid of classmethod in a future release if no good use for it can be found!</li>
</ul>

    </div>

<div class="meta">
    
    <span class="comments"><a href="/Python-new/#disqus_thread">Comments</a></span>
    
</div>
</article>

  <article class="post">
    <h2 class="title"> 
        <a href="/Python-inherit-and-super/">Python inherit and super</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2017-01-16T11:53:04.000&#43;08:00' itemprop="datePublished">2017-01-16</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/python">python</a>

<a href="/tags/super">super</a>

<a href="/tags/inherit">inherit</a>


</div>
    </div>
        <p>又学习了一个 python 的继承。有很多帖子都有介绍，比如<a href="https://laike9m.com/blog/li-jie-python-super,70/">理解 Python super</a>，<a href="http://www.cnblogs.com/lovemo1314/archive/2011/05/03/2035005.html">python super()</a>。</p>

<p>先看一个例子，这个是第一个文章里面的。</p>

<pre><code>class Root(object):
    def __init__(self):
        print(&quot;this is Root&quot;)


class B(Root):
    def __init__(self):
        print(&quot;enter B&quot;)
        super(B, self).__init__()
        print(&quot;leave B&quot;)


class C(Root):
    def __init__(self):
        print(&quot;enter C&quot;)
        super(C, self).__init__()
        print(&quot;leave C&quot;)


class D(C):
    def __init__(self):
        print(&quot;enter D&quot;)
        super(D, self).__init__()
        print(&quot;leave D&quot;)


class E(D, B):
    def __init__(self):
        print(&quot;enter E&quot;)
        super(E, self).__init__()
        print(&quot;leave E&quot;)

e = E()
print(e.__class__.mro())

# results:
# enter E
# enter D
# enter C
# enter B
# this is Root
# leave B
# leave C
# leave D
# leave E
# [&lt;class '__main__.E'&gt;, &lt;class '__main__.D'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.Root'&gt;, &lt;class 'object'&gt;]
</code></pre>

<p>没有什么问题，所有的类都做了初始化，很完美。接着再看一个例子，这个例子其实是上面第二篇文章里面的。</p>

<pre><code>class A(object):
    def __init__(self):
        print(&quot;enter A&quot;)
        print(&quot;leave A&quot;)


class B(object):
    def __init__(self):
        print(&quot;enter B&quot;)
        print(&quot;leave B&quot;)


class C(A):
    def __init__(self):
        print(&quot;enter C&quot;)
        super(C, self).__init__()
        print(&quot;leave C&quot;)


class D(A):
    def __init__(self):
        print(&quot;enter D&quot;)
        super(D, self).__init__()
        print(&quot;leave D&quot;)


class E(B, C):
    def __init__(self):
        print(&quot;enter E&quot;)
        super(E, self).__init__()
        print(&quot;leave E&quot;)


class F(E, D):
    def __init__(self):
        print(&quot;enter F&quot;)
        super(F, self).__init__()
        print(&quot;leave F&quot;)


f = F()
print(f.__class__.mro())

# results:
# enter F
# enter E
# enter B
# leave B
# leave E
# leave F
# [&lt;class '__main__.F'&gt;, &lt;class '__main__.E'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.D'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;]
</code></pre>

<p>我发现和文章里面贴的结果不一样，里面缺少对 C，D，A 的初始化。琢磨半天才弄明白，主要原因就是，<code>A</code>，<code>B</code> 其实也是继承自 <code>object</code>，然而我们并没有调用 <code>super</code> 来初始化，所以只需要加上就可以了。</p>

<pre><code>class A(object):
    def __init__(self):
        print(&quot;enter A&quot;)
        super(A, self).__init__()
        print(&quot;leave A&quot;)


class B(object):
    def __init__(self):
        print(&quot;enter B&quot;)
        super(B, self).__init__()
        print(&quot;leave B&quot;)


class C(A):
    def __init__(self):
        print(&quot;enter C&quot;)
        super(C, self).__init__()
        print(&quot;leave C&quot;)


class D(A):
    def __init__(self):
        print(&quot;enter D&quot;)
        super(D, self).__init__()
        print(&quot;leave D&quot;)


class E(B, C):
    def __init__(self):
        print(&quot;enter E&quot;)
        super(E, self).__init__()
        print(&quot;leave E&quot;)


class F(E, D):
    def __init__(self):
        print(&quot;enter F&quot;)
        super(F, self).__init__()
        print(&quot;leave F&quot;)


f = F()
print(f.__class__.mro())

# results:
# enter F
# enter E
# enter B
# enter C
# enter D
# enter A
# leave A
# leave D
# leave C
# leave B
# leave E
# leave F
# [&lt;class '__main__.F'&gt;, &lt;class '__main__.E'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.D'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;]
</code></pre>

<p>这样就完美了。目测这个会是一个隐藏的坑。</p>

    </div>

<div class="meta">
    
    <span class="comments"><a href="/Python-inherit-and-super/#disqus_thread">Comments</a></span>
    
</div>
</article>

  <article class="post">
    <h2 class="title"> 
        <a href="/Python-metaclass/">Python metaclass</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2017-01-12T18:26:22.000&#43;08:00' itemprop="datePublished">2017-01-12</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/python">python</a>


</div>
    </div>
        <p>又理解了一下 python 的 metaclass 可以做什么，尝试记录一下。</p>

<pre><code>class Meta(type):
    register = []

    def __new__(cls, class_name, parrent_class, params):
        print(&quot;In meta new: {}, {}, {}, {}&quot;.format(cls, class_name, parrent_class, params))
        cls.register.append(class_name)
        params['test_prop'] = True
        # return super(Meta, cls).__new__(cls, class_name, parrent_class, params)
        # return type.__new__(cls, class_name, parrent_class, params)
        # return super(Meta, cls).__new__(type, class_name, parrent_class, params)
        # return type.__new__(type, class_name, parrent_class, params)
        return type(class_name, parrent_class, params)

    def __init__(self, class_name, parrent_class, params):
        print(&quot;In meta init: {}, {}, {}&quot;.format(class_name, parrent_class, params))
        super(Meta, self).__init__(class_name, parrent_class, params)


class A(object, metaclass=Meta):
    pass

print(&quot;register: {}&quot;.format(Meta.register))
print(&quot;prop: {}&quot;.format(A.test_prop))
print(&quot;register: {}&quot;.format(A.register))  # Error

# outputs:
# In meta new: &lt;class '__main__.Meta'&gt;, A, (&lt;class 'object'&gt;,), {'__module__': '__main__', '__qualname__': 'A'}
# In meta init: A, (&lt;class 'object'&gt;,), {'__module__': '__main__', '__qualname__': 'A'}
# register: ['A']
# prop: True
# AttributeError: type object 'A' has no attribute 'register'

</code></pre>

<p>可以看到，在构造 <code>A</code> 的时候，<code>Meta</code> 这个类里面，<code>__new__</code> 和 <code>__init__</code> 都会被调用到。上面代码往 <code>A</code> 里面塞了一个属性。</p>

<p>在 <code>__new__</code> 里面，有几个注释，可以去掉注释看看不同的效果。目前还有点疑惑，传给 <code>__new__</code> 第一个参数到底是什么。另外，开始对 <code>super</code> 也有点疑惑了，还在学习。</p>

    </div>

<div class="meta">
    
    <span class="comments"><a href="/Python-metaclass/#disqus_thread">Comments</a></span>
    
</div>
</article>

  <article class="post">
    <h2 class="title"> 
        <a href="/Reinvent-the-wheel/">Reinvent the wheel</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2017-01-12T16:16:20.000&#43;08:00' itemprop="datePublished">2017-01-12</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/heart">heart</a>

<a href="/tags/tech">tech</a>


</div>
    </div>
        <p><a href="https://en.wikipedia.org/wiki/Reinventing_the_wheel">Reinvent the wheel</a> 估计技术人员都知道这个典故。</p>

<p>刚才突然想谈这个，是看到图拉鼎参加 <a href="https://weex-project.io/">weex</a> 的聚会有感而发。我要是没理解错，这个应该是类似于 React native 的一套实现，我没有仔细看过他的实现，不过说他重复造轮子应该也不为过，毕竟，大家普遍赞成的是在已有的轮子上面添砖加瓦，而不是另起一套。</p>

<p>重复造轮子到底应该不应该支持？</p>

<p>之前我司来了一个发明了 avalon 框架的牛人，之后我看好像就在很多的推介这个，新人来了先学习这个。后来还有很多这种框架，新人来了都是先学习这些框架。</p>

<p>这个事情上面，我看有几个好处
* 发明的人可以在公司内部得到很高的地位，以及相应的奖励。不管好用不好用，推行一版，一波人升天。后人再升级一版，又一波人升天。
* 学会了使用这些框架的人，如果自己本身不太灵活，到了其他公司会发现无法干活，因为使用多了会有一个很深的烙印。这样离职起来就没那么方便。
* 比较好规范和控制公司内部的技术方向。</p>

<p>坏处
* 和最新的技术方向可能有割裂，因为并不一定能及时更新适应。
* 问题解决只能依赖内部的这些人来解决，这种东西想要推广出去毕竟还是难。
* 浪费人力做基础建设。</p>

<p>其实看起来，对于基层员工来看好处还是大于坏处的。毕竟如果老板不关心这个成本或者不清楚可以节约这个成本的话，那些好处还是实实在在的，牛逼有的吹。</p>

<p>在老板关心的方面，可能还有一个点，就是创新有时候是比较难的，但是所谓的微创新其实是简单一些，造轮子的时候，一般多少都会有一些微创新。如果搞的人确实有能力，避免一些原来设计里面的鸡肋冗余的部分，让新的设计更加轻快，其实也算是有好处。</p>

    </div>

<div class="meta">
    
    <span class="comments"><a href="/Reinvent-the-wheel/#disqus_thread">Comments</a></span>
    
</div>
</article>

  <article class="post">
    <h2 class="title"> 
        <a href="/Beansdb-merge-tools/">Beansdb merge tools</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2016-12-26T18:36:11.000&#43;08:00' itemprop="datePublished">2016-12-26</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/beansdb">beansdb</a>


</div>
    </div>
        

<p>Beansdb 是豆瓣开源出来的一个高效的支持 memcached 协议的文件存储 db。按 key 查找的时候，会有索引定位到磁盘位置。不过貌似前段时间看到说他们搞了一个新的替代这个，我找了一下没找到链接。</p>

<p>使用 beansdb 的时候，有 2 个问题需要解决
* 冗余问题
* 数据过期删除问题</p>

<h2 id="数据冗余问题">数据冗余问题</h2>

<p>先说第一个问题。beansdb 本身不提供分布式 hash 逻辑，它就是个单机的程序。冗余需要你自己搞定，如果你使用标准的 memcache 协议，可以有多 server 的配置，读的时候其中一个失败会自动找下一个 server，写的时候就不会了，需要你自己写到多个 server。如果你所有的 server 都是一模一样的，那多写就可以了。如果不一样，你还需要考虑自己的 hash 策略。</p>

<p>豆瓣提供了一个 python 的<a href="https://github.com/douban/beansdb/blob/master/python/dbclient.py">客户端</a>，这个客户端里面其实包含了 hash 策略。通过把 key 和 server 分桶来做 hash。摘一点代码如下</p>

<pre><code>BEANSDBCFG = {
    &quot;localhost:7901&quot;: range(16),
    &quot;localhost:7902&quot;: range(16),
    &quot;localhost:7903&quot;: range(16),
}

db = Beansdb(BEANSDBCFG, 16)
</code></pre>

<p>上面定义了三个 server，每个包含 16 个桶（你可以根据你的需求比如定义第一个 server 只包含某些桶）。</p>

<pre><code>def __init__(self, servers, buckets_count=16, N=3, W=1, R=1):
</code></pre>

<p>这里是定义写入数据的时候的逻辑，那个 <code>buckets_count</code> 是桶的数量，<code>N</code> 和 <code>R</code> 貌似没用。。。，<code>W</code> 是改动的时候要求成功的最小 server 数量，包括删除和写入的时候。</p>

<p>读取的时候，会循环从包含这个 key 的桶的 server 列表里面循环读取，这里还有一个「自愈」的逻辑，循环读取直到遇到一个成功的 server，会同时把前面失败的 server 都写入一份数据。</p>

<p>这样下来基本就解决了读写分布式和故障恢复的逻辑了，非常巧妙。</p>

<p>其实针对这个问题，豆瓣还开源了个 <a href="https://github.com/douban/beanseye">beanseye</a>，具体功能没有仔细研究，不过应该是上面需要客户端处理的事情都不需要考虑了。</p>

<p>我们开始用的时候，不知道有 beanseye，我的场景是在 perl 环境下面使用，把 python 的客户端翻译了一个 perl 的版本出来。[1] 有兴趣可以看看。</p>

<h2 id="数据过期删除问题">数据过期删除问题</h2>

<p>beansdb 设计之初写入用的是 append 模式，就是说，遇到删除也是写入一条新的记录，并不会返回去修改原来的数据，所以能达到合理的 IO 速度。如果场景是大量不会删除的小文件，那么 beansdb 使用起来非常合适。</p>

<p>如果有数据过期或者删除的需求，就需要想办法处理这些数据了，否则的话，beandb 的数据文件里面会慢慢的有大量的无用数据，浪费磁盘空间。</p>

<p>这个删除过期数据的过程，我看豆瓣叫做 merge。思路其实就是把所有数据遍历一次，把有效的数据写入一个新的 data 文件，然后旧的删掉，就可以了。beansdb 的数据文件有 2 种，一种是 <code>xxx.data</code>，这种文件是数据文件，另外一种是 <code>xxx.hint.qlz</code> 这种是索引文件。</p>

<p>针对这个需求，我写了两版程序，第一版就是单纯的解读一下数据文件，把其中的数据的信息读出来，主要是版本号和创建时间，然后根据版本号只写入高版本的，根据创建时间把过期的数据丢弃。生成新的 data 文件之后，要删除 hint 文件，启动的时候会自动产生 hint 文件。然后在 beansdb 的机器上面定期跑这个脚本就好了，注意跑之前应该先关闭 beansdb。</p>

<p>第一个版本的程序只是解读了每个块的数据头，程序用起来也勉强还行，但是主要问题是，每次启动都需要重新产生 hint 文件，导致启动到提供服务很慢，所以就有了第二版程序。第二版包含了第一版的全部功能，还提供了按照文件大小来定义删除时限的功能。</p>

<p>第二个版本程序基本把 data 和 hint 文件产生的逻辑都用 perl 实现了（不过还没有经过太多测试）。下面简单讲讲逻辑。</p>

<h3 id="data-文件">data 文件</h3>

<pre><code class="language-cpp">‌typedef struct data_record
{
    char *value;
    union
    {
        bool free_value;    // free value or not
        uint32_t crc;
    };
    int32_t tstamp;
    int32_t flag;
    int32_t version;
    uint32_t ksz;
    uint32_t vsz;
    char key[0];
‌} DataRecord;
</code></pre>

<p>数据文件里面，每个 key 对应的数据的长度是 <code>4*6 + key_size + value_size + padding</code>。</p>

<pre><code>read($fh, my $header, 4*6);
my ( $crc, $tstamp, $flag, $ver, $ksz, $vsz ) = unpack('I i i i I I', $header);
</code></pre>

<p>头部是 24 个字节，依次包括校验数据，写入时间戳，标记位，版本号，key 的长度，value 的长度。上面 <code>unpack</code> 方法第一个参数里面的含义，可以参考<a href="http://perldoc.perl.org/functions/pack.html">perl 的文档</a>。每个 4 字节，32bit 整数。</p>

<p>然后是读取 <code>$ksz</code> 的长度的 key，读取 <code>$vsz</code> 长度 value。如果 <code>$flag</code> 标记表明 value 有压缩，压缩用的是 QLZ 算法，真实的值需要用 qlz 解压缩之后才能得到。</p>

<p>最后是 padding 部分，整个数据长度需要是 256 的整数倍。不足的部分，会写入 <code>\0</code> 做 padding。</p>

<p>merge 的过程不关心 value 的真实值，所以不需要解压缩，把读取到的原样写回去就可以了。另外就是 merge 的时候遇到同一个 key 多个 version 出现的时候，只保留大的那个就可以了。这样操作之后 data 文件会变小。</p>

<h3 id="hint-文件">hint 文件</h3>

<pre><code class="language-cpp">‌typedef struct hint_record
{
    uint32_t ksize:8;
    uint32_t pos:24;
    int32_t version;
    uint16_t hash;
    char key[NAME_IN_RECORD]; // allign
‌} HintRecord;
</code></pre>

<p>hint 文件比 data 文件稍微复杂一点，每一条记录是 <code>key_size + data_pos + ver + hash + key + padding</code>。</p>

<pre><code>my ( $ksz, $datapos, $ver, $hash ) = unpack(&quot;B8 B24 i B16&quot;, $header);

$ksz = unpack(&quot;I&quot;, pack(&quot;B32&quot;, $ksz));
$datapos = unpack(&quot;I&quot;, pack(&quot;B32&quot;, $datapos));
$datapos = $datapos &lt;&lt; 8;
$hash = unpack(&quot;I&quot;, pack(&quot;B32&quot;, $hash));
</code></pre>

<p>头部的 10 个字节如上面代码，第一个 8 bit 是 key 的长度，接下来 24 个 bit 是这个 key 对应数据在 data 文件里面的位置。然后是 4 字节版本，16 bit 的 hash。</p>

<p>padding 和上面 data 里面的逻辑一样，按照 256 的倍数补全。</p>

<p>hint 文件结尾有个 <code>.qlz</code>，表示整个 hint 里面的数据是压缩的，所以在处理前需要先解压缩一下。（不过我看到我代码里面在读取 hint 的时候，是全部数据解压，写入的时候，是按照 record 压缩的，很奇怪）。</p>

    </div>

<div class="meta">
    
    <span class="comments"><a href="/Beansdb-merge-tools/#disqus_thread">Comments</a></span>
    
</div>
</article>

  <article class="post">
    <h2 class="title"> 
        <a href="/release-some-staff-at-github/">Release some staff at github</a>
    </h2>
    <div class="entry-content">
    <div class="meta">
        <div class="date">Published on: <time datetime='2016-12-13T17:00:31.000&#43;08:00' itemprop="datePublished">2016-12-13</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/hexo">hexo</a>

<a href="/tags/lua">lua</a>

<a href="/tags/ngx_lua">ngx_lua</a>

<a href="/tags/mcrypt">mcrypt</a>


</div>
    </div>
        <p>把 blog 用到的模板整理了一下，放到了 <a href="https://github.com/wd/hexo-fabric">https://github.com/wd/hexo-fabric</a> ，这个最开始是 fork 别人的代码改的，后来发现原来那个人已经不用了，就整理一下，增加了一个 tag 支持，修改了一下字体和背景色，还有代码颜色等，都是一些小修改。同时也提交到了官方的 theme 库，不过 pull request 还没有通过。。</p>

<p>另外，还把之前写的一个给 ngx-lua 用的一个使用 mcrypt 加密解密的库 <a href="https://github.com/wd/lua-resty-mcrypt">https://github.com/wd/lua-resty-mcrypt</a> ，整理出来单独弄了一个模块。代码其实非常简单，这个也能看出来 ngx_lua 里面使用 ffi 调用 C 模块开发多舒服，不过因为 C 知识有限，可能还是会有一些问题，不过至少自己测试是 ok 的，也在线上跑了好久，只能遇到有问题的再说了。这个同时也提交到了春哥的 opm 仓库，那个倒没有审核，提交就被索引了，使用的话应该可以用 opm 命令直接安装。</p>

    </div>

<div class="meta">
    
    <span class="comments"><a href="/release-some-staff-at-github/#disqus_thread">Comments</a></span>
    
</div>
</article>



  <nav id="pagenavi">
    
    
        <a href="/page/2/" class="next">Next</a>
    
  <div class="center"><a href="/archives/index.html">Blog Archives</a></div>
  </nav>


    </div>
    <footer id="footer">
    <div style="display:inline">
    Copyright &copy; 2017
    
    wd
    . Powered by <a href="http://gohugo.io" target="_blank">Hugo</a> |
    Theme is <a href="https://github.com/wd/hugo-fabric">hugo-fabric</a>, fork from <a href="https://github.com/wd/hexo-fabric">hexo-fabric</a> by <a href="https://wdicc.com">me</a>
</div>

    </footer>
    <script src="/js/fabric.js"></script>


</div>
</div>
<script src="/js/jquery.ui.totop.js" type="text/javascript"></script>
<script type="text/javascript">
 
;(function($){$().UItoTop({easingType:'easeOutCirc'});})(jQuery);
 
</script>
</body>
</html>
