<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
    
	<title>Beansdb merge tools - wd and cc</title>
    <meta name="author" content="wd">
    
	<meta name="description" content="&lt;p&gt;Beansdb 是豆瓣开源出来的一个高效的支持 memcached 协议的文件存储 db。按 key 查找的时候，会有索引定位到磁盘位置。不过貌似前段时间看到说他们搞了一个新的替代这个，我找了一下没找到链接。&lt;/p&gt;
&lt;p&gt;使用 beansdb 的时候，有 2 个问题需要解决&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;冗余问题&lt;/li&gt;
&lt;li&gt;数据过期删除问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;数据冗余问题&quot;&gt;&lt;a href=&quot;#数据冗余问题&quot; class=&quot;headerlink&quot; title=&quot;数据冗余问题&quot;&gt;&lt;/a&gt;数据冗余问题&lt;/h2&gt;&lt;p&gt;先说第一个问题。beansdb 本身不提供分布式 hash 逻辑，它就是个单机的程序。冗余需要你自己搞定，如果你使用标准的 memcache 协议，可以有多 server 的配置，读的时候其中一个失败会自动找下一个 server，写的时候就不会了，需要你自己写到多个 server。如果你所有的 server 都是一模一样的，那多写就可以了。如果不一样，你还需要考虑自己的 hash 策略。&lt;/p&gt;
&lt;p&gt;豆瓣提供了一个 python 的&lt;a href=&quot;https://github.com/douban/beansdb/blob/master/python/dbclient.py&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;客户端&lt;/a&gt;，这个客户端里面其实包含了 hash 策略。通过把 key 和 server 分桶来做 hash。摘一点代码如下&lt;/p&gt;
&lt;figure class=&quot;highlight aspectj&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;BEANSDBCFG = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;localhost:7901&quot;&lt;/span&gt;: range(16),&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;localhost:7902&quot;&lt;/span&gt;: range(16),&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;localhost:7903&quot;&lt;/span&gt;: range(16),&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;db = Beansdb(BEANSDBCFG, 16)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面定义了三个 server，每个包含 16 个桶（你可以根据你的需求比如定义第一个 server 只包含某些桶）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def __init__(self, servers, buckets_count=16, N=3, W=1, R=1):
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里是定义写入数据的时候的逻辑，那个 &lt;code&gt;buckets_count&lt;/code&gt; 是桶的数量，&lt;code&gt;N&lt;/code&gt; 和 &lt;code&gt;R&lt;/code&gt; 貌似没用。。。，&lt;code&gt;W&lt;/code&gt; 是改动的时候要求成功的最小 server 数量，包括删除和写入的时候。&lt;/p&gt;
&lt;p&gt;读取的时候，会循环从包含这个 key 的桶的 server 列表里面循环读取，这里还有一个「自愈」的逻辑，循环读取直到遇到一个成功的 server，会同时把前面失败的 server 都写入一份数据。&lt;/p&gt;
&lt;p&gt;这样下来基本就解决了读写分布式和故障恢复的逻辑了，非常巧妙。&lt;/p&gt;
&lt;p&gt;其实针对这个问题，豆瓣还开源了个 &lt;a href=&quot;https://github.com/douban/beanseye&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;beanseye&lt;/a&gt;，具体功能没有仔细研究，不过应该是上面需要客户端处理的事情都不需要考虑了。&lt;/p&gt;
&lt;p&gt;我们开始用的时候，不知道有 beanseye，我的场景是在 perl 环境下面使用，把 python 的客户端翻译了一个 perl 的版本出来。[1] 有兴趣可以看看。&lt;/p&gt;
&lt;h2 id=&quot;数据过期删除问题&quot;&gt;&lt;a href=&quot;#数据过期删除问题&quot; class=&quot;headerlink&quot; title=&quot;数据过期删除问题&quot;&gt;&lt;/a&gt;数据过期删除问题&lt;/h2&gt;&lt;p&gt;beansdb 设计之初写入用的是 append 模式，就是说，遇到删除也是写入一条新的记录，并不会返回去修改原来的数据，所以能达到合理的 IO 速度。如果场景是大量不会删除的小文件，那么 beansdb 使用起来非常合适。&lt;/p&gt;
&lt;p&gt;如果有数据过期或者删除的需求，就需要想办法处理这些数据了，否则的话，beandb 的数据文件里面会慢慢的有大量的无用数据，浪费磁盘空间。&lt;/p&gt;
&lt;p&gt;这个删除过期数据的过程，我看豆瓣叫做 merge。思路其实就是把所有数据遍历一次，把有效的数据写入一个新的 data 文件，然后旧的删掉，就可以了。beansdb 的数据文件有 2 种，一种是 &lt;code&gt;xxx.data&lt;/code&gt;，这种文件是数据文件，另外一种是 &lt;code&gt;xxx.hint.qlz&lt;/code&gt; 这种是索引文件。&lt;/p&gt;
&lt;p&gt;针对这个需求，我写了两版程序，第一版就是单纯的解读一下数据文件，把其中的数据的信息读出来，主要是版本号和创建时间，然后根据版本号只写入高版本的，根据创建时间把过期的数据丢弃。生成新的 data 文件之后，要删除 hint 文件，启动的时候会自动产生 hint 文件。然后在 beansdb 的机器上面定期跑这个脚本就好了，注意跑之前应该先关闭 beansdb。&lt;/p&gt;
&lt;p&gt;第一个版本的程序只是解读了每个块的数据头，程序用起来也勉强还行，但是主要问题是，每次启动都需要重新产生 hint 文件，导致启动到提供服务很慢，所以就有了第二版程序。第二版包含了第一版的全部功能，还提供了按照文件大小来定义删除时限的功能。&lt;/p&gt;
&lt;p&gt;第二个版本程序基本把 data 和 hint 文件产生的逻辑都用 perl 实现了（不过还没有经过太多测试）。下面简单讲讲逻辑。&lt;/p&gt;
&lt;h3 id=&quot;data-文件&quot;&gt;&lt;a href=&quot;#data-文件&quot; class=&quot;headerlink&quot; title=&quot;data 文件&quot;&gt;&lt;/a&gt;data 文件&lt;/h3&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;‌&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; data_record&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *value;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;union&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; free_value;    &lt;span class=&quot;comment&quot;&gt;// free value or not&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;uint32_t&lt;/span&gt; crc;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int32_t&lt;/span&gt; tstamp;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int32_t&lt;/span&gt; flag;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int32_t&lt;/span&gt; version;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;uint32_t&lt;/span&gt; ksz;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;uint32_t&lt;/span&gt; vsz;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; key[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;‌&amp;#125; DataRecord;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;数据文件里面，每个 key 对应的数据的长度是 &lt;code&gt;4*6 + key_size + value_size + padding&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;read($fh, my $header, 4*6);
my ( $crc, $tstamp, $flag, $ver, $ksz, $vsz ) = unpack(&amp;apos;I i i i I I&amp;apos;, $header);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;头部是 24 个字节，依次包括校验数据，写入时间戳，标记位，版本号，key 的长度，value 的长度。上面 &lt;code&gt;unpack&lt;/code&gt; 方法第一个参数里面的含义，可以参考&lt;a href=&quot;http://perldoc.perl.org/functions/pack.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;perl 的文档&lt;/a&gt;。每个 4 字节，32bit 整数。&lt;/p&gt;
&lt;p&gt;然后是读取 &lt;code&gt;$ksz&lt;/code&gt; 的长度的 key，读取 &lt;code&gt;$vsz&lt;/code&gt; 长度 value。如果 &lt;code&gt;$flag&lt;/code&gt; 标记表明 value 有压缩，压缩用的是 QLZ 算法，真实的值需要用 qlz 解压缩之后才能得到。&lt;/p&gt;
&lt;p&gt;最后是 padding 部分，整个数据长度需要是 256 的整数倍。不足的部分，会写入 &lt;code&gt;\0&lt;/code&gt; 做 padding。&lt;/p&gt;
&lt;p&gt;merge 的过程不关心 value 的真实值，所以不需要解压缩，把读取到的原样写回去就可以了。另外就是 merge 的时候遇到同一个 key 多个 version 出现的时候，只保留大的那个就可以了。这样操作之后 data 文件会变小。&lt;/p&gt;
&lt;h3 id=&quot;hint-文件&quot;&gt;&lt;a href=&quot;#hint-文件&quot; class=&quot;headerlink&quot; title=&quot;hint 文件&quot;&gt;&lt;/a&gt;hint 文件&lt;/h3&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;‌&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; hint_record&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;uint32_t&lt;/span&gt; ksize:&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;uint32_t&lt;/span&gt; pos:&lt;span class=&quot;number&quot;&gt;24&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int32_t&lt;/span&gt; version;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;uint16_t&lt;/span&gt; hash;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; key[NAME_IN_RECORD]; &lt;span class=&quot;comment&quot;&gt;// allign&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;‌&amp;#125; HintRecord;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;hint 文件比 data 文件稍微复杂一点，每一条记录是 &lt;code&gt;key_size + data_pos + ver + hash + key + padding&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;my ( $ksz, $datapos, $ver, $hash ) = unpack(&amp;quot;B8 B24 i B16&amp;quot;, $header);

$ksz = unpack(&amp;quot;I&amp;quot;, pack(&amp;quot;B32&amp;quot;, $ksz));
$datapos = unpack(&amp;quot;I&amp;quot;, pack(&amp;quot;B32&amp;quot;, $datapos));
$datapos = $datapos &amp;lt;&amp;lt; 8;
$hash = unpack(&amp;quot;I&amp;quot;, pack(&amp;quot;B32&amp;quot;, $hash));
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;头部的 10 个字节如上面代码，第一个 8 bit 是 key 的长度，接下来 24 个 bit 是这个 key 对应数据在 data 文件里面的位置。然后是 4 字节版本，16 bit 的 hash。&lt;/p&gt;
&lt;p&gt;padding 和上面 data 里面的逻辑一样，按照 256 的倍数补全。&lt;/p&gt;
&lt;p&gt;hint 文件结尾有个 &lt;code&gt;.qlz&lt;/code&gt;，表示整个 hint 里面的数据是压缩的，所以在处理前需要先解压缩一下。（不过我看到我代码里面在读取 hint 的时候，是全部数据解压，写入的时候，是按照 record 压缩的，很奇怪）。&lt;/p&gt;
"> <!-- TODO: truncate -->
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="atom.xml" rel="alternate" title="wd and cc" type="application/atom+xml">
	<link href="/favicon.ico" rel="shortcut icon">
    <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
    <link href="/stylesheets/custom.css" media="screen, projection" rel="stylesheet" type="text/css">
    <link href="/stylesheets/hljs.css" media="screen, projection" rel="stylesheet" type="text/css">

    <link href='//fonts.googleapis.com/css?family=Slackey' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Fjalla+One' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Amethysta' rel='stylesheet' type='text/css'>
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
    <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![}]-->

    <script type="text/javascript" src="/javascripts/jquery-tapir.js"></script>

    <!-- remove or comment it to disable ajaxification -->   
    <!-- <script src="/javascripts/ajaxify.js"></script> -->

    

    

</head>


<body>
    <div id="wrapper">
    <header id="header" class="inner"><!-- for more effects see _animate.scss -->
<h1 class="animated bounceInDown">
    <div id="headerbg">
        wd and cc
    </div>
</h1>
<span class="subtitle">happy everyday</span>
<br>

<ul id="social-links" style="text-align:center; clear:both;">
  
  <!-- GitHub -->
  <li>
  <a href="https://github.com/wd" class="github" title="Github"></a>
  </li>
  
  
  
  
  <!-- Twitter -->
  <li>
  <a href="http://www.twitter.com/wd" class="twitter" title="Twitter"></a>
  </li>
  
  
  
  
  
</ul>


<!-- use full url including 'index.html' for navigation bar if you are using ajax -->
<ul id="nav">
	<li id="ajax"><a href="/index.html">Home</a></li>
	<li id="ajax"><a href="/archives/index.html">Archives</a></li>
	<li id="ajax"><a href="/tags/index.html">Tags</a></li>
    <li><a href="/atom.xml">RSS</a></li>
    
    <li>
    <div id="dark">
        <form action="//www.google.com.hk/search" method="get" accept-charset="UTF-8" id="search">
            <input type="hidden" name="sitesearch" value="https://wdicc.com" />
            <input type="text" name="q" results="0" placeholder="Search..." x-webkit-speech />
        </form>
    </div>
    </li>
        
</ul>




</header>

<div id="toload">
<!-- begin toload -->
    <div id="content" class="inner">
        <article class="post">
	<h2 class="title">Beansdb merge tools</h2>
    <div class="meta">
        <div class="date">Published on: <time datetime="2016-12-26T10:36:11.000Z" itemprop="datePublished">Dec 26, 2016</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/beansdb/">beansdb</a>
</div>
    </div>
	<div class="entry-content"><p>Beansdb 是豆瓣开源出来的一个高效的支持 memcached 协议的文件存储 db。按 key 查找的时候，会有索引定位到磁盘位置。不过貌似前段时间看到说他们搞了一个新的替代这个，我找了一下没找到链接。</p>
<p>使用 beansdb 的时候，有 2 个问题需要解决</p>
<ul>
<li>冗余问题</li>
<li>数据过期删除问题</li>
</ul>
<h2 id="数据冗余问题"><a href="#数据冗余问题" class="headerlink" title="数据冗余问题"></a>数据冗余问题</h2><p>先说第一个问题。beansdb 本身不提供分布式 hash 逻辑，它就是个单机的程序。冗余需要你自己搞定，如果你使用标准的 memcache 协议，可以有多 server 的配置，读的时候其中一个失败会自动找下一个 server，写的时候就不会了，需要你自己写到多个 server。如果你所有的 server 都是一模一样的，那多写就可以了。如果不一样，你还需要考虑自己的 hash 策略。</p>
<p>豆瓣提供了一个 python 的<a href="https://github.com/douban/beansdb/blob/master/python/dbclient.py" target="_blank" rel="external">客户端</a>，这个客户端里面其实包含了 hash 策略。通过把 key 和 server 分桶来做 hash。摘一点代码如下</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">BEANSDBCFG = &#123;</div><div class="line">    <span class="string">"localhost:7901"</span>: range(16),</div><div class="line">    <span class="string">"localhost:7902"</span>: range(16),</div><div class="line">    <span class="string">"localhost:7903"</span>: range(16),</div><div class="line">&#125;</div><div class="line"></div><div class="line">db = Beansdb(BEANSDBCFG, 16)</div></pre></td></tr></table></figure>
<p>上面定义了三个 server，每个包含 16 个桶（你可以根据你的需求比如定义第一个 server 只包含某些桶）。</p>
<pre><code>def __init__(self, servers, buckets_count=16, N=3, W=1, R=1):
</code></pre><p>这里是定义写入数据的时候的逻辑，那个 <code>buckets_count</code> 是桶的数量，<code>N</code> 和 <code>R</code> 貌似没用。。。，<code>W</code> 是改动的时候要求成功的最小 server 数量，包括删除和写入的时候。</p>
<p>读取的时候，会循环从包含这个 key 的桶的 server 列表里面循环读取，这里还有一个「自愈」的逻辑，循环读取直到遇到一个成功的 server，会同时把前面失败的 server 都写入一份数据。</p>
<p>这样下来基本就解决了读写分布式和故障恢复的逻辑了，非常巧妙。</p>
<p>其实针对这个问题，豆瓣还开源了个 <a href="https://github.com/douban/beanseye" target="_blank" rel="external">beanseye</a>，具体功能没有仔细研究，不过应该是上面需要客户端处理的事情都不需要考虑了。</p>
<p>我们开始用的时候，不知道有 beanseye，我的场景是在 perl 环境下面使用，把 python 的客户端翻译了一个 perl 的版本出来。[1] 有兴趣可以看看。</p>
<h2 id="数据过期删除问题"><a href="#数据过期删除问题" class="headerlink" title="数据过期删除问题"></a>数据过期删除问题</h2><p>beansdb 设计之初写入用的是 append 模式，就是说，遇到删除也是写入一条新的记录，并不会返回去修改原来的数据，所以能达到合理的 IO 速度。如果场景是大量不会删除的小文件，那么 beansdb 使用起来非常合适。</p>
<p>如果有数据过期或者删除的需求，就需要想办法处理这些数据了，否则的话，beandb 的数据文件里面会慢慢的有大量的无用数据，浪费磁盘空间。</p>
<p>这个删除过期数据的过程，我看豆瓣叫做 merge。思路其实就是把所有数据遍历一次，把有效的数据写入一个新的 data 文件，然后旧的删掉，就可以了。beansdb 的数据文件有 2 种，一种是 <code>xxx.data</code>，这种文件是数据文件，另外一种是 <code>xxx.hint.qlz</code> 这种是索引文件。</p>
<p>针对这个需求，我写了两版程序，第一版就是单纯的解读一下数据文件，把其中的数据的信息读出来，主要是版本号和创建时间，然后根据版本号只写入高版本的，根据创建时间把过期的数据丢弃。生成新的 data 文件之后，要删除 hint 文件，启动的时候会自动产生 hint 文件。然后在 beansdb 的机器上面定期跑这个脚本就好了，注意跑之前应该先关闭 beansdb。</p>
<p>第一个版本的程序只是解读了每个块的数据头，程序用起来也勉强还行，但是主要问题是，每次启动都需要重新产生 hint 文件，导致启动到提供服务很慢，所以就有了第二版程序。第二版包含了第一版的全部功能，还提供了按照文件大小来定义删除时限的功能。</p>
<p>第二个版本程序基本把 data 和 hint 文件产生的逻辑都用 perl 实现了（不过还没有经过太多测试）。下面简单讲讲逻辑。</p>
<h3 id="data-文件"><a href="#data-文件" class="headerlink" title="data 文件"></a>data 文件</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">‌<span class="keyword">typedef</span> <span class="keyword">struct</span> data_record</div><div class="line">&#123;</div><div class="line">    <span class="keyword">char</span> *value;</div><div class="line">    <span class="keyword">union</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">bool</span> free_value;    <span class="comment">// free value or not</span></div><div class="line">        <span class="keyword">uint32_t</span> crc;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">int32_t</span> tstamp;</div><div class="line">    <span class="keyword">int32_t</span> flag;</div><div class="line">    <span class="keyword">int32_t</span> version;</div><div class="line">    <span class="keyword">uint32_t</span> ksz;</div><div class="line">    <span class="keyword">uint32_t</span> vsz;</div><div class="line">    <span class="keyword">char</span> key[<span class="number">0</span>];</div><div class="line">‌&#125; DataRecord;</div></pre></td></tr></table></figure>
<p>数据文件里面，每个 key 对应的数据的长度是 <code>4*6 + key_size + value_size + padding</code>。</p>
<pre><code>read($fh, my $header, 4*6);
my ( $crc, $tstamp, $flag, $ver, $ksz, $vsz ) = unpack(&apos;I i i i I I&apos;, $header);
</code></pre><p>头部是 24 个字节，依次包括校验数据，写入时间戳，标记位，版本号，key 的长度，value 的长度。上面 <code>unpack</code> 方法第一个参数里面的含义，可以参考<a href="http://perldoc.perl.org/functions/pack.html" target="_blank" rel="external">perl 的文档</a>。每个 4 字节，32bit 整数。</p>
<p>然后是读取 <code>$ksz</code> 的长度的 key，读取 <code>$vsz</code> 长度 value。如果 <code>$flag</code> 标记表明 value 有压缩，压缩用的是 QLZ 算法，真实的值需要用 qlz 解压缩之后才能得到。</p>
<p>最后是 padding 部分，整个数据长度需要是 256 的整数倍。不足的部分，会写入 <code>\0</code> 做 padding。</p>
<p>merge 的过程不关心 value 的真实值，所以不需要解压缩，把读取到的原样写回去就可以了。另外就是 merge 的时候遇到同一个 key 多个 version 出现的时候，只保留大的那个就可以了。这样操作之后 data 文件会变小。</p>
<h3 id="hint-文件"><a href="#hint-文件" class="headerlink" title="hint 文件"></a>hint 文件</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">‌<span class="keyword">typedef</span> <span class="keyword">struct</span> hint_record</div><div class="line">&#123;</div><div class="line">    <span class="keyword">uint32_t</span> ksize:<span class="number">8</span>;</div><div class="line">    <span class="keyword">uint32_t</span> pos:<span class="number">24</span>;</div><div class="line">    <span class="keyword">int32_t</span> version;</div><div class="line">    <span class="keyword">uint16_t</span> hash;</div><div class="line">    <span class="keyword">char</span> key[NAME_IN_RECORD]; <span class="comment">// allign</span></div><div class="line">‌&#125; HintRecord;</div></pre></td></tr></table></figure>
<p>hint 文件比 data 文件稍微复杂一点，每一条记录是 <code>key_size + data_pos + ver + hash + key + padding</code>。</p>
<pre><code>my ( $ksz, $datapos, $ver, $hash ) = unpack(&quot;B8 B24 i B16&quot;, $header);

$ksz = unpack(&quot;I&quot;, pack(&quot;B32&quot;, $ksz));
$datapos = unpack(&quot;I&quot;, pack(&quot;B32&quot;, $datapos));
$datapos = $datapos &lt;&lt; 8;
$hash = unpack(&quot;I&quot;, pack(&quot;B32&quot;, $hash));
</code></pre><p>头部的 10 个字节如上面代码，第一个 8 bit 是 key 的长度，接下来 24 个 bit 是这个 key 对应数据在 data 文件里面的位置。然后是 4 字节版本，16 bit 的 hash。</p>
<p>padding 和上面 data 里面的逻辑一样，按照 256 的倍数补全。</p>
<p>hint 文件结尾有个 <code>.qlz</code>，表示整个 hint 里面的数据是压缩的，所以在处理前需要先解压缩一下。（不过我看到我代码里面在读取 hint 的时候，是全部数据解压，写入的时候，是按照 record 压缩的，很奇怪）。</p>
</div>

<div class="meta">
	
		<span class="comments"><a href="https://wdicc.com/Beansdb-merge-tools/#disqus_thread">Comments</a></span>
	
</div>
</article>

	<div class="share">
	<div class="addthis_toolbox addthis_default_style ">
	
	
	<a class="addthis_button_tweet"></a>
	
	
	<a class="addthis_counter addthis_pill_style"></a>
	</div>
  <script type="text/javascript" src="http://s7.addthis.com/js/250/addthis_widget.js#pubid=null"></script>
</div>





    
      <script type="text/javascript">
        var disqus_config = function () {
            this.page.url = 'https://wdicc.com/Beansdb-merge-tools/';
            this.page.identifier = 'https://wdicc.com/Beansdb-merge-tools/';
        };

        (function() {
          var d = document, s = d.createElement('script');
          s.src = '//wdicc.disqus.com/embed.js';
          s.setAttribute('data-timestamp', +new Date());
          (d.head || d.body).appendChild(s);
        })();
      </script>
    


<section id="comment">
    <h2 class="title">Comments</h2>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
</section>


    </div>
    <footer id="footer">
    <div style="display:inline">
    Copyright &copy; 2017

    wd
. Powered by <a href="http://zespia.tw/hexo/" target="_blank">Hexo</a> |
    Theme is <a href="https://github.com/wd/hexo-fabric">hexo-fabric</a>, fork from <a href="http://github.com/panks/fabric">fabric</a> by <a href="http://panks.me">Pankaj Kumar</a>
</div>


    </footer>
    <script src="/javascripts/fabric.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script>
 <!-- Delete or comment this line to disable Fancybox -->



<!-- end toload --> 
</div>
</div>
<script src="/javascripts/jquery.ui.totop.js" type="text/javascript"></script>
<script type="text/javascript">
/*<![CDATA[*/
;(function($){$().UItoTop({easingType:'easeOutCirc'});})(jQuery); 
/*]]>*/
</script><!-- remove it to remove the scroll to top button -->
</body>
</html>
