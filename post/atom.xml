<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on wd and cc</title><link>https://wdicc.com/post/</link><description>Recent content in Posts on wd and cc</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sun, 02 Feb 2020 16:20:21 +0800</lastBuildDate><atom:link href="https://wdicc.com/post/atom.xml" rel="self" type="application/rss+xml"/><item><title>Google Python Style Guide</title><link>https://wdicc.com/google-python-style-guide/</link><pubDate>Sun, 02 Feb 2020 16:20:21 +0800</pubDate><guid>https://wdicc.com/google-python-style-guide/</guid><description>来自这里。翻译的目的是为了方便快速理解，所以没有太纠结很准确，最好是和英文对应看。 1 Background Google 的 python 代码风格指导。 有一个 vim 的配置。 Emacs 默认的似乎就可以。 还有团队使用 yapf 自动格式化代码来避免对格式产生争论。 2 Python Language Rules 2.1 Lint 使用 pylint 检查代码。 可以通过行内注释关闭一些 warning 1 dict = &amp;#39;something awful&amp;#39; # Bad Idea... pylint: disable=redefined-builtin 2.2 Imports import x 引入包或者模块 from x import y x 是包前缀，y 是模块名称 from x import y as z 如果有两个模块都叫 y 或者 y 的名字太长了 import y as z 只有在 z 是个比较常见的缩写（例如 np 作为 numpy 的缩写） 例如 sound.</description></item><item><title>PostgreSQL at Low Level</title><link>https://wdicc.com/postgresql-at-low-level/</link><pubDate>Sun, 02 Feb 2020 11:04:47 +0800</pubDate><guid>https://wdicc.com/postgresql-at-low-level/</guid><description>总结一下这篇文章 PostgreSQL at low level: stay curious! Introduction 我们之前使用数据库的时候，生产环境都只在实体机上面使用，测试和开发为了资源复用会在虚拟机 vm 上面使用。 但是现在不少在 vm k8s 或者 aws 上面使用 db 数据库的，实际这里面可能有很多潜在的问题。以前是 pg - OS 这样两层结构，现在是 pg - os - cg - vm - k8s 这样多层结构，这里面任何一层出现问题实际都会导致你的查询变慢。我们以前虚拟机上面跑服务的时候，有时候就会被同物理机其他虚拟机上面的服务影响，例如突然的高 io。这样即使怎么看那个执行计划估计也没用，你必须去研究更底层可能的影响。 Shared memory docker 只给 /dev/shm 64MB 大小，所以是会遇到共享内存不足的问题啦。可以通过 strace 定位 1 2 3 4 5 6 7 8 9 10 11 12 # strace -k -p PID openat(AT_FDCWD, &amp;#34;/dev/shm/PostgreSQL.62223175&amp;#34; ftruncate(176, 50438144) = 0 fallocate(176, 0, 0, 50438144) = -1 ENOSPC &amp;gt; libc-2.</description></item><item><title>Dont Do This in PostgreSQL</title><link>https://wdicc.com/dont-do-this-in-postgresql/</link><pubDate>Sat, 01 Feb 2020 14:46:36 +0800</pubDate><guid>https://wdicc.com/dont-do-this-in-postgresql/</guid><description>前几天看见个这个，翻译一下。 不要使用 SQL_ASCII 可以看德哥这篇文章，使用这个编码后就是给啥存啥，如果 db 用户瞎用，里面 gbk utf8 都往里放，那将来用的时候会比较麻烦，而且这样舍弃了数据库提供的数据检查功能，不是浪费么。 不要使用 psql -W or –password 主要就是 psql 实际会自动处理这个事情的，如果需要密码会找你要的。不用强制让他提示你输入密码。 不要使用 rules 可以使用 trigger 代替。 depesz 讲的 To rule or not to rule that is the question depesz 的意思是不要使用 rule。即使是多年的 dba 也可能会用错。 rule 主要是通过修改 sql 来实现逻辑，而不是通过一定规则来执行另一个 sql。 PG 文档里面讲的 rules-triggers 用 rule 可以做很多 trigger 可以做的事情。一些约束，特别是外键不能使用 rule 完成。当一列里面的值在其他表里面不存在的时候可以使用 rule 重写命令为什么都不做，但是这样的话数据就丢掉了，这并不是个好主意。如果需要检查数据是否有效，在无效的时候还需要报个错什么的，那只能使用 trigger 完成。 这一章会讨论如何使用 rule 来更新 view。本例里面所有的 rule 都可以使用 view 的 trigger 代替。使用 trigger 会比 rule 简单一点，尤其那些在更新的时候逻辑比较复杂的。 当两个方法都可以的时候，哪种好取决于数据库的使用。trigger 会针对影响到的行每行触发一次。rule 通过修改 query 或者添加一些查询来完成。所以如果一条语句里面多条数据被影响，rule 会触发一条额外的命令，比 trigger 每行都执行一次快，并且这里可能还有很多重复性的计算好决定需要做什么。然而，trigger 概念上比 rule 简单，新手也不容易犯错。 举个例子： 1 2 3 4 5 6 7 8 9 CREATE TABLE computer ( hostname text, -- indexed manufacturer text -- indexed ); CREATE TABLE software ( software text, -- indexed hostname text -- indexed ); 每个表都有几千数据，hostname 是唯一键。rule 或者 trigger 需要实现一个约束，从 computer 表删除数据的时候，同时从 software 表删除。trigger 会使用下面的命令 1 DELETE FROM software WHERE hostname = $1; 因为 trigger 在每行删除的时候都会执行，所以数据库可以保存执行计划传递一个 hostname 作为参数就行。rule 需要使用下面的命令 1 2 CREATE RULE computer_del AS ON DELETE TO computer DO DELETE FROM software WHERE hostname = OLD.</description></item><item><title>Algorithms Lessons From MIT</title><link>https://wdicc.com/algorithms-lessons-from-mit/</link><pubDate>Wed, 29 Jan 2020 09:32:04 +0800</pubDate><guid>https://wdicc.com/algorithms-lessons-from-mit/</guid><description>在推上看到的这个课程 Introduction to Algorithms，虽然是 2011 年的，但是基础的东西还是比较稳定的，刚好补习一下基础知识，做点笔记。 Peak finding 从头一个一个顺序找，是 O(n) 复杂度。也可以用二分，从中间开始找，然后递归，复杂度是 O(log(n)) 。 Models of Computation, Document Distance L.append(x): O(1) L = L1 + L2: O(1) len(L): O(1) L.sort(): O(nlog(n)) 还和比较的复杂度有关系 val in L: O(n) D[key]=val: O(1) key in D: O(1) 还取决于有没有冲突 文档距离公式： d(D1, D2) = D1*D2 = ∑D1[W]*D2[W] 只考虑相同词出现的次数，这样文字多的会打分比较多，文字少的打分少，这个公式和文章规模没关系。所以修正下，除以他们的长度，就是 d(D1, D2) = D1*D2 = ∑(D1[W]*D2[W]/|D1|*|D2|) 这个就是计算两个向量的夹角，夹角越小表示两个越接近。 Insertion Sort, Merge Sort 插入排序：顺序检查每个元素，和前面的比较，如果比前面的小，那就和前面的交换。如果发生了交换，那需要递归和更前面的比较，直到没有交换。继续检查下一个元素。复杂度是 O(n^2)。 插入排序优化：需要和前面发生交换的时候，因为前面都是排好序的，所以可以使用二分找到合适的位置，而不用一个一个找。复杂度是 O(nlog(n))。 归并排序：归并需要是排序好的数组，但是可以通过拆分，把原始数据拆分成2个未排序数组，然后递归继续拆分，直到两个数组只有一个元素，比较之后就可以归并成一个有序数组，递归返回就可以完成排序。复杂度 O(nlog(n)) 递归算法的复杂度计算思路，T(n)=2T(n/2)+cx，取决于那个 x 如果 x 是 n ，每层递归都是 n，这样计算量是分布到每层的，层数是 log(n)，那就是 nlog(n)。 如果 x 是 1 ，那第一层是 c，第二层是 2c….</description></item><item><title>Comfort Zone</title><link>https://wdicc.com/comfort-zone/</link><pubDate>Sat, 18 Jan 2020 10:36:20 +0800</pubDate><guid>https://wdicc.com/comfort-zone/</guid><description> 舒适区 舒适区这个概念不同人其实有不同的定义，比如有些人可能是工作中学习一些自己没学过的知识，就需要打破他的舒适区，因为总觉得自己去学那些东西费力不说可能还需要去做自己以前不熟悉的事情。有些人换工作会打破他的舒适区，因为很多的未知，比如可能需要重新租房什么的会觉得好麻烦。 想要走出舒适区肯定会有那么一点痛苦，舒适区里面的呆着也不是没问题，毕竟不是每个人都会有危机感觉得需要不断突破自己。但是需要担心的是，现在这个高速发展的社会里，不进则退，如果你一直原地踏步，慢慢就可能被周围人甩掉。那些吃低保的人，10 年前可能活的也挺好的。 职业生涯规划 想走出舒适区肯定有很多选择，但是到底选哪个方向呢？方向选不好可能反而花了时间没得到结果，也会很郁闷。首先讲，任何方向都比没有方向好，动起来就好。总比打游戏好，对不。 然后，想要选对方向实际上是需要先做职业规划。自己喜欢什么方向，市场喜欢什么方向，还有就是什么方向可以增加自己的竞争力。 先想想自己对社会的价值在哪里，比如搞技术的，可以通过技术建一个系统提升其他人的工作效率。那如何能把这个事情做的更好，可能是这样的，只会做后端 python 开发的，需要去学学数据库，去学学前端 html，javascript 等，这些都弄明白之后，你就可以一个人（或者带一个团队）就把这个事情做好了。那你的职业规划就可以是往类似于技术合伙人，架构师之类的岗位努力。 如果是个运维人员，对社会的价值可能是如何能减少系统运行故障。那可能会需要知道自动化运维（毕竟手动的容易产生不确定性），备份恢复，负载均衡，现在还有容器隔离，虚拟化等等这些技术。搞明白之后呢，就可以为了实现 9999 的高可用指标努力了。 还有人虽然也是技术人员，但是做着做着发现经常协调团队成员或者和其他团队成员的协作很有特长，那可能会慢慢对管理比较感兴趣，对社会的价值可能就是协调管理好几十号人，同时技术方面也有自己的理解，这样就可以去做技术团队的管理，制定技术方向，规划团队的发展。 还有的技术人员，只对某些知识感兴趣，比如数据库，喜欢研究各种各样的数据库。慢慢会成为一个数据库专家，研究各种数据库的运行模式问题解决等等。 不同人有不同的兴趣爱好，可能有不同的方向。不同的方向有各自的特点，可以解决特定的问题，做职业规划的时候，可以多想想竞争力在哪里。技术越精湛，能力越强，回头会发现就业市场反而会变小，因为毕竟一个只有 200M 数据库的公司不需要招聘一个研究了 10 年数据库的人吧？应该这么说，他们不会给那么多钱招聘一个那样的专家，你愿意降薪自然也是可以的。。 合理的评估自己的价值 并不是每个人都可以随着年龄增长自己能力也会稳定增长，这个其实类似一个指数曲线，一般都会遇到瓶颈，越到后面越难突破。所以发现工作十年的代码抽象能力不如一个工作3年的年轻人的时候也不必惊讶，这个就是正常的现象。认识到自己的能力的意义在于，不要盲目的去和别人对比，看到别人工资比你高就眼红。对比一定是个多维度的事情。 有些人觉得现在的老板就是个傻逼，懂的好像还没有自己多，一些决定做的也不怎么样，凭啥给他打工？这个当然了，你可以不给他打工，去做自己的事业，自己做老板去折磨其他人。但是如果你没有能力去做，那是不是有个老板愿意要你也应该挺开心的？ 一个人在人才市场上面，找工作的时候其实和市场里面卖商品的没什么区别。相同的商品不同的店铺可能价格不一样，不同的商品又各有千秋，看用户的目的是什么。没钱的用户会追求性价比，有钱的用户会买奢侈品，不需要啥性价比。那你也需要知道自己的价值，怎么知道呢？如果一直在一个公司呆着，会和周围人比较，但是一个公司内部通常薪资不透明，你也不知道那个看着不如你的人工资是不是比你高。而且还有可能这个公司一直打压工资呢。 一个商品想要卖出合适的价格，无非就是多比较买家，多去面试，多调整自己的认知，只有交易发生的时候价值才能真的体现。 有些人害怕公司有监控，更新了简历公司就会知道。如果你害怕这个事情发生，那正是说明你自己也对自己没有信心，害怕失去现在的工作。而作为一个公司，即使知道你有可能会想走，那他们会怎么做？一种情况是，早就看你不顺眼了，你想走，那就等你走或者挤兑你走，那这样不管你更新不更新迟早都会让你走的。二种情况是，觉得你是个人才，不想你走，那看到这个情况可能会悄摸给你涨工资也说不好。不管哪种情况你是不是都没啥吃亏的？ 关于自己能力的认知再多说几句，码农喜欢开玩笑说自己是个搬砖的，对搬砖的满是鄙视，觉得赚钱少。其实他们自己何尝不知道这个事情很累还不赚钱呢？主要是他们没有其他赚钱能力。你想想你自己，除了给别人打工写代码，还有其他赚钱能力么？那说起来和搬砖的有什么区别呢？工种不一样起点不一样而已。之前看《软技能》这本书作者给自己设定的目标就是即使不工作，被动收入也可以养活自己。他的被动收入包括股票，卖自己的书，房子出租这些。你看，这个作者就知道培养自己多方面的能力，而不至于将来只能靠打工赚钱。</description></item><item><title>Django Channels2</title><link>https://wdicc.com/django-channels2/</link><pubDate>Sat, 28 Dec 2019 14:11:19 +0800</pubDate><guid>https://wdicc.com/django-channels2/</guid><description>Django 3.0.1 has released for sometime. We still use Django 1.11 in one of our project, with Channels 1.1.8, I think it&amp;#39;s the time to upgrade to newest Django and Channels. According this upgrade guide, Channels 2 is a fully rewritten, lots of things has changed. This post is just a record about the upgrade I&amp;#39;ve done. Routing In Channels 2 you need to add an ASGI_APPLICATION in the settings file, point to the asgi application.</description></item><item><title>Year in Review 2019</title><link>https://wdicc.com/year-in-review-2019/</link><pubDate>Wed, 18 Dec 2019 16:48:58 +0800</pubDate><guid>https://wdicc.com/year-in-review-2019/</guid><description>Here it comes, the end-of-year 2019. The next year will be 2020, it’s more easy to pronounce for foreigners :) Works Finally, I realized that I lack of experience and knowledge to continue run our startup company. When you are the founder of a company yourself, you can’t blame others doing things not well, especially when you didn’t know how to doing it well either. I have to accept the fact that I am not having all the skills that a company needed.</description></item><item><title>Should I Join a Startup Company</title><link>https://wdicc.com/should-i-join-a-startup-company/</link><pubDate>Thu, 12 Dec 2019 15:19:51 +0800</pubDate><guid>https://wdicc.com/should-i-join-a-startup-company/</guid><description> 前几天看到一个这个程序员为了期权加入创业公司，值得吗？，高票的回答写的挺有意思的，有兴趣可以看看。 大家都想前几年上市潮带来的程序员暴富神话发生在自己身上，所以会去初创，拿着原始股，想一想上市之后 10 - 100 倍回馈，这到时候得多有钱啊，睡觉都流口水。 正常来说，开一家公司是想要靠做业务赚钱的，比如卖马桶的卖一个赚 50 块钱，那一年想办法卖他 10 万个，年底算一算，500 万到手。比如卖煎饼的，卖一个煎饼赚 1 块钱，那一年想办法卖他 500 万个，年底算一算，500 万到手。 但是前几年上市潮告诉我们，还有一种发财的方法，就是上市。开一家公司，不管做什么吧，把 20% 的股票拿出来，找到人愿意出 100 万买，那么岂不就是等于每 1% 的股票价值就是 (100/20%)*1% = 5 万了？那么 5% 的股票就相当于值 25万。如果继续发展，继续抬升股价，那么可能以后这 1% 就值 100 万了，那算算，5% 就等于是 500 万啦。当然这些还需要等着上市，上市之后你的价值 500 万的股票一卖，有普通股民接盘，你也一样是赚了 500 万。 你看前面传统靠业务的企业赚钱，最后钱是谁的？当然是老板的，不过老板一开心，可能拿 100 万出来鼓励一下员工，那就大家都拿个奖金，这下大家都开心啦。 那么通过上市的方法呢，股票相对来说就多了，一般老板可能会占大部分，但是小兵手里也会给点，如果你得到了那 1%，那恭喜你，500 万到手。 这么看，好像去个公司拿股票更好啊，回头发财的时候，不必指望老板心情，只要手里有股票就可以。 实际呢？要想拿到那 500 万，可能需要经历下面的步骤： 老板愿意给你 1% 的股票。这么大比例股份的，一般需要多少是个核心人员啦，我记得哪看过，可能核心高管给个 5% 就不错了。注意这里说的是比例哦，一个公司可能会把公司设计成总共 1 万股，也可能设计成 100 万股，那同样拿 1000 股，差别可就大了去了。 那接下来需要有一个对的方向，找到愿意买那 20% 的人，好提升你手里股票的价值呀。一般投资机构为啥要买你们股票呢，他们想法和你的想法一样，都是希望最后上市的时候好大赚一笔，你看他的可是 20%，比你的 1% 多了 20 倍。但是根据什么判断呢，这就需要公司有一个增长点，一般都是用户量持续增加什么的，这个下面具体说。 一般上面那个叫 A 轮，离上市还早。需要继续保持增长速度，吸引新的投资人来投资，这个时候再卖股票可就不是 A 轮那个价格啦，会涨价。因为公司发展势头好啊，这次投资的人看好将来上市还是有的赚的，所以可以接受涨价。 这个时候可能会有一个选择，就是把你们手里的原始股票拆分一下，比如一拆二，然后再卖 10% 出去（相当于原来的 20%），这 10% 可以是增发，也可以是从你们自己手里回购，这样就有了兑现的机会。当然，这个需要人家新的投资人愿意，要不这不等于投资人花钱给大家发奖金么？ 这样如果你们公司发展一直不错，多轮融资之后，基本就成了某个方向的独角兽啦（这么多钱花出去了，如果市场占有率上不来，那没人继续买单啊，所以最后必须要是某个领域最厉害的），这个时候就可以上市了。 上市之后，手里股票一般有禁售期，可能是一年，过了之后如果公司发展还不错，股票没跌，那你就可以兑现你的 500 万了。 那么说说什么是增长点。实际上你回过头来看看，一个要上市的企业，和一个卖煎饼的，没什么区别。都是需要把自己业务搞到够大，然后赚钱。区别在于，卖煎饼的一开始就清楚自己可以赚多钱。而搞上市的，可以先不赚钱只花钱来圈场地，相当于是先把猪都圈到自己地里慢慢宰。因为投资人也不傻，如果市场里面你已经是最大了，那要么你去占别的市场，要不就是要看盈利情况啊，赚钱了股东每年分红才是正事。最后接盘的普通股民也不傻，看好不好看你的股票，最后总是需要有一个看的点，哪怕现在你能把牛逼吹到天上，但是后面连 1% 都实现不了，那未来估值也是个白瞎。那么多公司后面股价低迷不振就是这个原因。当然了，如果在大家都意识到这个问题的时候，你已经套现离场，那你就是赢家了。 基于上面的点，需要满足几个条件你才可以拿到你的 500 万。 你手里的股票够多。一来是初始的时候多，二来还需要老板不坑你，没有不停的增发稀释你手里股票。否则你干个10年最后股票价值 100 万，那平均下来还不如别人年终奖呢。 公司的业务持续壮大，一般牛逼公司动不动就是 300% 的增长，每年 4 倍，三年就 64 倍了。就按 100% 增长算，每年 2 倍三年是 8 倍。琢磨下你业务方向，可能的市场规模，和合伙人有没有这么牛逼。 公司还需要有盈利的点，如果一直只看到花钱看不到入账，那没人敢继续投资。没人投资还怎么做大。 你没有离职。如果从初创就加入，这个过程可能至少需要 10 年，当然也有牛逼的可能 5 年上市。 公司如果厚道，离职有时候也可以允许行权保留手里的股票。但是这个还得基于你愿意买，因为如果将来公司不能上市，买的就是废纸。 遇到问题，老板首先考虑需要保障的是投资人和自己的利益，其他人的，碰运气吧，毕竟得罪了投资人后面不好继续要钱了，而得罪了你的话，应该还是很轻松可以再忽悠一个的。</description></item><item><title>Add an Force Sync Button in Django Admin</title><link>https://wdicc.com/add-an-force-sync-button-in-django-admin/</link><pubDate>Thu, 12 Dec 2019 13:33:15 +0800</pubDate><guid>https://wdicc.com/add-an-force-sync-button-in-django-admin/</guid><description>我们的系统里面需要和外部的系统同步一些数据，为了保证数据正确处理，增加了一个队列。队列是通过一个 celery 里面的定时任务同步的。定时任务设置是 5 分钟一次，那有时候测试的时候或者出错的时候就可能会想要立刻执行下同步，好看看执行结果，要不很有可能等到下次执行的时候还是有问题，这就有点浪费时间了。 自然就想在 Django admin 后台增加一个按钮，点一下就执行一下同步功能。Django 提供了一个 admin.ModelAdmin.change_list_template 变量来让你自己定义 list 模版，我们就用这个实现了。 admin.py 的代码如下。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class TestAdmin(admin.ModelAdmin): change_list_template = &amp;#34;test/change_list.html&amp;#34; def get_urls(self): urls = super().get_urls() my_urls = [ url(r&amp;#39;^$&amp;#39;, self.force_sync), ] return my_urls + urls def force_sync(self, request): force_sync = request.GET.get(&amp;#39;force_sync&amp;#39;) if force_sync: logger.info(&amp;#39;Force sync start&amp;#39;) ret = manual_syn_task() logger.</description></item><item><title>ST_Buffer in Postgis</title><link>https://wdicc.com/st_buffer_in_postgis/</link><pubDate>Wed, 04 Dec 2019 10:33:20 +0800</pubDate><guid>https://wdicc.com/st_buffer_in_postgis/</guid><description>Postgis 一直没仔细用过，总是临到用时看看文档，这不又遇到问题了，折腾半天。 我们最近有一个需求是，需要把一些原有的多边形范围扩大 50 公里，然后和其他的图形比较看是否有包含关系。是否有包含这个不用看也知道，gis 肯定有现成的函数，那么问题就在于怎么扩大一个多边形的范围。 主要查到几个函数， ST_Expand 和 ST_Buffer。st_expand 可以从 x,y,z 方向扩展，显然不适合我这里的情况，我这不是正南正北的多边形。那就只有 st_buffer 了。 ST_Buffer ST_Buffer 的语法如下 1 2 3 4 5 6 7 geometry ST_Buffer(geometry g1, float radius_of_buffer, text buffer_style_parameters=&amp;#39;&amp;#39;); geometry ST_Buffer(geometry g1, float radius_of_buffer, integer num_seg_quarter_circle); geography ST_Buffer(geography g1, float radius_of_buffer, text buffer_style_parameters); geography ST_Buffer(geography g1, float radius_of_buffer, integer num_seg_quarter_circle); 第一个参数是 geometry 或者 geography 类型的。这又是什么？找到一篇参考文章，下面会详细一点说。 第二个参数是 radius_of_buffer，就是扩大的范围了，但是单位是啥？然后文档里面的解释是 Units of radius are measured in units of the spatial reference system ，这又是啥意思呢，就是取决于你的投影系统是什么。 Geometry 和 Geography 地理坐标系不像是 Mercator（墨卡托）坐标系，不是笛卡尔坐标（就是我们常见的横竖轴 xy 坐标那种）。地理坐标系表达的是一个点在球体上面的位置，通过他和子午线（经度）以及赤道（纬度）的角度来表示。 地球毕竟不是一个完美的球体，所以就算是地理坐标系，也有不同的大地测量系统（Geodetic datum）,这样同一个位置，不通的测量系统下，坐标会有一些差别。所以给一个 GPS 坐标点还需要指定对应的测量体系。我们常见的就是 WGS84 (EPSG：4326)。 地理坐标系只能通过地球仪这样的数据展示，不是二维的。大家也不可能都抱着地球仪跑，所以就有了投影映射到平面的需求。 常见的平面投影方式就是 Mercator，也就是 EPSG:3857。球体映射到平面肯定会有地方有失真啦，具体问题可以参考投影方式的说明吧，我们日常使用一般可以忽略这个问题。 Postgis 里面两种类型 geometry 和 geography。一般使用 geometry, 4326 存数据，使用 geography 计算距离。 那么上面的 radius_of_buffer 来说，对于 geometry 数据，是度数。对于 geography 数据，是我们常见的距离（米）。 使用 ST_Buffer 扩展多边形 我们数据库里面存的数据是 GeometryField，所以一种方法如下，把数据 cast 成 Geography 类型的做计算。 1 st_buffer(gis_data::Geography, 50000, &amp;#39;endcap=round join=mitre mitre_limit=2&amp;#39;) 另一种方法如下，使用 st_transform 转成 3857 再做计算。 1 st_buffer(st_transform(gis_data, 3857), 50000, &amp;#39;endcap=round join=mitre mitre_limit=2&amp;#39;) 计算完毕得到的是 Geography 数据，如果想要存回去，还需要转成 Geometry，通过 cast 或者 st_transform 都可以完成。 参考文章 https://www.</description></item><item><title>Upgrade RN From 0.57 to 0.61</title><link>https://wdicc.com/upgrade-rn-from-0.57to-0.61/</link><pubDate>Thu, 07 Nov 2019 12:21:57 +0800</pubDate><guid>https://wdicc.com/upgrade-rn-from-0.57to-0.61/</guid><description>好久没升级 app 使用的 RN 了，前几天看见已经是 0.61 了，我们用的还是 0.57，已经差了好几个版本了，有必要跟进一下了。 首先那个 react-native-git-upgrade 被抛弃了，提供了一个 web 的 diff 工具，自己给代码应用 diff 就好了。我的做法是，建一个分支，先把所有除了 android 目录之外的修改了，然后调试搞定 iOS 的编译。搞定之后再搞 android 的。 建议使用 yarn ios/android 这样的命令来运行看错误什么的，如果遇到问题，命令行会提示你一些操作，有的按照操作修改就行。 iOS iOS 这边主要是改进了模块的集成方法，官方支持了 cocoapods。最早的时候，增加模块的时候，如果有 native 代码，需要自己去添加到自己的工程里面。后面有了 react-native link 之后，一般只需要 link 一下就可以了。所以后面官方支持了自动 link 的功能，add 一个模块之后就会给你自动 link 了，不用你自己再操作了。再后面，大家广泛使用 cocoapods 之后，慢慢的一些 rn 模块就增加了自己的 .podspec 文件，这样就可以允许通过 cocoapods 引用这些依赖了，这样增加依赖还不用修改项目文件， Podfile 和 Podfile.lock 还可以增加到版本管理里面，也很方便。 现在到了 0.61 官方支持了 cocoapods，意思是你 add 一个模块之后，会自动给你通过 Podfile 引用到项目里面。怎么做到的呢？主要是通过 cocoapods 的 use_native_modules!</description></item><item><title>Doing Code Reviews</title><link>https://wdicc.com/doing-code-reviews/</link><pubDate>Tue, 29 Oct 2019 16:44:17 +0800</pubDate><guid>https://wdicc.com/doing-code-reviews/</guid><description>集中看了一波 code review 的帖子，记录一些笔记 How Do Code Reviews Work at Microsoft? 微软这个倒是没什么亮点，不过最后有一堆别等链接值得一看。 code review 包括测试结果 code review 包括用户界面，可以通过截图什么的提交，这样方便 review 包括静态检查结果 Code Reviews at Google are lightweight and fast Google 的方式 提交前运行静态检查工具 Tricorder 检查 所有提交都需要 review 代码是全部组员的，所以所有人都要为代码质量负责 代码可读性的 reviewer 必须要取得一个认证之后才能参与 review review 注重的是 owenership 和 readability，不看 reviewer 的职位年龄，如果总是需要年长的来 approve code，那会有瓶颈 取得认证有难度，但是比起职级要求来说简单多了 代码只有通过了经过认证的 readability 专家和对代码有 ownership 的人的审批才可以合并 想要取得认证，需要像 readability 高级专家组提交代码，他们会仔细检查代码质量，任何微小的错误和潜在的问题都不允许，比如锁进，多余的空格等。 Google 的 style guide code review 很轻快，小的1小时内，大的修改 5 小时内，具体怎么做到的，似乎有人写一篇论文。。 https://sback.</description></item><item><title>Some Interview Questions</title><link>https://wdicc.com/some-interview-questions/</link><pubDate>Thu, 17 Oct 2019 10:57:42 +0800</pubDate><guid>https://wdicc.com/some-interview-questions/</guid><description>Notes for some interview questions. OSI 7 layers Physical layer. Data link layer. Switches are working on this layer, so when we talk about mac address, node to node connection, it&amp;#39;s all happened here. Network layer. IP/ICMP protocol are for this layer. IP address, router, routing to other routers hanppend at this layer. Transport layer. TCP/UDP protocol are for this layer, it defines how packet data forward, and the packet speed, rate, etc.</description></item><item><title>Learning Python Coroutine</title><link>https://wdicc.com/learning-python-coroutine/</link><pubDate>Thu, 17 Oct 2019 10:49:40 +0800</pubDate><guid>https://wdicc.com/learning-python-coroutine/</guid><description>看了一个视频 OSB 2015 - How Do Python Coroutines Work?，从头开始讲 coroutine 是怎么抽象出来的，感觉好厉害。自己写了一点程序学习了一下。之前写的关于 coroutine 的帖子。 先准备一个 server.py ，可以接受客户端请求。要注意的是要使用 Threading ，或者 fork 的 server，要不服务端执行并不支持并发，需要处理完一个才能处理下一个，这样会发现虽然客户端那边请求是并发的，但是返回结果的时候是顺序的。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import socketserver from time import sleep HOST = &amp;#39;127.0.0.1&amp;#39; PORT = 2045 class MyTCPHandler(socketserver.BaseRequestHandler): def handle(self): data = self.request.recv(1024) sleep(1) self.request.sendall(&amp;#39;{} ok&amp;#39;.format(data.decode()).encode()) def run(): server = socketserver.ThreadingTCPServer((HOST, PORT), MyTCPHandler) server.</description></item><item><title>ASGI</title><link>https://wdicc.com/asgi/</link><pubDate>Tue, 15 Oct 2019 14:52:47 +0800</pubDate><guid>https://wdicc.com/asgi/</guid><description>Django 3.0 要支持 ASGI 了，全称 Asynchronous Server Gateway Interface，使用了 coroutines 异步。WSGI 是目前普遍使用的，把进来的请求标准化处理之后，交给 WSGI 程序，这个支持的是请求来了，处理完毕，返回结果这样的模型。对于像 websockt 这样的就不太友好了，websockt 实际是建立连接之后会持续发送请求和接收结果，所以有了 ASGI。 ASGI 不同的地方在于，他有一个 scope，表示一个连接，这个会一直存在直到用户断开连接。然后通过一个一个的 event 和应用交互，event 是个字典，必定包含一个 type 指明类型。ASGI 还支持了 coroutine。 这样对于 http 请求，一个请求就一个 scope， 所需要的数据基本就全了，除了 body 对应一个 event。对于 websockt 请求，一个 scope 会持续到直到用户断开，期间通过 event 发送详细消息。Application 不能和客户端在 scope 阶段交互，必须等进入 event loop 才可以，而且取决于协议规定，可能还需要等一些初始化的 event 之后才可以。 然后目前实现的 ASGI server 我看有 daphne，简单看了一下源码。 这个一般是命令行执行 daphne 这个命令，入口是在 setup.py 里面指定的 daphne.cli:CommandLineInterface.entrypoin ，这里面实例化了一个 cli 然后执行了 run。run 里面主要是处理命令行参数，找到我们指定的 application 然后 import 。 这里我们的用法是通过 get_channel_layer() 初始化了一个，这里面主要是通过配置文件里面的配置，把 backend 和 routing 初始化了一下。 1 2 3 4 5 6 asgi_layer = backend_class(**config) return ChannelLayerWrapper( channel_layer=asgi_layer, alias=name, routing=routing, ) cli.</description></item><item><title>New Way to Go Across the GFW</title><link>https://wdicc.com/new-way-to-go-across-the-gfw/</link><pubDate>Mon, 14 Oct 2019 10:57:29 +0800</pubDate><guid>https://wdicc.com/new-way-to-go-across-the-gfw/</guid><description>家里路由器用了一段时间的国内定制的梅林系统，还给这个系统做过一个插件使用 v2ray。后面试过换个软路由，使用的 openwrt，然后找到一个新的项目 ss-tproxy ，用起来也还可以，不过是基于 shell 脚本的，以及基于自己的理解，感觉他添加的 iptables 规则有点多，我自己也还想要做到观看 Netflix 使用不同的代理（因为自己的代理 ip 被 Netflix 识别了，没法看，只好找一家机场买了一个服务看，当然又不想所有流量都走机场），所以自己折腾了一个，实现原理就是前面那篇文章。 一开始是基于 v2ray 做的，尽量傻瓜化，只需要提供可用的 outbound 就可以，会自己产生用到的配置文件。实际运行起来发现内存用量有点大，用到 swap 之后路由器变慢，挺讨厌的。然后就琢磨使用 ss 加混淆吧，用了一下速度还不错，但是很快就发现会被断流。没办法，只能还是用回 v2ray，本来想试试看给路由器接一个树莓派吧，里面跑 v2ray，这样也不会影响路由器，但是自己的树莓派不知道哪里去了。。。这也是我那个程序三个运行模式的来源。 后面十一期间那个机场居然公开公布用户的信息，让我觉得机场还是不靠谱，想试试看之前看到的通过 SNI 方式解决看 Netflix 的方案，找了一家试了一下，也还可以。这样我就不用再需要在路由器上面分流了，只需要在 vps 上面配置一下 dnsmasq 就可以了。这样更方便。 这样路由器只需要能解决 gfwlist 里面的域名可以正常访问就可以了。然后看到很多地方提到 v2ray 的 sniffing 功能。之前其实也看到过，忽略掉了。这个功能实际上可以做到解决 dns 污染问题，而不用你还得想办法去劫持系统的 dns。这个可以做到，把用户请求里面的域名交给代理去解析，忽略已有的解析结果，这样不管污染没污染都不会有什么影响了，因为完全不会用国内的解析结果。 然后再配合一个 gfwlist 的域名列表，设置合适的路由，就都 ok 了。 我这有一个示例的 v2ray 配置文件，只需要配置好里面的 outbound 就好了，注意要保留那个 tag 名字，或者你也可以自己修改，和下面的 routing 里面的 tag 对应就可以。那个 ip 列表是解决 telegram 的使用的。还需要配合一个 gfwlist sites 列表，可以直接下载这个。 v2ray 在路由器跑有时候内存问题什么的，看着不太稳定，所以我还搭了一个检查程序，如果发现奔溃了自动重启一下。里面需要改一下 v2ray 的路径 /opt/svgfw/bin/v2ray -config /opt/gfw/config.</description></item><item><title>Drive in the US</title><link>https://wdicc.com/drive-in-the-us/</link><pubDate>Tue, 08 Oct 2019 12:47:56 +0800</pubDate><guid>https://wdicc.com/drive-in-the-us/</guid><description>十一前去美国自驾了一圈，其实算是第二次美国自驾了。第一次是五年前。第一次去的时候有一个当地生活了比较久的朋友陪着，包括她我们三个司机开了几天，所以实际感受没有这次深。这次是我和我老婆两个司机，完全自己规划自己开，一路全靠 Google Map 了。人总是很健忘，开完感觉有必要总结一下，以备今后查看。 驾照 美国认可国际驾照，但是中国似乎没有加入那个发国际驾照的组织，这样有中国驾照无法申请国际驾照。据说有变通的方法是去香港申请一个驾照，然后再申请国际驾照，但是估计也比较麻烦。好在美国大部分地区认可中国驾照。需要注意的是，各个州的规定不一样，有的州就不认可，比如德州，在这些州用中国驾照开车等于无照驾驶。 可以看到各个地方都会宣传说可以给你弄国际驾照，那个实际是国内驾照按照国际驾照的样子的翻译件。里面只是把国内驾照的信息按照国际驾照的样子翻译了过去，因为国内驾照上面没有英文，老外看不懂，准备这样的一个翻译件也很有用。这个翻译件似乎成本不高也不贵，很多地方买个什么就会送。 我们当时规划的是开 66 号公路，其中会途经德州，如果绕开会比较麻烦，走很多小路。后面决定就那么开过去，在德州的一个城市边上还住了一晚上，不过没去市区里面溜达，没遇到问题。反正一般警察也不会找你，除非遇到什么事故什么的，但是谁知道呢，一旦产生问题钱可能是小事，会耽误你的很多行程的安排。 驾驶习惯 美国那边也是右舵，租的车大部分也应该是自动档，开起来一般没啥问题。仪表盘可能会显示 MPH 而不是 KPH，这样也好，反正各种限速牌子也都是 MPH。档把可能会在方向盘上面，手刹可能在脚下，大概可能就这么几个差异。 Mile 和 KM 的转换大概是 1.6 倍，等于 1mph = 1.6kph。高速公路一般限速 55 - 75 都有，75 就差不多是 120 了。 开车的时候，右边是慢速车道，左边是超车道，一般是规定左边只有超车的时候才能使用，超车完毕应该并回右边车道。并线记得打灯。 有些地方的路是单车道，这个时候如果需要超车需要借用对向车道。注意看路中间的线，如果是实线是不能超车的，只有虚线可以，其实和国内一样，实线不能压。 有些地方还要求白天的时候也开车灯，这个一般是视线不好的地区，比如山路起伏比较多，开了车灯可以更好的看见对向车。 车在路上一般都满速开的，很少看见慢车。一般是限速 65 的道路，大货会开 60 - 65，小车想保持 65 就需要超过大货。不过一般小车都超速，开到 70 - 80 这样。超速了路边可能会有警车埋伏然后追车。 超速这个问题很迷，我在那边开发现基本都在超速。而且那边的车不喜欢刹车（可能也是不需要），转弯什么的都全速过，很吓人。我感觉还是安全一点开右边车道然后多踩踩刹车吧。 出口一般都在最右侧车道，有时候会出现最右侧直接对接一个出口，会发现不想出去的时候只能往左并一个车道，一般这种车道都写着 Exit Only。对于单向两车道，一般不会遇到这样的车道，都可以出去也可以继续往前开。多于两车道的可能会有这个情况，如果不想尴尬，可以开右边数第二个那个车道，比较稳妥一点。 有时候也会有那种分叉道出来，就是看着两边都是大路，分别都是 2 车道，这个时候就需要你提前准备好是打算走哪边。要不到了时候需要连续并几条线很危险，因为车都很快，如果真的弄错了就继续往前开吧，看看导航怎么提示。 加油 加油站都是自助，这个第一次会手足无措。一般加油站都有很多的那个油枪，进入加油站之后找一个对着自己油箱加油口方向的就可以。一般你在这里停多久都没人管你的，所以你大可以慢慢搞。我看油站还都提供一个小刷子，开高速不是容易玻璃上面积攒一些虫子尸体什么的么，用这个可以方便的清洗掉。免费的。 加油具体操作其实也挺简单，一般是两种方式： 使用信用卡付款：那么直接先刷卡，然后会提示你收起卡，之后会提示你拿起油枪后选择一下油品，然后就可以按把手上面的那个机关加油了。 使用现金付款：去柜台，和对方说你是几号位置，然后充多少钱进去。对方收钱之后你就可以去加油了，这个时候会发现油柜显示屏上面会显示你充的钱（有的可能也不显示），直接拿油枪选油品就可以加油了。如果最后没用完钱，可以再去柜台找他们退钱。 信用卡消费我遇到一个问题是，有一次一个加油站刷卡之后一次扣了我 $151，后来问他们说是会给退回的。那边刷卡账单很快，退款的账单就非常慢了，这个只能自己多看看，不想这样有纠纷建议可以每次都使用现金。另外有的加油站刷卡还会比现金贵 10 美分。 油品反正是从 87 开始，很多种，租的车也就 87 就算了。不同油站价格差异可能会比较大，我们在芝加哥加油 $2.</description></item><item><title>Notes for CPython Internals</title><link>https://wdicc.com/notes-for-cpython-internals/</link><pubDate>Thu, 05 Sep 2019 12:43:42 +0800</pubDate><guid>https://wdicc.com/notes-for-cpython-internals/</guid><description>视频地址这里。 Python 源码 Include/opcode.h 里面定义了所有 opcode。 Modules 里面是一些 c 实现的模块， Lib 里面是用 python 实现的模块。 Objects 里面是部分 python 对象对应的 c 实现。 Python 目录里面是 python core， Python/ceval.c 里面定义了 python interpreter 主要的循环，找那个 for(;;) 就可以，这个循环里面有一个巨长的 switch (opcode) 。 Opcode 和 interpreter 循环 test.py 1 2 3 x = 1 y = 2 print(x + y) 使用内置的 compile(source, filename, &amp;#39;exec&amp;#39;) 函数可以把代码编译成 code object , code object 有一个 co_code 属性，里面包含了代码的 bytecode。 1 2 3 4 5 6 7 8 9 &amp;gt;&amp;gt; c = compile(open(&amp;#39;test.</description></item><item><title>Book Review of Soft Skills</title><link>https://wdicc.com/book-review-of-soft-skills/</link><pubDate>Wed, 28 Aug 2019 17:32:36 +0800</pubDate><guid>https://wdicc.com/book-review-of-soft-skills/</guid><description> 改变自己对自己的看法 你所能犯的最大错误就是相信自己是在为别人工作。这样一来你对工作的安全感已然尽失。职业发展的驱动力一定是来自个体本身。记住：工作是属于公司的，而职业生涯却是属于你自己的。 把雇主当作是你的软件开发企业的一个客户吧。当然，你可能只有这么一个客户，你所有的收入都是从这一个客户处得来的，但是这种诠释雇用关系的方式可以将你从仰人鼻息的弱势地位转换成为自我治理和自我引导的主动地位。（事实上，许多真正的公司也就只有一个大客户，这个客户给它带来了大部分的收入。） 企业需要持续不断地改进和完善自己的产品。你也应该这么做。 关于职业的部分，作者主要的论点是就是这个。就是把你自己当作一个公司来思考问题，你去一个公司去工作不过是和这个公司合作而已，这样你就不局限于思考自己能做什么呢了，毕竟一个公司能做什么的想象力就大多了。 人们常常容易犯的一项错误就是，轻率地否决同事的想法，以便于可以提出自己的想法 如果你想激励他人做出最好的表现，或者希望达到改变的目的，你必须学会管住自己的舌头，只说些鼓励的话。 关于和其他人打交道需要注意的问题。 专业化的规则是：专业化程度越深，潜在的机会就越少，但获得这些机会的可能性越大。 专业知识往深了学习会遇到这个问题。往广了学会导致深度不够，但是机会增多很多，不过竞争肯定也多。 中等规模的公司往往要比大公司还稳定 在任何公司里能让你脱颖而出的最重要法宝就是承担更多的责任。 在任何组织中，总是有很多人会告诉你为什么这个想法行不通，为什么那个问题太难。这样的人不胜枚举。千万不要成为他们中的一员。相反，你要成为那个永远能为各种问题找到解决方案的人，要成为勇于执行这些解决方案以获得成果的人。 一位专业人士需要知道在什么时候说“不”，即使是面对自己的老板。 许多软件开发人员犯的一个巨大错误就是，当无法达到标准时，他们不是完善自己、迎接挑战，而是降低标准。 这个非常认同，勇于承担责任，并且确实可以承担责任的人，一般公司都喜欢。 做提出问题的人很难得，但是如果远远不如解决问题的人，永远都尝试去做解决问题的人。 做专业人士，不要轻易降低自己的标准，勇于挑战，这样才能快速提升。 同时也要现实一些。仔细想想自己还能维持多久，自己能做些什么来维持更久。你要制订一个计划：什么时候你就得认怂，重新做回雇员。 为自己当老板做好准备 获得客户的最佳方式是通过你已经认识的人。熟悉你的人更容易信任你，特别是在启动阶段。 你的目标应该是让自己达到这样一个点：你为这份副业分配的时间已经饱和，无法再接受其他工作，不得不回绝掉一些人。如果你在做兼职工作的时候做不到这一点，那你就不要想着去做全职了。 成为了自由职业者之后，你的时薪水平应该是作为全职雇员时的两倍 如果你的营销策略是基于自己的服务可以为客户节省大笔开支或者提高他们的业务，你就可以根据自己的服务为客户带来的价值来定价。 价值来自于为对方做了什么，而不是做了什么。 不断给你的收费加码，直到你听到“不行”为止。 这段是如何开始准备自己给自己干，以及如何给自己定价。 创业 在为产品找到客户之前就构建好产品。否则你只是冒险为一个不存在的问题创造了一个解决方案 没有要解决的问题的产品毫无意义，毫无意义的产品自然也就不会有用户，也就意味着你不会赚到钱。 许多创业公司的创始人发现，把股权出让后给不思进取的合伙人后，自己就面临一个大烂摊子，后者不仅对公司毫无贡献，还榨取公司的宝贵资产。 创业之前需要考虑好的问题。只有真的有实际价值的产品，才会有人给你买单。 在你的电子邮件签名的底部以及所有的在线个人主页中添加你的博客链接 当你营销自己的时候，如果你所做的一切都只是为了自己的利益而不给别人带来真正的价值，那么即使你所做的都正确无误，那也无济于事。你可以写博客、在社交媒体上分享自己的内容、在大会发言、著书立说，尽你所能来推广自己，但是，如果你表达的和你传递的信息不能帮到其他人，那么每个人都将会无视你。 人们最关心的还是自己。没人想听到你的成功故事，也不想知道为什么他们要帮你获得成功，但是他们肯定想听到你会怎样帮他们获得成功。所以，要想让自我营销的所有努力奏效，基本的方法就是帮助他人获得成功。 Zig Ziglar说得好：“如果你能帮助足够多的人们得到他们想要的东西，你就会得到自己想要的东西。”这是一个基本的策略，你应该将其用于自我营销。它比其他任何方法都更有效。 你的主要目标：为他人增加价值不要努力成为一个成功的人，而要努力成为一个有价值的人。 ——阿尔伯特·爱因斯坦 想给人们想要的东西，要先知道他们想要什么。但是这并非易事，因为如果你问他们，他们可能会撒谎。他们并非故意撒谎，而是他们也只有一个模糊的概念，并不确切地知道自己想要什么。就像新娘在找心目中的完美婚纱时，只有切实看到了才会知道“这就是我想要的”。 想要弄明白他们的真实想法，你得全凭自己。 学会以及要能不要脸皮的自我营销。以及你的东西需要真的是会给客户带来价值，至于什么是有价值，可能客户自己不知道，你也不知道，这些需要你去把握。总之一定要让自己做的事情对客户真的有价值，否则必定不能长久。 生产力 定额工作法的规则 挑选一项重复性任务。 明确有效时限，在此期间该任务被重复执行。 明确在给定的有效时限内该任务应该完成的次数的定额。 给自己承诺：一定要达成定额。 调整。调高或者调低定额，但是不能在有效时间段之内调整。 现在我用批量处理的方式处理邮件。每天我会检查几次自己的电子邮件，并回复紧急邮件。但总的来说，我会在一天中找个单独的时间集中处理所有的电子邮件。我会一次性浏览我的整个收件箱，并处理所有邮件。因为不再被其他任务打扰，我可以进入了“电子邮件模式”，在这种模式下我处理邮件的速度比一直打开收件箱的时候快很多，所以我的效率高很多。 如果能咬紧牙关坚持到底，如果能穿越那堵墙战胜自己，最终你会发现，简单地无视它的存在，你的倦怠感已经不治而愈。 经历痛苦就是克服倦怠的秘诀。你以后还会撞到更多的墙，但每穿越它一次，你将会体验到全新的动力、充沛的活力。另外，你的竞争者的数量会越来越少。 生产力的真正秘诀在于：长期坚持做一些小事。 个能够帮助你克服拖延的提高生产力的窍门：分解任务。 最可怕的效率杀手之一——无所作为 我们经常试图耗费300%的努力寻找95分的解决方案，而不是满足于找到90分的解决方案 这个是定额工作法，以及番茄工作法，我理解主要的目的是为了能让你持之以恒以及可以更加专注的去做一些事情。 一个大的任务或者一个长期的任务开始的时候总是会很痛苦，因为觉得难，坚持不下来什么的。通过设置定额，或者拆分成番茄钟，可以让这个事情变小，把大目标先改成完成这个小目标，这样会比较容易开始，以及比较容易坚持。 一旦开始之后，如果发现这样的小目标也无法坚持，那可以试着把这个任务继续拆小，直到自己可以承受。这样很多困难，持续时间长的任务就可以持续下去了。即使做再少，也比无所作为强是不是？ 另外，把时间分成番茄钟小段，还可以让你更加专注，这样可以更加方便的安排事情，比如每四个番茄钟看一下邮件，每 5 个番茄钟奖励自己看看社交媒体放松一下什么的。 目标 当你的“被动收入”达到每月所需的生活开销的时候，你就可以正式退休了。所谓被动收入，就是不用工作就能获得的收入。你必须确保被动收入会随着通货膨胀而增加 这个就是作者在 20 岁左右的时候定的目标。作者通过自己的努力，靠收房租，收稿费等在 30 多岁的时候达到了这个目标。</description></item><item><title>Python Coroutine</title><link>https://wdicc.com/python-coroutine/</link><pubDate>Tue, 27 Aug 2019 10:49:51 +0800</pubDate><guid>https://wdicc.com/python-coroutine/</guid><description>协程 coroutine 不知道是从什么时候开始的，感觉我第一次看到是 lua 里面支持 yield 。后面看到就是 javascript 里面的 Promise，async 和 await。 以前写 Javascript 的时候容易会遇到 callback hell，似乎 Promise 就是出来解决这个问题的，让你可以用同步的方式写异步程序。例如你有三个异步请求可以同时发出去，而后面的结果又需要这三个的结果都回来才能继续，那就可以用类似下面的伪代码，整体执行时间是最长的那个。 1 2 3 res1 = await test1 res2 = await test2 console.log(res1, res2) Python 里面似乎也类似。我目前理解主要就是让程序可以「同步」执行，但是又避免了需要维护锁的问题，没有锁就不会有死锁了吧。。。 解释下同步，主要是针对对于 cpu 资源的占用。对于计算型的程序，实际上每时每刻都在利用 cpu 做计算，这样就算把计算拆分成了多个计算程序，让他们同时运行，那同一时刻还是只有一个程序在利用 cpu 资源执行，这样并行实际并不能提升效率。所以对于纯计算型任务，可以通过多进程利用多个 cpu。 但是实际我们的程序执行的时候，并不全是 cpu 计算，有时候会需要等网络 io，文件 io 等，做这些事情的时候实际上 cpu 是空闲的。协程就是让这些程序在等待的时候，把控制权交出来，让其他程序运行。那个 yield 关键字就是做这个事情的， yield 很像 return ，遇到的时候就会返回，暂停程序的执行，等到适当的时候又可以从暂停的地方继续执行。 以前是使用 @asyncio.coroutine 和 yield from 来创建协程，似乎 3.</description></item><item><title>Book Review of Effective Python: 59 Specific Ways to Write Better Python</title><link>https://wdicc.com/book-review-of-effective-python/</link><pubDate>Mon, 26 Aug 2019 09:53:26 +0800</pubDate><guid>https://wdicc.com/book-review-of-effective-python/</guid><description>书名是《Effective Python：编写高质量 Python 代码的 59 个方法》这本书买了大概 2 年，一直没看完，前几天找了一些时间看完了。 这书是针对中级 Python 程序员的，里面没有对于语法什么的讲解，也没有对 c 代码实现的讲解，针对中级程序员。 用 Python 方式来思考 Python 3 里面包含两种表示字符串的类型：bytes 和 str。前者是二进制形式，后者是 Unicode 编码（比如使用 utf8）之后的形式。想要把 bytes 表示为 str 形式，需要使用 decode ，反之是 encode 。 切割列表的时候，start 和 end 可以越界，这样可以用来限制列表最大长度。 a=[0,1,2]; a[:10] 可以限制最大是 10 个。 可以使用列表推导式 [x*2 for x in a] 类似这样的形式，代替 map 和 filter 。 字典推导 {k: v for k, v in a.</description></item><item><title>Get Wool From Dogs</title><link>https://wdicc.com/get-wool-from-dogs/</link><pubDate>Tue, 20 Aug 2019 10:04:56 +0800</pubDate><guid>https://wdicc.com/get-wool-from-dogs/</guid><description> 不知道羊毛出在狗身上怎么翻译的好，暂时先说成 get wool from dogs 了。今天的内容可能会有点文不对题。 也不知道是什么人第一个发明的这个事情，但是不少人通过这个确实发达了一波。 互联网大量内容是免费的，这简直就是公理了。出来一个收费的服务大家会说傻子才付钱。我之前去一个外包公司他们用 phpldap 搭了一个服务，然后人家后台有一个广告说让大家捐款支持下，当然这个不是强制的。那个搭建服务器的台湾人说不会给捐款的，而他们实际是使用这个开源免费的工具来代替原来的一个收费服务的。 后来时间长了慢慢大家明白了，原来不付钱是有代价的，会失去自己的隐私和注意力。商家为了赚钱页面上面放满了广告，甚至有的广告你都不知道他是广告。百度被人骂不就是偷偷的把广告推给你么，使用百度搜索是免费的。 第一波共享单车出来的时候，感觉这事情很不可思议，单车那么容易丢失和损坏，骑一次才 5 毛一块的，损失一辆就几百，在这个车不能骑或者丢失前似乎不太可能把这个成本赚回来，更别说还有其他其他开发运营成本。后来才明白，人家看上的是你的押金。大量的押金存放到他们那里，这些都是灰色的地带，OFO 不是挪用押金后面被挤兑导致很难过么。 共享单车搞了这么一波之后，聪明人搞起来了 p2p，你想赚人家高额利息，人家实际看上的是你的本金。发财也轮不到你。 淘宝一开始开店是免费的，靠这个把 ebay 搞死了，要知道 ebay 可比淘宝早，ebay 的模式是从交易里面抽成或者收服务费，而淘宝完全免费。那淘宝也不能就这么一直不赚钱啊，利用用户的注意力靠广告赚商家的钱，有线电视你每个月交了钱还需要看广告呢，别说淘宝都不用你交钱。 现在呢，淘宝把其他网店平台干死之后，淘宝推他的天猫商城了，小店主很难赚钱了已经，再也不是一开始的样子了。天猫上面开店是需要交几千上万的保证金的。 京东上面东西方便吧，上午下单了晚上可能就到了，几十快钱就包邮。基于巨大的采购量，一方面可以压低进货成本，另一方面呢加上他们自己的快递包邮网络，成本低送货上门，甚至比楼下超市都方便啊。现在京东涨包邮起价了，你习惯之后是不是还是在京东买？不得不这样啊，因为楼下的超市已经死了。一个快递员上午送一趟下午送一趟，可能有几千个包裹？如果这里面每个快递费 6 圆，怎么样是不是很赚钱？ OFO 挪用押金之后，现在共享单车似乎都不收押金了，那怎么活下去？这不是活雷锋了么。一方面涨价，原来摩拜 1 小时 5 毛，现在 15 分钟 1 块。涨了 8 倍？别慌还有呢，如果车没有停在他们划定的区域，还有一个调度费，5 - 10 圆，是不是挺有意思的。 商业公司永远都是要赚钱的，如果现在还有公司出来说不以赚钱为目的，那最好别用。等你有了依赖估计就是他们的羔羊了。如果一个服务你享用的挺好，那根据自己能力和需要付费支持让他们可以持续运行是很好的一个事情。 当然，大家付费意愿起来之后，现在又有一波人还是觉得不够，你看那么多订阅制的软件。不过怎么说呢，反正人家也确实可能还是需要花精力做后续的一些事情的，愿不愿意付费还是看你了。</description></item><item><title>Emacs as Python IDE Again</title><link>https://wdicc.com/emacs-as-python-ide-again/</link><pubDate>Tue, 13 Aug 2019 14:56:02 +0800</pubDate><guid>https://wdicc.com/emacs-as-python-ide-again/</guid><description>上一篇里面说了使用 emacs 编辑 python 文件的方式，已经过去 2 年了，时代变了。更新一下。 随着 vscode 横空出世，带来了 LSP，这个东西是所有编辑器都可以受益的，有人开发了 lsp-mode，目前我感觉 lsp 比 jedi 好用多了。 elpy 目前还不支持 lsp。所以放弃了 elpy 了。 主要配置如下。使用了 lsp-python-ms 和 lsp-mode, pipenv 。我原来用 pyenv + virtualvenv，pipenv 是把两个整合的东西。pipenv 还支持 lock，以后估计会流行吧。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 (use-package lsp-python-ms :ensure t :demand nil :config ;;(setq lsp-python-ms-extra-paths &amp;#34;&amp;#34;) (setq lsp-python-ms-executable (string-trim (shell-command-to-string &amp;#34;find ~/.</description></item><item><title>Run Command Through Python</title><link>https://wdicc.com/run-command-through-python/</link><pubDate>Tue, 13 Aug 2019 14:53:34 +0800</pubDate><guid>https://wdicc.com/run-command-through-python/</guid><description>通过 python 执行命令有很多方法。 最简单的 os.system(command) , command 是要执行的命令，一个包括命令和参数的字符串。产生的输出会直接打印到 stdout 。返回值是命令执行的退出值。 然后就是 os.spawn* ，这个我感觉有点丧心病狂了。 os.spawnl(mode, path, …) os.spawnle(mode, path, …, env) os.spawnlp(mode, file, …) os.spawnlpe(mode, file, …, env) os.spawnv(mode, path, args) os.spawnve(mode, path, args, env) os.spawnvp(mode, file, args) os.spawnvpe(mode, file, args, env) 这些主要是命令输入的方式，和环境变量的控制不一样， l 是类似 os.</description></item><item><title>An Interesting Python Function</title><link>https://wdicc.com/an-interesting-python-function/</link><pubDate>Wed, 07 Aug 2019 16:53:09 +0800</pubDate><guid>https://wdicc.com/an-interesting-python-function/</guid><description> 这里看到的，感觉挺有意思的，记录一下。题目来自这里。 如何让下面这个函数返回 True ？ 1 2 3 4 5 def check(x): if x+1 is 1+x: return False if x+2 is not 2+x: return True 解法1: 自定义类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def check(x): if x+1 is 1+x: return False if x+2 is not 2+x: return False return True class Test(int): def __add__(self, v): if v == 1: return 0 else: return v print(check(Test())) # output: True 如果一个对象是在 + 的左侧，那会调用 __add__ ，如果在右侧，会调用 __radd__ 。上面的 Test 类继承自 int，重写了其中的 __add__ 方法，但是保留了 __radd__ ，所以上面的例子里面， Test()+1 会返回 0， 1+test() 会返回 1。 Test()+2 会返回 2， 2+Test() 也会返回 2。 解法2:特殊的整数 1 2 3 4 5 6 7 8 9 def check(x): if x+1 is 1+x: return False if x+2 is not 2+x: return False return True print(check(-7)) # output: True 只有 -7 可以。python 里面对于 -5 - 256 这些整数会提前生成，这些都是单例。所以 -7+1 is 1-7 是 False ，以及 -7+2 is not 2-7 是 False ，两个 if 条件都不成立。</description></item><item><title>How to Open an Company in China</title><link>https://wdicc.com/how-to-open-an-company-in-china/</link><pubDate>Wed, 07 Aug 2019 10:44:55 +0800</pubDate><guid>https://wdicc.com/how-to-open-an-company-in-china/</guid><description> 我记录一下国内开公司需要做的事情吧，有一些事情我没有参与，说的不一定准确，供参考。 公司结构，类型和名称 第一步需要先确定公司的性质。有限责任公司，无限责任公司，合伙公司这些，需要先了解一下。 国内目前不允许同股不同权，即所谓的 AB 股模式。那么为了控制公司的投票权，我们模仿了 VIE 模式，先创立一个合伙人企业 A，然后通过这个企业，控制实际做事情的企业 B。后续的融资也会都进入 B 那个企业，始终保证 A 是大股东。 公司名称有时候会出现和别的公司冲突的情况，似乎类型不一样可能也可以，反正这里面很多无法量化的东西，似乎可能会有一些腐败漏洞，这个将来也会涉及到你申请商标的事情，冲突了也没法申请下来。 公司注册和办公地点 确定公司模式之后需要确定公司注册地点。目前有一些地区对互联网创新什么的会有一些税收的减免政策，可以了解一下然后选一个合适的地方。营业执照上面是需要有一个办公地点的，所以也需要在当地有办公室。似乎有的地方可以提供注册地址给你用，你也不用真的去办公。 要注意的是，将来各种工商税收什么的也会需要到当地去处理，所以也需要适当考虑距离的问题。当然，这些可能也可以委托一个当地的处理这些事情的公司帮你处理。比如一些代记账什么的公司。 申请营业执照，开对公账户 上面的确定之后，这些事情估计就比较简单了，按照流程去办理一下就可以了。对于合伙人企业，似乎还需要所有人签订一些东西到工商那边备案，如果合伙人比较多，集齐签名可能会是个麻烦的事情。 另外，只有合伙人公司先开了之后，才能申请实际做事情的公司的执照的。申请执照感觉可能会需要 1 个月左右吧，两个都下来需要一些时间。 有了营业执照，很多以公司名义做的事情才可以做。比如以公司名义和别的公司签协议，转账，或者申请购买一些东西，这个下不来，后面很多事情都麻烦。 真实办公地点，办公环境 真实的办公地点和营业执照的关系不大，这里主要需要解决的问题是，公司员工的社保缴纳问题。一般你是无法在非注册地做这个事情的，可以在实际办公地注册一个分公司做这个事情。但是目前也有很多代交社保的公司，一般是签订一个类似派遣协议什么的，然后来做这个事情。这个是灰色地带。 你可以租一个写字楼的办公室，或者民居来做实际办公的地方，区别可能是价钱吧。不止房租，还会有网络，水电等的费用，商用和民用价格本身也不同。 目前也有一些联合办公的地方，他们会把比如一层写字楼处理好，然后出租里面的工位，同时还可以给你网络水电，会议室，打印机等等，基本上是比较省事的方式。 我们是从民居开始搞的，需要申请网络，买打印机（有一体机，包括传真，复印，扫描等），饮水机，投影仪（或者买一个大电视也可以），冰箱，微波炉（方便带饭）等等吧，还需要定期找人来打扫一下。 此外可能还会需要弄一些安全的设备，防止小偷，毕竟电脑什么的加一起也不少钱。我买了一些小米的东西，比如开门警报，摄像头什么的。 非技术人员基本就可以了。如果是技术人员办公的话，还会需要准备 gitlab 等这些东西，你可以使用 SASS 服务，现在也挺多的，可能会有一些费用，也可以自己搭建自己维护。如果自己搭建，那要不是需要现有服务器，要不就是自己买一个放在办公室里面。我自己买了一个 intel 的 NUC 放在办公室，充当拨号网关，和开发服务器，以及 gitlab 等各种公司内部服务的地方。 工商税务人力 需要准备劳动合同。制定公司的规章制度，报销方式，各种假期补助等等各种琐事。 还需要有会计和出纳管理公司的帐务，这个有一些专业的代理公司可以帮你做。 招聘 各招聘网站以公司名义招聘的话，都需要公司营业执照。有了营业执照之后就可以去注册了。我印像比较好的是拉钩，好几个人都是那里招聘的。 域名 不可避免的，一个公司必定会需要弄一个自己的域名。还可能会需要搞你自己产品使用的域名，为了保护自己，对于读音拼写相近的可能也需要申请一下，这个费用不贵。 准备服务器 做 app 网站什么的，总是需要你有服务器，以前是自己买服务器托管到机房，现在可以直接使用云服务，比如阿里云青云这些，我们用的是 AWS。这些开户都需要你提供营业执照。费用和计费方法各不同，可以多看看比较下。推荐的做法是多机房多 ISP 容灾。比如可以 aws 和 aliyun 都有服务器，这样一边挂了也还可以提供服务。当然这里会涉及到一些技术问题。 备案 想把域名和服务器对应起来，必须要先备案域名，否则提供给你服务器的地方可能根本就不会让你的服务上线。这个备案的事情比较麻烦，一般服务器提供商会提供协助你备案域名。 这里其实就有一个问题，我还不知道有没有办法把一个域名指向两个不同的服务商。 域名还需要到公安备案，这个取决于你提供的服务，如果有讨论区什么的，公安可能还会需要你过去当面聊聊，公安备案是需要你自己去提交的。 备案之后自己的网帐就可以让别人访问到了。后面说 app 的事情。 申请苹果开发帐号 如果你是做 app 的，那申请苹果帐号是必须的。公司名义申请的话，需要先搞一个 DDUS-Number，这个可以找一些公司申请。申请下来之后直接在苹果后台申请帐号就可以了。 Android 开发帐号 如果是做国内服务，那 Android 并没有一个统一的地方，各手机厂商都有自己的 appstore，需要你单独去申请。申请帐号一般只需要营业执照就可以，应用上架就麻烦了，需要有一个版权证明。这个网上也有申请的，收费和时间有关系，最慢的一个半月下来大概几百，快的可能几千，看你需求。 还好 Android 可以直接安装 apk，所以早期你也可以先提供一个直接下载 apk 的地方让用户安装，这样可以节约一些软著申请费用。</description></item><item><title>React Native Versions</title><link>https://wdicc.com/react-native-versions/</link><pubDate>Fri, 26 Jul 2019 15:45:27 +0800</pubDate><guid>https://wdicc.com/react-native-versions/</guid><description>RN 里面有很多个个版本号 package.json 里面定义的 version 。 android/app/build.gradle 里面定义的 versionName 和 versionCode 。 ios/YOURAPP/Info.plist 里面定义的 CFBundleShortVersionString 和 CFBundleVersion 。 如果你使用 code-push 的话，还有一个 code-push 自己的版本号，叫做 Label 一般是 v 开头的。 这几个版本号都有用，需要有规划的使用。我的经验如下。 统一 version, versionName, CFBundleShortVersionString ，使用类似 x.y.z 这样的格式，升级的时候都一起升级，每次发布这个版本前都会在 git 打一个 tag。这个是用来表示用户看到的 native 的版本。这样你的 app 在 ios 和 android 的市场里面，同一个版本的，一般就是同一套代码打包的， versionCode 和 CFBundleVersion 各自表示各平台软件的真实版本，可能会出现同一个 1 里面的版本的情况下，这个有多个的情况。一般的应用市场发布的时候，也是认这个版本号的。这个编号只增不减，原则上每次打包都增加，不管代码有无变更。 如果使用了 code-push，那还 1 里面的版本号还需要遵守一个原则： 如果 native 代码有变更，那需要增加 x.</description></item><item><title>Tools to Manage Your React Native Projects</title><link>https://wdicc.com/tools-to-manage-your-react-native-projects/</link><pubDate>Fri, 26 Jul 2019 14:55:38 +0800</pubDate><guid>https://wdicc.com/tools-to-manage-your-react-native-projects/</guid><description>RN 项目大部分人都知道是基于 Javascript 的，懂 js 就可以写了。但实际上并没那么简单。大概总结下这里面的问题，主要从管理项目的角度来说。 NPM JS 部分肯定是不能避免的，js 依赖重这个估计都知道， node_modules 被很多人吐槽了。package.json 里面写的依赖，一般都不会写死版本（这个我估计很多人都没有注意到），例如下面这个片段 1 2 3 4 5 6 7 { &amp;#34;crypto-js&amp;#34;: &amp;#34;^3.1.9-1&amp;#34;, &amp;#34;geodesy&amp;#34;: &amp;#34;^1.1.2&amp;#34;, &amp;#34;immutable&amp;#34;: &amp;#34;^3.8.2&amp;#34;, &amp;#34;moment&amp;#34;: &amp;#34;^2.19.1&amp;#34;, &amp;#34;react&amp;#34;: &amp;#34;16.5.0&amp;#34;, } 里面 geodesy 写的是 ^1.1.2 表示的是最低是这个版本，小版本号可以比这个大。 react 是写死版本号的。版本号不写死会产生一个问题，每次新安装的时候，如果有了新版本，那可能就会安装新的版本。即使你把自己的依赖都写死版本号也没有用，你依赖的依赖可能还是没有写死的。这样怎么办？ NPM 提供了 npm.lock 来管理版本，第一次使用 npm 安装的时候，会自动产生一个 npm.lock ，后面每次执行安装的时候，会根据这个里面规定的版本号来安装依赖。这样基本可以保证总是一样的版本。但是早期我使用 npm 的时候有一个问题，执行安装的时候居然还会修改 npm.lock ，我记得是会改里面的 hash 值，即使影响不大，但是每次提交修改 review 的时候都需要看看这个里面的东西就有点恶心了。所以后面我们换了 yarn，yarn 使用的是 yarn.lock 他执行安装的时候不会修改这文件里面的东西。（npm 我之后就没用了，所以后面讲的主要以 yarn 为准。）这样有了 lock 文件之后，表示所有依赖都有了确定的版本。 那么如何升级其中某一个依赖呢？方法很简单，删除 yarn.</description></item><item><title>Best Pratice for Celery</title><link>https://wdicc.com/best-pratice-for-celery/</link><pubDate>Wed, 17 Jul 2019 15:27:48 +0800</pubDate><guid>https://wdicc.com/best-pratice-for-celery/</guid><description>Celery beat and worker Celery works with two separate parts, the beat and the worker. The beat is the control center which determine when and where to send the tasks, there should be only one beat in each celery network. The worker is the one who runs the tasks and send the results back to the beat, there could be lots of works in each network. Result backend Result backend is the place where task results stored.</description></item><item><title>Use Anki to Leaning English</title><link>https://wdicc.com/use-anki-to-leaning-english/</link><pubDate>Wed, 17 Jul 2019 11:36:20 +0800</pubDate><guid>https://wdicc.com/use-anki-to-leaning-english/</guid><description>Anki 很早以前就听说了，是一款帮助你记忆东西的软件。 教小孩子的时候，一般不是会有一些卡片么，正面是一个字，比如 虎 背面是一个老虎的图像，这样帮助小孩识字。这种叫做 flashcards 。Anki 提供的就是制作并使用这些 flashcards 来帮助你记忆。 所以广义上面讲，Anki 不止可以用来记忆单词，比如学中文老外可以用来记忆中文，学物理化学的记忆各种公式什么的。正面放需要理解学习的东西，反面放帮助记忆的东西。 Anki 神奇的不是因为可以制作任意的记忆卡片，主要是他的针对所谓的遗忘曲线来学习的套路。所谓遗忘曲线，复杂的逻辑我也没看过，简单的用方便理解的方法来讲，比如我们背单词的时候，刚背玩 1 分钟内，通常是记忆最深刻的，10 分钟后就会有一些模糊了，1 天后可能就会忘记很多今天已经记住的单词了，此后不及时复习的话，你会发现下次再见到和第一次见到没什么区别，完全就是个新的单词一样。这个就是说，随着时间遗忘一个东西的速度会越来越快。 我之前使用百词斩背单词，它把单词都做了的图形化的提示信息，这个非常有助于记忆，我非常喜欢这点。他的工作模式是，每天设定一个目标，比如 20 个单词吧，那今天的任务就是复习昨天的 20 个单词，以及学习今天的 20 个单词，每天都这样一个模式。记得我前面说的遗忘曲线了没，这样的模式你会发现，这两天记忆好的单词，下个月可能就基本不记得啥意思了，和没学一样。而百词斩似乎提供了一些你自己复习的途径，不过我目前没找到合适的方式使用。百词斩对于新的单词，会提供三遍机会学习，第一遍是单词+图片，第二遍是单词+释义，第三遍是根据释义选单词。在每一遍里面，如果你选错了，那就会再出现一遍相同的题目。对于熟悉的单词，还提供了一个 斩 的选项，斩掉的单词就不会在出现了，你再也没有机会看到这个词了。百词斩还有一个问题是，因为他是选项模式，实际上那些选项也是一个提示，你可以使用排除法来选择答案，所以这些东西有时候会让你觉得你记住这个单词了，但实际上这个单词单独出现的时候不认识。 Anki 的工作模式是这样的，也是每天设定一个目标，比如新学 20 个单词。那今天你需要记忆的单词就包括了今天 之前 所有需要今天 review 的单词，和今天新的 20 个单词。新的单词没什么好说的，那 review 的单词是怎么构成的呢？当出来一个单词的时候，你根据自己的记忆情况，需要在单词下面的选项选择打算多久之后 review 他，选项按照单词被 review 的次数和你选择的 review 的情况来的，比如新单词的选项是 again 1m, good 10m, easy 1d, 如果你觉得这个词你不太熟悉，你可以从 again good 里面选一个，它会持续的在今天的学习里面出现，直到你觉得认识了，那就选 easy ，那这个词今天就不会出现了，会在明天的 review 里面出现。到了明天，这个词再次出现的时候，选项就变成了 again 10m, good 1d, easy 10d (具体选项我没记住，这里举个例子)，这个时候，如果发现这个单词忘记了，那就继续 again again 的选择直到你觉得记住了，根据你自己的感觉，选择 good 还是 easy ，这样会决定他下次是什么时候出现。类似这样，单词你越熟悉，他出现的次数就会越少，而且你也完全不用担心这个单词会不会你只是现在觉得认识了，后面过 1 个月又忘记了怎么办，那放心这些单词会持续出现的。 事实上，Anki 的设计不止这些。在设置里面还有一些因子，这些会影响出现的选项的时间。具体可以看后面提到的视频。使用 Anki 的时候，基本用法如下： 一个新的词，如果已经认识，那选择 easy 就好了。如果不认识，那根据情况选择 1m 或者 10m ，一般看到一个词一点都不认识的时候，多选几次 1m 加深一下印象，然后选择 10m 看是不是记住了，然后可以往复的选择 1m 和 10m 直到你觉得今天没必要看这个词了，那选择那个 1d 。 一个需要 review 的词，如果发现没记住，那就选 1m 让他进入和新词一样的逻辑，直到最后选择 1d 。 如果需要 review 的词你知道意思，这个时候有几个做法 这个词确实很简单，那继续 easy ，让他更少出现。 这个词有一点难度，是你新学的，但是基本也还能知道怎么回事，那可以选择 good ，让他适当的没那么少出现。 对这个词的部分释义不清楚，没记住，那可以酌情选择 hard ，让他增加出现的机会。 Anki 有一个问题是，随着你学习的新单词越来越多，那需要 review 的单词也越来越多，尤其当你偷懒几天没打开软件，巨大的 review 数量可能会让人崩溃。设置里面可以设置每天 review 的最大数量，默认是 200，如果自己实在不能 review 完可以改一下。我现在设置是 200，每天新词 20 个，看着情况是每天基本是需要处理 60 个词左右。只要持续每天清理就也还好。其实一天那么多时间，大可以利用碎片时间看看，也别担心自己实际没记住但是按了 easy 的情况，后面还会出现呢，后面出现的时候再好好记也可以。 Anki 还提供了一自定义学习模式，每天 Anki 不是会自动安排任务么，如果一天的任务完成后，还想多学习一些，那 Anki 提供了一个自定义学习模式 Custom Study。点击这个之后，需要你选择想学习什么，可以学习新的单词，也可以复习之前学过的，按照你自己的情况选择就好。选择之后，一些卡片就会添加到那个 Custom Study Session 这个 deck 里面。卡片到这个 deck 之后，如果你学习完毕就会都归还到原来的 deck 里面，也可以点那个 Empty 自己都清空。这个 deck 里面有两个设置比较重要，一个是 Step，我看默认是 1 分钟，这个和前面那个 step 是一个意思。还有一个是 Reschedule cards based on my answers in this deck，如果不选中这个，那一个卡片学习完毕之后，会有两个选项一个是 again 一个是 good ，选 good 会结束这个卡片的学习，不会对原来的 deck 里面对这个词的安排有什么影响。如果选中这个选项，那选项会有一个 good(n day) 这样的，点击之后实际会影响原来 deck 里面对这个词的规划。 2019.</description></item></channel></rss>