<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on wd and cc</title>
    <link>https://wdicc.com/post/</link>
    <description>Recent content in Posts on wd and cc</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 07 Nov 2019 12:21:57 +0800</lastBuildDate>
    
	<atom:link href="https://wdicc.com/post/atom.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Upgrade RN From 0.57 to 0.61</title>
      <link>https://wdicc.com/upgrade-rn-from-0.57to-0.61/</link>
      <pubDate>Thu, 07 Nov 2019 12:21:57 +0800</pubDate>
      
      <guid>https://wdicc.com/upgrade-rn-from-0.57to-0.61/</guid>
      <description>好久没升级 app 使用的 RN 了，前几天看见已经是 0.61 了，我们用的还是 0.57，已经差了好几个版本了，有必要跟进一下了。  首先那个 react-native-git-upgrade 被抛弃了，提供了一个 web 的 diff 工具，自己给代码应用 diff 就好了。我的做法是，建一个分支，先把所有除了 android 目录之外的修改了，然后调试搞定 iOS 的编译。搞定之后再搞 android 的。  建议使用 yarn ios/android 这样的命令来运行看错误什么的，如果遇到问题，命令行会提示你一些操作，有的按照操作修改就行。 iOS   iOS 这边主要是改进了模块的集成方法，官方支持了 cocoapods。最早的时候，增加模块的时候，如果有 native 代码，需要自己去添加到自己的工程里面。后面有了 react-native link 之后，一般只需要 link 一下就可以了。所以后面官方支持了自动 link 的功能，add 一个模块之后就会给你自动 link 了，不用你自己再操作了。再后面，大家广泛使用 cocoapods 之后，慢慢的一些 rn 模块就增加了自己的 .podspec 文件，这样就可以允许通过 cocoapods 引用这些依赖了，这样增加依赖还不用修改项目文件， Podfile 和 Podfile.lock 还可以增加到版本管理里面，也很方便。  现在到了 0.61 官方支持了 cocoapods，意思是你 add 一个模块之后，会自动给你通过 Podfile 引用到项目里面。怎么做到的呢？主要是通过 cocoapods 的 use_native_modules!</description>
    </item>
    
    <item>
      <title>Doing Code Reviews</title>
      <link>https://wdicc.com/doing-code-reviews/</link>
      <pubDate>Tue, 29 Oct 2019 16:44:17 +0800</pubDate>
      
      <guid>https://wdicc.com/doing-code-reviews/</guid>
      <description>集中看了一波 code review 的帖子，记录一些笔记 How Do Code Reviews Work at Microsoft?   微软这个倒是没什么亮点，不过最后有一堆别等链接值得一看。    code review 包括测试结果    code review 包括用户界面，可以通过截图什么的提交，这样方便 review    包括静态检查结果   Code Reviews at Google are lightweight and fast   Google 的方式    提交前运行静态检查工具 Tricorder 检查    所有提交都需要 review    代码是全部组员的，所以所有人都要为代码质量负责    代码可读性的 reviewer 必须要取得一个认证之后才能参与 review    review 注重的是 owenership 和 readability，不看 reviewer 的职位年龄，如果总是需要年长的来 approve code，那会有瓶颈    取得认证有难度，但是比起职级要求来说简单多了    代码只有通过了经过认证的 readability 专家和对代码有 ownership 的人的审批才可以合并    想要取得认证，需要像 readability 高级专家组提交代码，他们会仔细检查代码质量，任何微小的错误和潜在的问题都不允许，比如锁进，多余的空格等。    Google 的 style guide    code review 很轻快，小的1小时内，大的修改 5 小时内，具体怎么做到的，似乎有人写一篇论文。。 https://sback.</description>
    </item>
    
    <item>
      <title>Some Interview Questions</title>
      <link>https://wdicc.com/some-interview-questions/</link>
      <pubDate>Thu, 17 Oct 2019 10:57:42 +0800</pubDate>
      
      <guid>https://wdicc.com/some-interview-questions/</guid>
      <description>Notes for some interview questions. OSI 7 layers     Physical layer.    Data link layer. Switches are working on this layer, so when we talk about mac address, node to node connection, it&amp;#39;s all happened here.    Network layer. IP/ICMP protocol are for this layer. IP address, router, routing to other routers hanppend at this layer.    Transport layer. TCP/UDP protocol are for this layer, it defines how packet data forward, and the packet speed, rate, etc.</description>
    </item>
    
    <item>
      <title>Learning Python Coroutine</title>
      <link>https://wdicc.com/learning-python-coroutine/</link>
      <pubDate>Thu, 17 Oct 2019 10:49:40 +0800</pubDate>
      
      <guid>https://wdicc.com/learning-python-coroutine/</guid>
      <description>看了一个视频 OSB 2015 - How Do Python Coroutines Work?，从头开始讲 coroutine 是怎么抽象出来的，感觉好厉害。自己写了一点程序学习了一下。之前写的关于 coroutine 的帖子。  先准备一个 server.py ，可以接受客户端请求。要注意的是要使用 Threading ，或者 fork 的 server，要不服务端执行并不支持并发，需要处理完一个才能处理下一个，这样会发现虽然客户端那边请求是并发的，但是返回结果的时候是顺序的。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  import socketserver from time import sleep HOST = &amp;#39;127.0.0.1&amp;#39; PORT = 2045 class MyTCPHandler(socketserver.BaseRequestHandler): def handle(self): data = self.request.recv(1024) sleep(1) self.request.sendall(&amp;#39;{} ok&amp;#39;.format(data.decode()).encode()) def run(): server = socketserver.ThreadingTCPServer((HOST, PORT), MyTCPHandler) server.</description>
    </item>
    
    <item>
      <title>ASGI</title>
      <link>https://wdicc.com/asgi/</link>
      <pubDate>Tue, 15 Oct 2019 14:52:47 +0800</pubDate>
      
      <guid>https://wdicc.com/asgi/</guid>
      <description>Django 3.0 要支持 ASGI 了，全称 Asynchronous Server Gateway Interface，使用了 coroutines 异步。WSGI 是目前普遍使用的，把进来的请求标准化处理之后，交给 WSGI 程序，这个支持的是请求来了，处理完毕，返回结果这样的模型。对于像 websockt 这样的就不太友好了，websockt 实际是建立连接之后会持续发送请求和接收结果，所以有了 ASGI。  ASGI 不同的地方在于，他有一个 scope，表示一个连接，这个会一直存在直到用户断开连接。然后通过一个一个的 event 和应用交互，event 是个字典，必定包含一个 type 指明类型。ASGI 还支持了 coroutine。  这样对于 http 请求，一个请求就一个 scope， 所需要的数据基本就全了，除了 body 对应一个 event。对于 websockt 请求，一个 scope 会持续到直到用户断开，期间通过 event 发送详细消息。Application 不能和客户端在 scope 阶段交互，必须等进入 event loop 才可以，而且取决于协议规定，可能还需要等一些初始化的 event 之后才可以。  然后目前实现的 ASGI server 我看有 daphne，简单看了一下源码。  这个一般是命令行执行 daphne 这个命令，入口是在 setup.py 里面指定的 daphne.cli:CommandLineInterface.entrypoin ，这里面实例化了一个 cli 然后执行了 run。run 里面主要是处理命令行参数，找到我们指定的 application 然后 import 。  这里我们的用法是通过 get_channel_layer() 初始化了一个，这里面主要是通过配置文件里面的配置，把 backend 和 routing 初始化了一下。 1 2 3 4 5 6  asgi_layer = backend_class(**config) return ChannelLayerWrapper( channel_layer=asgi_layer, alias=name, routing=routing, )     cli.</description>
    </item>
    
    <item>
      <title>New Way to Go Across the GFW</title>
      <link>https://wdicc.com/new-way-to-go-across-the-gfw/</link>
      <pubDate>Mon, 14 Oct 2019 10:57:29 +0800</pubDate>
      
      <guid>https://wdicc.com/new-way-to-go-across-the-gfw/</guid>
      <description>家里路由器用了一段时间的国内定制的梅林系统，还给这个系统做过一个插件使用 v2ray。后面试过换个软路由，使用的 openwrt，然后找到一个新的项目 ss-tproxy ，用起来也还可以，不过是基于 shell 脚本的，以及基于自己的理解，感觉他添加的 iptables 规则有点多，我自己也还想要做到观看 Netflix 使用不同的代理（因为自己的代理 ip 被 Netflix 识别了，没法看，只好找一家机场买了一个服务看，当然又不想所有流量都走机场），所以自己折腾了一个，实现原理就是前面那篇文章。  一开始是基于 v2ray 做的，尽量傻瓜化，只需要提供可用的 outbound 就可以，会自己产生用到的配置文件。实际运行起来发现内存用量有点大，用到 swap 之后路由器变慢，挺讨厌的。然后就琢磨使用 ss 加混淆吧，用了一下速度还不错，但是很快就发现会被断流。没办法，只能还是用回 v2ray，本来想试试看给路由器接一个树莓派吧，里面跑 v2ray，这样也不会影响路由器，但是自己的树莓派不知道哪里去了。。。这也是我那个程序三个运行模式的来源。  后面十一期间那个机场居然公开公布用户的信息，让我觉得机场还是不靠谱，想试试看之前看到的通过 SNI 方式解决看 Netflix 的方案，找了一家试了一下，也还可以。这样我就不用再需要在路由器上面分流了，只需要在 vps 上面配置一下 dnsmasq 就可以了。这样更方便。  这样路由器只需要能解决 gfwlist 里面的域名可以正常访问就可以了。然后看到很多地方提到 v2ray 的 sniffing 功能。之前其实也看到过，忽略掉了。这个功能实际上可以做到解决 dns 污染问题，而不用你还得想办法去劫持系统的 dns。这个可以做到，把用户请求里面的域名交给代理去解析，忽略已有的解析结果，这样不管污染没污染都不会有什么影响了，因为完全不会用国内的解析结果。  然后再配合一个 gfwlist 的域名列表，设置合适的路由，就都 ok 了。  我这有一个示例的 v2ray 配置文件，只需要配置好里面的 outbound 就好了，注意要保留那个 tag 名字，或者你也可以自己修改，和下面的 routing 里面的 tag 对应就可以。那个 ip 列表是解决 telegram 的使用的。还需要配合一个 gfwlist sites 列表，可以直接下载这个。  v2ray 在路由器跑有时候内存问题什么的，看着不太稳定，所以我还搭了一个检查程序，如果发现奔溃了自动重启一下。里面需要改一下 v2ray 的路径 /opt/svgfw/bin/v2ray -config /opt/gfw/config.</description>
    </item>
    
    <item>
      <title>Drive in the US</title>
      <link>https://wdicc.com/drive-in-the-us/</link>
      <pubDate>Tue, 08 Oct 2019 12:47:56 +0800</pubDate>
      
      <guid>https://wdicc.com/drive-in-the-us/</guid>
      <description>十一前去美国自驾了一圈，其实算是第二次美国自驾了。第一次是五年前。第一次去的时候有一个当地生活了比较久的朋友陪着，包括她我们三个司机开了几天，所以实际感受没有这次深。这次是我和我老婆两个司机，完全自己规划自己开，一路全靠 Google Map 了。人总是很健忘，开完感觉有必要总结一下，以备今后查看。 驾照   美国认可国际驾照，但是中国似乎没有加入那个发国际驾照的组织，这样有中国驾照无法申请国际驾照。据说有变通的方法是去香港申请一个驾照，然后再申请国际驾照，但是估计也比较麻烦。好在美国大部分地区认可中国驾照。需要注意的是，各个州的规定不一样，有的州就不认可，比如德州，在这些州用中国驾照开车等于无照驾驶。  可以看到各个地方都会宣传说可以给你弄国际驾照，那个实际是国内驾照按照国际驾照的样子的翻译件。里面只是把国内驾照的信息按照国际驾照的样子翻译了过去，因为国内驾照上面没有英文，老外看不懂，准备这样的一个翻译件也很有用。这个翻译件似乎成本不高也不贵，很多地方买个什么就会送。  我们当时规划的是开 66 号公路，其中会途经德州，如果绕开会比较麻烦，走很多小路。后面决定就那么开过去，在德州的一个城市边上还住了一晚上，不过没去市区里面溜达，没遇到问题。反正一般警察也不会找你，除非遇到什么事故什么的，但是谁知道呢，一旦产生问题钱可能是小事，会耽误你的很多行程的安排。 驾驶习惯   美国那边也是右舵，租的车大部分也应该是自动档，开起来一般没啥问题。仪表盘可能会显示 MPH 而不是 KPH，这样也好，反正各种限速牌子也都是 MPH。档把可能会在方向盘上面，手刹可能在脚下，大概可能就这么几个差异。  Mile 和 KM 的转换大概是 1.6 倍，等于 1mph = 1.6kph。高速公路一般限速 55 - 75 都有，75 就差不多是 120 了。  开车的时候，右边是慢速车道，左边是超车道，一般是规定左边只有超车的时候才能使用，超车完毕应该并回右边车道。并线记得打灯。  有些地方的路是单车道，这个时候如果需要超车需要借用对向车道。注意看路中间的线，如果是实线是不能超车的，只有虚线可以，其实和国内一样，实线不能压。  有些地方还要求白天的时候也开车灯，这个一般是视线不好的地区，比如山路起伏比较多，开了车灯可以更好的看见对向车。  车在路上一般都满速开的，很少看见慢车。一般是限速 65 的道路，大货会开 60 - 65，小车想保持 65 就需要超过大货。不过一般小车都超速，开到 70 - 80 这样。超速了路边可能会有警车埋伏然后追车。  超速这个问题很迷，我在那边开发现基本都在超速。而且那边的车不喜欢刹车（可能也是不需要），转弯什么的都全速过，很吓人。我感觉还是安全一点开右边车道然后多踩踩刹车吧。  出口一般都在最右侧车道，有时候会出现最右侧直接对接一个出口，会发现不想出去的时候只能往左并一个车道，一般这种车道都写着 Exit Only。对于单向两车道，一般不会遇到这样的车道，都可以出去也可以继续往前开。多于两车道的可能会有这个情况，如果不想尴尬，可以开右边数第二个那个车道，比较稳妥一点。  有时候也会有那种分叉道出来，就是看着两边都是大路，分别都是 2 车道，这个时候就需要你提前准备好是打算走哪边。要不到了时候需要连续并几条线很危险，因为车都很快，如果真的弄错了就继续往前开吧，看看导航怎么提示。 加油   加油站都是自助，这个第一次会手足无措。一般加油站都有很多的那个油枪，进入加油站之后找一个对着自己油箱加油口方向的就可以。一般你在这里停多久都没人管你的，所以你大可以慢慢搞。我看油站还都提供一个小刷子，开高速不是容易玻璃上面积攒一些虫子尸体什么的么，用这个可以方便的清洗掉。免费的。  加油具体操作其实也挺简单，一般是两种方式：    使用信用卡付款：那么直接先刷卡，然后会提示你收起卡，之后会提示你拿起油枪后选择一下油品，然后就可以按把手上面的那个机关加油了。    使用现金付款：去柜台，和对方说你是几号位置，然后充多少钱进去。对方收钱之后你就可以去加油了，这个时候会发现油柜显示屏上面会显示你充的钱（有的可能也不显示），直接拿油枪选油品就可以加油了。如果最后没用完钱，可以再去柜台找他们退钱。    信用卡消费我遇到一个问题是，有一次一个加油站刷卡之后一次扣了我 $1，后来问他们说是会给退回的。那边刷卡账单很快，退款的账单就非常慢了，这个只能自己多看看，不想这样有纠纷建议可以每次都使用现金。另外有的加油站刷卡还会比现金贵 10 美分。  油品反正是从 87 开始，很多种，租的车也就 87 就算了。不同油站价格差异可能会比较大，我们在芝加哥加油 $29，到了加州就有 $5��了，差异很大。  高速路边有时候加油站挺多的，有些地方又会很少，最好提前规划好。感觉中部比较荒凉的地方就比较少，高速会比较多一点，普通道路会比较少。 停车   我们去的大部分地区都免费，市区会收费的比较多，我们去湖人体育馆标价 $3��直接吓尿了绕了一圈走了没停。  很多地方有限时停车的标记，比如白天可以免费停 2 小时什么的。这种一般也没人看着，停多久似乎也没人管，不知道超了是不是真的会有问题。  还有就是那种停车表，停车之后去那边买小时，不买可能会有罚单。  停车也不要停 Reserved 或者残疾人标记的位置，还有 Valet 标记的，这些都是保留车位，停了可能会被拖走。  反正是停车费可能很低，也可能是天价，一般去热闹的地区停车做好心里准备。 法规   我感觉有几个法规需要注意一下。  Stop 标志，国内没有这个。遇到这个是一定需要停车的，然后观察左右两边是否有其他车，没车的时候可以迅速通过。如果有车，对方也有 Stop 标志，那应该是大家按照到达节点的顺序轮流启动。如果对方没有，那对方一般不会停车以及减速，会直接假设你会停下来等他，直接开过去，这个时候如果你按照国内习惯没等，那可能直接就车祸了。类似的如果你在主路也可以不用管旁边有 stop 标志的岔路的车，他们会等你的。  Yield 标志。类似 Stop，应该是按照到达先后顺序大家轮流开过去。  遇到行人过马路需要停车等。要远一点停下，不要开到人旁边，避免对方不明白你是打算停车还是打算撞过去。  如果遇到有在应急车道（或者路肩 Shoulder 上面）停的车的时候，规定是尽量不要贴着他们那个车道过。比如他们停在最右侧车道的右侧，那么就不要在最右侧车道开了，经过他们的时候提前往左并一个车道，这样防止车过去带起来的风产生什么问题。当然如果左侧刚好也有车，不能并过去，那就适当减速经过。  遇到警察让停车就老实停车，注意不要下车，坐车上双手放在方向盘上让警察可以看见，然后等警察过来。不要乱动。 开车感受   感觉比国内开舒服多了，大家都很有礼貌。堵车也不会随意并线加塞，没有国内越塞越并，越并越堵的情况。国内常有的，某一个出口堵了之后，基本这条路就堵了。那边只会是出口那一条线堵车。偶尔会有开其他车道的可能没有提前并线，然后再并入的，排队的车也会给让，所以基本不会堵其他车道。  Stop 标志让主路开车的很舒服，在主路的时候完全不用管旁边可能会并入的车，他们会观察并处理好的，主路的车只管开就好了。  没有慢车，没有胡乱并线。  我们这次总共开了 3800 Mile，大概是 6000 多公里。大地点是从 Chicago, IL -&amp;gt; St.</description>
    </item>
    
    <item>
      <title>Notes for CPython Internals</title>
      <link>https://wdicc.com/notes-for-cpython-internals/</link>
      <pubDate>Thu, 05 Sep 2019 12:43:42 +0800</pubDate>
      
      <guid>https://wdicc.com/notes-for-cpython-internals/</guid>
      <description>视频地址这里。 Python 源码   Include/opcode.h 里面定义了所有 opcode。 Modules 里面是一些 c 实现的模块， Lib 里面是用 python 实现的模块。 Objects 里面是部分 python 对象对应的 c 实现。  Python 目录里面是 python core， Python/ceval.c 里面定义了 python interpreter 主要的循环，找那个 for(;;) 就可以，这个循环里面有一个巨长的 switch (opcode) 。 Opcode 和 interpreter 循环   test.py 1 2 3  x = 1 y = 2 print(x + y)     使用内置的 compile(source, filename, &amp;#39;exec&amp;#39;) 函数可以把代码编译成 code object , code object 有一个 co_code 属性，里面包含了代码的 bytecode。 1 2 3 4 5 6 7 8 9  &amp;gt;&amp;gt; c = compile(open(&amp;#39;test.</description>
    </item>
    
    <item>
      <title>Book Review of Soft Skills</title>
      <link>https://wdicc.com/book-review-of-soft-skills/</link>
      <pubDate>Wed, 28 Aug 2019 17:32:36 +0800</pubDate>
      
      <guid>https://wdicc.com/book-review-of-soft-skills/</guid>
      <description> 改变自己对自己的看法    你所能犯的最大错误就是相信自己是在为别人工作。这样一来你对工作的安全感已然尽失。职业发展的驱动力一定是来自个体本身。记住：工作是属于公司的，而职业生涯却是属于你自己的。  把雇主当作是你的软件开发企业的一个客户吧。当然，你可能只有这么一个客户，你所有的收入都是从这一个客户处得来的，但是这种诠释雇用关系的方式可以将你从仰人鼻息的弱势地位转换成为自我治理和自我引导的主动地位。（事实上，许多真正的公司也就只有一个大客户，这个客户给它带来了大部分的收入。）  企业需要持续不断地改进和完善自己的产品。你也应该这么做。   关于职业的部分，作者主要的论点是就是这个。就是把你自己当作一个公司来思考问题，你去一个公司去工作不过是和这个公司合作而已，这样你就不局限于思考自己能做什么呢了，毕竟一个公司能做什么的想象力就大多了。   人们常常容易犯的一项错误就是，轻率地否决同事的想法，以便于可以提出自己的想法  如果你想激励他人做出最好的表现，或者希望达到改变的目的，你必须学会管住自己的舌头，只说些鼓励的话。   关于和其他人打交道需要注意的问题。   专业化的规则是：专业化程度越深，潜在的机会就越少，但获得这些机会的可能性越大。   专业知识往深了学习会遇到这个问题。往广了学会导致深度不够，但是机会增多很多，不过竞争肯定也多。   中等规模的公司往往要比大公司还稳定  在任何公司里能让你脱颖而出的最重要法宝就是承担更多的责任。  在任何组织中，总是有很多人会告诉你为什么这个想法行不通，为什么那个问题太难。这样的人不胜枚举。千万不要成为他们中的一员。相反，你要成为那个永远能为各种问题找到解决方案的人，要成为勇于执行这些解决方案以获得成果的人。  一位专业人士需要知道在什么时候说“不”，即使是面对自己的老板。  许多软件开发人员犯的一个巨大错误就是，当无法达到标准时，他们不是完善自己、迎接挑战，而是降低标准。   这个非常认同，勇于承担责任，并且确实可以承担责任的人，一般公司都喜欢。  做提出问题的人很难得，但是如果远远不如解决问题的人，永远都尝试去做解决问题的人。  做专业人士，不要轻易降低自己的标准，勇于挑战，这样才能快速提升。   同时也要现实一些。仔细想想自己还能维持多久，自己能做些什么来维持更久。你要制订一个计划：什么时候你就得认怂，重新做回雇员。  为自己当老板做好准备  获得客户的最佳方式是通过你已经认识的人。熟悉你的人更容易信任你，特别是在启动阶段。  你的目标应该是让自己达到这样一个点：你为这份副业分配的时间已经饱和，无法再接受其他工作，不得不回绝掉一些人。如果你在做兼职工作的时候做不到这一点，那你就不要想着去做全职了。  成为了自由职业者之后，你的时薪水平应该是作为全职雇员时的两倍  如果你的营销策略是基于自己的服务可以为客户节省大笔开支或者提高他们的业务，你就可以根据自己的服务为客户带来的价值来定价。  价值来自于为对方做了什么，而不是做了什么。  不断给你的收费加码，直到你听到“不行”为止。   这段是如何开始准备自己给自己干，以及如何给自己定价。 创业    在为产品找到客户之前就构建好产品。否则你只是冒险为一个不存在的问题创造了一个解决方案  没有要解决的问题的产品毫无意义，毫无意义的产品自然也就不会有用户，也就意味着你不会赚到钱。  许多创业公司的创始人发现，把股权出让后给不思进取的合伙人后，自己就面临一个大烂摊子，后者不仅对公司毫无贡献，还榨取公司的宝贵资产。   创业之前需要考虑好的问题。只有真的有实际价值的产品，才会有人给你买单。   在你的电子邮件签名的底部以及所有的在线个人主页中添加你的博客链接  当你营销自己的时候，如果你所做的一切都只是为了自己的利益而不给别人带来真正的价值，那么即使你所做的都正确无误，那也无济于事。你可以写博客、在社交媒体上分享自己的内容、在大会发言、著书立说，尽你所能来推广自己，但是，如果你表达的和你传递的信息不能帮到其他人，那么每个人都将会无视你。  人们最关心的还是自己。没人想听到你的成功故事，也不想知道为什么他们要帮你获得成功，但是他们肯定想听到你会怎样帮他们获得成功。所以，要想让自我营销的所有努力奏效，基本的方法就是帮助他人获得成功。  Zig Ziglar说得好：“如果你能帮助足够多的人们得到他们想要的东西，你就会得到自己想要的东西。”这是一个基本的策略，你应该将其用于自我营销。它比其他任何方法都更有效。  你的主要目标：为他人增加价值不要努力成为一个成功的人，而要努力成为一个有价值的人。 ——阿尔伯特·爱因斯坦  想给人们想要的东西，要先知道他们想要什么。但是这并非易事，因为如果你问他们，他们可能会撒谎。他们并非故意撒谎，而是他们也只有一个模糊的概念，并不确切地知道自己想要什么。就像新娘在找心目中的完美婚纱时，只有切实看到了才会知道“这就是我想要的”。  想要弄明白他们的真实想法，你得全凭自己。   学会以及要能不要脸皮的自我营销。以及你的东西需要真的是会给客户带来价值，至于什么是有价值，可能客户自己不知道，你也不知道，这些需要你去把握。总之一定要让自己做的事情对客户真的有价值，否则必定不能长久。 生产力    定额工作法的规则    挑选一项重复性任务。    明确有效时限，在此期间该任务被重复执行。    明确在给定的有效时限内该任务应该完成的次数的定额。    给自己承诺：一定要达成定额。    调整。调高或者调低定额，但是不能在有效时间段之内调整。    现在我用批量处理的方式处理邮件。每天我会检查几次自己的电子邮件，并回复紧急邮件。但总的来说，我会在一天中找个单独的时间集中处理所有的电子邮件。我会一次性浏览我的整个收件箱，并处理所有邮件。因为不再被其他任务打扰，我可以进入了“电子邮件模式”，在这种模式下我处理邮件的速度比一直打开收件箱的时候快很多，所以我的效率高很多。  如果能咬紧牙关坚持到底，如果能穿越那堵墙战胜自己，最终你会发现，简单地无视它的存在，你的倦怠感已经不治而愈。  经历痛苦就是克服倦怠的秘诀。你以后还会撞到更多的墙，但每穿越它一次，你将会体验到全新的动力、充沛的活力。另外，你的竞争者的数量会越来越少。  生产力的真正秘诀在于：长期坚持做一些小事。  个能够帮助你克服拖延的提高生产力的窍门：分解任务。  最可怕的效率杀手之一——无所作为  我们经常试图耗费300%的努力寻找95分的解决方案，而不是满足于找到90分的解决方案   这个是定额工作法，以及番茄工作法，我理解主要的目的是为了能让你持之以恒以及可以更加专注的去做一些事情。  一个大的任务或者一个长期的任务开始的时候总是会很痛苦，因为觉得难，坚持不下来什么的。通过设置定额，或者拆分成番茄钟，可以让这个事情变小，把大目标先改成完成这个小目标，这样会比较容易开始，以及比较容易坚持。  一旦开始之后，如果发现这样的小目标也无法坚持，那可以试着把这个任务继续拆小，直到自己可以承受。这样很多困难，持续时间长的任务就可以持续下去了。即使做再少，也比无所作为强是不是？  另外，把时间分成番茄钟小段，还可以让你更加专注，这样可以更加方便的安排事情，比如每四个番茄钟看一下邮件，每 5 个番茄钟奖励自己看看社交媒体放松一下什么的。 目标    当你的“被动收入”达到每月所需的生活开销的时候，你就可以正式退休了。所谓被动收入，就是不用工作就能获得的收入。你必须确保被动收入会随着通货膨胀而增加   这个就是作者在 20 岁左右的时候定的目标。作者通过自己的努力，靠收房租，收稿费等在 30 多岁的时候达到了这个目标。 </description>
    </item>
    
    <item>
      <title>Python Coroutine</title>
      <link>https://wdicc.com/python-coroutine/</link>
      <pubDate>Tue, 27 Aug 2019 10:49:51 +0800</pubDate>
      
      <guid>https://wdicc.com/python-coroutine/</guid>
      <description>协程 coroutine 不知道是从什么时候开始的，感觉我第一次看到是 lua 里面支持 yield 。后面看到就是 javascript 里面的 Promise，async 和 await。  以前写 Javascript 的时候容易会遇到 callback hell，似乎 Promise 就是出来解决这个问题的，让你可以用同步的方式写异步程序。例如你有三个异步请求可以同时发出去，而后面的结果又需要这三个的结果都回来才能继续，那就可以用类似下面的伪代码，整体执行时间是最长的那个。 1 2 3  res1 = await test1 res2 = await test2 console.log(res1, res2)      Python 里面似乎也类似。我目前理解主要就是让程序可以「同步」执行，但是又避免了需要维护锁的问题，没有锁就不会有死锁了吧。。。  解释下同步，主要是针对对于 cpu 资源的占用。对于计算型的程序，实际上每时每刻都在利用 cpu 做计算，这样就算把计算拆分成了多个计算程序，让他们同时运行，那同一时刻还是只有一个程序在利用 cpu 资源执行，这样并行实际并不能提升效率。所以对于纯计算型任务，可以通过多进程利用多个 cpu。  但是实际我们的程序执行的时候，并不全是 cpu 计算，有时候会需要等网络 io，文件 io 等，做这些事情的时候实际上 cpu 是空闲的。协程就是让这些程序在等待的时候，把控制权交出来，让其他程序运行。那个 yield 关键字就是做这个事情的， yield 很像 return ，遇到的时候就会返回，暂停程序的执行，等到适当的时候又可以从暂停的地方继续执行。  以前是使用 @asyncio.coroutine 和 yield from 来创建协程，似乎 3.</description>
    </item>
    
    <item>
      <title>Book Review of Effective Python: 59 Specific Ways to Write Better Python</title>
      <link>https://wdicc.com/book-review-of-effective-python/</link>
      <pubDate>Mon, 26 Aug 2019 09:53:26 +0800</pubDate>
      
      <guid>https://wdicc.com/book-review-of-effective-python/</guid>
      <description>书名是《Effective Python：编写高质量 Python 代码的 59 个方法》这本书买了大概 2 年，一直没看完，前几天找了一些时间看完了。  这书是针对中级 Python 程序员的，里面没有对于语法什么的讲解，也没有对 c 代码实现的讲解，针对中级程序员。 用 Python 方式来思考     Python 3 里面包含两种表示字符串的类型：bytes 和 str。前者是二进制形式，后者是 Unicode 编码（比如使用 utf8）之后的形式。想要把 bytes 表示为 str 形式，需要使用 decode ，反之是 encode 。    切割列表的时候，start 和 end 可以越界，这样可以用来限制列表最大长度。 a=[0,1,2]; a[:10] 可以限制最大是 10 个。    可以使用列表推导式 [x*2 for x in a] 类似这样的形式，代替 map 和 filter 。    字典推导 {k: v for k, v in a.</description>
    </item>
    
    <item>
      <title>Get Wool From Dogs</title>
      <link>https://wdicc.com/get-wool-from-dogs/</link>
      <pubDate>Tue, 20 Aug 2019 10:04:56 +0800</pubDate>
      
      <guid>https://wdicc.com/get-wool-from-dogs/</guid>
      <description> 不知道羊毛出在狗身上怎么翻译的好，暂时先说成 get wool from dogs 了。今天的内容可能会有点文不对题。  也不知道是什么人第一个发明的这个事情，但是不少人通过这个确实发达了一波。  互联网大量内容是免费的，这简直就是公理了。出来一个收费的服务大家会说傻子才付钱。我之前去一个外包公司他们用 phpldap 搭了一个服务，然后人家后台有一个广告说让大家捐款支持下，当然这个不是强制的。那个搭建服务器的台湾人说不会给捐款的，而他们实际是使用这个开源免费的工具来代替原来的一个收费服务的。  后来时间长了慢慢大家明白了，原来不付钱是有代价的，会失去自己的隐私和注意力。商家为了赚钱页面上面放满了广告，甚至有的广告你都不知道他是广告。百度被人骂不就是偷偷的把广告推给你么，使用百度搜索是免费的。  第一波共享单车出来的时候，感觉这事情很不可思议，单车那么容易丢失和损坏，骑一次才 5 毛一块的，损失一辆就几百，在这个车不能骑或者丢失前似乎不太可能把这个成本赚回来，更别说还有其他其他开发运营成本。后来才明白，人家看上的是你的押金。大量的押金存放到他们那里，这些都是灰色的地带，OFO 不是挪用押金后面被挤兑导致很难过么。  共享单车搞了这么一波之后，聪明人搞起来了 p2p，你想赚人家高额利息，人家实际看上的是你的本金。发财也轮不到你。  淘宝一开始开店是免费的，靠这个把 ebay 搞死了，要知道 ebay 可比淘宝早，ebay 的模式是从交易里面抽成或者收服务费，而淘宝完全免费。那淘宝也不能就这么一直不赚钱啊，利用用户的注意力靠广告赚商家的钱，有线电视你每个月交了钱还需要看广告呢，别说淘宝都不用你交钱。  现在呢，淘宝把其他网店平台干死之后，淘宝推他的天猫商城了，小店主很难赚钱了已经，再也不是一开始的样子了。天猫上面开店是需要交几千上万的保证金的。  京东上面东西方便吧，上午下单了晚上可能就到了，几十快钱就包邮。基于巨大的采购量，一方面可以压低进货成本，另一方面呢加上他们自己的快递包邮网络，成本低送货上门，甚至比楼下超市都方便啊。现在京东涨包邮起价了，你习惯之后是不是还是在京东买？不得不这样啊，因为楼下的超市已经死了。一个快递员上午送一趟下午送一趟，可能有几千个包裹？如果这里面每个快递费 6 圆，怎么样是不是很赚钱？  OFO 挪用押金之后，现在共享单车似乎都不收押金了，那怎么活下去？这不是活雷锋了么。一方面涨价，原来摩拜 1 小时 5 毛，现在 15 分钟 1 块。涨了 8 倍？别慌还有呢，如果车没有停在他们划定的区域，还有一个调度费，5 - 10 圆，是不是挺有意思的。  商业公司永远都是要赚钱的，如果现在还有公司出来说不以赚钱为目的，那最好别用。等你有了依赖估计就是他们的羔羊了。如果一个服务你享用的挺好，那根据自己能力和需要付费支持让他们可以持续运行是很好的一个事情。  当然，大家付费意愿起来之后，现在又有一波人还是觉得不够，你看那么多订阅制的软件。不过怎么说呢，反正人家也确实可能还是需要花精力做后续的一些事情的，愿不愿意付费还是看你了。 </description>
    </item>
    
    <item>
      <title>Emacs as Python IDE Again</title>
      <link>https://wdicc.com/emacs-as-python-ide-again/</link>
      <pubDate>Tue, 13 Aug 2019 14:56:02 +0800</pubDate>
      
      <guid>https://wdicc.com/emacs-as-python-ide-again/</guid>
      <description>上一篇里面说了使用 emacs 编辑 python 文件的方式，已经过去 2 年了，时代变了。更新一下。  随着 vscode 横空出世，带来了 LSP，这个东西是所有编辑器都可以受益的，有人开发了 lsp-mode，目前我感觉 lsp 比 jedi 好用多了。  elpy 目前还不支持 lsp。所以放弃了 elpy 了。  主要配置如下。使用了 lsp-python-ms 和 lsp-mode, pipenv 。我原来用 pyenv + virtualvenv，pipenv 是把两个整合的东西。pipenv 还支持 lock，以后估计会流行吧。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  (use-package lsp-python-ms :ensure t :demand nil :config ;;(setq lsp-python-ms-extra-paths &amp;#34;&amp;#34;) (setq lsp-python-ms-executable (string-trim (shell-command-to-string &amp;#34;find ~/.</description>
    </item>
    
    <item>
      <title>Run Command Through Python</title>
      <link>https://wdicc.com/run-command-through-python/</link>
      <pubDate>Tue, 13 Aug 2019 14:53:34 +0800</pubDate>
      
      <guid>https://wdicc.com/run-command-through-python/</guid>
      <description>通过 python 执行命令有很多方法。  最简单的 os.system(command) , command 是要执行的命令，一个包括命令和参数的字符串。产生的输出会直接打印到 stdout 。返回值是命令执行的退出值。  然后就是 os.spawn* ，这个我感觉有点丧心病狂了。    os.spawnl(mode, path, …)    os.spawnle(mode, path, …, env)    os.spawnlp(mode, file, …)    os.spawnlpe(mode, file, …, env)    os.spawnv(mode, path, args)    os.spawnve(mode, path, args, env)    os.spawnvp(mode, file, args)    os.spawnvpe(mode, file, args, env)    这些主要是命令输入的方式，和环境变量的控制不一样， l 是类似 os.</description>
    </item>
    
    <item>
      <title>An Interesting Python Function</title>
      <link>https://wdicc.com/an-interesting-python-function/</link>
      <pubDate>Wed, 07 Aug 2019 16:53:09 +0800</pubDate>
      
      <guid>https://wdicc.com/an-interesting-python-function/</guid>
      <description>  这里看到的，感觉挺有意思的，记录一下。题目来自这里。  如何让下面这个函数返回 True ？ 1 2 3 4 5  def check(x): if x+1 is 1+x: return False if x+2 is not 2+x: return True    解法1: 自定义类  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  def check(x): if x+1 is 1+x: return False if x+2 is not 2+x: return False return True class Test(int): def __add__(self, v): if v == 1: return 0 else: return v print(check(Test())) # output: True     如果一个对象是在 + 的左侧，那会调用 __add__ ，如果在右侧，会调用 __radd__ 。上面的 Test 类继承自 int，重写了其中的 __add__ 方法，但是保留了 __radd__ ，所以上面的例子里面， Test()+1 会返回 0， 1+test() 会返回 1。 Test()+2 会返回 2， 2+Test() 也会返回 2。 解法2:特殊的整数  1 2 3 4 5 6 7 8 9  def check(x): if x+1 is 1+x: return False if x+2 is not 2+x: return False return True print(check(-7)) # output: True     只有 -7 可以。python 里面对于 -5 - 256 这些整数会提前生成，这些都是单例。所以 -7+1 is 1-7 是 False ，以及 -7+2 is not 2-7 是 False ，两个 if 条件都不成立。 </description>
    </item>
    
    <item>
      <title>How to Open an Company in China</title>
      <link>https://wdicc.com/how-to-open-an-company-in-china/</link>
      <pubDate>Wed, 07 Aug 2019 10:44:55 +0800</pubDate>
      
      <guid>https://wdicc.com/how-to-open-an-company-in-china/</guid>
      <description>  我记录一下国内开公司需要做的事情吧，有一些事情我没有参与，说的不一定准确，供参考。 公司结构，类型和名称   第一步需要先确定公司的性质。有限责任公司，无限责任公司，合伙公司这些，需要先了解一下。  国内目前不允许同股不同权，即所谓的 AB 股模式。那么为了控制公司的投票权，我们模仿了 VIE 模式，先创立一个合伙人企业 A，然后通过这个企业，控制实际做事情的企业 B。后续的融资也会都进入 B 那个企业，始终保证 A 是大股东。  公司名称有时候会出现和别的公司冲突的情况，似乎类型不一样可能也可以，反正这里面很多无法量化的东西，似乎可能会有一些腐败漏洞，这个将来也会涉及到你申请商标的事情，冲突了也没法申请下来。 公司注册和办公地点   确定公司模式之后需要确定公司注册地点。目前有一些地区对互联网创新什么的会有一些税收的减免政策，可以了解一下然后选一个合适的地方。营业执照上面是需要有一个办公地点的，所以也需要在当地有办公室。似乎有的地方可以提供注册地址给你用，你也不用真的去办公。  要注意的是，将来各种工商税收什么的也会需要到当地去处理，所以也需要适当考虑距离的问题。当然，这些可能也可以委托一个当地的处理这些事情的公司帮你处理。比如一些代记账什么的公司。 申请营业执照，开对公账户   上面的确定之后，这些事情估计就比较简单了，按照流程去办理一下就可以了。对于合伙人企业，似乎还需要所有人签订一些东西到工商那边备案，如果合伙人比较多，集齐签名可能会是个麻烦的事情。  另外，只有合伙人公司先开了之后，才能申请实际做事情的公司的执照的。申请执照感觉可能会需要 1 个月左右吧，两个都下来需要一些时间。  有了营业执照，很多以公司名义做的事情才可以做。比如以公司名义和别的公司签协议，转账，或者申请购买一些东西，这个下不来，后面很多事情都麻烦。 真实办公地点，办公环境   真实的办公地点和营业执照的关系不大，这里主要需要解决的问题是，公司员工的社保缴纳问题。一般你是无法在非注册地做这个事情的，可以在实际办公地注册一个分公司做这个事情。但是目前也有很多代交社保的公司，一般是签订一个类似派遣协议什么的，然后来做这个事情。这个是灰色地带。  你可以租一个写字楼的办公室，或者民居来做实际办公的地方，区别可能是价钱吧。不止房租，还会有网络，水电等的费用，商用和民用价格本身也不同。  目前也有一些联合办公的地方，他们会把比如一层写字楼处理好，然后出租里面的工位，同时还可以给你网络水电，会议室，打印机等等，基本上是比较省事的方式。  我们是从民居开始搞的，需要申请网络，买打印机（有一体机，包括传真，复印，扫描等），饮水机，投影仪（或者买一个大电视也可以），冰箱，微波炉（方便带饭）等等吧，还需要定期找人来打扫一下。  此外可能还会需要弄一些安全的设备，防止小偷，毕竟电脑什么的加一起也不少钱。我买了一些小米的东西，比如开门警报，摄像头什么的。  非技术人员基本就可以了。如果是技术人员办公的话，还会需要准备 gitlab 等这些东西，你可以使用 SASS 服务，现在也挺多的，可能会有一些费用，也可以自己搭建自己维护。如果自己搭建，那要不是需要现有服务器，要不就是自己买一个放在办公室里面。我自己买了一个 intel 的 NUC 放在办公室，充当拨号网关，和开发服务器，以及 gitlab 等各种公司内部服务的地方。 工商税务人力   需要准备劳动合同。制定公司的规章制度，报销方式，各种假期补助等等各种琐事。  还需要有会计和出纳管理公司的帐务，这个有一些专业的代理公司可以帮你做。 招聘   各招聘网站以公司名义招聘的话，都需要公司营业执照。有了营业执照之后就可以去注册了。我印像比较好的是拉钩，好几个人都是那里招聘的。 域名   不可避免的，一个公司必定会需要弄一个自己的域名。还可能会需要搞你自己产品使用的域名，为了保护自己，对于读音拼写相近的可能也需要申请一下，这个费用不贵。 准备服务器   做 app 网站什么的，总是需要你有服务器，以前是自己买服务器托管到机房，现在可以直接使用云服务，比如阿里云青云这些，我们用的是 AWS。这些开户都需要你提供营业执照。费用和计费方法各不同，可以多看看比较下。推荐的做法是多机房多 ISP 容灾。比如可以 aws 和 aliyun 都有服务器，这样一边挂了也还可以提供服务。当然这里会涉及到一些技术问题。 备案   想把域名和服务器对应起来，必须要先备案域名，否则提供给你服务器的地方可能根本就不会让你的服务上线。这个备案的事情比较麻烦，一般服务器提供商会提供协助你备案域名。  这里其实就有一个问题，我还不知道有没有办法把一个域名指向两个不同的服务商。  域名还需要到公安备案，这个取决于你提供的服务，如果有讨论区什么的，公安可能还会需要你过去当面聊聊，公安备案是需要你自己去提交的。  备案之后自己的网帐就可以让别人访问到了。后面说 app 的事情。 申请苹果开发帐号   如果你是做 app 的，那申请苹果帐号是必须的。公司名义申请的话，需要先搞一个 DDUS-Number，这个可以找一些公司申请。申请下来之后直接在苹果后台申请帐号就可以了。 Android 开发帐号   如果是做国内服务，那 Android 并没有一个统一的地方，各手机厂商都有自己的 appstore，需要你单独去申请。申请帐号一般只需要营业执照就可以，应用上架就麻烦了，需要有一个版权证明。这个网上也有申请的，收费和时间有关系，最慢的一个半月下来大概几百，快的可能几千，看你需求。  还好 Android 可以直接安装 apk，所以早期你也可以先提供一个直接下载 apk 的地方让用户安装，这样可以节约一些软著申请费用。 </description>
    </item>
    
    <item>
      <title>React Native Versions</title>
      <link>https://wdicc.com/react-native-versions/</link>
      <pubDate>Fri, 26 Jul 2019 15:45:27 +0800</pubDate>
      
      <guid>https://wdicc.com/react-native-versions/</guid>
      <description>RN 里面有很多个个版本号    package.json 里面定义的 version 。    android/app/build.gradle 里面定义的 versionName 和 versionCode 。    ios/YOURAPP/Info.plist 里面定义的 CFBundleShortVersionString 和 CFBundleVersion 。    如果你使用 code-push 的话，还有一个 code-push 自己的版本号，叫做 Label 一般是 v 开头的。    这几个版本号都有用，需要有规划的使用。我的经验如下。    统一 version, versionName, CFBundleShortVersionString ，使用类似 x.y.z 这样的格式，升级的时候都一起升级，每次发布这个版本前都会在 git 打一个 tag。这个是用来表示用户看到的 native 的版本。这样你的 app 在 ios 和 android 的市场里面，同一个版本的，一般就是同一套代码打包的，    versionCode 和 CFBundleVersion 各自表示各平台软件的真实版本，可能会出现同一个 1 里面的版本的情况下，这个有多个的情况。一般的应用市场发布的时候，也是认这个版本号的。这个编号只增不减，原则上每次打包都增加，不管代码有无变更。    如果使用了 code-push，那还 1 里面的版本号还需要遵守一个原则：    如果 native 代码有变更，那需要增加 x.</description>
    </item>
    
    <item>
      <title>Tools to Manage Your React Native Projects</title>
      <link>https://wdicc.com/tools-to-manage-your-react-native-projects/</link>
      <pubDate>Fri, 26 Jul 2019 14:55:38 +0800</pubDate>
      
      <guid>https://wdicc.com/tools-to-manage-your-react-native-projects/</guid>
      <description>RN 项目大部分人都知道是基于 Javascript 的，懂 js 就可以写了。但实际上并没那么简单。大概总结下这里面的问题，主要从管理项目的角度来说。 NPM   JS 部分肯定是不能避免的，js 依赖重这个估计都知道， node_modules 被很多人吐槽了。package.json 里面写的依赖，一般都不会写死版本（这个我估计很多人都没有注意到），例如下面这个片段 1 2 3 4 5 6 7  { &amp;#34;crypto-js&amp;#34;: &amp;#34;^3.1.9-1&amp;#34;, &amp;#34;geodesy&amp;#34;: &amp;#34;^1.1.2&amp;#34;, &amp;#34;immutable&amp;#34;: &amp;#34;^3.8.2&amp;#34;, &amp;#34;moment&amp;#34;: &amp;#34;^2.19.1&amp;#34;, &amp;#34;react&amp;#34;: &amp;#34;16.5.0&amp;#34;, }      里面 geodesy 写的是 ^1.1.2 表示的是最低是这个版本，小版本号可以比这个大。 react 是写死版本号的。版本号不写死会产生一个问题，每次新安装的时候，如果有了新版本，那可能就会安装新的版本。即使你把自己的依赖都写死版本号也没有用，你依赖的依赖可能还是没有写死的。这样怎么办？  NPM 提供了 npm.lock 来管理版本，第一次使用 npm 安装的时候，会自动产生一个 npm.lock ，后面每次执行安装的时候，会根据这个里面规定的版本号来安装依赖。这样基本可以保证总是一样的版本。但是早期我使用 npm 的时候有一个问题，执行安装的时候居然还会修改 npm.lock ，我记得是会改里面的 hash 值，即使影响不大，但是每次提交修改 review 的时候都需要看看这个里面的东西就有点恶心了。所以后面我们换了 yarn，yarn 使用的是 yarn.lock 他执行安装的时候不会修改这文件里面的东西。（npm 我之后就没用了，所以后面讲的主要以 yarn 为准。）这样有了 lock 文件之后，表示所有依赖都有了确定的版本。  那么如何升级其中某一个依赖呢？方法很简单，删除 yarn.</description>
    </item>
    
    <item>
      <title>Best Pratice for Celery</title>
      <link>https://wdicc.com/best-pratice-for-celery/</link>
      <pubDate>Wed, 17 Jul 2019 15:27:48 +0800</pubDate>
      
      <guid>https://wdicc.com/best-pratice-for-celery/</guid>
      <description>Celery beat and worker   Celery works with two separate parts, the beat and the worker. The beat is the control center which determine when and where to send the tasks, there should be only one beat in each celery network. The worker is the one who runs the tasks and send the results back to the beat, there could be lots of works in each network. Result backend   Result backend is the place where task results stored.</description>
    </item>
    
    <item>
      <title>Use Anki to Leaning English</title>
      <link>https://wdicc.com/use-anki-to-leaning-english/</link>
      <pubDate>Wed, 17 Jul 2019 11:36:20 +0800</pubDate>
      
      <guid>https://wdicc.com/use-anki-to-leaning-english/</guid>
      <description>Anki 很早以前就听说了，是一款帮助你记忆东西的软件。  教小孩子的时候，一般不是会有一些卡片么，正面是一个字，比如 虎 背面是一个老虎的图像，这样帮助小孩识字。这种叫做 flashcards 。Anki 提供的就是制作并使用这些 flashcards 来帮助你记忆。  所以广义上面讲，Anki 不止可以用来记忆单词，比如学中文老外可以用来记忆中文，学物理化学的记忆各种公式什么的。正面放需要理解学习的东西，反面放帮助记忆的东西。  Anki 神奇的不是因为可以制作任意的记忆卡片，主要是他的针对所谓的遗忘曲线来学习的套路。所谓遗忘曲线，复杂的逻辑我也没看过，简单的用方便理解的方法来讲，比如我们背单词的时候，刚背玩 1 分钟内，通常是记忆最深刻的，10 分钟后就会有一些模糊了，1 天后可能就会忘记很多今天已经记住的单词了，此后不及时复习的话，你会发现下次再见到和第一次见到没什么区别，完全就是个新的单词一样。这个就是说，随着时间遗忘一个东西的速度会越来越快。  我之前使用百词斩背单词，它把单词都做了的图形化的提示信息，这个非常有助于记忆，我非常喜欢这点。他的工作模式是，每天设定一个目标，比如 20 个单词吧，那今天的任务就是复习昨天的 20 个单词，以及学习今天的 20 个单词，每天都这样一个模式。记得我前面说的遗忘曲线了没，这样的模式你会发现，这两天记忆好的单词，下个月可能就基本不记得啥意思了，和没学一样。而百词斩似乎提供了一些你自己复习的途径，不过我目前没找到合适的方式使用。百词斩对于新的单词，会提供三遍机会学习，第一遍是单词+图片，第二遍是单词+释义，第三遍是根据释义选单词。在每一遍里面，如果你选错了，那就会再出现一遍相同的题目。对于熟悉的单词，还提供了一个 斩 的选项，斩掉的单词就不会在出现了，你再也没有机会看到这个词了。百词斩还有一个问题是，因为他是选项模式，实际上那些选项也是一个提示，你可以使用排除法来选择答案，所以这些东西有时候会让你觉得你记住这个单词了，但实际上这个单词单独出现的时候不认识。  Anki 的工作模式是这样的，也是每天设定一个目标，比如新学 20 个单词。那今天你需要记忆的单词就包括了今天 之前 所有需要今天 review 的单词，和今天新的 20 个单词。新的单词没什么好说的，那 review 的单词是怎么构成的呢？当出来一个单词的时候，你根据自己的记忆情况，需要在单词下面的选项选择打算多久之后 review 他，选项按照单词被 review 的次数和你选择的 review 的情况来的，比如新单词的选项是 again 1m, good 10m, easy 1d, 如果你觉得这个词你不太熟悉，你可以从 again good 里面选一个，它会持续的在今天的学习里面出现，直到你觉得认识了，那就选 easy ，那这个词今天就不会出现了，会在明天的 review 里面出现。到了明天，这个词再次出现的时候，选项就变成了 again 10m, good 1d, easy 10d (具体选项我没记住，这里举个例子)，这个时候，如果发现这个单词忘记了，那就继续 again again 的选择直到你觉得记住了，根据你自己的感觉，选择 good 还是 easy ，这样会决定他下次是什么时候出现。类似这样，单词你越熟悉，他出现的次数就会越少，而且你也完全不用担心这个单词会不会你只是现在觉得认识了，后面过 1 个月又忘记了怎么办，那放心这些单词会持续出现的。  事实上，Anki 的设计不止这些。在设置里面还有一些因子，这些会影响出现的选项的时间。具体可以看后面提到的视频。使用 Anki 的时候，基本用法如下：    一个新的词，如果已经认识，那选择 easy 就好了。如果不认识，那根据情况选择 1m 或者 10m ，一般看到一个词一点都不认识的时候，多选几次 1m 加深一下印象，然后选择 10m 看是不是记住了，然后可以往复的选择 1m 和 10m 直到你觉得今天没必要看这个词了，那选择那个 1d 。    一个需要 review 的词，如果发现没记住，那就选 1m 让他进入和新词一样的逻辑，直到最后选择 1d 。    如果需要 review 的词你知道意思，这个时候有几个做法    这个词确实很简单，那继续 easy ，让他更少出现。    这个词有一点难度，是你新学的，但是基本也还能知道怎么回事，那可以选择 good ，让他适当的没那么少出现。    对这个词的部分释义不清楚，没记住，那可以酌情选择 hard ，让他增加出现的机会。      Anki 有一个问题是，随着你学习的新单词越来越多，那需要 review 的单词也越来越多，尤其当你偷懒几天没打开软件，巨大的 review 数量可能会让人崩溃。设置里面可以设置每天 review 的最大数量，默认是 200，如果自己实在不能 review 完可以改一下。我现在设置是 200，每天新词 20 个，看着情况是每天基本是需要处理 60 个词左右。只要持续每天清理就也还好。其实一天那么多时间，大可以利用碎片时间看看，也别担心自己实际没记住但是按了 easy 的情况，后面还会出现呢，后面出现的时候再好好记也可以。  Anki 还提供了一自定义学习模式，每天 Anki 不是会自动安排任务么，如果一天的任务完成后，还想多学习一些，那 Anki 提供了一个自定义学习模式 Custom Study。点击这个之后，需要你选择想学习什么，可以学习新的单词，也可以复习之前学过的，按照你自己的情况选择就好。选择之后，一些卡片就会添加到那个 Custom Study Session 这个 deck 里面。卡片到这个 deck 之后，如果你学习完毕就会都归还到原来的 deck 里面，也可以点那个 Empty 自己都清空。这个 deck 里面有两个设置比较重要，一个是 Step，我看默认是 1 分钟，这个和前面那个 step 是一个意思。还有一个是 Reschedule cards based on my answers in this deck，如果不选中这个，那一个卡片学习完毕之后，会有两个选项一个是 again 一个是 good ，选 good 会结束这个卡片的学习，不会对原来的 deck 里面对这个词的安排有什么影响。如果选中这个选项，那选项会有一个 good(n day) 这样的，点击之后实际会影响原来 deck 里面对这个词的规划。  这里有一个对 Anki 的设置和工作模式的详细的解说，有兴趣可以看看。 2019.</description>
    </item>
    
    <item>
      <title>English Learning Notes From Culips</title>
      <link>https://wdicc.com/english-learning-notes-from-culips/</link>
      <pubDate>Mon, 08 Jul 2019 14:33:00 +0800</pubDate>
      
      <guid>https://wdicc.com/english-learning-notes-from-culips/</guid>
      <description>Here is the podcast, I take some notes from it, it&amp;#39;s really helpful if you try to leaning English. I recommand you that listen the podcast yourself multiple times. What the Mass Immersion Approach is     learning 3 to 6 hours a day, and listen in background when cooking, cleaning.    Compare yourself to yesterday, don’t try to compare yourself to other people.   What’s more important input or output?</description>
    </item>
    
    <item>
      <title>Logging in Celery and Django</title>
      <link>https://wdicc.com/logging-in-celery-and-django/</link>
      <pubDate>Fri, 05 Jul 2019 14:26:24 +0800</pubDate>
      
      <guid>https://wdicc.com/logging-in-celery-and-django/</guid>
      <description>Get celery work with django   Celery can work with django, it&amp;#39;s very simple. 1 2 3 4 5 6 7 8 9 10 11 12 13  from __future__ import absolute_import import os from celery import Celery from django.conf import settings # set the default Django settings module for the &amp;#39;celery&amp;#39; program. os.environ.setdefault(&amp;#39;DJANGO_SETTINGS_MODULE&amp;#39;, &amp;#39;your_app.settings&amp;#39;) app = Celery(&amp;#39;you_app&amp;#39;) # Using a string here means the worker will not have to # pickle the object when using Windows.</description>
    </item>
    
    <item>
      <title>Fullstack Engineers</title>
      <link>https://wdicc.com/fullstack-engineers/</link>
      <pubDate>Wed, 03 Jul 2019 10:17:53 +0800</pubDate>
      
      <guid>https://wdicc.com/fullstack-engineers/</guid>
      <description> 199x 年左右我初中，那会普遍流行的还是 dos 系统，公众对计算机的理解也就是一个打字设备，代替以前用油墨的方式印刷的。我有一个舅舅，那会大学（应该是专科）已经毕业了，他在青岛那边学习的就是计算机相关的专业，回我们那边之后分配到了一个公家单位，主要的工作也是打字。  dos 下面制表用 CCED，录入用五笔，还有 UCDOS 之类的中文 console。那个时候流行的就是学习五笔，然后就是录入软件制表软件这些。  那个时候我就表现出了对这些事情的兴趣，自己背五笔编码码，练习五笔，还学自己习过 foxbase。很多的银行的那种黑窗口操作界面就是基于 foxbase 的。那会玩的比较多的游戏是仙剑和红警。  不过那个时候基于公众对这个东西的认识就是打字，以及游戏，所以基本很不看好这样的一个职业。农村人报考大学的时候优先还是财经什么的觉得似乎可以有铁饭碗的专业。  我那会找了一本 foxbase 的书自己看，里面也有编程的部分，基本上第一章我就看不下去了。对于 a = 1 + 2 这样的表达式我还可以理解，但是对于 a = a + 1 这样的我就理解不能了，也没有人可以去问，所以当时第一章后面有一道题目是计算 1 到 100 累加的结果，我就想破头都想不明白除了一个一个加还有什么简单的方法，递归什么的就更加不明白了。这样基本就卡第一章了。  上了大学之后，开始学 c 语言有机房，就各种控制不住了，自从去机房学会了 MUD 有一段时间玩的废寝忘食的，为了一直占着机器，还需要同学中午给去送饭，一呆就是一天。  不过业余时间也还是学习了一些其他知识的，分区装系统，做网页。最开始是联系了一个书商出一套 Office 之类的书，我们的做法就是找几本其他书拿来抄一下，所以那会也叫攥书，而这些书主要的卖点也就是针对最新的版本，也不像是 C 语言那样谭浩强有绝对的权威，所以基本上都是这么个模式，我后面带动了全班很多同学攥书，我们宿舍的几个都搞了几本书，赚个零花钱。后面还搞了一些做网页的书什么的。  毕业的时候找工作，赶上互联网第一波泡沫，我们专业还是非 CS 的，所以找相关工作不好找，我拿到 2 个 offer，一个是相对来说还和专业挂钩，是搞集成电路的，另一个就是出版社，为了北京户口，选择了出版社。  出版社做编辑和写书不一样，而且发现本身也还是对技术工作感兴趣，所以慢慢的开始把办公室的网络维护什么的接管了。国企里面都是多一事不如少一事，我主动承担其他人巴不得呢。利用空闲时间，搞了一台 pc，把出版社的邮件服务器用 Qmail 自己搭了一个，还有出版社的网站也自己写了一个 demo，那会购买还没这么方便，需要自己去银行汇款的。像什么反垃圾邮件，防火墙什么的这些都折腾折腾。还试过 freebsd，发现没有 rh 好玩。  这样搞了几年，自己也觉得没什么意思了。就从出版社出来了。找了一个上地那边的搞外包的公司。当时面试的是一个台湾人，还挺有好感的。去了之后发现是 it 部门，那台湾哥们搭了一个 openldap 觉得挺嗨，我觉得好像也没啥，自己弄了一个虚拟机花了几天弄了一个类似的出来。后面干了1，2周之后，对方觉得我不合适，干活干不到正点上面，弄的我也很郁闷，因为没人和我说过需要做什么，我就只好干点看到的力所能及的。  期间也面试了一些比较好的单位，但是都是因为经验不足没搞定，因为我毕竟之前就是业余的维护一台我自己搞的服务器而已。  后面换了一家做手机 SP 服务的，就是提供一些彩铃啊，wap 站什么的。过去做运维人员，这个岗位只有一个人，我去的时候前一个要离职了我过去接手，而那个人也是接手没多久，所以后面出一些问题的时候我还时不时得找第一个人。这家我去的时候还有几十台服务器，奈何这个行业慢慢的不行了，服务器基本在慢慢回收中。来了这里之后自己也开始思考这么多机器如何运维的问题，包括监控，备份什么的。后面自己搞了 nagios，写了一个通用的监控脚本，还自己给一台办公室服务器接了一个插卡的猫用来发报警短信。用这个猫还做了简单的可以交互的小工具，比如查天气，重启服务什么的。  基本上来了半年多把监控什么的梳理好了，因为业务萎缩的缘故，平时就没什么事情了。后面就是学习 shell 脚本什么的，学了一些编程的东西。慢慢没意思之后，一个朋友推荐去 yahoo 做运维。去他们部门面试没通过，后面换了一个其他部门通过了。  去了 yahoo 之后才明白大厂是怎么搞运维的，各种工具，分工。也是梳理清楚这边的监控之后，没事情做了，开始参与写程序。那边用的很多工具都是 perl 写的，似乎大部分牛逼的都是老美弄的，中国这边就是用户，很多东西出了问题都需要和老美沟通解决。  在那边后面有一段时间 leader 是一个 oracle DBA，所以慢慢的也开始接触了一些 oracle 的东西，学习了一下 SQL。那会我们部门有职位就是做统计需求的，解决方式就是写一堆 shell 脚本和 SQL。所以后面有岗位变化的时候，我就鬼使神差的去搞统计去了。因为似乎并不难做。  这样后面 yahoo 中国完蛋到了淘宝量子统计的时候，也就不做运维了，开始做统计，学习 hadoop，hive 这些，那会还看了一段时间的遗传算法，当时是想在业务里面用来尝试推断用户喜好的。后面因为打算给当时的网站功能改版，因为小团队，也没几个人，所以统计做完之后，又开始参与网站的开发，写 javascript。又了解了一堆 jquery 的东西。  之后到了去哪儿之后，开始继续搞统计觉得没什么意思，就开始搞广告系统开发。因为我知道一个公司的广告部门是最爽的，赚钱哗哗的，成本还不被人注意。这个系统当时我们好几个人一起弄的，技术方面使用了 perl，python，lua，c，SQL，java，开发的时候大家各自用自己擅长或者这个领域比较省事的技术做的，开发好之后大家把对接到一起。  这个系统后续的问题也很明显，其中某个组件有问题的时候，如果负责人不在，那其他人比较难搞。这个系统随着人员变更，慢慢的就变的比较难维护了。当然我觉得比较难的原因不是系统设计的问题，是因为后续维护人员的技术能力问题。但是国内公司能持续的有那么厉害人做这个事情恐怕也不多，一般优秀的会慢慢的上升离开。  这样在去哪儿这边我慢慢的开始负责数据库维护（因为我有一些运维经验），移动端的服务 APP 和网站（因为当时没有其他人做，我牵头做的），广告系统（因为其他人慢慢的离开流失，这系统慢慢的也就我比较熟悉全部组件的运作逻辑了），一些数据统计工作（因为我以前做过这个方面的事情）。  所以离开去哪儿的时候，我基本上各方面的事情都捣鼓过，各方面都清楚一些，比初学者肯定是知道的多，但是我自己认为都不算是专家。我是属于把技能树点乱的类型，没有在一棵树下面持续挖掘，而是种了一堆树。当然这也可以是某种职业生涯发展的方向，这样的人也不是说在这个社会找不到可以发挥的地方。  乱糟糟回忆了一堆，主要是想说，知识都是相关的，很多时候如果你想做好一个事情，你可能是必须要弄明白他周边的另外十个，而这个时候你可能都不是专家。  比如就算做运维，简单的时候可能使用好别人写好的工具就可以了，但是一旦遇到问题自己又没有 debug 代码的能力，那么只能去求助能看懂代码的人，这个时候就很低效。  比如从开发角度看，语言使用比如用 django 写个 view 什么的，元类，装饰器，迭代器，多线程这些，必要的时候还需要使用 c 封装一些调用提升速度。还需要了解数据库，model 和数据库的关系，数据库自己的特性，索引，约束，联合查询，聚合这些。写好代码还需要了解持续集成，发布回滚环境区分，自动化测试。发布之后，如果想要服务稳定，还需要弄明白负载均衡冗余，数据库备份，主从，数据库出问题了恢复，DNS 切换。如果往深了研究，这里面每一个点都可以有那么一位专家来研究，我觉得一个人是不可能把这些东西都弄明白的，弄明白也就是皮毛。  所以全栈？呵呵，我理解的全栈是不可能有人做到的。知识迭代这么快，就算有人现在大致都弄明白了，他如果不持续的在各方面更新的话，很快也会再次落伍。  不过倒是可以有专家/科学家工程师，就是某一个领域研究比较深入的人，比如看过 python 源码，发过补丁，可以按照自己需求去实现 python 垃圾回收功能等等。不是停留在应用使用上面，或者参与过现有框架的一些开发等。这样的人通常不管去哪个领域，给一些时间都可以比较深入的进入钻研。 </description>
    </item>
    
    <item>
      <title>How Does Https Actually Work</title>
      <link>https://wdicc.com/how-does-https-actually-work/</link>
      <pubDate>Thu, 27 Jun 2019 17:44:52 +0800</pubDate>
      
      <guid>https://wdicc.com/how-does-https-actually-work/</guid>
      <description>翻译自 How does https actually work 。  HTTPS is simply your standard HTTP protocol slathered with a generous layer of delicious SSL/TLS encryption goodness. Unless something goes horribly wrong (and it can), it prevents people like the infamous Eve from viewing or modifying the requests that make up your browsing experience; it’s what keeps your passwords, communications and credit card details safe on the wire between your computer and the servers you want to send this data to.</description>
    </item>
    
    <item>
      <title>Django Testing</title>
      <link>https://wdicc.com/django-testing/</link>
      <pubDate>Wed, 19 Jun 2019 15:38:56 +0800</pubDate>
      
      <guid>https://wdicc.com/django-testing/</guid>
      <description>Django 自己的 unittest 支持的挺好，一般只需要在 app 下面加一个 tests.py 在里面写 case 就可以了。case 对应的类继承 django.test.TestCase 就好。  这个 django.test.TestCase 继承自 unittest.TestCase ，django 这个多了一个自动使用事务的功能，所以用 django 这个的话，每个测试用例执行前后会自动回滚数据库操作，这样不用你自己 cleanup 数据，还比较方便。 setUp 和 tearDown   每一个测试类里面，都可以有一个 setUp 方法，是在 case 方法执行前执行，例如一些准备工作，和一个 tearDown 方法，在 case 执行之后执行，例如一些清理工作。还可以有若干个使用 test_ 开头的测试用例，这些 setUp 其实类似于把每个测试用例里面共同的部分提取出来一样，不过是不用你在每个 case 里面单独调用了，会自动处理。 setUpClass 和 tearDownClass   django 还提供了 setUpClass 和 tearDownClass ，类似上面的 setUp 方法，不过这个是每个 class 只会执行一次。另外按照这里的说法， setUpClass 不会使用事务，不过我看源码(django 2.1.4) 好像是会的，我没测试。。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  @classmethod def setUpClass(cls): super().</description>
    </item>
    
    <item>
      <title>Add Disk for Aws</title>
      <link>https://wdicc.com/add-disk-for-aws/</link>
      <pubDate>Wed, 19 Jun 2019 15:29:33 +0800</pubDate>
      
      <guid>https://wdicc.com/add-disk-for-aws/</guid>
      <description>AWS 的 ec2 支持不停机扩展磁盘，体验还不错，记录一下操作。  先看看磁盘是不是支持，例如下面的 GPT 的是支持的 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  $ sudo gdisk -l /dev/xvda GPT fdisk (gdisk) version 0.8.10 Partition table scan: MBR: protective BSD: not present APM: not present GPT: present Found valid GPT with protective MBR; using GPT. Disk /dev/xvda: 20971520 sectors, 10.0 GiB Logical sector size: 512 bytes Disk identifier (GUID): 826F22DD-540A-4299-AB06-F03EE98F1CAF Partition table holds up to 128 entries First usable sector is 34, last usable sector is 20971486 Partitions will be aligned on 2048-sector boundaries Total free space is 2014 sectors (1007.</description>
    </item>
    
    <item>
      <title>Debuging Django</title>
      <link>https://wdicc.com/debuging-django/</link>
      <pubDate>Mon, 29 Apr 2019 14:41:12 +0800</pubDate>
      
      <guid>https://wdicc.com/debuging-django/</guid>
      <description>起初 hackernews 看到一个文章 PySnooper: Never use print for debugging again，觉得挺有意思的，结果把 hackernews 的讨论看了一下发现有意思东西更多一点，总结一下。    PySnooper: Never use print for debugging again，只需要给函数加一个装饰器，就可以把函数执行的每一步的结果都打印出来。    django-extensions 的 runserver-plus 配合 Werkzeug 可以实现在遇到异常的时候，支持在 web 上面调试代码，打印异常的时候的上下文内容什么的。    Python 自己的 breakpoint 函数，执行到的时候默认会进入 pdb.set_trace() 状态方便你进行上下文调试。    icecream 提供了一个方便的 ic 函数，可以无感的加入到你的代码里面，不影响你的代码的执行结果，但是会打印传给它的参数和执行结果。    Behold: A debugging tool for large Python projects，可以替代你写冗长的打印命令。不过感觉它自己的语法似乎也并不方便。。。    VS Code 提供的 Logpoints 和 Visual Studio 提供的 Break When Value Changes。    stackprinter 可以让你的堆栈打印更友好，打印堆栈的时候还可以输出上下文的取值。    pdb, epdb，ipdb, 应该都是类似的东西，其中 pdb 是自带的。通过给代码增加 import ipdb ipdb.</description>
    </item>
    
    <item>
      <title>How to Create an Index in Django Without Downtime</title>
      <link>https://wdicc.com/how-to-create-an-index-in-django-without-downtime/</link>
      <pubDate>Fri, 26 Apr 2019 11:46:27 +0800</pubDate>
      
      <guid>https://wdicc.com/how-to-create-an-index-in-django-without-downtime/</guid>
      <description>django 自己带了一个 ORM 实现，基本可以通过 ORM 管理数据库，这样用户可以在不会 SQL 的情况下使用数据库。在对 model 的属性（字段）做了修改之后，通过执行 makemigrations 可以生成一个 migrate 文件，然后执行 migrate 命令可以把这些修改应用到数据库。同时在数据库里面，也会记录当前 migrate 执行的状态，这样能保证数据库的状态和 django 自己认为的数据库的状态是一致的。  但是这里可能会有一个问题，我们有多个数据库环境，也有多个人一起开发，这样就会导致这个有点混乱，多个人修改 model 后都执行了 makemigrations 的话，可能会有冲突和问题（实际上 django 已经考虑过这个问题的，migrate 文件都是按照时间戳来命名的，冲突可能性也不大，但是为了避免新手加入弄不好，所以我们采取了另外一个方法做这个事情）。  下面的内容翻译自 https://realpython.com/create-django-index-without-downtime/ ，我们使用了里面提到的 sqlmigrate 的方式。  管理数据库变更在软件开发中是一个比较大的挑战。幸运的是，从 django 1.7 开始有了内置的数据库变更处理框架。这个框架对于处理数据库变更来说很强大很好用。但是为了保证框架提供的灵活性，有一些妥协在里面。为了理解 django 数据库变更框架的限制，我们将解决一个有名的问题：如何在不停机情况下通过 django 创建索引。  在这个教程里面，你将学习到：    django 是什么时候和如何产生数据库变更的    django 是如何执行变更的    如何按照需要编辑这些变更    这篇文章面向的是对 django 数据库变更（migrations）已经有所了解的人的。如果对这些还不了解，那可以先看看 Django Migrations: A Primer 。 在 django 里面创建索引存在的问题   一个常见的变更是当你的数据增加的时候会需要建索引。索引可以查询的速度和应用的响应速度。  大部分数据库里面增加索引需要在表上面加一个排它锁。当索引创建的时候，排它锁不允许进行数据修改（DML）操作，例如 UPDATE, INSERT, 和 DELETE 。  当数据库执行这些操作的时候，会立刻加锁。例如如果一个用户登录的时候，django 会更新 auth_user 表的 last_login 字段。为了执行这个操作，数据库会先请求一个行锁，如果这行被其他连接加了锁，那你可能会得到一个数据库异常。  锁表会让系统在做变更的时候不可用。表越大，创建索引的时间越长，系统不可用时间越长。  一些数据库提供了不锁表建索引的方法。例如，在 PostgreSQL 里面可以使用 CONCURRENTLY 关键字： 1  CREATE INDEX CONCURRENTLY ix ON table (column);     在 Oracle 里面，有一个 ONLINE 选项允许在创建索引的时候执行 DML 操作： 1  CREATE INDEX ix ON table (column) ONLINE;     在生成数据库变更的时候，django 不会使用这些关键字。执行这些变更创建索引会导致数据库增加表的排他锁，而阻止 DML 操作。  异步创建索引也有一些潜在的问题。最好提前了解一下自己数据库可能存在的问题。例如，在 PostgreSQL 里面异步创建索引的时候时间会比较长，因为它需要对表做一些额外的扫描。  这篇文章里面，会使用 django 的数据库变更在一个大表上面创建索引而不会带来停机时间。 配置   这里将在一个叫 app 的应用里面使用一个 Sale 模型。在真实世界，类似 Sale 这样的模型一般是数据库的主要的表，会存储大量的数据。 1 2 3 4 5 6 7 8 9 10  # models.</description>
    </item>
    
    <item>
      <title>Readings</title>
      <link>https://wdicc.com/readings/</link>
      <pubDate>Fri, 19 Apr 2019 15:38:57 +0800</pubDate>
      
      <guid>https://wdicc.com/readings/</guid>
      <description> ﻿1984 ([英] 乔治·奥威尔)   这书看完我觉得这根本就是一本恐怖小说，当里面的内容正在和将要发生的时候你就不会觉得里面的描述有点搞笑了。不过看到后面有译者的补充内容说和其他国家的朋友讨论的时候，大家都会有各种不同的带入感，觉得也挺有意思的。这可能是所谓的普世价值吧，大家都觉得不应该这样。 1  思想罪可是件要不得的事情，老兄，”他庄重地说，“它很阴险。你甚至还不知道发生了什么事，它就抓住了你。你知道它怎样抓住我的吗?在睡梦里!     这里是温斯顿一个朋友讲他怎么被抓的，因为说梦话说了一些不该说的，被女儿举报。。。 1  谁能控制过去就控制未来;谁能控制现在就控制过去     拗口么，控制了现在就可以（通过修改历史）控制过去。 1 2 3  不是!不光是要你们招供，也不光是要惩罚你们。你要我告诉你为什么把你们带到这里来吗?是为了给你们治病。是为了使你神志恢复健全! 温斯顿，你要知道，凡是我们带到这里来的人，没有一个不是治好走的。我们对你犯的那些愚蠢罪行并不感到兴趣。党对表面行为不感兴趣，我们关心的是思想。我们不单单要打败敌人，我们要改造他们。你懂得我的意思吗?“     犯了思想罪的人都病了，需要治。 1  党越有力量，就越不能容忍;反对力量越弱，专制暴政就越严。果尔德施坦因及其异端邪说将永远存在。    1Q84 (村上春树)  1  姑且礼貌的问问。可是希望得到回答的哟。嘴不利索的话，点头或者摇头。     这个书是看完上面的 1984 之后翻的，看了第二章感觉就有意思起来了，很会通过故事吸引人。不过这个书里面的隐喻实在好难懂啊，看别人的书评才能理解一些，可能作者厉害的地方就在这里吧。。。 伟大的博弈:华尔街金融帝国的崛起(1653～2011)(珍藏版) (约翰·S·戈登)   这本书几乎是从美国建国讲起，讲到后面华尔街兴起，以及美国的金融市场是怎么一步一步发展起来的，华尔街的起起落落，和看故事书一样。 1  作为新兴工业经济基石的钢铁也彻底改变了华尔街的外观。许多建于19世纪50年代的陈旧的6层小办公楼被一一推倒，让位给“摩天大楼”（skyscraper）——这个词在1883年才被创造出来。钢铁建材的出现和电梯的发明使摩天大楼成为可能，而纽约狭小的城市面积更使得摩天大楼的大量出现不可避免。纽约古老街区里窄窄的街道从此开始熟识摩天大楼巨大的投影和楼宇之间漏出的些许阳光。这种趋势引起了市民和市府官员们的警觉，当40层的“衡平保险公司大厦”（Equitable Building）在雪松大街和青松大街之间的百老汇上开始建造时，它严严实实地占据了整个街区，这直接导致美国第一部城市规划条例的颁布。就像快餐一样，城市规划条例也发源于华尔街。事实上，美国文化中很多与金钱无关的传统都与华尔街有关。     一些美国的文化据说是发源于华尔街，比如快餐是因为股价上下波动很快大家忙到没时间吃饭，所以有了快餐。。。城市规划是因为华尔街发展太快不得不开始进行必要的规划。。。 1  荷兰人早在导演和参与“郁金香泡沫”时练就的投机技术，很快就被运用到了北美新大陆。发生在这块处女地的第一次金融投机活动是针对当时原始的货币——贝壳串珠进行的投机，这次金融投机揭开了北美350年的金融史——同时也是350年的投机史的序幕。这些投机技术在以后的历史中被反复应用，投机者们沉溺其中，乐此不疲。     从郁金香泡沫开始讲投机，囤积贝壳让贝壳价值上涨获利。 1  荷兰人发明了最早的操纵股市的技术，例如卖空（short-selling，指卖出自己并不拥有的股票，希望在股价下跌后购回以赚取差价）、“洗盘”（bear raid，指内部人合谋卖空股票，直到其他股票拥有者恐慌并全部卖出自己的股票导致股价下跌，内部人得以低价购回股票以平仓来获利）、对敲（syndicate，指一群合谋者在他们之间对倒股票来操纵股价），以及逼空股票（corner，也称杀空或坐庄某一只股票，或囤积某一种商品，指个人或集团秘密买断某种股票或商品的全部流通供应量，逼迫任何需要购买这种股票或商品的其他买家不得不在被操纵的价位上购买）。    1  （这种总是期望有人会愿意出价更高的想法，长期以来被称为投资的博傻理论）    1  。这时候菲利普斯开始买进贝壳串珠，并囤积起来。实际上，他把贝壳串珠装在桶里埋在地下，以减少贝壳串珠的流通量。几周之内，他就控制了串珠市场，成功地抬高了价格。到1666年，3颗白串珠就相当于1个斯图弗。     控制市场上面的量，控制价格。 1  最常见的铸币是西班牙的里亚尔银币（Spanish real），经常被切成2块、4块、8块来找零钱。这就是为什么直到今天，纽约证券交易所还是以一美元的1/8为最小单位来报价，而不是1/10。    1  到18世纪90年代，尽管费城的发展速度远远低于纽约，但它依然是那时美国的金融中心。美国的第一家银行——北美银行（Bank of North America）是在费城成立的；美国的第一家证券交易所——费城证券交易所（Philadelphia Stock Exchange）在1790年成立。在此后的10年内，费城仍然是美国的首都，而华盛顿那时尚在建设之中，因此，汉密尔顿的中央银行——美国银行（Bank of the United States[35]）也于1791年在费城成立。     早期的时候，费城是金融中心，纽约还排不上号。 1  ·资本市场的繁荣催生了第一批专业的证券经纪人，他们需要一个专用的交易场所；为了防止在门口偷听价格“搭便车”的场外交易发生，也为了防止经纪人们无休止地杀低交易佣金，他们签订了著名的《梧桐树协议》——这一向被认为是纽约交易所的源头，而本质上是一个卡特尔——价格同盟。     开始的时候证券交易是小部分人聚集起来做的一个事情，他们为了保证自己的佣金利益，搞了这个协议，很多年之后（似乎是19xx年）才放开佣金，那会都是固定佣金。 1  ·在这一时期，有限责任制度——现代企业制度的基石得以奠定，美国各州通过了《普通公司法》，带动了新一轮的经济增长，从1792年到1817年，联邦税收在25年内增长了9倍。     公司法颁布之前企业都不能像人一样拥有自己的财产。 1  18世纪末期，经纪人这个概念的含义要比今天宽泛得多。这个词早在14世纪就从法语引入到英语中，它的法语原意是：把一桶酒分装成一杯一杯或一瓶一瓶后再卖出的人。在17世纪之前，这个词一直特指零售商和批发商，此后，它就完全被用来特指自己不直接参与生产的中介人。到这个时期，“经纪人”的含义逐渐演变为：将买方和卖方撮合在一起，并对促成的交易收取佣金的人     broker 这个词在计算机领域也有，做代理，分发这类事情的，叫做 broker。 1  美国银行股票（很快被简称为“BUS”）的交易在1791年春就已经开始了。这一年7月，该股票正式认购时，在一小时之内就全部卖光，随后股价一路攀升。这个新生国家的第一次大规模的股票公开发行（IPO）启动了它的第一轮牛市。    1  股票的含义才被特指为代表所有权的证券，而债券被特指为代表债权的证券    1  《梧桐树协议》。这被公认为是纽约证券交易所的最初起源，但本质上却是一个经纪人的卡特尔，纽约证券交易所的这一本质直到180多年后才得以改变。    1  ”杰斐逊一向痛恨投机者，此时几乎掩饰不住自己的兴奋，他算了一下，投机者损失总值达到了500万美元，这相当于当时纽约的房地产总值。他的结论是，股市恐慌所带来的损失跟自然灾害摧毁纽约所带来的损失是一样的。     股市恐慌带来的损失也会很大。带来失业，市场不景气，各种连锁反应。 1 2 3 4 5 6  投机一直是一个颇受争议的名词，至少在华尔街以外的地方是这样。投机者经常被看成是资本主义市场发展进程中的寄生虫，他们并不创造财富，但却能从中谋利 投机有助于确保市场产生最公正的价格 另外，投机很像色情，给它下个定义或许很难，但明眼人却一眼就能辨别出来。正如20世纪初伟大的英国金融家欧内斯特·卡塞尔（Ernest Cassel）爵士所说：“当我年轻的时候，人们称我为赌徒；后来我的生意规模越来越大，我被称为一名投机者；而现在我被称为银行家。但其实我一直在做同样的工作。”     有投机机会会带来交易量，这样会有博弈，所以有助于确保公平。 1  一些债券以可转换债券的形式发行（意味着债券持有者可以根据需要把它们转换成股票），有一批可转换债券甚至允许持有人随心所欲地在债券和股票之间来回转换，这在华尔街的历史上是绝无仅有的，这种特性使它成为近乎完美的投机工具。     股票上涨的时候，换成股票兑现，股票下跌的时候，换成债券又会保值。 1  [91]格雷欣法则（Gresham’s Law），指使用者保留贵重的货币，而优先选择使用价值低的货币。托马斯· 格雷欣（Thomas Gresham, 1519~1579），英国金融家，皇家证券交易所（Royal Exchange）的创始人。—译者注     也就是劣币驱逐良币。因为保值的东西不容易贬值，而不保值的东西最好尽快兑现，要不可能过几天就不值钱了。所以会保留良币，使用劣币，这样市场上就只能看到劣币了。 1  1861年　美国南北战争爆发。    1  从私募走向公募：传统上，政府为战争进行融资，主要依靠征税和大量印钞，这是南北方政府同时能想到并做到的。而华尔街上年轻的银行家——库克为北方政府所做的是南方政府所没有想到的。他没有采用传统上私下向银行和经纪商出售债券的方式，即私募发行，而是革命性地通过华尔街向公众发售战争国债，即公募发行。他告诉普通美国人，购买这些战争债券不仅是一种爱国的表现，也是一笔很好的投资。到战争后期，库克出售国债的速度已经超过北方政府为战争花钱的速度。而与此同时，严重依赖印钞票支付战争费用的南方政府，面对相对于战前高达9000%的通货膨胀率无奈地接受了战败的结局。     北方军有华尔街这些金融大鳄的点子和支持，很好的募集到了支持战争的钱，打赢了南方军。 1  1865年　南方邦联军投降，美国内战结束。不久，林肯遇刺。    1  1868年11月30日，两个交易所颁布了同样的监管条例，要求对所有在交易所拍卖的股票进行登记，并且，任何新股发行都必须提前30天通知交易所。     在这之前，企业几乎可以随意增发股票，所以没人知道一个公司在市场上到底有多少股票。这个简直不敢想，居然这会才规定。。。 1  对于研究华尔街的历史学家而言，道琼斯指数同样是无价的，因为它是现存最早的股票市场的连续平均指数，从1896年就开始有了记录。发明这个绝妙而又简单的办法的天才是查尔斯·道[130]，他也是《华尔街日报》（Wall Street Journal）的创办人之一。     道琼工业指数的诞生。。。。。这个哥们居然还是华尔街日报的创办人。。。。 1 2 3 4  意大利在15世纪文艺复兴时期出现了复式记账法（double-entry bookkeeping） 但是，由谁来作这个报告呢？公司内部的财务人员毕竟是为公司管理层工作，所以很难做到真正地独立。这时，独立会计师的人数迅速增加。1884年，在纽约、芝加哥和费城的商业电话簿上只能找到81个会计师，仅过了5年，这个数字就达到了322。1882年会计师及簿记师协会（Institute of Accountants and Bookkeepers）在纽约成立，并且开始向那些通过了严格考试的人员发放资格证书。1887年，美国公共会计师协会（American Association of Public Accountants）成立，它是现在美国会计行业管理机构的前身。1896年，纽约州通过立法奠定了这项职业的法律基础，并使用“注册会计师”这样一个称号来表示这些人是符合法律标准的会计师。纽约州的法律和“注册会计师”（Certified Public Accountant，CPA）这个名词马上也被其他州采用了。     股票价格是会和一个公司运营到底怎么样有关系的，公司运营的不好，股票自然会跌，但是这之前公司记账都是自己记的，那简直想怎么记怎么记。。。这会开始有了第三方的记账机构。。。 1  19世纪90年代　华尔街取得两大进步：股票市场平均指数和现代会计制度出现。    1  ·再一次，依仗摩根巨大的影响力，摩根和华尔街的银行家们阻止了这场可能将美国经济拖入深渊的金融恐慌。美国这个当时世界上最强大的经济实体，在危机中不得不依靠摩根个人来扮演中央银行角色，这一事实促成了美联储在1913年成立。这一年，成为美国金融历史的分水岭。     摩根牛逼到不行，各种救市，拯救美国经济。。。 1  这种不安远不仅限于华尔街，那年秋天，西奥多·罗斯福在麦金利死后继任总统，他坚信并提倡政府对经济的干预，以防止某些强大的经济力量变成政治上的霸权。当1904年美国司法部宣布按照《谢尔曼反托拉斯法案》（Sherman Antitrust Act）起诉并要求拆分北方证券公司（Northern Securities Corporation）时，J·P·摩根被惊得目瞪口呆。北方证券公司是摩根处理E·H·哈里曼和詹姆斯·J·希尔关于北太平洋铁路公司的经济纠纷而成立的一家公司。摩根火速赶到了华盛顿，想搞明白为什么西奥多·罗斯福不能像绅士之间的交往那样事先告诉他，以便私下里达成一个双方满意的解决方案。     反垄断。 1  中央银行的职能是监控商业银行，管理货币供应，同时在金融市场恐慌或银行危机时期担当最后贷款人（lender of last resort）的角色。     中央银行就是主持金融市场的，和。。救市的。。。 1  “经济学”在本质上是研究市场中人的学问     股票是人心的体现，贪念，欲望。。。 1  1913年12月23日，国会立法批准设立美联储，这一年成为美国金融史上的分水岭。    1  人类社会有一条铁律：在没有外来压力时，任何组织的发展都会朝着有利于该组织精英的方向演进。这条规律既适用于津贴丰厚的公司管理层，也适用于被领袖人物控制的工会，既适用于美国国会，也适用于好莱坞。     所以如果工人不罢工，那就只有可能被剥削的越来越严重，嗯，996。。。 1 2 3  在华尔街200年的历史上，不论出现过什么样的阴谋诡计，仍然有两条游戏规则从来没有被亵渎过。第一条是“成交了就是成交了”（A deal is a deal） 第二条同样神圣的规则是，私人契约的隐私权不受侵犯     这个是平等交易的基石吧。 1  ·1933年，美国取消金本位制，颁布《证券法》和《格拉斯-斯蒂格尔法》；1934年，美国颁布《证券交易法》；同年，依据该法成立了美国证监会；1940年，美国颁布《投资公司法》和《投资顾问法》。至此，美国资本市场在自我演进超过百年之后第一次出现了关于证券发行、交易和投资基金的法律，也第一次建立了监管机构，这一系列制度建设形成了现代金融体系监管的基本框架，也为随后几十年美国金融市场的发展奠定了基础。    1  5月27日，罗斯福签署了《联邦证券法》（Federal Securities Act），这是美国历史上第一部规范证券交易的法律，它要求所有的新股发行都必须在美国证券交易委员会（Securities and Exchange Commission，即美国证监会）注册，而且必须披露特定的信息。6月5日，国会取消了美国的金本位制，     进一步规范市场。 1  尽管惠特尼百般阻挠，罗斯福总统还是提交了一项法案，于是，惠特尼和交易所决定由他们自己动手先来改革华尔街上最有问题的那些行为。    1  1934年2月13日，交易所委员会投票通过法令，禁止联手坐庄，同时也禁止专门经纪人将内幕信息透漏给他们的朋友，并禁止专门经纪人购买他们所做市股票的期权。    1  为了防止卖空投机和股市恐慌时打压市场，卖空单只有在股价上升时——也就是说卖空股票的价格高于上一个成交价时——才被认定有效。    1  为了防止今后单一金融风险再次扩散为金融系统风险，纽约证券交易所于1964年第一次建立了风险基金。就像19世纪交易所和经纪人委员会采取行动抑制过度的投机行为以及投资银行一致要求上市公司出具年度报告和独立的会计报表一样，华尔街的参与者们再一次意识到，他们有着超越各自利益的共同利益，需要大家共同维护。     只有规范的市场，才是健康的，持续发展的。 1  美里尔将这一切彻底改变了。他严格培训他的客户经理们——这些人现在被称做注册代理人（registered representative），让他们掌握经纪业务的基本知识，并且，美里尔在他们刚刚开始工作时就给他们支付固定工资，而不是让他们完全依靠佣金过活     专业的代理人出现，专业的事情有专业的人员做更加靠谱，这个是社会分工和规模化必须走的路。 1  格雷厄姆被称为“现代证券分析之父”，他倡导的基本面研究和开创的证券分析方法在一定程度上改变了华尔街此前盛行的投机风气，并为现代资产管理业奠定了基础。其著作《证券分析》和《聪明的投资者》影响甚广。巴菲特早年曾向格雷厄姆学习投资。     理性的分析证券市场的规律，分析股票的走向。 1  纽约证券分析协会（New York Society of Security Analysts）于20世纪30年代成立    1  1960年，这个预言变成了现实，养老基金和工会拥有数以十亿计的资金，它们成为华尔街的大玩家。那一年，美国中部卡车司机联合工会（Teamsters）持有的股票价值为2350万美元，美国矿工联合工会（United Mine Workers Union）有1640万美元投资在华尔街。1961年，联邦政府预算总额只有不到1000亿美元，而所有非保险类养老基金持有的股票市值就有174亿美元之多。在那个时期，养老基金每年都有10亿美元的资金进入股市，有20亿美元进入债市。除此以外，随着千百万美国家庭开始有能力购买原先是奢侈品的人寿保险，这些人寿保险的承办主体——保险公司也越来越多地成为华尔街的主要投资者。     保险金的进入，让这个市场更大，也就更加需要稳定和健康的市场。 1  道琼斯指数是按照价格加权而不是按照市值加权计算，这意味着在道琼斯平均指数的计算过程中，高价股票的影响大于低价股票，而股票市值的大小对指数的影响却没有被考虑进来（股票的市值=股票价格×股票总流通股）    1  1965年，自动报价机终于与一块电子显示屏相连接，使整个大厅的人都可以同步看到正在打印的记录单上的股价信息    1  《联邦证券法》就要求经纪人为客户寻找到股票的最好报价    1  纽约证券交易所的专门经纪人们通过交易所的管理委员在1955年制定了《394条例》（Rule 394），该条例禁止会员公司买卖交易所以外的股票，“除非是在交易所特别豁免的情况下”。换句话说，联邦法律要求经纪人们去寻找能给出最好价格的市场，而纽约证券交易所却禁止他们这样去做。    1  1975年5月1日，《梧桐树协议》签订183年之后，固定佣金制在华尔街上寿终正寝，几年之后，它也将从伦敦交易所消失    1  纳斯达克是“美国证券交易商自动报价系统”（National Association of Securities Dealers Automated Quotation System）    1  到20世纪80年代末期，美国事实上只剩下两个证券交易市场：一个是纽约证券交易所，主要交易挂牌证券，它们市值较大，并被广泛持有；另一个是纳斯达克市场，主要交易那些市值较小的、未在交易所挂牌的股票。当然，也有明显的例外，例如英特尔和微软这两家大公司都是在纳斯达克交易，而不是“主板”[202]    1  以萨班尼斯和奥克利两位提案人命名的《萨班尼斯和奥克利法案》（Sarbanes-Oxyley Act）为财务会计制度带来了巨大的变化，其中包括禁止会计师事务所为同一家公司同时提供审计和咨询服务。此外，股票期权必须在授予员工之际便计入公司当期费用，而不能等到期权执行时再计入公司费用，以便能使投资者更清楚地了解到公司的价值。    1  ·2001年11月，美国安然公司财务丑闻被接连曝光，安然公司股价一路由每股90美元下滑至每股30美分。2001年12月2日，在全球拥有3000多家子公司、名列《财富》杂志“美国500强”第七名、掌控着美国20%的电能和天然气交易、被誉为“华尔街宠儿”的安然公司申请破产保护。不久，其聘请的会计师事务所安达信——一个有90多年历史的世界级会计师事务所退出审计市场。    </description>
    </item>
    
    <item>
      <title>Blogs Weechat Official Accounts and Freedom</title>
      <link>https://wdicc.com/blogs-weechat-official-accounts-and-freedom/</link>
      <pubDate>Thu, 28 Mar 2019 11:18:37 +0800</pubDate>
      
      <guid>https://wdicc.com/blogs-weechat-official-accounts-and-freedom/</guid>
      <description> 十几年前，还没有微博的时候，大家热衷于开 blog 写点自己想写的东西，出来了一大批 blog 平台，不管写多少内容有没有什么价值，很多人都会开一个自己的 blog。同时也有不少人自己搭建自己的 blog 平台，那会还有人卖空间专门搭 blog 用，提供一个虚拟主机，可以一键弄一个自己的 wordpress。  我最早的时候的 blog 是自己搭建的，后来也用过 wordpress，也去新浪开过博客。现在看开 blog 其实满足了用户的两个诉求，一个是写东西表达自己的想法，一个是社交。单纯的表达自己的想法可能也是一种发泄输出吧，写下来会觉得有了输出，之后会觉得告一个段落。至于社交，一般是几个好友会互相关注对方的 blog，比如当时的 msn space，qq 空间这些会直接在 im 工具里面提醒你。对于感兴趣的人不管是朋友还是陌生人，可以留个言什么的互相交流。以前在各个平台开的博客现在有的是平台死了文章没有了，有的是自己都忘记用什么账号开的了，找不到了。倒是自己搭的平台因为自己持续的在把数据保留下来，现在还有一些历史数据，现在回看这些内容感觉也挺好玩挺温馨的。  到了现在，blog 基本都死了，出现了微信公众号这个东西，我一直觉得微信公众号是一个反互联网的东西，他们想了很多办法来防止里面的内容被外部抓到，比如我自己发布的内容想在自己网站提供一个列表给大家看就不行，因为虽然提供了在 pc 浏览器看内容的方式，但是只能看单篇，想看其他的必须用手机扫了码之后在手机看，并没有提供 pc 的列表页。只能是发一篇把一篇文章地址加入到自己的列表里面。  内容格式支持 html，编辑器不好用还催生了一批辅助工具，从这些工具复制源码之后，确实可以有效果，但是因为微信实际并不能编辑源码，有时候遇到复制的奇葩的代码，会发现无论如何都编辑不好。而且关键是微信官方对待公众号和对待聊天功能一样，并没有多少兴趣去把这个东西做到极致，也可能是因为他们从 qq 那边看到，功能怎么样和用户用不用其实并不是那么的强相关吧，并不是提供了用户所有想要的功能用户就会用，这样反而增加了产品的复杂度可能得不偿失。  公众号还有一个问题是，他们天然倾向于满足用户的需求，用户需要低俗八卦那他就会想办法多制造这些内容，而且这些东西在那些人的圈子里面流窜，获得更多的用户。比如那些养生的东西，这能吃那不能吃的文章在中老年圈子里面就流传的很快。但是一篇反过来避谣的文章就流传不起来，因为这些人不会关注这样的公众号。造谣一时爽，避谣跑断腿。只是拿这样的一篇文章如何能说服对方呢？对方首先一个并没有看到多少人支持这个观点，另外一个可能会说好好我信你了，然后就完事了，也不会转发打自己的脸，不会觉得要对那些看了自己转发的文章的人负责。  微博上面相对好一点，在原微博上可以直接可以看到不同观点，反对的微博也可能会再次出现在自己的时间线也同样可以看到针对这个微博大家的观点，这也是一个学习的过程，反思自己之前为什么会没有在第一时间看到其他提出来的问题呢，自己也会持续提升自己的判断辨别能力。但是微博上面又会放大参与者的情绪，导致一些极端的情况，这就另说了。  今天还听了另外一个观点，可以一起聊聊。现在各种算法会依据你看的内容不停推荐类似的内容，比如你喜欢看猫，那就持续的推猫的内容，让你不停的看下去。最开始可能是今日头条开始这么做的吧，后面网易新闻也跟进了。我一直用的是网易新闻，期间试过看今日头条，发现里面内容质量不高之后就删掉了，直到某天网易新闻也开始做了类似的事情，新闻每次刷新都会给你推荐新的，导致没有看完的时候，就把网易新闻也删除了。换了即刻，现在发现即刻也可以乱推一些东西之后，取消关注了很多的频道，现在用的也不多了。  你喜欢看什么，就尽量多的给你推什么，这个算法有问题么？其实挺美好的，这样不就不用你来回自己去找想看的内容了吗？但是这样其实也会有几个问题，一可能会让你接触不到其他你没接触到但是有可能喜欢的东西，二可能会让人的思路变得极端。每天都环绕在一个没有争议的环境里面，慢慢的可能会失去辨别能力，也很更加不容易接受不同的东西。  说回那个观点，那个观点讲的就是比如看了一个宣扬极端观点的视频，他持续给你推荐这些视频的话，会不会容易把这个人变的很极端？按说是存在这种可能的，当然如果这个人自己确实对这个感兴趣那总也是会自己找这些信息看的，不过是这种推荐可能节约了他的时间。  标题为啥还提到了自由呢？微信我感觉就是不自由的，把大家圈进来之后就只能在这里面玩，决不允许有出去的机会。并且也没有意愿提供一个自由的环境。群里发一个链接，还需要先经过微信的审核，如果他们不想让你打开你就打不开，比如淘宝的链接就打不开。话说这个居然没有反垄断法来管理也是有意思。微博上面发的内容相对自由一点，但是微博的审查也比较厉害，当然这个是也有国家层面的事情，不多说了。 </description>
    </item>
    
  </channel>
</rss>