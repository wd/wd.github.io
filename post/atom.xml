<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on wd and cc</title>
    <link>https://wdicc.com/post/</link>
    <description>Recent content in Posts on wd and cc</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 05 Jan 2019 09:53:09 +0800</lastBuildDate>
    
	<atom:link href="https://wdicc.com/post/atom.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Amap Work With Code Push</title>
      <link>https://wdicc.com/amap-work-with-code-push/</link>
      <pubDate>Sat, 05 Jan 2019 09:53:09 +0800</pubDate>
      
      <guid>https://wdicc.com/amap-work-with-code-push/</guid>
      <description>我们 app 用了高德地图和 codepush，iOS 里面之前用的高德地图 sdk 的 5.x 版本，最近想升级到最新的 6.6.0 发现和 codepush 出现了 symbol 的冲突，主要是两个函数 aes_decrypt_key128 和 aes_encrypt_key128 。
高德地图是不开源的，万幸我们有 codepush 的源码，所以思路是只需要把 codepush 里面冲突的函数改个名字就好了。
改代码很简单，主要是怎么和项目集成。我用的是 patch-package ，做法如下。
给 package.json 的 scripts 增加一个 postinstall
&amp;quot;scripts&amp;quot;: { &amp;quot;postinstall&amp;quot;: &amp;quot;patch-package&amp;quot; }  然后就是改 node_modules/react-native-code-push 下面的文件，改完之后，执行一下 yarn patch-package react-native-code-push 会生成一个类似 patches/react-native-code-push+5.5.1.patch 的文件，确认一下这个文件里面是不是包含了你修改的内容。
这就可以了，以后执行 yarn install 的时候会自动打这个 patch。
这个方式比 fork 一份对方的代码好一点，有时候有些代码发到 npm 的是编译之后的版本，fork 之后也不好用，除非你也发布一个。用 patch 的方式会好一点，安装的还是对方发布的。</description>
    </item>
    
    <item>
      <title>Android Packaging</title>
      <link>https://wdicc.com/android-packaging/</link>
      <pubDate>Sun, 02 Dec 2018 16:52:34 +0800</pubDate>
      
      <guid>https://wdicc.com/android-packaging/</guid>
      <description>国内市场因为 android 的发布渠道比较多，所以一般我们会想要追踪一下用户使用的包是从哪里下载安装的。
Android 打包支持 buildTypes ，一般这个会用来区分不同的环境，比如 dev，beta，prod 等，不同环境可能会有一些不同的设置，比如 dev 会打开更多的日志输出什么的。
 android{ buildTypes { debug { ... } release { ... } beta { ... } } }  还有一个支持是 productFlavors，一般用这个来区分不同的渠道，不同渠道也可以有一些不同的设置，类似上面的 buildTypes。
 android { productFlavors { xiaomi {} baidu {} wandoujia {} x360 {} } productFlavors.all { flavor -&amp;gt; flavor.manifestPlaceholders = [CHANNEL_ID: name] } }  配合 AndroidManifext.xml 文件的配置
 &amp;lt;meta-data android:name=&amp;quot;CHANNEL_ID&amp;quot; android:value=&amp;quot;${CHANNEL_ID}&amp;quot; /&amp;gt;  在代码里面取到这个，然后设置渠道。
这样就可以打渠道包了 ./gradlew assembleWandoujiaRelease 编译 wandoujia 这个渠道的 releases 包。这个方式有一个问题是，每一个渠道包都需要从头编译一次，一个渠道 10 分钟，那所有渠道下来，就可能需要一个小时了，关键是很多无用功。</description>
    </item>
    
    <item>
      <title>A* Search Algorithm</title>
      <link>https://wdicc.com/a-star-search-algorithm/</link>
      <pubDate>Sat, 24 Nov 2018 14:48:04 +0800</pubDate>
      
      <guid>https://wdicc.com/a-star-search-algorithm/</guid>
      <description>前段时间我们设想了一个需求，想帮助用户规划一下从 A - B 的航线。对于路径规划从来没弄过，研究了一下，基本都在提这个 A 星寻路算法。
 先贴几个文章： 简单的讲解的文章例如 https://www.jianshu.com/p/65282bd32391 这个详细一点的 https://blog.csdn.net/DinnerHowe/article/details/79380317  我写了一个简单的程序，这个程序没有做过任何的优化，只能说是解释了这个算法的逻辑而已，在终端里面可以可视化的把计算过程显示出来。效果可以看这里。
#!/usr/bin/python import sys import random RED = &#39;\033[31m&#39; GREEN = &#39;\033[32m&#39; GRAY = &#39;\033[35m&#39; NC = &#39;\033[0m&#39; class Point(object): x = 0 y = 0 close = False open = False start = False end = False wall = False H = 99 G = 99 parent = None def __init__(self, **kwargs): if &#39;x&#39; in kwargs: self.</description>
    </item>
    
    <item>
      <title>Phpbb Auth Plugin</title>
      <link>https://wdicc.com/phpbb-auth-plugin/</link>
      <pubDate>Sat, 17 Nov 2018 21:15:50 +0800</pubDate>
      
      <guid>https://wdicc.com/phpbb-auth-plugin/</guid>
      <description>这几天我们这里需要搞一个论坛，我搜了一些，选了 phpbb，这个毕竟年头比较久远，也支持 PostgreSQL。
我们自己本身有自己的会员逻辑，所以就需要把他的登陆和我们自己的结合，而 phpbb 也支持自己作 Auth Plugin。
 涉及到的文件有几个 includes/auth/auth_foo.php：这个是具体的 auth 逻辑代码的地方。 config/default/container/services_auth.yml：这个是注册这个 auth 逻辑的地方。 template 模板文件：这个我没涉及到，所以没去了解。  service 文件的配置：
auth.provider.skyreq: class: phpbb\auth\provider\foo arguments: - &#39;@dbal.conn&#39; - &#39;@config&#39; - &#39;@passwords.manager&#39; - &#39;@request&#39; - &#39;@user&#39; - &#39;@service_container&#39; - &#39;%core.root_path%&#39; - &#39;%core.php_ext%&#39; tags: - { name: auth.provider }  上面配置里面 arguments 指定的，是 auth_foo.php 的 constructor 接受的参数。可以需要什么配置什么，个数要对应。
配置这个之后，只需要在 auth_foo.php 里面实现具体的逻辑就可以了。
init_method 这个方法是在后台用户选中这个 auth 方法的时候执行的，比如你如果有一些配置的话就可以在这里验证。如果需要用户录入配置的话，还需要配合 template 文件，好提供录入的界面。我这里没有这个需求。
login_method 这个方法是在用户登陆的时候会调用。会传入用户名和密码两个参数。实现逻辑可以参考 auth_db 这个模块。phpbb 为了安全，对于管理员用户会有一个二次验证的过程，管理员的 session 过期时间也会短一些。所以我们必须要实现这个，否则一个管理员就无法访问后台了。我这里是完全复制的 auth_db 的逻辑，里面改动了一点增加了一个硬编码只允许几个我指定的用户登陆。然后验证也完全用的 phpbb 的密码逻辑。</description>
    </item>
    
    <item>
      <title>Fear, trust and JavaScript: When types and functional programming fail</title>
      <link>https://wdicc.com/fear-trust-and-javascript/</link>
      <pubDate>Thu, 01 Nov 2018 12:56:20 +0800</pubDate>
      
      <guid>https://wdicc.com/fear-trust-and-javascript/</guid>
      <description>翻译自 Fear, trust and JavaScript: When types and functional programming fail , 最早是 hacker news 看到的。
只是翻译大意。
作为开发人员，我们需要减少对代码执行失败的恐惧，增强对代码的信心。很多 javascript 开发人员从函数式编程语言和强类型语言里面借鉴思路来将信任交给工具和代码来减少恐惧。类似可选类型，函数转换，和只读化这些思想可以帮助写出更好的 javascript 代码。当把这些想法都加入到 javascript 里面，会有一些妥协，协作起来比较差，并且最终会导致将信任从开发人员交给代码和工具的想法失败。
举例来看看 javascript 里面是如何在两种观点下面处理数据的：理解数据的结构和修改数据。
Fear and the shape of data 在类似 javascript 的动态语言里面，很难知道你数据的结构。默认的方式是依赖公约(convention)。相信其它程序员和其它系统按照协议给你正确的数据。
fetchUser(id).then( user =&amp;gt; { // Got my user! }) // Later render(user.name) // He has a name  我一般管这种方式叫「假装这是你要的」。在高可信的环境下，这个会工作的挺好。
但是恐惧会悄悄的到来。代码的复杂度会增加。代码会是不同开发人员基于不同的公约(convention)开发的。你收到的数据来自于不可控的上游以及不稳定的格式。会开始看到空指针错误。对代码的信任会崩塌，对数据格式的疑问会引起焦虑而不是信任。
 这个数据里面到底有什么值？ 我可以删除里面的数据而不产生影响吗？ 我可以把这个数据传入这个函数吗？  例如下面这个。
fetchUser(id).then( user =&amp;gt; { // Got my user! if(!</description>
    </item>
    
    <item>
      <title>Typescript and Jest</title>
      <link>https://wdicc.com/typescript-and-jest/</link>
      <pubDate>Thu, 01 Nov 2018 11:59:29 +0800</pubDate>
      
      <guid>https://wdicc.com/typescript-and-jest/</guid>
      <description>最近在折腾 typescript，把很多项目改成了 ts 的。有一个老项目，改的过程中感觉各种不踏实，打算还是先写点测试用例，就折腾了一下 jest。各种坑。。。
首先需要加一个 tsconfig.json
{ &amp;quot;compilerOptions&amp;quot;: { &amp;quot;target&amp;quot;: &amp;quot;es2015&amp;quot;, &amp;quot;module&amp;quot;: &amp;quot;es2015&amp;quot;, &amp;quot;lib&amp;quot;: [ &amp;quot;es2015&amp;quot; ], &amp;quot;outDir&amp;quot;: &amp;quot;./lib&amp;quot;, &amp;quot;declaration&amp;quot;: true, &amp;quot;noEmit&amp;quot;: true, &amp;quot;moduleResolution&amp;quot;: &amp;quot;node&amp;quot;, &amp;quot;esModuleInterop&amp;quot;: true, &amp;quot;allowSyntheticDefaultImports&amp;quot;: true, /* Strict Type-checking */ &amp;quot;strict&amp;quot;: true, &amp;quot;strictNullChecks&amp;quot;: true, &amp;quot;noImplicitAny&amp;quot;: true, &amp;quot;noImplicitThis&amp;quot;: true, &amp;quot;alwaysStrict&amp;quot;: true, /* Additional Checks */ &amp;quot;noUnusedLocals&amp;quot;: true, /* Report errors on unused locals. */ &amp;quot;noUnusedParameters&amp;quot;: true, /* Report errors on unused parameters. */ &amp;quot;noImplicitReturns&amp;quot;: true, /* Report error when not all code paths in function return a value.</description>
    </item>
    
    <item>
      <title>Upgrade to React 16.3</title>
      <link>https://wdicc.com/upgrade-to-react-16.3/</link>
      <pubDate>Mon, 22 Oct 2018 16:21:30 +0800</pubDate>
      
      <guid>https://wdicc.com/upgrade-to-react-16.3/</guid>
      <description>随着 React native 升级，React 也升级到了 16.5 了。原来的改成新的生命周期了。
class ExampleComponent extends React.Component { static getDerivedStateFromProps(nextProps, prevState) { // Called after a component is instantiated or before it receives new props. // Return an object to update state in response to prop changes. // Return null to indicate no change to state. } UNSAFE_componentWillMount() { // New name for componentWillMount() // Indicates that this method can be unsafe for async rendering. // Prefer componentDidMount() instead.</description>
    </item>
    
    <item>
      <title>Cleanup Your Disk Space</title>
      <link>https://wdicc.com/cleanup-your-disk-space/</link>
      <pubDate>Fri, 12 Oct 2018 12:26:47 +0800</pubDate>
      
      <guid>https://wdicc.com/cleanup-your-disk-space/</guid>
      <description>200 多 G 的空间，说没就没。搞个开发真不容易。
清理 yarn npm 开发的 cache，这些有需要的会再次下载
yarn cache clean npm cache clean  清理 gradle android 开发的 cache，这些有需要的话 android-studio 会在生成
rm -rf ~/.gradle/  清理 xcode ios 开发的东西，这些清理掉了需要用的话 xcode 会再生成
rm -rf ~/Library/Developer/  清理 brew 安装的软件的旧版本，这个执行之后 python 可能会不正常，执行一下 pyenv rehash 之类的命令
brew cleanup  </description>
    </item>
    
    <item>
      <title>R.I.P Maomao</title>
      <link>https://wdicc.com/r.i.p-maomao/</link>
      <pubDate>Fri, 28 Sep 2018 10:33:30 +0800</pubDate>
      
      <guid>https://wdicc.com/r.i.p-maomao/</guid>
      <description>毛毛应该是 2004 年上半年我从一个人家里抱回来的，到现在 14 岁多一点。从 2013.12.29 发现得了糖尿病，到现在是 4 年多一点，等于是大概 10 岁左右的时候得的。
前面 10 年是无忧无虑欢乐的 10 年，猫基本什么都不用管，只有刚开始第一次长假出去玩的时候，拜托过朋友给中间来看看。后面出去玩基本就把两只猫都扔家里了，给他们弄足够的水和吃的，最长出去玩的时间得有 10 天，回来猫只是会比较粘人，其它基本还好。
自从毛毛病了之后，就和养了一个孩子一样，必须每天早晚 2 针胰岛素。参考上面的文章，通过自己学习，掌握了采血，通过稀释来配胰岛素等。所以开始还需要定期配好稀释好的胰岛素，一次大概配置 20 针左右，放到冰箱，然后每天 2 针，10 天左右就需要重新配置。配药的时候，需要注意量和不能有空气，每次和老婆就像吸毒人员一样，小心翼翼的配好。直到后面加了糖猫猫的群，发现了 bd 针，才开始不在自己稀释配药了。
毛毛病了之后，我们基本就很难出远门了，因为必须要回来打针。所以出去几次远门都拜托朋友、cc 妈妈等过来给定期打针。直到今年，才开始尝试给带着猫回家，去了一趟我们家，一趟 cc 家，整体猫虽然很害怕，不过也还好，没出什么问题。
这次本来打算带着他们去沈阳的，结果没想到毛毛出事了。都是我的问题，我知道猫可以活 10 到 20 年，我曾经无处次想过猫死的时候的情形，没想到昨天就这么来了。昨天一晚没有睡，我早上感觉浑身乏力，以为是饿的，去吃了早点才发现不是这个原因。下定决心给他安乐的是我，我可能太薄情了，看着他抽搐受不了。毛毛病了这几年，我们也还断断续续的去了很多次医院，也有几次病危，但是都挺过来了。
糖尿病猫做无碳水疗法需要喂高蛋白的猫粮，我们家没有条件给妞妞和毛毛分开喂食，只能一起吃。前段时间妞妞身体也不舒服过一次，去医院做 b 超，说是他的有一个肾萎缩的很厉害，建议我们喂老年猫粮，少喂高蛋白的。我也很发愁怎么搞。我和老婆两个北漂，父母多不在这里不能帮忙。
现在只剩妞妞一个了，打算还是带着他去沈阳，还有乌龟一起。要不一只猫在家估计很孤单也会有问题，妞妞是一个特别粘人的猫。妞妞比毛毛大一岁，今年 15 岁多一点，希望能健康活着。
毛毛病了之后，我就发现经过了童年成年到中年，也到了要开始有生离死别的时候了。当你喜爱的人一个一个都离开你的时候，为了什么活着？我和老婆没有孩子，当父母都百年之后我真不知道我会不会去选择提前结束。快乐的前半生即将或者已经过去了，后面怎么面对？
安息吧毛毛，我们爱你。</description>
    </item>
    
    <item>
      <title>Typescript for React Native</title>
      <link>https://wdicc.com/typescript-for-react-native/</link>
      <pubDate>Sun, 16 Sep 2018 16:36:17 +0800</pubDate>
      
      <guid>https://wdicc.com/typescript-for-react-native/</guid>
      <description>前几天研究 settimeout 的问题的时候，发现 react-native-background-timer 自己没有 typescript 的 type 文件，但是有人给写了一个 @types/react-native-background-timer，这个包算偏门了，都有人写了 type 文件，我感觉是时候试试看 typescript 了。
搜了一下，发现没有多少在 rn 里面使用 ts 的，有一些关于 react 的，又很奇怪，大都基于 webpack 的。后来找到一篇官方的 blog 上面的，然后结合自己的研究，找到了思路。我是基于已有项目来做的，那个 blog 是基于新项目，大同小异。
首先装几个包，这几个包里面， =typescript 提供 typescript 的编译器， react-native-typescript-transformer 提供了从 ts 代码到 js 代码的转换支持， @types 的两个包提供了 react 和 react-native 的 type 文件。
$ yarn add -D typescript react-native-typescript-transformer @types/react @types/react-native  在项目的根目录还需要准几个文件。 tsconfig.json，你的目录里面可能已经有一个 jsconfig.json 了，那个是给 eslint 用的。tsconfig.json 同时给 typescript 和 tslint 使用。
{ &amp;quot;compilerOptions&amp;quot;: { &amp;quot;target&amp;quot;: &amp;quot;es2015&amp;quot;, &amp;quot;module&amp;quot;: &amp;quot;es2015&amp;quot;, &amp;quot;lib&amp;quot;: [ &amp;quot;es2015&amp;quot; ], &amp;quot;jsx&amp;quot;: &amp;quot;react&amp;quot;, &amp;quot;noEmit&amp;quot;: true, &amp;quot;moduleResolution&amp;quot;: &amp;quot;node&amp;quot;, &amp;quot;strict&amp;quot;: true, &amp;quot;esModuleInterop&amp;quot;: true, &amp;quot;types&amp;quot;: [ &amp;quot;react&amp;quot;, &amp;quot;react-native&amp;quot; ], &amp;quot;allowSyntheticDefaultImports&amp;quot;: true }, &amp;quot;include&amp;quot;: [ &amp;quot;.</description>
    </item>
    
    <item>
      <title>Background Task in React Native</title>
      <link>https://wdicc.com/background-task-in-react-native/</link>
      <pubDate>Sat, 08 Sep 2018 16:06:18 +0800</pubDate>
      
      <guid>https://wdicc.com/background-task-in-react-native/</guid>
      <description>react-native 支持 setTimeout 和 setInterval 这些 js 的方法来设置 timer 执行一些任务。但是对于长时间执行的任务，比如你想每 1 分钟都执行一下网络请求看看是不是有新的数据，这个时候会有一个黄条警告和你说不要这么做。
我们有类似需求，就找到了 react-native-background-timer 这个包。这个用起来和 js 的 setTimeout 的方法一样，可以一直运行。
我们另外还使用了 websocket 来和服务器保持数据同步。这样就必须要保证有网络问题的时候，可以自动重连保证链接。我们找到了 reconnecting-websocket 这个包，他提供了自动重连功能。这个包是基于 js 写的，没有任何的 native 代码。我们用的过程中发现时不时会出现断开的情况，因为并不能稳定复现，我们一开始也没有太多时间研究这个问题，所以这个 bug 几乎是持续了几个月。另外，也主要是因为我们还有 pc 设备，也用了 websocket，但是那边表现就很稳定，所以基本可以确定是 android 的问题。
我们试过自己手动断网，和手动重启服务器的方式断开 websocket，然后发现他都会重连。出现 bug 的时候，都是比如放了一个晚上，第二天来了之后，发现断开了。或者有时候似乎又不会断，总之是不很好的稳定可以复现。
一开始怀疑是 android 进入省电模式之后，应用会出问题，把设备一直接着电源之后，似乎发现好像好了，但是实际上还是会出现断开的情况。后来给 app 增加了 REQUEST_IGNORE_BATTERY_OPTIMIZATIONS 权限，试图解决，发现也不行。
最近一个月总算有时间看看了，仔细研究了一下。给 app 增加了更多的 log，记录一下 websocket 的链接和断开的情况。发现一个情况，似乎整整 24h 的时候，会出现一个断开。断开之后有时候会连不上，有时候可以。因为是整整 24h，所以这个断开基本上可以肯定是 server 那边问题，但是断开不能重连依然是用户端这边的问题。
后来我们找到了 24h 断开的原因，我们 websocket server 用的是 channel redis，里面默认是 24h 会断开。这个案子破了，定期倒是没问题，现在就是为啥不会重连的问题了。
def __init__( self, hosts=None, prefix=&amp;quot;asgi:&amp;quot;, expiry=60, group_expiry=86400, capacity=100, channel_capacity=None, symmetric_encryption_keys=None, ):  通过分析 websocket 的日志，发现断开之后，执行重连的时候，reconnect-websocket 避免过度重连，会增加一个延时，调用 this.</description>
    </item>
    
    <item>
      <title>React Native Deeplink</title>
      <link>https://wdicc.com/react-native-deeplink/</link>
      <pubDate>Mon, 03 Sep 2018 18:00:56 +0800</pubDate>
      
      <guid>https://wdicc.com/react-native-deeplink/</guid>
      <description>App 一般都支持类似 coolflight://list 这样的链接，可以直接打开 app 并打开列表，这个就是 deeplink。
这个需要对 native 代码做一些修改，可以参考这里的修改，ios 和 android 都有写。这里有一个需要注意的是，对于 android 有一个配置是
 &amp;lt;data android:scheme=&amp;quot;mychat&amp;quot; android:host=&amp;quot;mychat&amp;quot; /&amp;gt;  这个里面配置 host 的话，后面使用的时候就需要类似 mychat://mychat/list 这样的方式了，就是多了一层 mychat。这样也会导致 ios 和 android 的链接不统一，我查了文档也没有查到没有设置 host 会有什么问题，我就去掉了，去掉之后，ios 和 android 的链接就统一了。都是 mychat://list
另外 android 还有一个需要注意的地方是，activity 的 launchmod 需要设置为 singleTask 要不会导致每次通过 deeplink 打开 app 都会新建一个，导致你有多个 js 在后台跑。
&amp;lt;activity android:name=&amp;quot;.MainActivity&amp;quot; android:launchMode=&amp;quot;singleTask&amp;quot;&amp;gt;  在 js 里面可以使用 Linking.openURL(url).catch(err =&amp;gt; console.error(&#39;An error occurred&#39;, err)) 打开一个 deeplink ，可以是别的 app 的，也可以是自己的。
然后就是在 js 里面处理对应的 deeplink 了。</description>
    </item>
    
    <item>
      <title>React Mobx</title>
      <link>https://wdicc.com/react-mobx/</link>
      <pubDate>Sun, 02 Sep 2018 19:18:16 +0800</pubDate>
      
      <guid>https://wdicc.com/react-mobx/</guid>
      <description>我们之前用的是 redux 来做的统一 store，最近一个新项目有同学用了 mobx，就了解了一下，刚开始看的时候，感觉比 redux 好啊？
mobx 的逻辑是自动收集 store 属性被哪些 dom 使用，然后在属性被改变的时候，自动更新 dom。这样的模式显然比 redux 的 action，reducer，selector 那一套简单多了。
给对应的组件加上 @observer 装饰器之后，store 改变就会自动重现渲染组件。store 可以用下面的模式给到组件
const store = new TodoList(); &amp;lt;TodoListView todoList={store} /&amp;gt;  也可以用 @inject 装饰器
@inject(store =&amp;gt; store) @observer class TodoListView { }  之后都通过 this.props 引用。
一切都很美好，直到我看到了这个，这里列了一些 mobx 的坑。比如有讲到，mobx 为了能监控到对 store 的依赖和修改，其实是把 store 属性做了修改，所以 store 有一个属性是一个 Map，那么实际得到的是一个和 ES6 Map api 类似的一个对象，但是并不是原生的 Map。比如有一个属性是 Object，你给加了一个 key，例如 store.object[&#39;a&#39;] = &#39;test&#39;，那么这个修改并不能被监视，具体看那个文档吧。
写 Javascript 基本就是从一个小坑爬出来掉到一个大坑里面。</description>
    </item>
    
    <item>
      <title>Android Custom</title>
      <link>https://wdicc.com/android-custom/</link>
      <pubDate>Sun, 02 Sep 2018 08:00:16 +0800</pubDate>
      
      <guid>https://wdicc.com/android-custom/</guid>
      <description>我们给用户的设备，有 android pad 和 pc。pc 系统我之前基于 porteus 定制了一个，勉强可以用。apad 的系统一直没搞好。
Android 系统必须要解锁之后才可以定制系统，否则没有 root 权限，system 分区的数据不能修改。
 Android 系统有四个重要的分区。 boot ，和 linux 的类似，里面有 kernel 和 ramdisk，ramdisk 应该是在启动之后会成为 / 分区 recovery ，恢复分区，如果想对系统分区做什么操作，可以使用这里的程序引导系统，这个时候允许你进行一些操作。默认的 recovery 只能 wipe 和刷系统。自定义的 recovery 比较厉害，可以支持备份啊啥的一堆事情，比如 twrp 还有图形界面。 system ，系统分区，系统程序都在这里，包括系统自带的一些 app 等等。正常情况对这个分区是不能修改的，系统分区都是只读的。 data ，数据分区，这个分区是给用户使用的。用户安装的一下 app 以及一些数据都在这里。wipe 的时候就是会清空这个分区的数据。大家熟悉的 sdcard 那个分区，其实数据也是在这里的。data 分区里面 app 只能读取自己的数据，无法访问别的 app 的。但是放在 /sdcard 分区的数据，大家都可以访问（当然，还得有 sdcard 的权限）  前三个分区都可以定制。首先需要解锁 bootloader，这个各个定制版都可能有区别，比如华为我记得还需要去他们网站获取一个解锁码，获取的时候会提示你解锁之后就不给保了。原生的 android 都是去开发者选项里面打开，然后在启动的时候进 bootloader，执行 fastboot oem unlock-go 。解锁的时候会自动 reset 系统，注意先备份数据。
解锁之后，就可以刷自己的 recovery 了。刷之前建议先备份一下 boot recovery system 分区，以方便自己回头可以刷回来。我用的是 twrp，其它的好像现在也么看到。这个得找和你的手机匹配的才行。具体方法是执行 fastboot boot twrpxxxxx.</description>
    </item>
    
    <item>
      <title>Boot Linux Through PXE</title>
      <link>https://wdicc.com/boot-linux-through-pxe/</link>
      <pubDate>Mon, 02 Jul 2018 16:47:31 +0800</pubDate>
      
      <guid>https://wdicc.com/boot-linux-through-pxe/</guid>
      <description>测试 porteus 的时候，每次都是做好 iso 之后写到一个 u 盘，然后用 u 盘启动看看效果，发现有点蛋疼，这浪费时间不说，我的 u 盘寿命估计也得少一截。就研究了一下 pxe 启动，这样每次改完之后通过 pxe 直接读取我改了之后的 iso 引导 linux 就好了。
我这看 pxe 启动主要需要做两个事情，一个是 dhcp 的时候广播 tftp 的信息，一个是通过 nfs 共享给那个系统需要读取的文件。nfs 共享也可以改用 http 等其他服务。
dnsmasq 广播 tftp 的信息，可以通过 dnsmasq 来做。dhcp 部分就不贴了，只贴 tftp 相关的。
tftp-root=/srv/pxe/boot dhcp-boot=/pxelinux.0 enable-tftp  网卡启动的时候会获取 /pxelinux.0 然后获取 /pxelinux.cfg/default （这个实际上有一个判断顺序，方便给不同的机器不同的配置）。然后根据这里面的配置，获取内核信息。然后加载内核。
nfs 加载内核之后还需要系统文件，这个时候貌似有几个选择，比如通过 http 发送。我这用的是 nfs。想要通过 nfs 发送，内核得能支持 nfs mount。各 linux 的做法貌似不太一样。
配置 nfs 的目录，在 /etc/exports 里面加入类似这样的信息。
/srv/pxe/porteus *(ro,fsid=0,no_subtree_check) /srv/pxe/storage *(rw,fsid=1,no_root_squash,no_subtree_check)  然后 exportfs -rv ，这样 nfs 设置好了。</description>
    </item>
    
    <item>
      <title>Install Porteus to HD</title>
      <link>https://wdicc.com/install-porteus-to-hd/</link>
      <pubDate>Mon, 02 Jul 2018 16:23:54 +0800</pubDate>
      
      <guid>https://wdicc.com/install-porteus-to-hd/</guid>
      <description>Porteus 是一个很好玩的系统，他基于 aufs 弄出来的一个「只读」系统，说是只读，实际上他也可以把修改保存到一个硬盘目录，然后启动的时候自动加载这些修改，这样就修改都还在。但是如果把这个目录删除，那么修改就都没有了，这就是所谓的只读。
我开始的需求是需要搞一个 linux，然后给用户使用，并且希望用户只能用浏览器，不能使用其他东西，因为我们提供的服务就是一个网页。不能使用其他东西是为了避免使用的时候导致系统奔溃什么的，还得派人花时间去维护。然后看到有人推荐 Kiosk，看了一下感觉这个东西太完美了，就是我想要的东西。然后就开始研究这个系统。研究的过程中发现了他是基于 Porteus 的，就开始看 porteus。
Kiosk 确实也不错，但是我使用的时候想要定制支持中文输入法，打印机等设备，然后发现他阉割加定制的太多了，导致我看了几天居然还没有找到他的入口在哪里，尝试想搞定输入法，费了很多劲。kiosk 使用的是 openbox + tint2 ，后面看了 porteus 之后，他支持 mate，kde 这些桌面，并且也直接就支持 scim，所以打算还是基于这个定制比较简单一点。
具体定制就不多说了，主要是定制好 iso 之后，怎么安装到硬盘。
其实也相当简单，只需要把 u 盘上面的内容复制到一个硬盘分区，然后安装一个 bootloader 就可以了。
安装 bootloader 的时候由于对这个东西不是特别熟悉，以及这么多年不搞 linux 之后又出来很多新的概念，所以走了一些弯路，一番学习之后，发现简单的很。可以参考这里。
然后就是需要弄一个 grub.cfg 就可以了。
set timeout=1 set superusers=root password_pbkdf2 root grub.pbkdf2.sha512.10000.xxxxxxxx password guest guest if [ x&amp;quot;$default&amp;quot; = xsaved ];then load_env; set default=&amp;quot;$saved_entry&amp;quot;; fi insmod vbe insmod efi_gop insmod efi_uga insmod font insmod part_gpt search --label --no-floppy --set kgzx KGZX set prefix=($kgzx)/boot/grub if loadfont $prefix/fonts/unicode.</description>
    </item>
    
    <item>
      <title>Compile Kernel Module</title>
      <link>https://wdicc.com/compile-kernel-module/</link>
      <pubDate>Mon, 02 Jul 2018 16:13:56 +0800</pubDate>
      
      <guid>https://wdicc.com/compile-kernel-module/</guid>
      <description>使用 porteus 的时候，发现网卡不支持，找了一下发现有内核驱动可以用，那就需要编译一下内核的模块。
这里有一个帖子写了如何编译内核，主要步骤是先给内核打 aufs 的补丁，然后就是正常的 make config &amp;&amp; make &amp;&amp; make modules_install 了。
我这只是编译一个网卡驱动，操作步骤大概如下，把内核解压放到 /mnt/sda1/kernel 下面，然后把网卡驱动代码放到 /mnt/sda1/kernel/linux-4.16.3/drivers/net/wireless/rtl8821ce 下面。
# cd /mnt/sda1/kernel/linux-4.16.3/ # modprobe configs &amp;amp;&amp;amp; zcat /proc/config.gz &amp;gt; .config # make oldconfig # make prepare # make modules_prepare # export srctree=/mnt/sda1/kernel/linux-4.16.3 # ln -s /mnt/sda1/kernel/linux-4.16.3 /usr/src/linux # cd drivers/net/wireless/rtl8821ce # make  然后在这个目录下面会产生一个 rtl8821ce.ko 的文件。
如果是遇到自己用的内核有一个模块没编译，那可以用下面的方式
# after make modules_prepare # make modules SUBDIRS=drivers/firmware/efi/  这样会在 drivers/firmware/efi/ 目录下面产生一个 xx.ko 之类的文件。</description>
    </item>
    
    <item>
      <title>Geodesy</title>
      <link>https://wdicc.com/geodesy/</link>
      <pubDate>Sun, 01 Jul 2018 08:10:05 +0800</pubDate>
      
      <guid>https://wdicc.com/geodesy/</guid>
      <description>坐标点之间的距离角度计算不能简单的用平面几何来算，得按照球面计算，PostgreSQL 提供了 gis 数据的计算支持，各种图形关系判断，距离计算等等。但是我们有时候也需要在 js 里面计算，开始的时候尝试自己按照公式写来着，写了一些发现太蛋疼了，因为只是单纯的看公式，缺少空间概念，算的对不对啥的都不知道。后来发现了这个 js 库，简直太贴心了。
 提供了我用过的几个功能 度数表示转换，小数点形式到度分秒形式的互转。在 utm.js 里面。 计算线的真北角。point1.bearingTo(point2)，真北角计算是和线的方向有关系的。 和当前点夹角是 x，距离是 y 的点，point1.destinationPoint(y, x)。 两点之间的距离，point1.distanceTo(point2)  然后顺便记录一些东西。
// 两条线的夹角的一半，普通角度 let angle = (360 + 180 + bearing1 - bearing2) % 360 // 360 保证只有正的 let halfAngle = angle &amp;gt; 180 ? (360 - angle)/2 : angle/2 // 只要锐角 // 计算两条线夹角中线的真北角 // left,right bearing 需要是真北角 let rightBearing = 90 + (bearing1 + bearing2)/2 let leftBearing = 180 + rightBearing // Math.</description>
    </item>
    
    <item>
      <title>UEFI Bootable Usb</title>
      <link>https://wdicc.com/uefi-bootable-usb/</link>
      <pubDate>Sat, 30 Jun 2018 07:30:58 +0800</pubDate>
      
      <guid>https://wdicc.com/uefi-bootable-usb/</guid>
      <description>UEFI shell UEFI firmware 应该会读取设备里面的分区，找到 ESP 然后再读里面的内容。我看到最简单的方式是把 u 盘格式化成 fat 然后建一个目录 /boot/efi 然后下载一个 uefi shell 把 .efi 文件放到这个目录 /boot/efi/shellx64.efi ，然后启动的时候就多了一个 uefi 菜单了，选择之后可以进入一个 uefi shell。
uefi shell 里面有几个命令可以用。
map map 可以列出来当前机器的磁盘情况，找到你的 esp 分区。
ls ls 可以列出来磁盘目录里面的内容，比如 ls fs0:\boot ，注意磁盘和目录之间用 : ，目录层级之间用 \ 。
bcfg 可以通过 bcfg boot dump -v 列出来当前所有的 efi 菜单，注意每个项目都有一个序号，后面会用到。
比如我想自己加一个菜单进去，那就找到最后那个的序号，然后执行 bcfg add 8 fs0:\boot\grub\grubx64.efi GRUB (fat 系统不区分大小写)，指向我自己通过 grub-install --efi-directory=/mnt/sda1/ 放到 esp 分区的 grub 的 efi ，这样启动的时候就多了一个 GRUB 的选项，通过这个选项就可以进入 linux，然后使用更方便的 efibootmgr 来编辑这个菜单了。</description>
    </item>
    
    <item>
      <title>Grub2 and UEFI</title>
      <link>https://wdicc.com/grub2-and-uefi/</link>
      <pubDate>Fri, 29 Jun 2018 20:03:54 +0800</pubDate>
      
      <guid>https://wdicc.com/grub2-and-uefi/</guid>
      <description>这几天搞 Linux 又学习了一些新的东西。
以前都是把 grub 装到 MBR，然后通过 grub 可以 chainloader 启动 windows。现在发现我装了之后并不能启动我的 windows 10 了，就只好研究了一下。
GPT 分区 以前都是 MBR(Master Boot Record) 形式的分区，主分区 4 个，如果想要建更多，需要建扩展分区，然后再在扩展分区里面建立逻辑分区。现在发现有了 GPT(GUID Partition Table) 分区。这个方式呢，比 MBR 方式有好处，支持更多分区，支持大于 2.2TB 容量的磁盘。
我看我的 windows 10 机器预装就是用的这个分区格式。
UEFI 系统 UEFI(Unified Extensible Firmware Interface) 是基于 BIOS 的 MBR 启动方式不同的东西，是基于单独的 EFI System Partition(ESP) 里面的数据启动的。里面的程序都需要和 UEFI firmware 的 bitness 一致，x86_64 啥的。
所以我的 windows 10 在 ESP 分区里面已经放了一个自己的起动器。Linux 启动之后，可以查看 /sys/firmware/efi 看看是不是有，有的话表示 kernel 支持 efi，且和 firmware 的 bitness 一致。</description>
    </item>
    
    <item>
      <title>Redux Selector</title>
      <link>https://wdicc.com/redux-selector/</link>
      <pubDate>Sun, 13 May 2018 10:43:28 +0800</pubDate>
      
      <guid>https://wdicc.com/redux-selector/</guid>
      <description>redux 应用可以通过 selector 来做 state - props 的映射工作。selector 本身有缓存效果，所以可以一定意义上加速。我用的是这个 https://github.com/reduxjs/reselect。
selector 主要是一个纯函数，给同样的输入，得到同样的输出，只处理数据，没有其他附加影响。这样就可以缓存中间结果了。
新建 selector 有两个方法，一个是直接定义函数，例如
const s1 = (state) =&amp;gt; { // 经过计算 return state.user } const s2 = state =&amp;gt; state.data  另外一个方法是通过 createSelector 函数来创建，例如
const s3 = createSelector(s1, s2, (s1, s2) =&amp;gt;{ // 经过计算 return xx })  实际上 selector 都是一些函数，具体用的是侯会执行这些函数，第一个方法创建的还好理解，第二个方法里面，会传什么参数呢？输入是什么呢？
实际上，第二个方法定义的 selector 执行的时候类似这样。
const res = s3(s1(state), s2(state))  输入是里面 selector 的输入，然后不停嵌套到最初的数据。这样一个 selector 使用的方法就广泛了。比如
const s1_res = s1(state) // 从其他地方或者逻辑获取到这个值 const res = s3(s1_res, s2(state)) // 直接用来作为 s3 的输入  </description>
    </item>
    
    <item>
      <title>Openwrt</title>
      <link>https://wdicc.com/openwrt/</link>
      <pubDate>Sun, 13 May 2018 10:01:39 +0800</pubDate>
      
      <guid>https://wdicc.com/openwrt/</guid>
      <description>前段时间还搞了一下 openwrt 定制，记录一下。
openwrt 提供了很方便的方式让你可以在 x86 机器上面定制路由器固件，到 https://archive.openwrt.org/ 下载对应的源码就可以。
比如我用的是这个 https://archive.openwrt.org/barrier_breaker/14.07/ar71xx/generic/OpenWrt-ImageBuilder-ar71xx_generic-for-linux-x86_64.tar.bz2 ， barrier_breaker 是版本， ar71xx 是 cpu 架构。解压之后目录类似如下
drwxr-xr-x 12 wd wd 4.0K Mar 29 17:18 . drwxr-xr-x 3 wd wd 4.0K Mar 26 20:32 .. drwxr-xr-x 3 wd wd 4.0K Mar 27 10:40 bin drwxr-xr-x 3 wd wd 4.0K Oct 1 2014 build_dir -rw-r--r-- 1 wd wd 94K Oct 1 2014 .config drwxr-xr-x 2 wd wd 4.0K Oct 1 2014 dl drwxr-xr-x 3 wd wd 4.</description>
    </item>
    
    <item>
      <title>Develop Plugin for Asuswrt Merlin</title>
      <link>https://wdicc.com/develop-plugin-for-asuswrt-merlin/</link>
      <pubDate>Sun, 13 May 2018 08:03:28 +0800</pubDate>
      
      <guid>https://wdicc.com/develop-plugin-for-asuswrt-merlin/</guid>
      <description>换华硕路由器之后，一直用的是梅林（merlin）的固件（rom）。基于这个固件，有一个 koolshare 的团队做了很多插件，并且做了一个通用的软件中心，可以方便的管理插件，还挺不错的。
打算用 v2ray 的时候，就想着如何才能无缝替换掉 ss。因为 v2ray 在路由器上面跑效率不高内存占用比较高，ss 作者开始说不打算支持 v2ray。后来研究了 ss 原理之后发现替换很简单，只需要具备 2 个功能就可以，一个是可以支持 socks 代理，一个是可以透明转发流量的端口。这两个协议在 v2ray 都支持，所以要做的其实就是在启动 ss 相应软件的时候启动 v2ray 的就可以了。
基于这个逻辑写了一个文档 ，能弄明白的话，自己用应该也够了。后来一时兴起，做了一个改进版。这个版本基本上就傻瓜化了。做的时候对基于 merlin 开发有了一些经验记录一下，发现讲这个的东西不多。
一些基础知识 路由器上面的内容是只读的，修改之后重启就会重置。但是 JFFS 分区里面的内容是会保留的。想要保存数据有两个方法。
 存一个文件放到 JFFS 分区上面。 通过 dbus 命令储存。(这个命令具体会把数据存哪里我还没仔细看。)  文件方式没什么好说的，储存和读取解析需要你自己做。 dbus 命令提供了 key-value 的形式储存数据，可以通过例如 dbus list v2ray 列出来所有 v2ray 开头的 key 的情况，执行 dbus 命令不带参数会有使用方法提示。
一般开发插件还有一个设置也需要开启，就是允许执行 JFFS 的自定义脚本。这个指的是路由器启动的时候，自动执行 /jffs/scripts/ 下面的一些文件，也并不是任意文件都会执行，merlin 自己的 wiki 有比较详细的说明。
所以实际上一个插件的工作方式实际上是这样
 路由器启动 读取 dbus 配置的数据 执行 /jffs/scripts/ 目录下面相应的脚本 这些脚本里面会执行你的插件的脚本 你的脚本会读取 dbus 配置的数据，以及读取你存储的文件 不管是你的界面还是脚本有新的数据需要保存，通过 dbus 或者文件存下来  每次路由器启动都是这样一个从头初始化的过程。</description>
    </item>
    
    <item>
      <title>Self Hosted Blog</title>
      <link>https://wdicc.com/self-hosted-blog/</link>
      <pubDate>Fri, 06 Apr 2018 14:59:49 +0800</pubDate>
      
      <guid>https://wdicc.com/self-hosted-blog/</guid>
      <description>给 checked 的一个反馈。
给播客写反馈是个很奇怪的事情，当我听完博客觉得心潮澎湃的写反馈的时候，其实主播们应该已经对那些说过的事情的兴趣估计已经没有了。所以感觉是像是一个很激动兴奋的人找别人聊天，结果人家波澜不惊的和你说：嗯嗯嗯。。一样。。
有两点反馈，一点关于文章格式，一点关于自建博客。
语言这个东西，发明出来就是为了交流用的，如果某种流行的东西有助于交流，那我觉得没有什么问题。比如空行代替头部空两个字，感觉好很多。比如使用 &#39;。。。。&#39; 代替 &#39;……&#39; 也没什么（其实是给我下面标点乱用打埋伏。。。:p ）。
直角引号的讨论有很多，随便搜了一个 。我记得最早流行这个好像就是知乎，后来搜狗输入法还提供了一个选项是在知乎输入引号的时候输入直角引号。我个人喜欢看直角的，因为很多时候那个蝌蚪样子的，有好几个编码，比如 ‘ ’、“ ”、&#39; &#39;、&#34; &#34;、 这几个都是半角的，左右不好区分开。但是直角的，再怎么也比较好区分左右，并且对竖排文字，比如广告图什么的里面也很有好。可以参考下这个 。
下面聊自建博客。这个 20 年前我和 hum 的看法是一样的，有病才去自己弄，需要自己搞服务器，自己维护，成本很高。但是使用别人搞的，也并不是没有问题。
 网站倒闭。最初的 MSN Live Space，然后新浪博客，然后国外的 wordpress，然后国内牛博网等等很多，那会博客风起来的时候，非常多这种网站，目前这些都不能访问或者死掉了。死掉的时候，你的文章怎么办？良心一点的提供一个导出，要不然就是你自己想办法解决。写的时候可能文本，最后拿到的没准是一堆的 HTML，很难处理。 流氓的版权协议。国内各大网站都会要你发的帖子的著作权，可以找找看有没有说版权归你，使用的时候会找你协商以及给你版权费的。 格式样式不可控。各网站都有自己的风格，比如我们程序员经常会想贴一点代码，想要一个高亮，但是人家不给你提供的话，你就很难做到。还有比如想要在文章顶部显示一个大纲方便看的人一目了然的需求。不过目前因为 markdown 的兴起，还算是对程序员友好，也算有希望统一这个格式的问题。同时 markdown 还能一定意义上解决上面提到的导出迁移的问题（当然，前提是人家让你导出），不过呢，还有另一个问题是 markdown 原定的标准实际是个残废，很多常用的东西都不支持，比如表格，比如 footnote，然后各家必定会对他扩展，那就会导致你从这家导出来的别家不一定支持。这里顺便安利一下 org-mode。  我自己使用自建博客很多年了，以后应该也不会使用其他商业的博客。我自己的博客的用途是留存我自己的经历，本身只分享文本内容，因为图片的流量问题，一般免费服务的空间都会限制，这些图片你自己维护起来也很费劲。就算是付费的，也很少有终身的，以后的事情谁能说的清。所以我都是用文字来表达，好处一方面是整站打包也就几M，另一方面，分享出去的东西别人也很方便的可以留存。
如果用途不止我那个，那平台名气是可以借用的，用平台肯定是最好的选择。
自建博客目前其实也很简单，空间在 github 开个账号就可以，只需要传 HTML 内容就可以，可以通过一些工具把文章转成 HTML 就可以。就算没有这种商业服务，自己搞一个 vps 跑一个 nginx 之类的，服务这些 HTML 也是一个很简单的事情。比如我用的是 hugo，支持 markdown，org-mode。类似的还有 hexo。
最后说忍不住补充一下 org-mode。org-mode 一直被认为是 Emacs 用户才能用，其实并不是，目前也也有一些支持他的文本处理工具，比如 hugo 和 pandoc 就支持 org-mode 文件输入，输出 HTML。目测目前 markdown 的那个表格就是学习的 org-mode 的，org-mode 的表格还支持写公式计算。别的不多说了，org-mode 基本是 markdown 的一个超集，有兴趣可以了解一下。</description>
    </item>
    
    <item>
      <title>Beijing Traffic</title>
      <link>https://wdicc.com/beijing-traffic/</link>
      <pubDate>Fri, 06 Apr 2018 14:51:19 +0800</pubDate>
      
      <guid>https://wdicc.com/beijing-traffic/</guid>
      <description>给比特新声的一个反馈，记录一下。
北京最初的时候，应该只有二环里面四个区（崇文，宣武，东西城）可能才算城区，后面慢慢的，加上海淀，朝阳等几个区，那会通州区还是通县，类似的大兴，密云县。到目前的大北京的情况，东边繁华地带都和河北接壤了（就是燕郊）。
北京实在太大了。
我在中关村上班的时候，家在东五环外面，去公司上班，开车单程需要 35 公里。快的话 40 分钟，慢的话 1.5 小时。我也有同事住在燕郊，长阳，你们可以查查有多远。
大概 10 年左右，我从中关村 7 点下班了开车回家是 40 分钟。基本不堵车，全程 4 环加 5 环路，基本没有红绿灯，开的还是挺快的。但是现在就不行了，即使在 1/5 车限行的情况下，堵车也很厉害。可能只有单双号还能和以前一比了。
北京特别大，但是走哪里都有一个比较集中的生活区，会有一些大的商场，超市，方便你购买生活用品和吃饭。但是随着年轻人不在家里做饭或者很少做饭，这些商场现在也是人满为患，到了饭点吃饭基本都需要排队。
北京喜欢建大路。二环到现在的六环。这种规划我认为比较脑残，可能能体现出来一些气派的感觉，毕竟第一次看到能让 10 辆车并行通过的路，还是会觉得：哇，比我们那的土路确实牛逼多了。这种路，刚修好的几年里面，确实会爽，只要开上去，一路没有红绿灯困扰，不堵车还是挺快的。尤其领导开上来的时候，把路一封，其他车上不来，领导的自豪感估计挺强的。
 说说脑残的地方。 这种路非常怕扰动。为了快速，肯定要减少出入口，因为车辆出入的时候，速度肯定会比较慢，多了就容易影响其他不出入的车。这样，一旦遇到点情况，大家都出不去，只能在里面堵着。我说的情况包括不限于车祸，恶劣天气，路况的变化。 这种路一般都有应急车道。但是有时候遇到比如桥梁啥的，可能那一小段会没有应急车道。而就这个情况，会导致拥堵。怎么发生的呢？车辆一旦稍微多一点，就会有车开应急车道，这些车到了没有应急车道的地方，必然需要并到路里面来，因为车辆本身多，他一并入，必然导致后车需要减速让行，然后连锁反应，后面的车觉得这个车道好像比旁边的车道慢，就会并入旁边车道或者进入应急车道。恶性循环，而这个情况的出现，可能值需要一辆走应急的车来触发一下，这条路立刻就不行了。 讲一个搞笑的事情，我每天都路过环路的一个桥，这个桥就没有应急车道。而且这个桥上桥是个上坡，那一些货车到了这里就起不来速度，就会导致这个地方产生那个连锁反应开始拥堵。这个拥堵，一般到了下桥的地方就恢复了。感觉道路设计应该也是一个比较有意思的事情。 五环路之前是收费的，所以出入口就更加少了，每次开上去遇到堵车都没有办法绕开。 过马路很头大。马路太宽，要么建天桥，要么地道，或者就是绕道到一个立交桥的地方过。拿着重物的话，天桥和地道上下会觉得不方便。绕道立交桥又会比较远。很难受。 这里还想起来另外一个事情，就是北京也喜欢建大的小区。然后小区物业为了管理方便，自然把能关的门都关掉，这样可以开那么几个门派少量的保安看着。如果一个小区在大路边上，大概率是没有临路的门的，所以过了马路还得绕道到另外一边进小区。 这种大路，还会导致临路的屋子住的很难受。大路上面一般车多且速度快，噪音很大，灰尘也很大。 这个因为一旦开上去后路就比较，往往都是一直大路开就可以，所以这个很多人会首选往这里开，尤其新手怕开错路，这也就导致这种路更容易拥堵。而且，因为修大路会导致很多小路给大路让行，在小路上面开很难受。 也因为这个思路，主路一旦堵了之后，很多排队上主路的车，会继续把辅路也堵住。然后往那些方向走的路就彻底都废掉了。  上面是我觉得几个大路不好的地方。我 6 月份去上海，发现很喜欢上海的路。另外当时觉得上海好像比北京小多了。我是住在静安寺附近，去了田子坊，人民公园，外滩一路玩，发现骑摩拜就可以。
上海的路大都有树荫，骑车很舒服。自行车道也都有，另外很多的单行线。和香港的路有点类似。不知道像北京这么大的城市，是不是也适合这样的设计。</description>
    </item>
    
    <item>
      <title>Bitcoin</title>
      <link>https://wdicc.com/bitcoin/</link>
      <pubDate>Sun, 25 Mar 2018 20:10:44 +0800</pubDate>
      
      <guid>https://wdicc.com/bitcoin/</guid>
      <description>比特币上万刀一个之后，简直已经没人不知道这个东西了。有的东西只要号称要搞比特币，股票就得涨 30%。我简单讲讲我的理解。
 比特币相关概念，有两个重要的要点。 区块链 去中心化  区块链 大家都知道区块链是一个账本。普通的账本，比如银行存折，每笔交易都会记录本次交易的金额，也会记录操作之后的余额。这样多次交易之后，你也无法只修改其中一条记录，因为一旦修改，和这条记录之后的记录就对不上了。但是其实抛开存折这回事的话，在你的记录中间插入一些记录是没有人会发现的。不过我们因为有存折，存折上面一行记录一条记录，中间也没法插入其他的。但是目前存折其实用的人不多了。
区块链的特点是把一些数据以链条一样的形式串起来。不过和链条有区别的地方是，链条每个节点是相同的，其实切断链条，取掉一个节点，然后接上，看着并没有什么不同。但是区块链任何一个节点都是不同的，去掉一个，后面的就无法连接起来了。因为每一个节点都是唯一的，且每一个节点都包含了他上一个节点的信息。某一个节点丢失或者被修改，那下一个节点保存的这个节点的信息和实际情况就对不上了。
这样的一个链条下来，能达到防止中间某条记录被篡改，保证了数据的可靠性。
去中心化 我们的账本，交易记录，大多是存放在银行的。银行开放了一些接口可以让你查账。但是实际上如果银行如果记录了一笔你认为错误的记录，你很难提供一个方法来证明银行出错了。这个就是中心化的方式存在的问题。当然，现实环境里面，银行也不会主动去做损坏自己名誉的事情，比如做假账错账。银行也会想办法防止自己内部的员工因为某些自己的目的来作恶，比如系统会记录各种审计记录，系统开发人员和使用人员权限分离，使用的时候需要授权鉴权等，这些都是防止银行自己出错的措施。
去中心化，就是把银行这个节点拿掉，所有参与记账的人员（就是旷工）都共享一份账本。每个人都可以验证账本数据的正确性，大家互相不信任，通过博弈来实现这个账本的记录和传递。
因为去中心化，大家数据同步是需要时间的，那么实际上一个账本的记录走向是会分叉的，一个博弈是大家都会挑选长的分支走。因为如果其他旷工不选短的，那么他自己选短的链条对他没有任何好处，他将得不到自己的挖矿奖励。所以旷工都会保证自己确认的交易都是没问题的。那么整个网络才是一个可信的，可持续的。
如果是有大量的旷工（算力）联合起来了，那么其实他们就可以控制链条走向了。现在很多时候挖矿是加入了矿池，走向可能是会被矿池控制的。
目前很多的公司都搞区块链，基本都不讲如何实现去中心化，如果没有去中心化，那还是一个大公司记录的话，实际上只是是用了一部分比特币的概念。没有去中心化思维的区块链就是耍流氓，千万别信。</description>
    </item>
    
    <item>
      <title>BJ Chinaunicom Iptv</title>
      <link>https://wdicc.com/bj-chinaunicom-iptv/</link>
      <pubDate>Sun, 25 Mar 2018 09:21:39 +0800</pubDate>
      
      <guid>https://wdicc.com/bj-chinaunicom-iptv/</guid>
      <description>刚入住现在的房子的时候，只有朝阳有线，当时还没有高清台，机顶盒也很烂。后来大家争取来了歌华有线，好了很多。再之后，我买了华为盒子之后，发现有线电视简直就是情怀了，很少开了，都是在线看视频。尤其后来装了一个 HDP 直播之后，电视节目也可以看了，就更少开有线了。就去把有线盒子给退了。
有段时间岳母在北京住着，离不开有线，HDP 直播很不稳定，节目有时候还打不开什么的，岳母老抱怨。后来想起来，装了北京联通宽带好像会送一个 iptv 的盒子，可以看电视节目。就联系了一下联通，给过来装了一个盒子。
这个盒子只能直接接到光猫的 lan4 口，我的上网的路由器是接在 lan1 口的。盒子虽然支持无线，但是不能直接连我 lan1 口的路由器。这个盒子有自带的遥控器，不好用，并且系统里面会诱导你用点播什么的，不是很爽。前段时间看到一个水木的帖子讲折腾 iptv 的 ，自己想尝试在任意设备看，就了解了一下。
光猫有的带路由功能，可以直接光猫拨号，以及可以登录后台修改网络结构。有的不带，等于啥功能都没有。IPTV 和通常的上网通道在猫里面是隔离的，不同的 vlan 走不同的网络。所以这也是为什么盒子只能接 lan4，而且这个 lan4 口并不能正常的访问我们的互联网，限制了只能访问那个 iptv 运转需要的网络。而 lan1 可以访问互联网，但是不能访问 iptv 的网络。我家的电视和光猫分别在客厅的两个面对的墙，因为盒子只能直连光猫，那光猫到盒子，盒子到电视都必须是有线，经过客厅线就没法走了。类似下面这样的。
光猫 lan4 --- 网线 ---&amp;gt; iptv 盒子 --- HDMI ---&amp;gt; 电视  后来找到了一个通过电力猫解决的办法。买一对就可以了。类似下面这样。
光猫 lan4 -- 网线 --&amp;gt; 电力猫1 ........电网..... 电力猫2 ---- 网线 ---&amp;gt; iptv 盒子 ---- HDMI ---&amp;gt; 电视  这样基本就可以了。但是那个盒子用起来不爽，所以打算折腾一下。按照那个帖子我试了，我这无法配置光猫，无法控制光猫的 ip 段。这样那个方案似乎就没法用了。后来又找了一些方案，比如这个方案可以单路由搞这个事情，但是我发现也有问题，里面需要知道光猫里面的 vlan 划分，我这没法知道，也没法弄了。
后来发现了另外一个思路，解决了我的问题。线路连接思路大概如下。
光猫 lan1 -- 主路由 WAN 光猫 lan4 -- 辅路由 WAN 辅路由 LAN（任意一个口） --- 主路由 LAN（任意一个口）  然后主路由就以前的设置就可以，假设主路由的 LAN 的网段是 192.</description>
    </item>
    
    <item>
      <title>Apple Carplay</title>
      <link>https://wdicc.com/apple-carplay/</link>
      <pubDate>Sat, 24 Mar 2018 09:08:47 +0800</pubDate>
      
      <guid>https://wdicc.com/apple-carplay/</guid>
      <description>Carplay 技术苹果老早就搞出来了，一直没有机会体验。最近车上搞了一个 carplay，总结下这段时间的体验。
手机连上车之后，Carplay 会自动启动，然后其实是会把车的娱乐系统的那个屏幕变成第二个手机屏幕一样。上面会排列一堆支持 Carplay 的 app，只有 app 支持才能在上面用（越狱之后可以解开这个限制，我没试过）。
Apple 自带的软件，比如 Phone, Messages, Music, Podcasts, Maps 这些都支持。第三方的地图比如 Google maps 高德都不支持，不清楚是不是 Apple 限制的。第三方的音乐软件，比如 Spotify, QQ音乐，网易音乐支持。界面会和手机上面的有点区别，应该是需要特别为 Carplay 做界面。
Carplay 和 Airplay 很像，就是 app 实际是运行在你手机上面的，比如你启动了 Spotify 的话，这个时候看手机，会发现手机上面也显示的是 Spotify 的界面，手机上面如果按 Home 退出，那 Carplay 的界面上面也会会到 Home。
苹果自带的 Maps 在国内用的是高德的数据，最近支持了摄像头限速提醒。我用英文系统，可以设置为显示当地的文字，地图上面看到的就是中文，不过语音提示都是英文的，念地名的时候很好笑。在汽车屏幕上面不能不支持手势缩放，只能点那个加减按钮。也不支持我车自带的一个旋钮缩放地图，那个旋钮在车自带的地图里面可以很方便的缩放。苹果地图会自动做一些判断，比如早上上车会提示你是不是要去公司，可以做到点一下就自动设置好导航路线。另外，因为实际上是在手机上面也会同时导航，打开手机界面的话，也能看到，当然手机就不会重复播报提醒的，但是如果你有 apple watch 的话，手表会提醒。快到转向什么的，会振动提醒。
播客播放的时候，支持调整速度，但是只能是 0.5，1, 1.5 这样，不能调到 0.8，1.3 这样。但是在 APP 里面调整好了会显示。支持快速前进和后退几十秒，和 app 里面操作类似。
Message 有消息的时候，图标上面会有提醒，点开会自动启动 siri 给你播报，但是播不出来中文，感觉很蠢，而且还不显示内容。。。会提示你是不是要回复，可以通过 siri 回复。
然后就是，siri 实在太蠢了。我开始的时候，在个人信息里面设置了 Home 和 Work 的地址，然后试了语音说 Navigate to home 或者 Take me to home，结果就给我找到一个东北的地方，不知道是不是音译匹配上了，非常蠢，试了很多次都不行。最后只能点那个提示出来的 Home。（我刚才又试了几次，发现目前可以准确找到 Home 了。。）</description>
    </item>
    
    <item>
      <title>React Native compnent reuse</title>
      <link>https://wdicc.com/react-native-compnent-reuse/</link>
      <pubDate>Sat, 24 Mar 2018 08:44:39 +0800</pubDate>
      
      <guid>https://wdicc.com/react-native-compnent-reuse/</guid>
      <description>做功能的时候，一般我们会适当的封装一些组件出来共享，这样好管理和维护，这个大家估计都会这么做。有时候手机上面因为屏幕小，填一些表单的时候，会需要到另外一个页面去维护选择一些内容，那这个页面是页面还是组件呢？
我总结下来，所有需要填写的页面，都应该按照组件的思维来封。因为他们实际上很可能会被多次复用，一个路径上面可能会出现多次。当然，普通页面也可能会出现多次，出现多次的展示页面如果是相同的内容，那 store 里面用一个按说也没问题，如果是不同的内容，那应该会有一个 id 来区分不同的内容，这个时候 store 里面存一个用这个 id 做 key 的 map 就可以了。
继续说填写页面。比如我们的新建订单的页面，会有两个入口，一个是全新的，一个是从历史订单复制的。从历史订单复制的，就需要在 store 里面先把已有的数据放一份，再进入新建页面，如果用户点了返回按键，还需要把 store 里面的状态清掉，否则下次进入的时候还会有出来上次的数据。
如果按照组件的思维封装，那数据入口只有 props，store 里面不会有，就不用考虑清数据的问题。至于返回的数据，根据页面情况，一般是有两个途径，一个是需要把数据返回给上一个页面的，一个是直接把数据通过网络请求发送的。对于第一个，可以通过 callback 方法给上一个页面，对于第二个，通过 action 来做就可以了。
我们需要把页面里面的数据区分一下 private 数据和 public 数据。对于 private 数据每次使用基本不一样，通过 props 传递进来。而 public 数据基本是相同的，那通过 store 存下来，必要的时候更新就可以了。
我们使用的是 reac-navigation，使用的时候，可以通过 navigate(&#39;newPage&#39;, {prop1: &#39;prop1 value&#39;, callback: func1}) 这种方法来把数据和 callback 方法传递过去。那个页面处理完毕之后，通过 callback 把数据返回来。这样就不用费力把数据通过 action - reducer - selector 传到上一个页面了，并且页面再次使用也不用操心上一次使用的时候的残留数据了，页面被复用也不会互相干扰。</description>
    </item>
    
    <item>
      <title>Go Across the Gfw</title>
      <link>https://wdicc.com/go-across-the-gfw/</link>
      <pubDate>Thu, 15 Feb 2018 08:56:03 +0800</pubDate>
      
      <guid>https://wdicc.com/go-across-the-gfw/</guid>
      <description>一直用的是梅林里面自带的方案来处理翻墙，后来想在公司的服务器上面也搞一下这个事情，至少把 Google 等常用站点能翻出去，就研究了一下原理。
目前墙有两个基本措施需要我们去跨越。1 DNS 污染。 2 数据包解析劫持。3 ip 封禁。
DNS 污染是通过修改或者限制 DNS 请求的数据，来让用户取到一个错误的 ip 而导致用户不能访问正确的网站的方法。一些比较大的网站都被做了 DNS 污染，比如 Google，youtube，facebook，twitter 等。
数据包解析是指在出国的核心路由上面，分析用户要访问的网站和发送的数据，然后发现问题之后，从中间给用户和网站发送 rst 数据包，让双方断开连接的一种方法。这样就算是用户通过指定 host 等方法避开了 DNS 污染，也可以进一步阻止请求。这种方法对于 https 的请求应该是没有效果的。所以有时候可以通过指定 host 的方法访问到 google。
对于上面的避开措施，第三种方法就起作用了，就是直接封禁 ip。这样就算指定了 host 也不能访问。
如果想要翻墙，就需要避开上面这三种封禁的方法。我这里列了一些方式，https://wdicc.com/across-the-great-wall-we-can-reach-every-corner-in-the-world/ 各有利弊。这里想讲的是梅林大致的逻辑。
最主要的一个思路是使用 iptables 把一些包发给一些支持透明代理的软件，例如 ss-redir 或者 v2ray 的 dokodemo-door 协议的端口。这些软件会自动把数据请求通过代理请求到之后，返回给用户。
-A PREROUTING -p tcp -j REDIRECT --to-ports 1080 -A PREROUTING -p tcp -m multiport --dports 443 dst -j REDIRECT --to-ports 1080 -A PREROUTING -p tcp -m multiport --dports 80 dst -j REDIRECT --to-ports 1080  第一句是把所有请求都转发到了 1080 端口，这样就是全部请求都走代理。第二三句是把所有 443 和 80 端口的请求都转发到了 1080 这个代理端口。如果只是想要某些网站走代理呢？那一个办法是在这个语句里面指定 --dest=12.</description>
    </item>
    
  </channel>
</rss>