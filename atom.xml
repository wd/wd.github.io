<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Home on wd and cc</title>
    <link>https://wdicc.com/</link>
    <description>Recent content in Home on wd and cc</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 16 Sep 2018 16:36:17 +0800</lastBuildDate>
    
        <atom:link href="https://wdicc.com/atom.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Typescript for React Native</title>
      <link>https://wdicc.com/typescript-for-react-native/</link>
      <pubDate>Sun, 16 Sep 2018 16:36:17 +0800</pubDate>
      
      <guid>https://wdicc.com/typescript-for-react-native/</guid>
      <description>&lt;p&gt;前几天研究 settimeout 的问题的时候，发现 &lt;a href=&#34;https://github.com/ocetnik/react-native-background-timer&#34; title=&#34;react-native-background-timer&#34;&gt;react-native-background-timer&lt;/a&gt; 自己没有 typescript 的 type 文件，但是有人给写了一个 &lt;a href=&#34;https://www.npmjs.com/package/@types/react-native-background-timer&#34; title=&#34;@types/react-native-background-timer&#34;&gt;@types/react-native-background-timer&lt;/a&gt;，这个包算偏门了，都有人写了 type 文件，我感觉是时候试试看 typescript 了。&lt;/p&gt;

&lt;p&gt;搜了一下，发现没有多少在 rn 里面使用 ts 的，有一些关于 react 的，又很奇怪，大都基于 webpack 的。后来找到一篇&lt;a href=&#34;https://facebook.github.io/react-native/blog/2018/05/07/using-typescript-with-react-native&#34; title=&#34;官方的 blog 上面的&#34;&gt;官方的 blog 上面的&lt;/a&gt;，然后结合自己的研究，找到了思路。我是基于已有项目来做的，那个 blog 是基于新项目，大同小异。&lt;/p&gt;

&lt;p&gt;首先装几个包，这几个包里面， &lt;code&gt;=typescript&lt;/code&gt; 提供 typescript 的编译器， &lt;code&gt;react-native-typescript-transformer&lt;/code&gt; 提供了从 ts 代码到 js 代码的转换支持， @types 的两个包提供了 react 和 react-native 的 type 文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ yarn add -D typescript react-native-typescript-transformer @types/react @types/react-native
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在项目的根目录还需要准几个文件。 tsconfig.json，你的目录里面可能已经有一个 &lt;code&gt;jsconfig.json&lt;/code&gt; 了，那个是给 eslint 用的。tsconfig.json 同时给 typescript 和 tslint 使用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
  &amp;quot;compilerOptions&amp;quot;: {
    &amp;quot;target&amp;quot;: &amp;quot;es2015&amp;quot;,
    &amp;quot;module&amp;quot;: &amp;quot;es2015&amp;quot;,
    &amp;quot;lib&amp;quot;: [
      &amp;quot;es2015&amp;quot;
    ],
    &amp;quot;jsx&amp;quot;: &amp;quot;react&amp;quot;,
    &amp;quot;noEmit&amp;quot;: true,
    &amp;quot;moduleResolution&amp;quot;: &amp;quot;node&amp;quot;,
    &amp;quot;strict&amp;quot;: true,
    &amp;quot;esModuleInterop&amp;quot;: true,
    &amp;quot;types&amp;quot;: [
       &amp;quot;react&amp;quot;,
       &amp;quot;react-native&amp;quot;
     ],
    &amp;quot;allowSyntheticDefaultImports&amp;quot;: true
  },
  &amp;quot;include&amp;quot;: [
     &amp;quot;./app/**/*&amp;quot;
  ],
  &amp;quot;exclude&amp;quot;: [
    &amp;quot;node_modules&amp;quot;
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里面的 include/exclude 按照需要调整，注意里面没有 output，我们并不需要 typescript 输出 js 文件。（当然，也可以用输出 js 文件的方式来做这个事情，但是这样就不太好自动化了，细节不说了）&lt;/p&gt;

&lt;p&gt;然后还需要一个 rn-cli.config.js，这个是给 &lt;code&gt;react-native-typescript-transformer&lt;/code&gt; 用的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;module.exports = {
  getTransformModulePath() {
    return require.resolve(&#39;react-native-typescript-transformer&#39;);
  },
  getSourceExts() {
    return [&#39;ts&#39;, &#39;tsx&#39;];
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后就可以写一些 &lt;code&gt;.ts&lt;/code&gt; 文件了。 &lt;code&gt;.ts&lt;/code&gt; 文件表示只有 js 代码， &lt;code&gt;.tsx&lt;/code&gt; 文件表示里面有 react 代码。写完之后可以执行一下 &lt;code&gt;yarn tsc&lt;/code&gt; 看看，是否有错误。没有错误的话，也可以在模拟器里面看看自己的 ts 代码是不是确实可以执行。&lt;/p&gt;

&lt;p&gt;你的代码可以在模拟器里面执行，主要是下面这段代码的作用。 &lt;code&gt;ts.transpileModule&lt;/code&gt; 会把 ts 代码转换成 js 代码，最终执行的是 js 代码。这里有一个需要注意的地方就是这里不管 ts 的语法错误，也就是你比如定义了一个 type 是 string 类型的变量，你给他做了 number 类型的赋值，这个在 js 里面是可以的，ts 是不允许的，但是这里并不会看到错误。执行 &lt;code&gt;yarn tsc&lt;/code&gt; 可以看到错误提示。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;module.exports.transform = function(src, filename, options) {
  if (typeof src === &#39;object&#39;) {
    // handle RN &amp;gt;= 0.46
    ;({ src, filename, options } = src)
  }

  if (filename.endsWith(&#39;.ts&#39;) || filename.endsWith(&#39;.tsx&#39;)) {
    const tsCompileResult = ts.transpileModule(src, {
      compilerOptions,
      fileName: filename,
      reportDiagnostics: true,
    })

    const errors = tsCompileResult.diagnostics.filter(
      ({ category }) =&amp;gt; category === ts.DiagnosticCategory.Error
    )
.....
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
所以保证代码符合 typescript 有下面几个方法：
&lt;li&gt;使用支持 typescript 的编辑器，依靠编辑器的提示。vs code 配合 tslint 可以做到这个。&lt;/li&gt;
&lt;li&gt;提交代码之前执行 &lt;code&gt;yarn tsc&lt;/code&gt; 验证代码没问题之后再提交。&lt;/li&gt;
&lt;li&gt;在 git 的 commit-hook 里面增加一个 hook 自动执行 &lt;code&gt;yarn tsc&lt;/code&gt; 检查。git 也可以在 server 端做这个检查。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了保证这个，我在 git 的 commit-hook 里面增加了一个 hook。放到 &lt;code&gt;.git/hooks/pre-commit&lt;/code&gt; 就可以。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/sh

has_ts_file=`git diff --cached --name-status | awk &#39;$1 != &amp;quot;D&amp;quot; { print $2 }&#39; | grep &#39;.ts$&#39; |wc -l`

exec 1&amp;gt;&amp;amp;2

if [ &amp;quot;$has_ts_file&amp;quot; -ge &#39;1&#39; ];then
    yarn tsc
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是 git 的 hooks 文件并不是 repo 的一部份，如何保证大家都是一样的配置呢？有一个 npm 包可以做这个事情。。 &lt;code&gt;yarn add -D pre-commit&lt;/code&gt; ，然后在 package.json 里面增加一些配置。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;    &amp;quot;scripts&amp;quot;: {
        &amp;quot;start&amp;quot;: &amp;quot;node node_modules/react-native/local-cli/cli.js start&amp;quot;,
        &amp;quot;test&amp;quot;: &amp;quot;jest&amp;quot;,
        &amp;quot;lint&amp;quot;: &amp;quot;node_modules/.bin/eslint app&amp;quot;,
        &amp;quot;version&amp;quot;: &amp;quot;./version-ios.sh&amp;quot;,
        &amp;quot;precommit&amp;quot;: &amp;quot;./pre-commit&amp;quot;
    },
    &amp;quot;pre-commit&amp;quot;: [
        &amp;quot;precommit&amp;quot;
    ],
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;scripts 里面的 precommit 和 pre-commit 是新加的。那个 pre-commit 就是上面的那个脚本，放到项目目录一起管理就可以。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Background Task in React Native</title>
      <link>https://wdicc.com/background-task-in-react-native/</link>
      <pubDate>Sat, 08 Sep 2018 16:06:18 +0800</pubDate>
      
      <guid>https://wdicc.com/background-task-in-react-native/</guid>
      <description>&lt;p&gt;react-native 支持 &lt;code&gt;setTimeout&lt;/code&gt; 和 &lt;code&gt;setInterval&lt;/code&gt; 这些 js 的方法来设置 timer 执行一些任务。但是对于长时间执行的任务，比如你想每 1 分钟都执行一下网络请求看看是不是有新的数据，这个时候会有一个黄条警告和你说不要这么做。&lt;/p&gt;

&lt;p&gt;我们有类似需求，就找到了 &lt;a href=&#34;https://github.com/ocetnik/react-native-background-timer&#34; title=&#34;react-native-background-timer&#34;&gt;react-native-background-timer&lt;/a&gt; 这个包。这个用起来和 js 的 setTimeout 的方法一样，可以一直运行。&lt;/p&gt;

&lt;p&gt;我们另外还使用了 websocket 来和服务器保持数据同步。这样就必须要保证有网络问题的时候，可以自动重连保证链接。我们找到了 &lt;a href=&#34;https://github.com/pladaria/reconnecting-websocket&#34; title=&#34;reconnecting-websocket&#34;&gt;reconnecting-websocket&lt;/a&gt; 这个包，他提供了自动重连功能。这个包是基于 js 写的，没有任何的 native 代码。我们用的过程中发现时不时会出现断开的情况，因为并不能稳定复现，我们一开始也没有太多时间研究这个问题，所以这个 bug 几乎是持续了几个月。另外，也主要是因为我们还有 pc 设备，也用了 websocket，但是那边表现就很稳定，所以基本可以确定是 android 的问题。&lt;/p&gt;

&lt;p&gt;我们试过自己手动断网，和手动重启服务器的方式断开 websocket，然后发现他都会重连。出现 bug 的时候，都是比如放了一个晚上，第二天来了之后，发现断开了。或者有时候似乎又不会断，总之是不很好的稳定可以复现。&lt;/p&gt;

&lt;p&gt;一开始怀疑是 android 进入省电模式之后，应用会出问题，把设备一直接着电源之后，似乎发现好像好了，但是实际上还是会出现断开的情况。后来给 app 增加了 &lt;code&gt;REQUEST_IGNORE_BATTERY_OPTIMIZATIONS&lt;/code&gt; 权限，试图解决，发现也不行。&lt;/p&gt;

&lt;p&gt;最近一个月总算有时间看看了，仔细研究了一下。给 app 增加了更多的 log，记录一下 websocket 的链接和断开的情况。发现一个情况，似乎整整 24h 的时候，会出现一个断开。断开之后有时候会连不上，有时候可以。因为是整整 24h，所以这个断开基本上可以肯定是 server 那边问题，但是断开不能重连依然是用户端这边的问题。&lt;/p&gt;

&lt;p&gt;后来我们找到了 24h 断开的原因，我们 websocket server 用的是 channel redis，&lt;a href=&#34;https://github.com/django/channels_redis/blob/master/channels_redis/core.py#L149&#34; title=&#34;里面默认是 24h 会断开&#34;&gt;里面默认是 24h 会断开&lt;/a&gt;。这个案子破了，定期倒是没问题，现在就是为啥不会重连的问题了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt; def __init__(
        self,
        hosts=None,
        prefix=&amp;quot;asgi:&amp;quot;,
        expiry=60,
        group_expiry=86400,
        capacity=100,
        channel_capacity=None,
        symmetric_encryption_keys=None,
    ):
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过分析 websocket 的日志，发现断开之后，执行重连的时候，reconnect-websocket 避免过度重连，会增加一个延时，调用 &lt;a href=&#34;https://github.com/pladaria/reconnecting-websocket/blob/master/reconnecting-websocket.ts#L326&#34; title=&#34;this._wait()&#34;&gt;this._wait()&lt;/a&gt;，问题就出在了这里，我们发现这个 promise 会卡住不能 resolve，这里面调用的就是 &lt;code&gt;setTimeout&lt;/code&gt; 。结合一开始说的，比较怀疑 rn 自己的 setTimeout 有问题，就试了一下使用 react-native-background-timer 来实现。改了之后运行了几天发现问题解决了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;    private _wait(): Promise&amp;lt;void&amp;gt; {
        return new Promise(resolve =&amp;gt; {
            setTimeout(resolve, this._getNextDelay());
        });
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;继续看看为啥 rn 自己的 timer 有问题。&lt;/p&gt;

&lt;p&gt;找到了 &lt;a href=&#34;https://github.com/facebook/react-native/blob/master/Libraries/Core/Timers/JSTimers.js&#34; title=&#34;JSTimers.js&#34;&gt;JSTimers.js&lt;/a&gt;，这里面通过调用 &lt;code&gt;Timing.createTimer&lt;/code&gt; 来创建 timer 的。Timing.createTimer 这个 native 模块的代码在&lt;a href=&#34;https://github.com/facebook/react-native/blob/master/ReactAndroid/src/main/java/com/facebook/react/modules/core/Timing.java#L324&#34; title=&#34;这里&#34;&gt;这里&lt;/a&gt;。这代码里面用到的包不熟悉，看了半天觉得看不明白，但是看到了这些。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;  @Override
  public void onHostPause() {
    isPaused.set(true);
    clearFrameCallback();
    maybeIdleCallback();
  }

  @Override
  public void onHostResume() {
    isPaused.set(false);
    // TODO(5195192) Investigate possible problems related to restarting all tasks at the same
    // moment
    setChoreographerCallback();
    maybeSetChoreographerIdleCallback();
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那个 &lt;code&gt;onHostPause&lt;/code&gt; 很可疑，我们知道 android 黑屏的时候，是会调用 app 的 onPause 的。继续找这个类实现了 &lt;a href=&#34;https://github.com/facebook/react-native/blob/master/ReactAndroid/src/main/java/com/facebook/react/bridge/LifecycleEventListener.java&#34; title=&#34;LifecycleEventListener&#34;&gt;LifecycleEventListener&lt;/a&gt; 这个接口，里面注释写和 active 切换有关系，实际就是和 onPause 这些 activity 的生命周期挂钩的。&lt;/p&gt;

&lt;p&gt;app 放到后台之后，会调用 onHostPause，然后 timer 就都不执行了，所以那个 promise 一直不能 resolve，然后 reconnect-websocket 就不会连接。&lt;/p&gt;

&lt;p&gt;RN 提供了 &lt;a href=&#34;https://facebook.github.io/react-native/docs/headless-js-android.html&#34; title=&#34;Headless JS&#34;&gt;Headless JS&lt;/a&gt; 来执行后台任务。我们就是改造了一下 reconnect-websocket 用 react-native-background-timer 就解决问题了。有需要可以用这个 https://github.com/wd/reconnecting-websocket 。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>React Native Deeplink</title>
      <link>https://wdicc.com/react-native-deeplink/</link>
      <pubDate>Mon, 03 Sep 2018 18:00:56 +0800</pubDate>
      
      <guid>https://wdicc.com/react-native-deeplink/</guid>
      <description>&lt;p&gt;App 一般都支持类似 &lt;code&gt;coolflight://list&lt;/code&gt; 这样的链接，可以直接打开 app 并打开列表，这个就是 deeplink。&lt;/p&gt;

&lt;p&gt;这个需要对 native 代码做一些修改，可以参考&lt;a href=&#34;https://reactnavigation.org/docs/en/deep-linking.html&#34; title=&#34;这里&#34;&gt;这里&lt;/a&gt;的修改，ios 和 android 都有写。这里有一个需要注意的是，对于 android 有一个配置是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;data android:scheme=&amp;quot;mychat&amp;quot; android:host=&amp;quot;mychat&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个里面配置 host 的话，后面使用的时候就需要类似 &lt;code&gt;mychat://mychat/list&lt;/code&gt; 这样的方式了，就是多了一层 mychat。这样也会导致 ios 和 android 的链接不统一，我查了&lt;a href=&#34;https://developer.android.com/training/app-links/deep-linking&#34; title=&#34;文档&#34;&gt;文档&lt;/a&gt;也没有查到没有设置 host 会有什么问题，我就去掉了，去掉之后，ios 和 android 的链接就统一了。都是 &lt;code&gt;mychat://list&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;另外 android 还有一个需要注意的地方是，activity 的 launchmod 需要设置为 &lt;code&gt;singleTask&lt;/code&gt; 要不会导致每次通过 deeplink 打开 app 都会新建一个，导致你有多个 js 在后台跑。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;activity
  android:name=&amp;quot;.MainActivity&amp;quot;
  android:launchMode=&amp;quot;singleTask&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 js 里面可以使用 &lt;code&gt;Linking.openURL(url).catch(err =&amp;gt; console.error(&#39;An error occurred&#39;, err))&lt;/code&gt; 打开一个 deeplink ，可以是别的 app 的，也可以是自己的。&lt;/p&gt;

&lt;p&gt;然后就是在 js 里面处理对应的 deeplink 了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;componentDidMount() {
  Linking.getInitialURL().then((url) =&amp;gt; {
    if (url) {
      console.log(&#39;Initial url is: &#39; + url);
    }
  }).catch(err =&amp;gt; console.error(&#39;An error occurred&#39;, err));

  Linking.addEventListener(&#39;url&#39;, this._handleOpenURL);
}

componentWillUnmount() {
  Linking.removeEventListener(&#39;url&#39;, this._handleOpenURL);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 &lt;code&gt;componentDidMount&lt;/code&gt; 里面，通过 &lt;code&gt;Linking.getInitialURL()&lt;/code&gt; 可以得到 app 冷启动的时候拿到的 link。通过 &lt;code&gt;Linking.addEventListener(&#39;url&#39;, callback)&lt;/code&gt; 可以拿到热启动 app 拿到的 link，分别处理或者统一处理都可以，看业务需求。&lt;/p&gt;

&lt;p&gt;我们用的是 React Navigation，他支持可以直接给 screen 设置 path，然后和 deeplink 匹配跳转。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const SimpleApp = createStackNavigator({
  Home: { screen: HomeScreen },
  Chat: {
    screen: ChatScreen,
    path: &#39;chat/:user&#39;,
  },
});


const prefix = &#39;mychat://&#39;; // 这里我们上面提到的统一了，所以不用区分 ios 和 android
const MainApp = () =&amp;gt; &amp;lt;SimpleApp uriPrefix={prefix} /&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样只需要定义一个 &lt;code&gt;uriPrefix&lt;/code&gt; 就可以了。&lt;/p&gt;

&lt;p&gt;我们为了把 navigation 和 redux 结合，自定义了 navigation 的 &lt;code&gt;navigation&lt;/code&gt; 属性，就不允许这么弄了。需要自己处理。&lt;/p&gt;

&lt;p&gt;主要思路是通过 &lt;code&gt;SimpleApp.router.getActionForPathAndParams(path, params)&lt;/code&gt; 得到 action，然后 dipatch 这个 action 就可以了。&lt;/p&gt;

&lt;p&gt;那个 &lt;code&gt;chat/:user&lt;/code&gt; 可以匹配到 &lt;code&gt;mychat://chat/Jim&lt;/code&gt; 这样的 deeplink，然后那个 &lt;code&gt;user: Jim&lt;/code&gt; 会以 param 的方式给到 screen，通过 param.user 可以访问到。&lt;/p&gt;

&lt;p&gt;path 的格式支持的是这个 &lt;a href=&#34;https://github.com/pillarjs/path-to-regexp&#34; title=&#34;path-to-regexp&#34;&gt;path-to-regexp&lt;/a&gt; 支持的格式，可以自定义表达式，具体可以参考那个文档。&lt;/p&gt;

&lt;p&gt;path 支持使用 &lt;code&gt;?&lt;/code&gt; 来表示一个字段是可选的，例如 &lt;code&gt;mychat://chat/:user?&lt;/code&gt; 表示会匹配到 &lt;code&gt;mychat://chat&lt;/code&gt; 和 &lt;code&gt;mychat://chat/Jim&lt;/code&gt; 。 &lt;code&gt;mychat://chat/:user?/:msg?&lt;/code&gt; 这样的，可以匹配 &lt;code&gt;mychat://chat&lt;/code&gt; &lt;code&gt;mychat://chat/Jim&lt;/code&gt; &lt;code&gt;mychat://chat/Jim/hey&lt;/code&gt; 但是不能匹配 &lt;code&gt;mychat://chat//hey&lt;/code&gt; 。默认匹配的是 &lt;code&gt;([^\\/]+)&lt;/code&gt; 可以通过自定义表达式支持。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;  path: &#39;chat/:user([^\\/]*)?/:msg?&#39;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>React Mobx</title>
      <link>https://wdicc.com/react-mobx/</link>
      <pubDate>Sun, 02 Sep 2018 19:18:16 +0800</pubDate>
      
      <guid>https://wdicc.com/react-mobx/</guid>
      <description>&lt;p&gt;我们之前用的是 redux 来做的统一 store，最近一个新项目有同学用了 mobx，就了解了一下，刚开始看的时候，感觉比 redux 好啊？&lt;/p&gt;

&lt;p&gt;mobx 的逻辑是自动收集 store 属性被哪些 dom 使用，然后在属性被改变的时候，自动更新 dom。这样的模式显然比 redux 的 action，reducer，selector 那一套简单多了。&lt;/p&gt;

&lt;p&gt;给对应的组件加上 &lt;code&gt;@observer&lt;/code&gt; 装饰器之后，store 改变就会自动重现渲染组件。store 可以用下面的模式给到组件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const store = new TodoList();
&amp;lt;TodoListView todoList={store} /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以用 &lt;code&gt;@inject&lt;/code&gt; 装饰器&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;@inject(store =&amp;gt; store)
@observer
class TodoListView {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后都通过 &lt;code&gt;this.props&lt;/code&gt; 引用。&lt;/p&gt;

&lt;p&gt;一切都很美好，直到我看到了&lt;a href=&#34;https://mobx.js.org/best/react.html&#34; title=&#34;这个&#34;&gt;这个&lt;/a&gt;，这里列了一些 mobx 的坑。比如有讲到，mobx 为了能监控到对 store 的依赖和修改，其实是把 store 属性做了修改，所以 store 有一个属性是一个 Map，那么实际得到的是一个和 ES6 Map api 类似的一个对象，但是并不是原生的 Map。比如有一个属性是 Object，你给加了一个 key，例如 store.object[&#39;a&#39;] = &#39;test&#39;，那么这个修改并不能被监视，具体看那个文档吧。&lt;/p&gt;

&lt;p&gt;写 Javascript 基本就是从一个小坑爬出来掉到一个大坑里面。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Android Custom</title>
      <link>https://wdicc.com/android-custom/</link>
      <pubDate>Sun, 02 Sep 2018 08:00:16 +0800</pubDate>
      
      <guid>https://wdicc.com/android-custom/</guid>
      <description>&lt;p&gt;我们给用户的设备，有 android pad 和 pc。pc 系统我之前基于 porteus 定制了一个，勉强可以用。apad 的系统一直没搞好。&lt;/p&gt;

&lt;p&gt;Android 系统必须要解锁之后才可以定制系统，否则没有 root 权限，system 分区的数据不能修改。&lt;/p&gt;

&lt;ul&gt;
Android 系统有四个重要的分区。
&lt;li&gt;&lt;code&gt;boot&lt;/code&gt; ，和 linux 的类似，里面有 kernel 和 ramdisk，ramdisk 应该是在启动之后会成为 / 分区&lt;/li&gt;
&lt;li&gt;&lt;code&gt;recovery&lt;/code&gt; ，恢复分区，如果想对系统分区做什么操作，可以使用这里的程序引导系统，这个时候允许你进行一些操作。默认的 recovery 只能 wipe 和刷系统。自定义的 recovery 比较厉害，可以支持备份啊啥的一堆事情，比如 twrp 还有图形界面。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;system&lt;/code&gt; ，系统分区，系统程序都在这里，包括系统自带的一些 app 等等。正常情况对这个分区是不能修改的，系统分区都是只读的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;data&lt;/code&gt; ，数据分区，这个分区是给用户使用的。用户安装的一下 app 以及一些数据都在这里。wipe 的时候就是会清空这个分区的数据。大家熟悉的 sdcard 那个分区，其实数据也是在这里的。data 分区里面 app 只能读取自己的数据，无法访问别的 app 的。但是放在 /sdcard 分区的数据，大家都可以访问（当然，还得有 sdcard 的权限）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;前三个分区都可以定制。首先需要解锁 bootloader，这个各个定制版都可能有区别，比如华为我记得还需要去他们网站获取一个解锁码，获取的时候会提示你解锁之后就不给保了。原生的 android 都是去开发者选项里面打开，然后在启动的时候进 bootloader，执行 &lt;code&gt;fastboot oem unlock-go&lt;/code&gt; 。解锁的时候会自动 reset 系统，注意先备份数据。&lt;/p&gt;

&lt;p&gt;解锁之后，就可以刷自己的 recovery 了。刷之前建议先备份一下 &lt;code&gt;boot&lt;/code&gt; &lt;code&gt;recovery&lt;/code&gt; &lt;code&gt;system&lt;/code&gt; 分区，以方便自己回头可以刷回来。我用的是 twrp，其它的好像现在也么看到。这个得找和你的手机匹配的才行。具体方法是执行 fastboot boot twrpxxxxx.img 临时使用 twrp 启动，然后用通过 &lt;code&gt;adb shell&lt;/code&gt; 登录 shell，之后用 &lt;code&gt;dd if=/dev/block/mmcblk0pXX of=/sdcard/xxx.img&lt;/code&gt; 来备份，之后用 &lt;code&gt;adb pull /sdcard/xxx.img&lt;/code&gt; 下载到本地。具体各个分区的那个 XX 是什么，可以用 &lt;code&gt;fdisk -l&lt;/code&gt; 看。&lt;/p&gt;

&lt;p&gt;这里有一个需要注意的是，我发现我这使用临时启动到 twrp 的方式还是不能修改 system 分区，必须是把 twrp 刷入 recovery 之后才可以。就是这个导致我一直没有搞好 apad 的系统，我开始一直是用临时启动到 recovery 的方式来做的，对 system 做修改就是死机。&lt;/p&gt;

&lt;p&gt;现在比较新的系统都有一个 dm-verify ，想修改 system 分区就需要关闭这个，否则任何修改都会导致系统不能启动。我在 &lt;a href=&#34;https://forum.xda-developers.com/android/software/universal-dm-verity-forceencrypt-t3817389&#34; title=&#34;xda 找到一个&#34;&gt;xda 找到一个&lt;/a&gt; 可以直接在 recovery 里面通过 sideload 刷就可以。&lt;/p&gt;

&lt;p&gt;关闭 dm-verify 之后就可以修改系统了。我还有一个需求是想系统启动之后，通过 iptables 对系统使用的网络做一些限制。想要在系统启动之后做一些事情，比较简单的就是修改 system 分区的那些 xxx.rc 加入自己的东西。我试了之后发现虽然程序可以执行，但是这种方式的程序，并不能直接操作 iptables 命令（执行不报错，但是无实际效果）。查了说大概是 kernel 级别的限制，这样难不成就去定制 kernel 了？&lt;/p&gt;

&lt;p&gt;Android 系统的 root 实际应该就是对系统 kernel 打了一个补丁，放了一个后门，允许通过 su 命令来获取 root 权限，这里获取的 root 权限可是货真价实的，可以执行 iptables 命令。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://forum.xda-developers.com/apps/magisk&#34; title=&#34;Magisk&#34;&gt;Magisk&lt;/a&gt; 可以给系统 root。recovery 里面通过 sideload 刷入之后，系统会多出来一个 app，有程序想用 su 的话，这个 app 会弹一个提示问是不是允许。magisk 应该是给 kernel 打了补丁，关闭了 dm-verify（所以用 magisk 的话，就可以不用上面那个了），然后启动的时候，会 mount 一个 su.img 提供 su 命令，会启动一个 su 的 daemon。这个可以通过看 ramdisk 里面的内容可以看到。magisk 还会在你的 /data 分区装一个 app，一起配合使用。但是要注意一点，我们 wipe 系统之后，这个 app 也会被删除。但是前面说的那些 su.img 之类都是在 boot 分区的，那些都还有，一个没有 app 配合的 su 也可以用，就是所有程序都直接使用，没有限制了。所以如果是你自己用，那最最好是和 boot 一起刷，或者就是自己安装一个 app。&lt;/p&gt;

&lt;p&gt;对于 system 的修改，拿到 root 权限就可以了。但是对于 boot 分区，只能拿到一个 boot.img，想要修改，还需要使用一些工具把里面的内容解出来，以及之后再打包。我找到一个&lt;a href=&#34;https://forum.xda-developers.com/showthread.php?t=2319018&#34; title=&#34;工具&#34;&gt;工具&lt;/a&gt; 。&lt;/p&gt;

&lt;p&gt;android 系统启动的时候会读取一些 xxx.rc，这些 rc 类似 linux 下面那些，但是不像 linux 那些都是脚本，是有一个自己的格式的内容。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;on property:sys.boot_completed=1
    start wd-post-boot

service wd-post-boot /system/bin/sh /wd.post_boot.sh
    class late_start
    user root
    disabled
    oneshot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比如我上面这个，定义了一个 service &lt;code&gt;wd-post-boot&lt;/code&gt; ，然后让他在 &lt;code&gt;sys.boot_completed&lt;/code&gt; 这个 prop 值为 1 的时候执行一次。还有很多其它的方法，可以找 android 的文档看，我说的不能执行 iptables 就是这里的脚本里面不能执行。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Boot Linux Through PXE</title>
      <link>https://wdicc.com/boot-linux-through-pxe/</link>
      <pubDate>Mon, 02 Jul 2018 16:47:31 +0800</pubDate>
      
      <guid>https://wdicc.com/boot-linux-through-pxe/</guid>
      <description>&lt;p&gt;测试 porteus 的时候，每次都是做好 iso 之后写到一个 u 盘，然后用 u 盘启动看看效果，发现有点蛋疼，这浪费时间不说，我的 u 盘寿命估计也得少一截。就研究了一下 pxe 启动，这样每次改完之后通过 pxe 直接读取我改了之后的 iso 引导 linux 就好了。&lt;/p&gt;

&lt;p&gt;我这看 pxe 启动主要需要做两个事情，一个是 dhcp 的时候广播 tftp 的信息，一个是通过 nfs 共享给那个系统需要读取的文件。nfs 共享也可以改用 http 等其他服务。&lt;/p&gt;

&lt;h2 id=&#34;dnsmasq&#34;&gt;dnsmasq&lt;/h2&gt;

&lt;p&gt;广播 tftp 的信息，可以通过 dnsmasq 来做。dhcp 部分就不贴了，只贴 tftp 相关的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tftp-root=/srv/pxe/boot
dhcp-boot=/pxelinux.0
enable-tftp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;网卡启动的时候会获取 &lt;code&gt;/pxelinux.0&lt;/code&gt; 然后获取 &lt;code&gt;/pxelinux.cfg/default&lt;/code&gt; （这个实际上有一个判断顺序，方便给不同的机器不同的配置）。然后根据这里面的配置，获取内核信息。然后加载内核。&lt;/p&gt;

&lt;h2 id=&#34;nfs&#34;&gt;nfs&lt;/h2&gt;

&lt;p&gt;加载内核之后还需要系统文件，这个时候貌似有几个选择，比如通过 http 发送。我这用的是 nfs。想要通过 nfs 发送，内核得能支持 nfs mount。各 linux 的做法貌似不太一样。&lt;/p&gt;

&lt;p&gt;配置 nfs 的目录，在 &lt;code&gt;/etc/exports&lt;/code&gt; 里面加入类似这样的信息。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/srv/pxe/porteus *(ro,fsid=0,no_subtree_check)
/srv/pxe/storage *(rw,fsid=1,no_root_squash,no_subtree_check)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后 &lt;code&gt;exportfs -rv&lt;/code&gt; ，这样 nfs 设置好了。&lt;/p&gt;

&lt;p&gt;我这 export 的目录和上面 tftp-root 的目录不一样，有的发行版可能会按照 tftp-root 的设置来读取，这个还得区分发行版看。&lt;/p&gt;

&lt;h2 id=&#34;其他&#34;&gt;其他&lt;/h2&gt;

&lt;p&gt;上面的例子只是写了一个大高，是实际使用相差很大。比如如何得到 &lt;code&gt;pxelinux.0&lt;/code&gt; ，如何让内核支持 nfs，以及在内核启动的时候加载 nfs 并使用 nfs 的数据启动，这些都和发行版有关系，还需要单看。&lt;/p&gt;

&lt;ul&gt;
参考
&lt;li&gt;&lt;a href=&#34;https://www.syslinux.org/wiki/index.php?title=PXELINUX&#34; title=&#34;PXELINUX&#34;&gt;PXELINUX&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Install Porteus to HD</title>
      <link>https://wdicc.com/install-porteus-to-hd/</link>
      <pubDate>Mon, 02 Jul 2018 16:23:54 +0800</pubDate>
      
      <guid>https://wdicc.com/install-porteus-to-hd/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://porteus.org/&#34; title=&#34;Porteus&#34;&gt;Porteus&lt;/a&gt; 是一个很好玩的系统，他基于 aufs 弄出来的一个「只读」系统，说是只读，实际上他也可以把修改保存到一个硬盘目录，然后启动的时候自动加载这些修改，这样就修改都还在。但是如果把这个目录删除，那么修改就都没有了，这就是所谓的只读。&lt;/p&gt;

&lt;p&gt;我开始的需求是需要搞一个 linux，然后给用户使用，并且希望用户只能用浏览器，不能使用其他东西，因为我们提供的服务就是一个网页。不能使用其他东西是为了避免使用的时候导致系统奔溃什么的，还得派人花时间去维护。然后看到有人推荐 &lt;a href=&#34;http://porteus-kiosk.org/index.html&#34; title=&#34;Kiosk&#34;&gt;Kiosk&lt;/a&gt;，看了一下感觉这个东西太完美了，就是我想要的东西。然后就开始研究这个系统。研究的过程中发现了他是基于 Porteus 的，就开始看 porteus。&lt;/p&gt;

&lt;p&gt;Kiosk 确实也不错，但是我使用的时候想要定制支持中文输入法，打印机等设备，然后发现他阉割加定制的太多了，导致我看了几天居然还没有找到他的入口在哪里，尝试想搞定输入法，费了很多劲。kiosk 使用的是 openbox + tint2 ，后面看了 porteus 之后，他支持 mate，kde 这些桌面，并且也直接就支持 scim，所以打算还是基于这个定制比较简单一点。&lt;/p&gt;

&lt;p&gt;具体定制就不多说了，主要是定制好 iso 之后，怎么安装到硬盘。&lt;/p&gt;

&lt;p&gt;其实也相当简单，只需要把 u 盘上面的内容复制到一个硬盘分区，然后安装一个 bootloader 就可以了。&lt;/p&gt;

&lt;p&gt;安装 bootloader 的时候由于对这个东西不是特别熟悉，以及这么多年不搞 linux 之后又出来很多新的概念，所以走了一些弯路，一番&lt;a href=&#34;https://wdicc.com/grub2-and-uefi/&#34; title=&#34;学习&#34;&gt;学习&lt;/a&gt;之后，发现简单的很。可以参考&lt;a href=&#34;https://wdicc.com/grub2-and-uefi/#grub&#34; title=&#34;这里&#34;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;然后就是需要弄一个 &lt;code&gt;grub.cfg&lt;/code&gt; 就可以了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set timeout=1
set superusers=root
password_pbkdf2 root grub.pbkdf2.sha512.10000.xxxxxxxx
password guest guest

if [ x&amp;quot;$default&amp;quot; = xsaved ];then
 load_env;
 set default=&amp;quot;$saved_entry&amp;quot;;
fi

insmod vbe
insmod efi_gop
insmod efi_uga

insmod font
insmod part_gpt

search --label --no-floppy --set kgzx KGZX
set prefix=($kgzx)/boot/grub

if loadfont $prefix/fonts/unicode.pf2
then
    insmod gfxterm
    set gfxmode=auto
    set gfxpayload=keep
    terminal_output gfxterm
    insmod png
    background_image $prefix/grub.png
fi

menuentry &#39;我的系统&#39; --unrestricted {
  set root=&amp;quot;($kgzx)&amp;quot;
  linux /boot/syslinux/vmlinuz changes=/mnt/sda4/
  initrd /boot/syslinux/initrd.xz
  boot
}

menuentry &#39;Cleanup&#39; --users &amp;quot;guest&amp;quot; {
  set root=&amp;quot;($kgzx)&amp;quot;
  linux   /boot/syslinux/vmlinuz 3 restore=1
  initrd /boot/syslinux/initrd.xz
  boot
}

menuentry &#39;Backup&#39; --users &amp;quot;root&amp;quot; {
  search --file --set root /efi/Microsoft/Boot/bootmgfw.efi
  chainloader /efi/Microsoft/Boot/bootmgfw.efi
  boot
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果只是使用 mbr 方式，也可以用 grub-legacy 也就是 0.97 那个版本，安装操作类似的，grub.cfg 不一样，那个是叫做 &lt;code&gt;menu.lst&lt;/code&gt; 。然后那个版本不支持 uefi boot 和中文菜单。好像也不支持菜单设置密码？没啥特别的建议还是 grub2 吧。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Compile Kernel Module</title>
      <link>https://wdicc.com/compile-kernel-module/</link>
      <pubDate>Mon, 02 Jul 2018 16:13:56 +0800</pubDate>
      
      <guid>https://wdicc.com/compile-kernel-module/</guid>
      <description>&lt;p&gt;使用 porteus 的时候，发现网卡不支持，找了一下发现有内核驱动可以用，那就需要编译一下内核的模块。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.porteus.org/component/content/article/20-tutorials/development/91-compilation-and-usage-of-custom-porteus-kernel.html&#34; title=&#34;这里&#34;&gt;这里&lt;/a&gt;有一个帖子写了如何编译内核，主要步骤是先给内核打 aufs 的补丁，然后就是正常的 make config &amp;&amp; make &amp;&amp; make modules_install 了。&lt;/p&gt;

&lt;p&gt;我这只是编译一个网卡驱动，操作步骤大概如下，把内核解压放到 /mnt/sda1/kernel 下面，然后把网卡驱动代码放到 /mnt/sda1/kernel/linux-4.16.3/drivers/net/wireless/rtl8821ce 下面。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# cd /mnt/sda1/kernel/linux-4.16.3/
# modprobe configs &amp;amp;&amp;amp; zcat /proc/config.gz &amp;gt; .config
# make oldconfig
# make prepare
# make modules_prepare
# export srctree=/mnt/sda1/kernel/linux-4.16.3
# ln -s /mnt/sda1/kernel/linux-4.16.3 /usr/src/linux
# cd drivers/net/wireless/rtl8821ce
# make
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在这个目录下面会产生一个 rtl8821ce.ko 的文件。&lt;/p&gt;

&lt;p&gt;如果是遇到自己用的内核有一个模块没编译，那可以用下面的方式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# after make modules_prepare
# make modules SUBDIRS=drivers/firmware/efi/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样会在 drivers/firmware/efi/ 目录下面产生一个 xx.ko 之类的文件。&lt;/p&gt;

&lt;p&gt;把上面产生的 ko 文件放到你的 linux 的对应目录就可以使用 modprob 加载了，例如 &lt;code&gt;/lib/modules/4.16.3-porteus/kernel/drivers/net/wireless/8821ce.ko&lt;/code&gt; 。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Geodesy</title>
      <link>https://wdicc.com/geodesy/</link>
      <pubDate>Sun, 01 Jul 2018 08:10:05 +0800</pubDate>
      
      <guid>https://wdicc.com/geodesy/</guid>
      <description>&lt;p&gt;坐标点之间的距离角度计算不能简单的用平面几何来算，得按照球面计算，PostgreSQL 提供了 gis 数据的计算支持，各种图形关系判断，距离计算等等。但是我们有时候也需要在 js 里面计算，开始的时候尝试自己按照公式写来着，写了一些发现太蛋疼了，因为只是单纯的看公式，缺少空间概念，算的对不对啥的都不知道。后来发现了这个 &lt;a href=&#34;https://github.com/chrisveness/geodesy&#34; title=&#34;js 库&#34;&gt;js 库&lt;/a&gt;，简直太贴心了。&lt;/p&gt;

&lt;ol&gt;
提供了我用过的几个功能
&lt;li&gt;度数表示转换，小数点形式到度分秒形式的互转。在 utm.js 里面。&lt;/li&gt;
&lt;li&gt;计算线的真北角。point1.bearingTo(point2)，真北角计算是和线的方向有关系的。&lt;/li&gt;
&lt;li&gt;和当前点夹角是 x，距离是 y 的点，point1.destinationPoint(y, x)。&lt;/li&gt;
&lt;li&gt;两点之间的距离，point1.distanceTo(point2)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;然后顺便记录一些东西。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 两条线的夹角的一半，普通角度
let angle = (360 + 180 + bearing1 - bearing2) % 360 // 360 保证只有正的
let halfAngle = angle &amp;gt; 180 ? (360 - angle)/2 : angle/2 // 只要锐角

// 计算两条线夹角中线的真北角
// left,right bearing 需要是真北角
let rightBearing = 90 + (bearing1 + bearing2)/2
let leftBearing = 180 + rightBearing

// Math.sin 之类的方法使用的应该是小数形式的度数表示
let angleToDecimal = halfAngle*Math.PI/180
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>UEFI Bootable Usb</title>
      <link>https://wdicc.com/uefi-bootable-usb/</link>
      <pubDate>Sat, 30 Jun 2018 07:30:58 +0800</pubDate>
      
      <guid>https://wdicc.com/uefi-bootable-usb/</guid>
      <description>&lt;h1 id=&#34;uefi-shell&#34;&gt;UEFI shell&lt;/h1&gt;

&lt;p&gt;UEFI firmware 应该会读取设备里面的分区，找到 ESP 然后再读里面的内容。我看到最简单的方式是把 u 盘格式化成 fat 然后建一个目录 &lt;code&gt;/boot/efi&lt;/code&gt; 然后下载一个 &lt;a href=&#34;https://wiki.archlinux.org/index.php/Unified_Extensible_Firmware_Interface#UEFI_Shell&#34; title=&#34;uefi shell&#34;&gt;uefi shell&lt;/a&gt; 把 .efi 文件放到这个目录 &lt;code&gt;/boot/efi/shellx64.efi&lt;/code&gt; ，然后启动的时候就多了一个 uefi 菜单了，选择之后可以进入一个 uefi shell。&lt;/p&gt;

&lt;p&gt;uefi shell 里面有几个命令可以用。&lt;/p&gt;

&lt;h2 id=&#34;map&#34;&gt;map&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;map&lt;/code&gt; 可以列出来当前机器的磁盘情况，找到你的 esp 分区。&lt;/p&gt;

&lt;h2 id=&#34;ls&#34;&gt;ls&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;ls&lt;/code&gt; 可以列出来磁盘目录里面的内容，比如 &lt;code&gt;ls fs0:\boot&lt;/code&gt; ，注意磁盘和目录之间用 &lt;code&gt;:&lt;/code&gt; ，目录层级之间用 &lt;code&gt;\&lt;/code&gt; 。&lt;/p&gt;

&lt;h2 id=&#34;bcfg&#34;&gt;bcfg&lt;/h2&gt;

&lt;p&gt;可以通过 &lt;code&gt;bcfg boot dump -v&lt;/code&gt; 列出来当前所有的 efi 菜单，注意每个项目都有一个序号，后面会用到。&lt;/p&gt;

&lt;p&gt;比如我想自己加一个菜单进去，那就找到最后那个的序号，然后执行 &lt;code&gt;bcfg add 8 fs0:\boot\grub\grubx64.efi GRUB&lt;/code&gt; (fat 系统不区分大小写)，指向我自己通过 &lt;code&gt;grub-install --efi-directory=/mnt/sda1/&lt;/code&gt; 放到 esp 分区的 grub 的 efi ，这样启动的时候就多了一个 GRUB 的选项，通过这个选项就可以进入 linux，然后使用更方便的 efibootmgr 来编辑这个菜单了。&lt;/p&gt;

&lt;ul&gt;
参考:
&lt;li&gt;&lt;a href=&#34;https://wiki.archlinux.org/index.php/EFISTUB#UEFI_Shell&#34; title=&#34;UEFI Shell&#34;&gt;UEFI Shell&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;自己制作-iso&#34;&gt;自己制作 iso&lt;/h1&gt;

&lt;p&gt;通过 &lt;a href=&#34;https://www.syslinux.org/wiki/index.php?title=Isohybrid#UEFI&#34; title=&#34;isohybrid&#34;&gt;isohybrid&lt;/a&gt; 可以把一个 iso 做成支持 uefi 的格式，然后通过 dd 写入 u 盘之后，这个 u 盘就支持 uefi 启动了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkisofs \
 -o output.iso \
 -c boot/syslinux/isolinux.boot \
 -b boot/syslinux/isolinux.bin \
  -no-emul-boot -boot-load-size 4 -boot-info-table \
 -eltorito-alt-boot \
 -eltorito-platform 0xEF -eltorito-boot isolinux/efiboot.img \
  -no-emul-boot \
 CD_ROOT
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;efiboot.img 实际是一个 iso 格式的磁盘 img，可以通过下面的方式产生&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ dd if=/dev/zero of=./efiboot.img bs=1M count=4
$ mount efiboot.img ./mnt
$ cp -r EFI /mnt
$ umount /mnt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;EFI/boot 目录是 efi 启动你自己定义的内容，然后执行 &lt;code&gt;isohybrid --uefi output.iso&lt;/code&gt; 。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Grub2 and UEFI</title>
      <link>https://wdicc.com/grub2-and-uefi/</link>
      <pubDate>Fri, 29 Jun 2018 20:03:54 +0800</pubDate>
      
      <guid>https://wdicc.com/grub2-and-uefi/</guid>
      <description>&lt;p&gt;这几天搞 Linux 又学习了一些新的东西。&lt;/p&gt;

&lt;p&gt;以前都是把 grub 装到 MBR，然后通过 grub 可以 chainloader 启动 windows。现在发现我装了之后并不能启动我的 windows 10 了，就只好研究了一下。&lt;/p&gt;

&lt;h2 id=&#34;gpt-分区&#34;&gt;GPT 分区&lt;/h2&gt;

&lt;p&gt;以前都是 MBR(Master Boot Record) 形式的分区，主分区 4 个，如果想要建更多，需要建扩展分区，然后再在扩展分区里面建立逻辑分区。现在发现有了 GPT(GUID Partition Table) 分区。这个方式呢，比 MBR 方式有好处，支持更多分区，支持大于 2.2TB 容量的磁盘。&lt;/p&gt;

&lt;p&gt;我看我的 windows 10 机器预装就是用的这个分区格式。&lt;/p&gt;

&lt;h2 id=&#34;uefi-系统&#34;&gt;UEFI 系统&lt;/h2&gt;

&lt;p&gt;UEFI(Unified Extensible Firmware Interface) 是基于 BIOS 的 MBR 启动方式不同的东西，是基于单独的 EFI System Partition(ESP) 里面的数据启动的。里面的程序都需要和 UEFI firmware 的 bitness 一致，x86_64 啥的。&lt;/p&gt;

&lt;p&gt;所以我的 windows 10 在 ESP 分区里面已经放了一个自己的起动器。Linux 启动之后，可以查看 &lt;code&gt;/sys/firmware/efi&lt;/code&gt; 看看是不是有，有的话表示 kernel 支持 efi，且和 firmware 的 bitness 一致。&lt;/p&gt;

&lt;p&gt;ESP 分区是 fat16/fat32 格式的，不像 mbr 在固定位置，到底是哪个分区是呢？是通过通过分区的 boot flag 这个标志来识别的。&lt;/p&gt;

&lt;h2 id=&#34;efibootmgr&#34;&gt;efibootmgr&lt;/h2&gt;

&lt;p&gt;Linux 下面可以使用 efibootmgr 管理 efi 菜单，当然得 kernel 支持，主要看 &lt;code&gt;/sys/firmware/efi&lt;/code&gt; 目录吧。具体内核参数可以看&lt;a href=&#34;https://wiki.archlinux.org/index.php/Unified_Extensible_Firmware_Interface#Linux_kernel_config_options_for_UEFI&#34; title=&#34;这个&#34;&gt;这个&lt;/a&gt;。我看着应该是只有通过 efi 启动的系统，才能读取 efi firmware 的信息。否则就算有内核模块也不能读取。&lt;/p&gt;

&lt;p&gt;我还发现我这的机器上面通过 efibootmgr 删除了 windows 的行之后，启动的时候按 F12 出来的启动选项里面还有 windwos，会自动加回来，不知道是主板的保护还是哪里的问题，bios 里面没找到可以关闭这个功能的地方。&lt;/p&gt;

&lt;h2 id=&#34;grub&#34;&gt;Grub&lt;/h2&gt;

&lt;p&gt;grub 支持安装到 MBR 也支持安装到 ESP 分区。不过只是把内容放到那个分区，最后给 efi 加启动的菜单，还需要 efibootmgr，就是需要相应的内核支持。&lt;/p&gt;

&lt;p&gt;类似这样，就是通过 uefi 启动了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# grub-install --target=x86_64-efi --efi-directory=/mnt/sda1 --bootloader-id=GRUB --boot-directory=/mnt/sda4/boot /dev/sda
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以装到 MBR，就是通过传统的 bios 启动。可能需要加 &lt;code&gt;--force&lt;/code&gt; ，我遇到的情况会提示 gpt 分区的 boot flag 没有，我这直接不理他加 force 就可以。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# grub-install --boot-directory=/mnt/sda4/boot /dev/sda
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;grub 实际上是放到第一个分区前面的一部分空间里面的，传统的 MBR 方式分区软件一般会预留 31kb 从第 63 个扇区开始分区。对于 GPT 分区，因为会有一个 ESP 分区，grub 也可以直接利用这个，装到这个分区，ESP 分区会有一个 bootable flag，因为这等于是单独给 grub 用的分区，所以 grub 也不客气会直接覆盖里面的东西，用自己的文件系统格式，一般系统都不支持，这样也可以防止你自己或者被其他软件误操作。所以要注意，如果你打算用 efi 模式启动，那通过第一个方式用 &lt;code&gt;--efi-directory&lt;/code&gt; 把 grub 装到这个分区，或者就还是用 mbr 方式好了。参考&lt;a href=&#34;https://www.gnu.org/software/grub/manual/grub/html_node/BIOS-installation.html#BIOS-installation&#34; title=&#34;这个&#34;&gt;这个&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;加载-windows&#34;&gt;加载 windows&lt;/h2&gt;

&lt;p&gt;我看可以通过 chainloader 加载 windows，也有 ntldr 加载，不太清楚具体区别。chainloader 是通过读取指定设备的块来的，比如 chainloader +1 读第一个块。或者 chainloader /EFI/Microsoft/Boot/bootmgfw.efi。&lt;/p&gt;

&lt;p&gt;UEFI 模式安装的 windows 可以参考&lt;a href=&#34;https://wiki.archlinux.org/index.php/GRUB#Windows_installed_in_UEFI.2FGPT_Mode_menu_entry&#34; title=&#34;这里&#34;&gt;这里&lt;/a&gt;，传统 MBR 方式的，参考&lt;a href=&#34;https://wiki.archlinux.org/index.php/GRUB#Windows_installed_in_BIOS.2FMBR_mode&#34; title=&#34;这里&#34;&gt;这里&lt;/a&gt;，这个用的是 ntldr 的方式，估计用 chainloader +1 应该也可以。&lt;/p&gt;

&lt;h2 id=&#34;怎么通过-uefi-启动-grub&#34;&gt;怎么通过 uefi 启动 grub&lt;/h2&gt;

&lt;p&gt;想要使用 efibootmgr 编辑 efi 的菜单，就得通过 efi 模式启动到一个 linux。那一种方式是找一个支持 efi 启动的 live cd。另外一种是使用一个 &lt;a href=&#34;https://wiki.archlinux.org/index.php/Unified_Extensible_Firmware_Interface#UEFI_Shell&#34; title=&#34;uefi shell&#34;&gt;uefi shell&lt;/a&gt;，可以参考&lt;a href=&#34;https://wdicc.com/uefi-bootable-usb/&#34; title=&#34;这里&#34;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;设备名称是变的怎么办&#34;&gt;设备名称是变的怎么办&lt;/h2&gt;

&lt;p&gt;我发现我这插了 u 盘之后，u 盘就成了 hd0 了，这样写在 grub.cfg 里面的 &lt;code&gt;set root=&amp;quot;(hd0,1)&amp;quot;&lt;/code&gt; 这样的代码就有问题了。grub2 提供了一个 &lt;a href=&#34;https://www.gnu.org/software/grub/manual/grub/grub.html#search&#34; title=&#34;search&#34;&gt;search&lt;/a&gt; 命令来查找你想要的东西，然后把结果设置到一个变量。&lt;/p&gt;

&lt;p&gt;文档里面写了 &lt;code&gt;search.file&lt;/code&gt; 是 &lt;code&gt;search --file&lt;/code&gt; 的 alias，但实际上还有坑在这里。区别的地方看下面&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;search.file /efi/Microsoft/Boot/bootmgfw.efi root
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;search --file /efi/Microsoft/Boot/bootmgfw.efi --set root
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看到区别了吧，那个 root 相当于是自己定义的变量（实际上 grub2 会隐含的用到 root 变量，所以也不能完全说是自己定义的）。我在这个坑上面花了一些时间。&lt;/p&gt;

&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.rodsbooks.com/efi-bootloaders/index.html&#34; title=&#34;Managing EFI Boot Loaders for Linux&#34;&gt;Managing EFI Boot Loaders for Linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.rodsbooks.com/efi-bootloaders/grub2.html&#34; title=&#34;Managing EFI Boot Loaders for Linux: Using GRUB 2&#34;&gt;Managing EFI Boot Loaders for Linux: Using GRUB 2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.gnu.org/software/grub/manual/grub/html_node/Installing-GRUB-using-grub_002dinstall.html&#34; title=&#34;4.1 Installing GRUB using grub-install&#34;&gt;4.1 Installing GRUB using grub-install&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Redux Selector</title>
      <link>https://wdicc.com/redux-selector/</link>
      <pubDate>Sun, 13 May 2018 10:43:28 +0800</pubDate>
      
      <guid>https://wdicc.com/redux-selector/</guid>
      <description>&lt;p&gt;redux 应用可以通过 selector 来做 state -&gt; props 的映射工作。selector 本身有缓存效果，所以可以一定意义上加速。我用的是这个 &lt;a href=&#34;https://github.com/reduxjs/reselect&#34; title=&#34;https://github.com/reduxjs/reselect&#34;&gt;https://github.com/reduxjs/reselect&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;selector 主要是一个纯函数，给同样的输入，得到同样的输出，只处理数据，没有其他附加影响。这样就可以缓存中间结果了。&lt;/p&gt;

&lt;p&gt;新建 selector 有两个方法，一个是直接定义函数，例如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const s1 = (state) =&amp;gt; {
    // 经过计算
    return state.user
}
const s2 = state =&amp;gt; state.data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外一个方法是通过 &lt;code&gt;createSelector&lt;/code&gt; 函数来创建，例如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const s3 = createSelector(s1, s2, (s1, s2) =&amp;gt;{
    // 经过计算
    return xx
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际上 selector 都是一些函数，具体用的是侯会执行这些函数，第一个方法创建的还好理解，第二个方法里面，会传什么参数呢？输入是什么呢？&lt;/p&gt;

&lt;p&gt;实际上，第二个方法定义的 selector 执行的时候类似这样。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const res = s3(s1(state), s2(state))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输入是里面 selector 的输入，然后不停嵌套到最初的数据。这样一个 selector 使用的方法就广泛了。比如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const s1_res = s1(state) // 从其他地方或者逻辑获取到这个值

const res = s3(s1_res, s2(state)) // 直接用来作为 s3 的输入
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Openwrt</title>
      <link>https://wdicc.com/openwrt/</link>
      <pubDate>Sun, 13 May 2018 10:01:39 +0800</pubDate>
      
      <guid>https://wdicc.com/openwrt/</guid>
      <description>&lt;p&gt;前段时间还搞了一下 openwrt 定制，记录一下。&lt;/p&gt;

&lt;p&gt;openwrt 提供了很方便的方式让你可以在 x86 机器上面定制路由器固件，到 &lt;a href=&#34;https://archive.openwrt.org/&#34; title=&#34;https://archive.openwrt.org/&#34;&gt;https://archive.openwrt.org/&lt;/a&gt; 下载对应的源码就可以。&lt;/p&gt;

&lt;p&gt;比如我用的是这个 &lt;a href=&#34;https://archive.openwrt.org/barrier_breaker/14.07/ar71xx/generic/OpenWrt-ImageBuilder-ar71xx_generic-for-linux-x86_64.tar.bz2&#34; title=&#34;https://archive.openwrt.org/barrier_breaker/14.07/ar71xx/generic/OpenWrt-ImageBuilder-ar71xx_generic-for-linux-x86_64.tar.bz2&#34;&gt;https://archive.openwrt.org/barrier_breaker/14.07/ar71xx/generic/OpenWrt-ImageBuilder-ar71xx_generic-for-linux-x86_64.tar.bz2&lt;/a&gt; ， &lt;code&gt;barrier_breaker&lt;/code&gt; 是版本， &lt;code&gt;ar71xx&lt;/code&gt; 是 cpu 架构。解压之后目录类似如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;drwxr-xr-x 12 wd wd 4.0K Mar 29 17:18 .
drwxr-xr-x  3 wd wd 4.0K Mar 26 20:32 ..
drwxr-xr-x  3 wd wd 4.0K Mar 27 10:40 bin
drwxr-xr-x  3 wd wd 4.0K Oct  1  2014 build_dir
-rw-r--r--  1 wd wd  94K Oct  1  2014 .config
drwxr-xr-x  2 wd wd 4.0K Oct  1  2014 dl
drwxr-xr-x  3 wd wd 4.0K Mar 26 20:37 include
-rw-r--r--  1 wd wd 5.0K Sep 21  2014 Makefile
-rw-r--r--  1 wd wd 570K Oct  1  2014 .packageinfo
drwxr-xr-x  4 wd wd 4.0K Oct  1  2014 packages
-rw-r--r--  1 wd wd  331 Oct  1  2014 repositories.conf
-rw-r--r--  1 wd wd  11K Sep 21  2014 rules.mk
drwxr-xr-x  4 wd wd 4.0K Sep 21  2014 scripts
drwxr-xr-x  3 wd wd 4.0K Oct  1  2014 staging_dir
drwxr-xr-x  3 wd wd 4.0K Oct  1  2014 target
-rw-r--r--  1 wd wd 128K Sep 21  2014 .targetinfo
drwxr-xr-x  2 wd wd 4.0K Mar 27 10:40 tmp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译的命令如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make image \
    PROFILE=TLWR703 \
    PACKAGES=&amp;quot;firewall -ip6tables -kmod-ip6tables -kmod-ipv6 -odhcp6c -ppp -ppp-mod-pppoe -liblua -libubus-lua -libuci-lua -luci-app-firewall -luci-i18n-english -luci-lib-ipkg -luci-lib-lmo -luci-lib-sys -luci-proto-core -luci-proto-ppp -luci-sgi-cgi -luci-theme-base -luci-theme-openwrt kmod-mii kmod-usb-net kmod-usb-net-cdc-ether usb-modeswitch curl&amp;quot; \
    FILES=files/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译结果会放在 &lt;code&gt;bin/ar71xx/&lt;/code&gt; 下面&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-rw-r--r-- 1 wd wd  827 May 13 10:08 md5sums
-rw-r--r-- 1 wd wd 2.2M May 13 10:08 openwrt-ar71xx-generic-root.squashfs
-rw-r--r-- 1 wd wd 1.9M May 13 10:08 openwrt-ar71xx-generic-root.squashfs-64k
-rw-r--r-- 1 wd wd 3.8M May 13 10:08 openwrt-ar71xx-generic-tl-wr703n-v1-squashfs-factory.bin
-rw-r--r-- 1 wd wd 2.9M May 13 10:08 openwrt-ar71xx-generic-tl-wr703n-v1-squashfs-sysupgrade.bin
-rw-r--r-- 1 wd wd 1.5M May 13 10:08 openwrt-ar71xx-generic-uImage-gzip.bin
-rw-r--r-- 1 wd wd 1.1M May 13 10:08 openwrt-ar71xx-generic-uImage-lzma.bin
-rwxr-xr-x 1 wd wd 3.2M May 13 10:08 openwrt-ar71xx-generic-vmlinux.bin
-rwxr-xr-x 1 wd wd 3.3M May 13 10:08 openwrt-ar71xx-generic-vmlinux.elf
-rw-r--r-- 1 wd wd 1.5M May 13 10:08 openwrt-ar71xx-generic-vmlinux.gz
-rw-r--r-- 1 wd wd 1.1M May 13 10:08 openwrt-ar71xx-generic-vmlinux.lzma
-rwxr-xr-x 1 wd wd 1.2M May 13 10:08 openwrt-ar71xx-generic-vmlinux-lzma.elf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那个 &lt;code&gt;openwrt-ar71xx-generic-tl-wr703n-v1-squashfs-factory.bin&lt;/code&gt; 就是我那个路由器的出厂固件。简直简单到没法说了。&lt;/p&gt;

&lt;p&gt;前面那个编译命令里面， &lt;code&gt;PROFILE&lt;/code&gt; 是指定要编译的路由器，这个必须得是固件支持的，可以在 &lt;code&gt;target/linux/ar71xx/generic/profiles/&lt;/code&gt; 目录看到。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;00-default.mk  8devices.mk  atheros.mk   buffalo.mk  dragino.mk   ew.mk          jjplus.mk   netgear.mk   pcs.mk      rosewill.mk  tp-link.mk   wd.mk
01-minimal.mk  alfa.mk      atlantis.mk  compex.mk   easylink.mk  gl-connect.mk  linksys.mk  oolite.mk    planex.mk   senao.mk     trendnet.mk  zcomax.mk
02-ath5k.mk    allnet.mk    bhu.mk       d-link.mk   engenius.mk  hiwifi.mk      nclink.mk   openmesh.mk  redwave.mk  sitecom.mk   ubnt.mk      zyxel.mk
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;PACKAGES&lt;/code&gt; 指定了要包含的包，可以在 &lt;code&gt;packages/&lt;/code&gt; 目录下面看到有的包。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;FILES&lt;/code&gt; 指定了自己定义要包含到固件里面的文件。可以把这个目录当作 &lt;code&gt;/&lt;/code&gt; 来放文件，比如你放到 &lt;code&gt;files/abc&lt;/code&gt; 下面的文件，将来会在路由器的 &lt;code&gt;/abc&lt;/code&gt; 下面。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.:
etc

./etc:
banner  config  crontabs  dropbear  run.sh

./etc/config:
dropbear  firewall  network  system  wireless

./etc/crontabs:
root

./etc/dropbear:
authorized_keys
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;后面还给 wr703n 接了一个华为 4g usb E8372h 型号，支持了 4g 上网。需要的包是这些， &lt;code&gt;kmod-mii kmod-usb-net kmod-usb-net-cdc-ether usb-modeswitch&lt;/code&gt; ，华为这个 usb 支持 ether 方式使用，并且 usb-modeswitch 直接就支持，不用自己配置。把 eth1 作为 wan 就可以了。&lt;/p&gt;

&lt;p&gt;中国联通的信道&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;3G: WCDMA Band 1/8&lt;/li&gt;
&lt;li&gt;4G: LTE-FDD 1/3/8  LTE-TDD 40/41&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考的一些文章&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://soha.moe/post/make-4g-wifi-ap-with-openwrt.html&#34; title=&#34;https://soha.moe/post/make-4g-wifi-ap-with-openwrt.html&#34;&gt;https://soha.moe/post/make-4g-wifi-ap-with-openwrt.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://right.com.cn/forum/forum.php?mod=viewthread&amp;amp;action=printable&amp;amp;tid=209854&#34; title=&#34;http://right.com.cn/forum/forum.php?mod=viewthread&amp;amp;action=printable&amp;amp;tid=209854&#34;&gt;http://right.com.cn/forum/forum.php?mod=viewthread&amp;action=printable&amp;tid=209854&lt;/a&gt; 这个论坛里面之前有一个帖子帮助很大没保存&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Develop Plugin for Asuswrt Merlin</title>
      <link>https://wdicc.com/develop-plugin-for-asuswrt-merlin/</link>
      <pubDate>Sun, 13 May 2018 08:03:28 +0800</pubDate>
      
      <guid>https://wdicc.com/develop-plugin-for-asuswrt-merlin/</guid>
      <description>&lt;p&gt;换华硕路由器之后，一直用的是梅林（merlin）的固件（rom）。基于这个固件，有一个 &lt;a href=&#34;http://koolshare.cn/forum-96-1.html&#34; title=&#34;koolshare&#34;&gt;koolshare&lt;/a&gt; 的团队做了很多插件，并且做了一个通用的软件中心，可以方便的管理插件，还挺不错的。&lt;/p&gt;

&lt;p&gt;打算用 v2ray 的时候，就想着如何才能无缝替换掉 ss。因为 v2ray 在路由器上面跑效率不高内存占用比较高，ss 作者开始说不打算支持 v2ray。后来研究了 ss 原理之后发现替换很简单，只需要具备 2 个功能就可以，一个是可以支持 socks 代理，一个是可以透明转发流量的端口。这两个协议在 v2ray 都支持，所以要做的其实就是在启动 ss 相应软件的时候启动 v2ray 的就可以了。&lt;/p&gt;

&lt;p&gt;基于这个逻辑写了一个&lt;a href=&#34;https://gist.github.com/wd/e0bc83b33ce63506a9bdbc3b81658c52&#34; title=&#34;文档&#34;&gt;文档&lt;/a&gt; ，能弄明白的话，自己用应该也够了。后来一时兴起，做了一个&lt;a href=&#34;https://gist.github.com/wd/1445e3fcf0c9bc535a6e70d2de1d1624&#34; title=&#34;改进版&#34;&gt;改进版&lt;/a&gt;。这个版本基本上就傻瓜化了。做的时候对基于 merlin 开发有了一些经验记录一下，发现讲这个的东西不多。&lt;/p&gt;

&lt;h1 id=&#34;一些基础知识&#34;&gt;一些基础知识&lt;/h1&gt;

&lt;p&gt;路由器上面的内容是只读的，修改之后重启就会重置。但是 JFFS 分区里面的内容是会保留的。想要保存数据有两个方法。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;存一个文件放到 JFFS 分区上面。&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;dbus&lt;/code&gt; 命令储存。(这个命令具体会把数据存哪里我还没仔细看。)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;文件方式没什么好说的，储存和读取解析需要你自己做。 &lt;code&gt;dbus&lt;/code&gt; 命令提供了 key-value 的形式储存数据，可以通过例如 &lt;code&gt;dbus list v2ray&lt;/code&gt; 列出来所有 &lt;code&gt;v2ray&lt;/code&gt; 开头的 key 的情况，执行 &lt;code&gt;dbus&lt;/code&gt; 命令不带参数会有使用方法提示。&lt;/p&gt;

&lt;p&gt;一般开发插件还有一个设置也需要开启，就是允许执行 JFFS 的自定义脚本。这个指的是路由器启动的时候，自动执行 &lt;code&gt;/jffs/scripts/&lt;/code&gt; 下面的一些文件，也并不是任意文件都会执行，merlin 自己的 &lt;a href=&#34;https://github.com/RMerl/asuswrt-merlin/wiki/User-scripts&#34; title=&#34;wiki&#34;&gt;wiki&lt;/a&gt; 有比较详细的说明。&lt;/p&gt;

&lt;p&gt;所以实际上一个插件的工作方式实际上是这样&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;路由器启动&lt;/li&gt;
&lt;li&gt;读取 dbus 配置的数据&lt;/li&gt;
&lt;li&gt;执行 &lt;code&gt;/jffs/scripts/&lt;/code&gt; 目录下面相应的脚本&lt;/li&gt;
&lt;li&gt;这些脚本里面会执行你的插件的脚本&lt;/li&gt;
&lt;li&gt;你的脚本会读取 dbus 配置的数据，以及读取你存储的文件&lt;/li&gt;
&lt;li&gt;不管是你的界面还是脚本有新的数据需要保存，通过 dbus 或者文件存下来&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;每次路由器启动都是这样一个从头初始化的过程。&lt;/p&gt;

&lt;h1 id=&#34;基于-koolshare-软件中心的离线包&#34;&gt;基于 koolshare 软件中心的离线包&lt;/h1&gt;

&lt;p&gt;我开发是基于 koolshare 软件中心的，他提供了一个离线安装的功能，以及很多好用的小工具，可以方便开发。想支持离线安装，需要你提供一个 &lt;a href=&#34;https://github.com/wd/koolshare_plugin_v2ray/blob/master/install.sh&#34; title=&#34;install.sh&#34;&gt;install.sh&lt;/a&gt;，你上传的包的名字必须是 &lt;code&gt;name.tar.gz&lt;/code&gt; ， &lt;code&gt;name&lt;/code&gt; 名字还得和解压之后的目录名字对应，有些人多次下载系统可能会给他改成 &lt;code&gt;name(1).tar.gz&lt;/code&gt; 这种会失败。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;install.sh&lt;/code&gt; 里面底部定义的那几个 &lt;code&gt;softcenter_module_v2ray_&lt;/code&gt; 开头的配置是给软件中心用的。 &lt;code&gt;home_url&lt;/code&gt; 是软件中心里面点击你插件的图标的时候打开的页面。&lt;/p&gt;

&lt;p&gt;安装离线包的时候不会自动处理 &lt;code&gt;uninstall.sh&lt;/code&gt; ，需要你自己把这个放到&lt;a href=&#34;https://github.com/wd/koolshare_plugin_v2ray/blob/master/install.sh#L61&#34; title=&#34;对应地方&#34;&gt;对应地方&lt;/a&gt;，并且需要有对的名字。&lt;/p&gt;

&lt;p&gt;整个安装完全是你自己控制自己要做的事情。卸载也一样，需要自己删除自己复制的脚本文件和产生的数据等。&lt;/p&gt;

&lt;h1 id=&#34;界面功能&#34;&gt;界面功能&lt;/h1&gt;

&lt;p&gt;merlin 的界面文件是 &lt;code&gt;.asp&lt;/code&gt; 结尾，里面唯一相关的标记是类似这样的 &lt;code&gt;&amp;lt;% nvram_get(&amp;quot;firmver&amp;quot;); %&amp;gt;&lt;/code&gt; ，不记得是不是 asp 语法里面的东西了。基本上都是一些 js 和 html 的东西。&lt;/p&gt;

&lt;h2 id=&#34;初始化&#34;&gt;初始化&lt;/h2&gt;

&lt;p&gt;一般是在界面的 body 的 onload 方法里面执行&lt;a href=&#34;https://github.com/wd/koolshare_plugin_v2ray/blob/master/webs/Module_v2ray.asp#L463&#34; title=&#34;自己的函数&#34;&gt;自己的函数&lt;/a&gt;。&lt;a href=&#34;https://github.com/wd/koolshare_plugin_v2ray/blob/master/webs/Module_v2ray.asp#L500&#34; title=&#34;这里&#34;&gt;这里&lt;/a&gt;是预留左侧系统原有的导航按钮的地方。&lt;/p&gt;

&lt;h2 id=&#34;保存配置&#34;&gt;保存配置&lt;/h2&gt;

&lt;p&gt;界面里面可以通过 post 给 &lt;code&gt;applydb.cgi&lt;/code&gt; 的方式保存给 dbus，类似&lt;a href=&#34;https://github.com/wd/koolshare_plugin_v2ray/blob/master/webs/Module_v2ray.asp#L251&#34; title=&#34;这里&#34;&gt;这里&lt;/a&gt;。先把表单里面的值都读出来做适当的处理，然后存到 &lt;code&gt;dbus&lt;/code&gt; 这个变量里面， &lt;code&gt;SystemCmd&lt;/code&gt; 定义的是执行 post 的之后需要执行的脚本。 &lt;code&gt;action_mode&lt;/code&gt; 是执行脚本之后界面的动作。&lt;/p&gt;

&lt;p&gt;这个里面你的脚本会被调用，你需要处理的事情，比如保存配置到文件什么的就可以在这里做了。&lt;/p&gt;

&lt;p&gt;这里有一个问题是执行命令的时候，不能得到执行的结果反馈。&lt;/p&gt;

&lt;h2 id=&#34;执行命令的时候显示反馈&#34;&gt;执行命令的时候显示反馈&lt;/h2&gt;

&lt;p&gt;上面保存配置是通过 ajax 异步执行的，ajax 的执行结果立刻就会反馈，脚本调用也是异步的，调用脚本的执行结果需要你自己想办法获取。&lt;/p&gt;

&lt;p&gt;类似我&lt;a href=&#34;https://github.com/wd/koolshare_plugin_v2ray/blob/master/webs/Module_v2ray.asp#L300&#34; title=&#34;这里&#34;&gt;这里&lt;/a&gt;，在 ajax 执行成功之后获取执行的结果。先显示一个图层，在里面再&lt;a href=&#34;https://github.com/wd/koolshare_plugin_v2ray/blob/master/webs/Module_v2ray.asp#L305&#34; title=&#34;无限执行另外一个 ajax&#34;&gt;无限执行另外一个 ajax&lt;/a&gt;，把 ajax 的执行结果放到刚才那个图层里面，这样用户就可以看到了。然后通过检查结果里面是否&lt;a href=&#34;https://github.com/wd/koolshare_plugin_v2ray/blob/master/webs/Module_v2ray.asp#L316&#34; title=&#34;包含特定字符&#34;&gt;包含特定字符&lt;/a&gt;来判断脚本是不是执行完毕。&lt;/p&gt;

&lt;p&gt;ajax 请求的是一个 &lt;a href=&#34;https://github.com/wd/koolshare_plugin_v2ray/blob/master/webs/Module_v2ray.asp#L307&#34; title=&#34;url&#34;&gt;url&lt;/a&gt;，这个 url 对应的文件是&lt;a href=&#34;https://github.com/wd/koolshare_plugin_v2ray/blob/master/res/v2ray_status.htm&#34; title=&#34;这个&#34;&gt;这个&lt;/a&gt;。里面其实很简单，就是把 &lt;code&gt;/tmp/v2ray_status.log&lt;/code&gt; 的内容显示出来。&lt;/p&gt;

&lt;p&gt;所以通过这个方式，上面的脚本自需要把想要反馈的内容放到这个 log 文件就可以了，整个逻辑就这样。我这里为了简单所有的脚本执行都复用了这个 log 文件，所以为了避免被上次执行的命令影响，每次执行脚本写入这个文件前都先把这个文件里面的历史数据清楚掉。&lt;/p&gt;

&lt;h2 id=&#34;其他命令执行结果的方式&#34;&gt;其他命令执行结果的方式&lt;/h2&gt;

&lt;p&gt;merlin 还提供了一个 &lt;code&gt;apply.cgi&lt;/code&gt; 可以执行脚本，例如&lt;a href=&#34;https://github.com/wd/koolshare_plugin_v2ray/blob/master/webs/Module_v2ray.asp#L136&#34; title=&#34;这里&#34;&gt;这里&lt;/a&gt;。我忘记是不是同步执行的了，好像是命令执行完毕之后才会执行 ajax 的回调。&lt;/p&gt;

&lt;p&gt;依然还是通过请求刚才那个 &lt;code&gt;/res/v2ray_status.html&lt;/code&gt; 文件来&lt;a href=&#34;https://github.com/wd/koolshare_plugin_v2ray/blob/master/webs/Module_v2ray.asp#L147&#34; title=&#34;取结果&#34;&gt;取结果&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;这里还不有一个坑，如果长时间没有从登录界面进入过路由器管理界面，那执行这个可能会遇到获取到的数据是一个 html 的到 Login 页面的 redirect。&lt;/p&gt;

&lt;h2 id=&#34;读取保存的数据&#34;&gt;读取保存的数据&lt;/h2&gt;

&lt;h3 id=&#34;通过-js-读取&#34;&gt;通过 js 读取&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;/dbconf?p=v2ray&amp;amp;v=&amp;lt;% uptime(); %&amp;gt;&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那个 p 会只显示匹配那个前缀的数据。上面这个 url 直接打开看看就知道了，会产生一个 &lt;code&gt;db_v2ray&lt;/code&gt; 这个变量。在界面里面就可以使用例如 &lt;code&gt;db_v2ray[&amp;quot;v2ray_module_version&amp;quot;]&lt;/code&gt; 来获取 dbus 的数据了。&lt;/p&gt;

&lt;h3 id=&#34;通过页面标签获取&#34;&gt;通过页面标签获取&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;input type=&amp;quot;hidden&amp;quot; id=&amp;quot;ss_basic_enable&amp;quot; name=&amp;quot;ss_basic_enable&amp;quot; value=&amp;quot;&amp;lt;% dbus_get_def(&amp;quot;ss_basic_enable&amp;quot;, &amp;quot;&amp;quot;); %&amp;gt;&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如上面这个，通过 &lt;code&gt;&amp;lt;% dbus_get_def()/&amp;gt;&lt;/code&gt; 这样的标签就可以获取到相应的变量。&lt;/p&gt;

&lt;h1 id=&#34;cron&#34;&gt;Cron&lt;/h1&gt;

&lt;p&gt;如果想要定时执行一些任务，可以添加 cron。merlin 管理界面的用户不一定都是 admin，所以 cron 的用户也不一定是什么，可以用 &lt;code&gt;cru&lt;/code&gt; &lt;a href=&#34;https://github.com/wd/koolshare_plugin_v2ray/blob/master/scripts/v2ray_watchdog.sh#L91&#34; title=&#34;命令&#34;&gt;命令&lt;/a&gt;来管理 cron。&lt;/p&gt;

&lt;h1 id=&#34;自己的启动脚本&#34;&gt;自己的启动脚本&lt;/h1&gt;

&lt;p&gt;前面也说过，可以放到&lt;a href=&#34;https://github.com/RMerl/asuswrt-merlin/wiki/User-scripts&#34; title=&#34;这些对应的脚本&#34;&gt;这些对应的脚本&lt;/a&gt;里面。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Self Hosted Blog</title>
      <link>https://wdicc.com/self-hosted-blog/</link>
      <pubDate>Fri, 06 Apr 2018 14:59:49 +0800</pubDate>
      
      <guid>https://wdicc.com/self-hosted-blog/</guid>
      <description>&lt;p&gt;给 checked 的一个反馈。&lt;/p&gt;

&lt;p&gt;给播客写反馈是个很奇怪的事情，当我听完博客觉得心潮澎湃的写反馈的时候，其实主播们应该已经对那些说过的事情的兴趣估计已经没有了。所以感觉是像是一个很激动兴奋的人找别人聊天，结果人家波澜不惊的和你说：嗯嗯嗯。。一样。。&lt;/p&gt;

&lt;p&gt;有两点反馈，一点关于文章格式，一点关于自建博客。&lt;/p&gt;

&lt;p&gt;语言这个东西，发明出来就是为了交流用的，如果某种流行的东西有助于交流，那我觉得没有什么问题。比如空行代替头部空两个字，感觉好很多。比如使用 &#39;。。。。&#39; 代替 &#39;……&#39; 也没什么（其实是给我下面标点乱用打埋伏。。。:p ）。&lt;/p&gt;

&lt;p&gt;直角引号的讨论有很多，随便搜了&lt;a href=&#34;https://www.zhihu.com/question/19589668&#34; title=&#34;一个&#34;&gt;一个&lt;/a&gt; 。我记得最早流行这个好像就是知乎，后来搜狗输入法还提供了一个选项是在知乎输入引号的时候输入直角引号。我个人喜欢看直角的，因为很多时候那个蝌蚪样子的，有好几个编码，比如 ‘ ’、“ ”、&#39; &#39;、&#34; &#34;、 这几个都是半角的，左右不好区分开。但是直角的，再怎么也比较好区分左右，并且对竖排文字，比如广告图什么的里面也很有好。可以参考下&lt;a href=&#34;https://zh.wikipedia.org/wiki/%25E5%25BC%2595%25E5%258F%25B7&#34; title=&#34;这个&#34;&gt;这个&lt;/a&gt; 。&lt;/p&gt;

&lt;p&gt;下面聊自建博客。这个 20 年前我和 hum 的看法是一样的，有病才去自己弄，需要自己搞服务器，自己维护，成本很高。但是使用别人搞的，也并不是没有问题。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;网站倒闭。最初的 MSN Live Space，然后新浪博客，然后国外的 wordpress，然后国内牛博网等等很多，那会博客风起来的时候，非常多这种网站，目前这些都不能访问或者死掉了。死掉的时候，你的文章怎么办？良心一点的提供一个导出，要不然就是你自己想办法解决。写的时候可能文本，最后拿到的没准是一堆的 HTML，很难处理。&lt;/li&gt;
&lt;li&gt;流氓的版权协议。国内各大网站都会要你发的帖子的著作权，可以找找看有没有说版权归你，使用的时候会找你协商以及给你版权费的。&lt;/li&gt;
&lt;li&gt;格式样式不可控。各网站都有自己的风格，比如我们程序员经常会想贴一点代码，想要一个高亮，但是人家不给你提供的话，你就很难做到。还有比如想要在文章顶部显示一个大纲方便看的人一目了然的需求。不过目前因为 markdown 的兴起，还算是对程序员友好，也算有希望统一这个格式的问题。同时 markdown 还能一定意义上解决上面提到的导出迁移的问题（当然，前提是人家让你导出），不过呢，还有另一个问题是 markdown 原定的标准实际是个残废，很多常用的东西都不支持，比如表格，比如 footnote，然后各家必定会对他扩展，那就会导致你从这家导出来的别家不一定支持。这里顺便安利一下 org-mode。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我自己使用自建博客很多年了，以后应该也不会使用其他商业的博客。我自己的博客的用途是留存我自己的经历，本身只分享文本内容，因为图片的流量问题，一般免费服务的空间都会限制，这些图片你自己维护起来也很费劲。就算是付费的，也很少有终身的，以后的事情谁能说的清。所以我都是用文字来表达，好处一方面是整站打包也就几M，另一方面，分享出去的东西别人也很方便的可以留存。&lt;/p&gt;

&lt;p&gt;如果用途不止我那个，那平台名气是可以借用的，用平台肯定是最好的选择。&lt;/p&gt;

&lt;p&gt;自建博客目前其实也很简单，空间在 github 开个账号就可以，只需要传 HTML 内容就可以，可以通过一些工具把文章转成 HTML 就可以。就算没有这种商业服务，自己搞一个 vps 跑一个 nginx 之类的，服务这些 HTML 也是一个很简单的事情。比如我用的是 hugo，支持 markdown，org-mode。类似的还有 hexo。&lt;/p&gt;

&lt;p&gt;最后说忍不住补充一下 org-mode。org-mode 一直被认为是 Emacs 用户才能用，其实并不是，目前也也有一些支持他的文本处理工具，比如 hugo 和 pandoc 就支持 org-mode 文件输入，输出 HTML。目测目前 markdown 的那个表格就是学习的 org-mode 的，org-mode 的表格还支持写公式计算。别的不多说了，org-mode 基本是 markdown 的一个超集，有兴趣可以了解一下。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Beijing Traffic</title>
      <link>https://wdicc.com/beijing-traffic/</link>
      <pubDate>Fri, 06 Apr 2018 14:51:19 +0800</pubDate>
      
      <guid>https://wdicc.com/beijing-traffic/</guid>
      <description>&lt;p&gt;给比特新声的一个反馈，记录一下。&lt;/p&gt;

&lt;p&gt;北京最初的时候，应该只有二环里面四个区（崇文，宣武，东西城）可能才算城区，后面慢慢的，加上海淀，朝阳等几个区，那会通州区还是通县，类似的大兴，密云县。到目前的大北京的情况，东边繁华地带都和河北接壤了（就是燕郊）。&lt;/p&gt;

&lt;p&gt;北京实在太大了。&lt;/p&gt;

&lt;p&gt;我在中关村上班的时候，家在东五环外面，去公司上班，开车单程需要 35 公里。快的话 40 分钟，慢的话 1.5 小时。我也有同事住在燕郊，长阳，你们可以查查有多远。&lt;/p&gt;

&lt;p&gt;大概 10 年左右，我从中关村 7 点下班了开车回家是 40 分钟。基本不堵车，全程 4 环加 5 环路，基本没有红绿灯，开的还是挺快的。但是现在就不行了，即使在 1/5 车限行的情况下，堵车也很厉害。可能只有单双号还能和以前一比了。&lt;/p&gt;

&lt;p&gt;北京特别大，但是走哪里都有一个比较集中的生活区，会有一些大的商场，超市，方便你购买生活用品和吃饭。但是随着年轻人不在家里做饭或者很少做饭，这些商场现在也是人满为患，到了饭点吃饭基本都需要排队。&lt;/p&gt;

&lt;p&gt;北京喜欢建大路。二环到现在的六环。这种规划我认为比较脑残，可能能体现出来一些气派的感觉，毕竟第一次看到能让 10 辆车并行通过的路，还是会觉得：哇，比我们那的土路确实牛逼多了。这种路，刚修好的几年里面，确实会爽，只要开上去，一路没有红绿灯困扰，不堵车还是挺快的。尤其领导开上来的时候，把路一封，其他车上不来，领导的自豪感估计挺强的。&lt;/p&gt;

&lt;ol&gt;
说说脑残的地方。
&lt;li&gt;这种路非常怕扰动。为了快速，肯定要减少出入口，因为车辆出入的时候，速度肯定会比较慢，多了就容易影响其他不出入的车。这样，一旦遇到点情况，大家都出不去，只能在里面堵着。我说的情况包括不限于车祸，恶劣天气，路况的变化。&lt;/li&gt;
  这种路一般都有应急车道。但是有时候遇到比如桥梁啥的，可能那一小段会没有应急车道。而就这个情况，会导致拥堵。怎么发生的呢？车辆一旦稍微多一点，就会有车开应急车道，这些车到了没有应急车道的地方，必然需要并到路里面来，因为车辆本身多，他一并入，必然导致后车需要减速让行，然后连锁反应，后面的车觉得这个车道好像比旁边的车道慢，就会并入旁边车道或者进入应急车道。恶性循环，而这个情况的出现，可能值需要一辆走应急的车来触发一下，这条路立刻就不行了。
  讲一个搞笑的事情，我每天都路过环路的一个桥，这个桥就没有应急车道。而且这个桥上桥是个上坡，那一些货车到了这里就起不来速度，就会导致这个地方产生那个连锁反应开始拥堵。这个拥堵，一般到了下桥的地方就恢复了。感觉道路设计应该也是一个比较有意思的事情。
  五环路之前是收费的，所以出入口就更加少了，每次开上去遇到堵车都没有办法绕开。
&lt;li&gt;过马路很头大。马路太宽，要么建天桥，要么地道，或者就是绕道到一个立交桥的地方过。拿着重物的话，天桥和地道上下会觉得不方便。绕道立交桥又会比较远。很难受。&lt;/li&gt;
  这里还想起来另外一个事情，就是北京也喜欢建大的小区。然后小区物业为了管理方便，自然把能关的门都关掉，这样可以开那么几个门派少量的保安看着。如果一个小区在大路边上，大概率是没有临路的门的，所以过了马路还得绕道到另外一边进小区。
&lt;li&gt;这种大路，还会导致临路的屋子住的很难受。大路上面一般车多且速度快，噪音很大，灰尘也很大。&lt;/li&gt;
&lt;li&gt;这个因为一旦开上去后路就比较，往往都是一直大路开就可以，所以这个很多人会首选往这里开，尤其新手怕开错路，这也就导致这种路更容易拥堵。而且，因为修大路会导致很多小路给大路让行，在小路上面开很难受。&lt;/li&gt;
  也因为这个思路，主路一旦堵了之后，很多排队上主路的车，会继续把辅路也堵住。然后往那些方向走的路就彻底都废掉了。
&lt;/ol&gt;

&lt;p&gt;上面是我觉得几个大路不好的地方。我 6 月份去上海，发现很喜欢上海的路。另外当时觉得上海好像比北京小多了。我是住在静安寺附近，去了田子坊，人民公园，外滩一路玩，发现骑摩拜就可以。&lt;/p&gt;

&lt;p&gt;上海的路大都有树荫，骑车很舒服。自行车道也都有，另外很多的单行线。和香港的路有点类似。不知道像北京这么大的城市，是不是也适合这样的设计。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Bitcoin</title>
      <link>https://wdicc.com/bitcoin/</link>
      <pubDate>Sun, 25 Mar 2018 20:10:44 +0800</pubDate>
      
      <guid>https://wdicc.com/bitcoin/</guid>
      <description>&lt;p&gt;比特币上万刀一个之后，简直已经没人不知道这个东西了。有的东西只要号称要搞比特币，股票就得涨 30%。我简单讲讲我的理解。&lt;/p&gt;

&lt;ul&gt;
比特币相关概念，有两个重要的要点。
&lt;li&gt;区块链&lt;/li&gt;
&lt;li&gt;去中心化&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;区块链&#34;&gt;区块链&lt;/h2&gt;

&lt;p&gt;大家都知道区块链是一个账本。普通的账本，比如银行存折，每笔交易都会记录本次交易的金额，也会记录操作之后的余额。这样多次交易之后，你也无法只修改其中一条记录，因为一旦修改，和这条记录之后的记录就对不上了。但是其实抛开存折这回事的话，在你的记录中间插入一些记录是没有人会发现的。不过我们因为有存折，存折上面一行记录一条记录，中间也没法插入其他的。但是目前存折其实用的人不多了。&lt;/p&gt;

&lt;p&gt;区块链的特点是把一些数据以链条一样的形式串起来。不过和链条有区别的地方是，链条每个节点是相同的，其实切断链条，取掉一个节点，然后接上，看着并没有什么不同。但是区块链任何一个节点都是不同的，去掉一个，后面的就无法连接起来了。因为每一个节点都是唯一的，且每一个节点都包含了他上一个节点的信息。某一个节点丢失或者被修改，那下一个节点保存的这个节点的信息和实际情况就对不上了。&lt;/p&gt;

&lt;p&gt;这样的一个链条下来，能达到防止中间某条记录被篡改，保证了数据的可靠性。&lt;/p&gt;

&lt;h2 id=&#34;去中心化&#34;&gt;去中心化&lt;/h2&gt;

&lt;p&gt;我们的账本，交易记录，大多是存放在银行的。银行开放了一些接口可以让你查账。但是实际上如果银行如果记录了一笔你认为错误的记录，你很难提供一个方法来证明银行出错了。这个就是中心化的方式存在的问题。当然，现实环境里面，银行也不会主动去做损坏自己名誉的事情，比如做假账错账。银行也会想办法防止自己内部的员工因为某些自己的目的来作恶，比如系统会记录各种审计记录，系统开发人员和使用人员权限分离，使用的时候需要授权鉴权等，这些都是防止银行自己出错的措施。&lt;/p&gt;

&lt;p&gt;去中心化，就是把银行这个节点拿掉，所有参与记账的人员（就是旷工）都共享一份账本。每个人都可以验证账本数据的正确性，大家互相不信任，通过博弈来实现这个账本的记录和传递。&lt;/p&gt;

&lt;p&gt;因为去中心化，大家数据同步是需要时间的，那么实际上一个账本的记录走向是会分叉的，一个博弈是大家都会挑选长的分支走。因为如果其他旷工不选短的，那么他自己选短的链条对他没有任何好处，他将得不到自己的挖矿奖励。所以旷工都会保证自己确认的交易都是没问题的。那么整个网络才是一个可信的，可持续的。&lt;/p&gt;

&lt;p&gt;如果是有大量的旷工（算力）联合起来了，那么其实他们就可以控制链条走向了。现在很多时候挖矿是加入了矿池，走向可能是会被矿池控制的。&lt;/p&gt;

&lt;p&gt;目前很多的公司都搞区块链，基本都不讲如何实现去中心化，如果没有去中心化，那还是一个大公司记录的话，实际上只是是用了一部分比特币的概念。没有去中心化思维的区块链就是耍流氓，千万别信。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>BJ Chinaunicom Iptv</title>
      <link>https://wdicc.com/bj-chinaunicom-iptv/</link>
      <pubDate>Sun, 25 Mar 2018 09:21:39 +0800</pubDate>
      
      <guid>https://wdicc.com/bj-chinaunicom-iptv/</guid>
      <description>&lt;p&gt;刚入住现在的房子的时候，只有朝阳有线，当时还没有高清台，机顶盒也很烂。后来大家争取来了歌华有线，好了很多。再之后，我买了华为盒子之后，发现有线电视简直就是情怀了，很少开了，都是在线看视频。尤其后来装了一个 HDP 直播之后，电视节目也可以看了，就更少开有线了。就去把有线盒子给退了。&lt;/p&gt;

&lt;p&gt;有段时间岳母在北京住着，离不开有线，HDP 直播很不稳定，节目有时候还打不开什么的，岳母老抱怨。后来想起来，装了北京联通宽带好像会送一个 iptv 的盒子，可以看电视节目。就联系了一下联通，给过来装了一个盒子。&lt;/p&gt;

&lt;p&gt;这个盒子只能直接接到光猫的 lan4 口，我的上网的路由器是接在 lan1 口的。盒子虽然支持无线，但是不能直接连我 lan1 口的路由器。这个盒子有自带的遥控器，不好用，并且系统里面会诱导你用点播什么的，不是很爽。前段时间看到一个水木的&lt;a href=&#34;http://www.newsmth.net/bbscon.php?bid=1050&amp;amp;id=757772&amp;amp;ftype=3&amp;amp;num=3435&#34; title=&#34;帖子讲折腾 iptv 的&#34;&gt;帖子讲折腾 iptv 的&lt;/a&gt; ，自己想尝试在任意设备看，就了解了一下。&lt;/p&gt;

&lt;p&gt;光猫有的带路由功能，可以直接光猫拨号，以及可以登录后台修改网络结构。有的不带，等于啥功能都没有。IPTV 和通常的上网通道在猫里面是隔离的，不同的 vlan 走不同的网络。所以这也是为什么盒子只能接 lan4，而且这个 lan4 口并不能正常的访问我们的互联网，限制了只能访问那个 iptv 运转需要的网络。而 lan1 可以访问互联网，但是不能访问 iptv 的网络。我家的电视和光猫分别在客厅的两个面对的墙，因为盒子只能直连光猫，那光猫到盒子，盒子到电视都必须是有线，经过客厅线就没法走了。类似下面这样的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;光猫 lan4 --- 网线 ---&amp;gt; iptv 盒子 --- HDMI ---&amp;gt; 电视
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;后来找到了一个通过电力猫解决的办法。买一对就可以了。类似下面这样。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;光猫 lan4 -- 网线 --&amp;gt; 电力猫1  ........电网..... 电力猫2 ---- 网线 ---&amp;gt;  iptv 盒子 ---- HDMI ---&amp;gt; 电视
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样基本就可以了。但是那个盒子用起来不爽，所以打算折腾一下。按照那个帖子我试了，我这无法配置光猫，无法控制光猫的 ip 段。这样那个方案似乎就没法用了。后来又找了一些方案，比如&lt;a href=&#34;https://github.com/phorcys/merlin-BJ-Unicomm-IPTV-scripts&#34; title=&#34;这个方案&#34;&gt;这个方案&lt;/a&gt;可以单路由搞这个事情，但是我发现也有问题，里面需要知道光猫里面的 vlan 划分，我这没法知道，也没法弄了。&lt;/p&gt;

&lt;p&gt;后来发现了&lt;a href=&#34;http://www.newsmth.net/bbscon.php?bid=1050&amp;amp;id=760517&#34; title=&#34;另外一个思路&#34;&gt;另外一个思路&lt;/a&gt;，解决了我的问题。线路连接思路大概如下。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;光猫 lan1 -- 主路由 WAN
光猫 lan4 -- 辅路由 WAN
辅路由 LAN（任意一个口） --- 主路由 LAN（任意一个口）
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后主路由就以前的设置就可以，假设主路由的 LAN 的网段是 192.168.8.x。辅路由需要设置几个地方。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;辅路由 LAN 关闭 DHCP。辅路由 LAN 部分 ip 比如设置为 192.168.8.4 (数值可以自己定，不要和其他设备 ip 冲突了)。&lt;/li&gt;
&lt;li&gt;辅路由 LAN 里面设置 IPTV 的 Udpxy 端口比如 8012。&lt;/li&gt;
&lt;li&gt;辅路由 WAN 设置为通过 DHCP 自动获取 ip。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这个时候，连接到主路由的设备应该就可以通过访问 192.168.8.4 来访问到辅路由的配置界面了。到&lt;a href=&#34;https://opengg.github.io/bj-unicom-iptv/&#34; title=&#34;这里&#34;&gt;这里&lt;/a&gt; udpxy address 输入 192.168.8.4:8012 生成一个 m3u 列表，就可以在连接到主路由的设备里面，通过各种支持的软件里面看了。&lt;/p&gt;

&lt;p&gt;如果还想使用 iptv 看，可以在 iptv 的无线设置里面连接辅路由的无线就可以。&lt;/p&gt;

&lt;p&gt;这个方案巧妙的使用了路由器自带的交换机功能，把主路由和辅路由放到了一个 LAN 里面。虽然多了一个路由器，但是节省了电力猫，iptv 盒子，电视的一个 HDMI 口。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Apple Carplay</title>
      <link>https://wdicc.com/apple-carplay/</link>
      <pubDate>Sat, 24 Mar 2018 09:08:47 +0800</pubDate>
      
      <guid>https://wdicc.com/apple-carplay/</guid>
      <description>&lt;p&gt;Carplay 技术苹果老早就搞出来了，一直没有机会体验。最近车上搞了一个 carplay，总结下这段时间的体验。&lt;/p&gt;

&lt;p&gt;手机连上车之后，Carplay 会自动启动，然后其实是会把车的娱乐系统的那个屏幕变成第二个手机屏幕一样。上面会排列一堆支持 Carplay 的 app，只有 app 支持才能在上面用（越狱之后可以解开这个限制，我没试过）。&lt;/p&gt;

&lt;p&gt;Apple 自带的软件，比如 Phone, Messages, Music, Podcasts, Maps 这些都支持。第三方的地图比如 Google maps 高德都不支持，不清楚是不是 Apple 限制的。第三方的音乐软件，比如 Spotify, QQ音乐，网易音乐支持。界面会和手机上面的有点区别，应该是需要特别为 Carplay 做界面。&lt;/p&gt;

&lt;p&gt;Carplay 和 Airplay 很像，就是 app 实际是运行在你手机上面的，比如你启动了 Spotify 的话，这个时候看手机，会发现手机上面也显示的是 Spotify 的界面，手机上面如果按 Home 退出，那 Carplay 的界面上面也会会到 Home。&lt;/p&gt;

&lt;p&gt;苹果自带的 Maps 在国内用的是高德的数据，最近支持了摄像头限速提醒。我用英文系统，可以设置为显示当地的文字，地图上面看到的就是中文，不过语音提示都是英文的，念地名的时候很好笑。在汽车屏幕上面不能不支持手势缩放，只能点那个加减按钮。也不支持我车自带的一个旋钮缩放地图，那个旋钮在车自带的地图里面可以很方便的缩放。苹果地图会自动做一些判断，比如早上上车会提示你是不是要去公司，可以做到点一下就自动设置好导航路线。另外，因为实际上是在手机上面也会同时导航，打开手机界面的话，也能看到，当然手机就不会重复播报提醒的，但是如果你有 apple watch 的话，手表会提醒。快到转向什么的，会振动提醒。&lt;/p&gt;

&lt;p&gt;播客播放的时候，支持调整速度，但是只能是 0.5，1, 1.5 这样，不能调到 0.8，1.3 这样。但是在 APP 里面调整好了会显示。支持快速前进和后退几十秒，和 app 里面操作类似。&lt;/p&gt;

&lt;p&gt;Message 有消息的时候，图标上面会有提醒，点开会自动启动 siri 给你播报，但是播不出来中文，感觉很蠢，而且还不显示内容。。。会提示你是不是要回复，可以通过 siri 回复。&lt;/p&gt;

&lt;p&gt;然后就是，siri 实在太蠢了。我开始的时候，在个人信息里面设置了 Home 和 Work 的地址，然后试了语音说 Navigate to home 或者 Take me to home，结果就给我找到一个东北的地方，不知道是不是音译匹配上了，非常蠢，试了很多次都不行。最后只能点那个提示出来的 Home。（我刚才又试了几次，发现目前可以准确找到 Home 了。。）&lt;/p&gt;

&lt;p&gt;我车上 Carplay 导航和自带的导航不能同时启动，启动一个另外一个导航就会退出。Carplay 不支持车的 HUD 显示，本来想做一个补充的，用车自带的导航在 HUD 显示，Carplay 的导航提示摄像头和限速。不知道其他车是不是也这样。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>React Native compnent reuse</title>
      <link>https://wdicc.com/react-native-compnent-reuse/</link>
      <pubDate>Sat, 24 Mar 2018 08:44:39 +0800</pubDate>
      
      <guid>https://wdicc.com/react-native-compnent-reuse/</guid>
      <description>&lt;p&gt;做功能的时候，一般我们会适当的封装一些组件出来共享，这样好管理和维护，这个大家估计都会这么做。有时候手机上面因为屏幕小，填一些表单的时候，会需要到另外一个页面去维护选择一些内容，那这个页面是页面还是组件呢？&lt;/p&gt;

&lt;p&gt;我总结下来，所有需要填写的页面，都应该按照组件的思维来封。因为他们实际上很可能会被多次复用，一个路径上面可能会出现多次。当然，普通页面也可能会出现多次，出现多次的展示页面如果是相同的内容，那 store 里面用一个按说也没问题，如果是不同的内容，那应该会有一个 id 来区分不同的内容，这个时候 store 里面存一个用这个 id 做 key 的 map 就可以了。&lt;/p&gt;

&lt;p&gt;继续说填写页面。比如我们的新建订单的页面，会有两个入口，一个是全新的，一个是从历史订单复制的。从历史订单复制的，就需要在 store 里面先把已有的数据放一份，再进入新建页面，如果用户点了返回按键，还需要把 store 里面的状态清掉，否则下次进入的时候还会有出来上次的数据。&lt;/p&gt;

&lt;p&gt;如果按照组件的思维封装，那数据入口只有 props，store 里面不会有，就不用考虑清数据的问题。至于返回的数据，根据页面情况，一般是有两个途径，一个是需要把数据返回给上一个页面的，一个是直接把数据通过网络请求发送的。对于第一个，可以通过 callback 方法给上一个页面，对于第二个，通过 action 来做就可以了。&lt;/p&gt;

&lt;p&gt;我们需要把页面里面的数据区分一下 private 数据和 public 数据。对于 private 数据每次使用基本不一样，通过 props 传递进来。而 public 数据基本是相同的，那通过 store 存下来，必要的时候更新就可以了。&lt;/p&gt;

&lt;p&gt;我们使用的是 reac-navigation，使用的时候，可以通过 &lt;code&gt;navigate(&#39;newPage&#39;, {prop1: &#39;prop1 value&#39;, callback: func1})&lt;/code&gt; 这种方法来把数据和 callback 方法传递过去。那个页面处理完毕之后，通过 callback 把数据返回来。这样就不用费力把数据通过 action -&gt; reducer -&gt; selector 传到上一个页面了，并且页面再次使用也不用操心上一次使用的时候的残留数据了，页面被复用也不会互相干扰。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go Across the Gfw</title>
      <link>https://wdicc.com/go-across-the-gfw/</link>
      <pubDate>Thu, 15 Feb 2018 08:56:03 +0800</pubDate>
      
      <guid>https://wdicc.com/go-across-the-gfw/</guid>
      <description>&lt;p&gt;一直用的是梅林里面自带的方案来处理翻墙，后来想在公司的服务器上面也搞一下这个事情，至少把 Google 等常用站点能翻出去，就研究了一下原理。&lt;/p&gt;

&lt;p&gt;目前墙有两个基本措施需要我们去跨越。1 DNS 污染。 2 数据包解析劫持。3 ip 封禁。&lt;/p&gt;

&lt;p&gt;DNS 污染是通过修改或者限制 DNS 请求的数据，来让用户取到一个错误的 ip 而导致用户不能访问正确的网站的方法。一些比较大的网站都被做了 DNS 污染，比如 Google，youtube，facebook，twitter 等。&lt;/p&gt;

&lt;p&gt;数据包解析是指在出国的核心路由上面，分析用户要访问的网站和发送的数据，然后发现问题之后，从中间给用户和网站发送 rst 数据包，让双方断开连接的一种方法。这样就算是用户通过指定 host 等方法避开了 DNS 污染，也可以进一步阻止请求。这种方法对于 https 的请求应该是没有效果的。所以有时候可以通过指定 host 的方法访问到 google。&lt;/p&gt;

&lt;p&gt;对于上面的避开措施，第三种方法就起作用了，就是直接封禁 ip。这样就算指定了 host 也不能访问。&lt;/p&gt;

&lt;p&gt;如果想要翻墙，就需要避开上面这三种封禁的方法。我这里列了一些方式，https://wdicc.com/across-the-great-wall-we-can-reach-every-corner-in-the-world/ 各有利弊。这里想讲的是梅林大致的逻辑。&lt;/p&gt;

&lt;p&gt;最主要的一个思路是使用 iptables 把一些包发给一些支持透明代理的软件，例如 &lt;code&gt;ss-redir&lt;/code&gt; 或者 &lt;code&gt;v2ray&lt;/code&gt; 的 &lt;code&gt;dokodemo-door&lt;/code&gt; 协议的端口。这些软件会自动把数据请求通过代理请求到之后，返回给用户。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-A PREROUTING -p tcp -j REDIRECT --to-ports 1080

-A PREROUTING -p tcp -m multiport --dports 443 dst -j REDIRECT --to-ports 1080
-A PREROUTING -p tcp -m multiport --dports 80 dst -j REDIRECT --to-ports 1080
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一句是把所有请求都转发到了 1080 端口，这样就是全部请求都走代理。第二三句是把所有 443 和 80 端口的请求都转发到了 1080 这个代理端口。如果只是想要某些网站走代理呢？那一个办法是在这个语句里面指定 &lt;code&gt;--dest=12.34.56.78&lt;/code&gt; 指定目标 ip，但是这样一来有的网站 ip 很多且会变化，这样就有点累了。&lt;/p&gt;

&lt;p&gt;iptables 支持和 ipset 配合来做数据包的过滤，而 dnsmasq 支持自动添加特定的 ipset 条目，这两个结合就完美了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;server=/.google.com/208.67.222.222#443
server=/.google.com.hk/208.67.222.222#443
server=/.gstatic.com/208.67.222.222#443
server=/.ggpht.com/208.67.222.222#443
server=/.googleusercontent.com/208.67.222.222#443
server=/.appspot.com/208.67.222.222#443
server=/.googlecode.com/208.67.222.222#443
server=/.googleapis.com/208.67.222.222#443
server=/.gmail.com/208.67.222.222#443
server=/.ytimg.com/208.67.222.222#443

ipset=/.google.com/setmefree
ipset=/.google.com.hk/setmefree
ipset=/.gstatic.com/setmefree
ipset=/.ggpht.com/setmefree
ipset=/.googleusercontent.com/setmefree
ipset=/.appspot.com/setmefree
ipset=/.googlecode.com/setmefree
ipset=/.googleapis.com/setmefree
ipset=/.gmail.com/setmefree
ipset=/.ytimg.com/setmefree
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面是 dnsmasq 的配置，前面的 server 部分，对于指定域名使用特定的 DNS 服务器，用来防污染。ipset 部分，把这些域名解析的结果，提交给 ipset 的 setmefree 这个 set，然后方便配合 iptables 来做过滤。&lt;/p&gt;

&lt;p&gt;dnsmasq 做了上面的配置之后，查询一下列表里面的 DNS，然后通过 &lt;code&gt;ipset list setmefree&lt;/code&gt; 可以看到里面会有一些 ip。&lt;/p&gt;

&lt;p&gt;然后是修改 iptables，增加 ipset 的规则过滤。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-A PREROUTING -p tcp -m multiport --dports 443 -m set --match-set setmefree dst -j REDIRECT --to-ports 1080
-A PREROUTING -p tcp -m multiport --dports 80 -m set --match-set setmefree dst -j REDIRECT --to-ports 1080
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，对于列到 dnsmasq 那个里面的 ipset 部分的域名，全部会走代理了。对于其他地址的请求，不会有任何影响。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GeoHash</title>
      <link>https://wdicc.com/geohash/</link>
      <pubDate>Thu, 25 Jan 2018 11:00:57 +0800</pubDate>
      
      <guid>https://wdicc.com/geohash/</guid>
      <description>&lt;p&gt;我们的应用里面，会有需要用户提交一些坐标点，然后还需要判断这些坐标点和其他坐标点是不是重合或者距离在一定范围内（例如 200M）。&lt;/p&gt;

&lt;p&gt;这个需求最简单的做法就是用户提交的时候，循环和所有需要判断的点比较一下就可以了，但是如果数据量比较大的情况下，这个消耗还是很可观的，因为无法提前索引。所以我们就想，是不是有更好的思路呢？&lt;/p&gt;

&lt;p&gt;一个比较简单的思路是，每次坐标点存储的时候都 hash 一下，一定范围内的，都 hash 到同一个值，这样比较的时候只需要做等于判断就可以了，这个可以索引。那么最简单的做法就是参考 &lt;a href=&#34;https://en.wikipedia.org/wiki/Decimal_degrees&#34; title=&#34;https://en.wikipedia.org/wiki/Decimal_degrees&#34;&gt;https://en.wikipedia.org/wiki/Decimal_degrees&lt;/a&gt; 把坐标点的经纬度按照精度 round，例如 &lt;code&gt;123.4567890123&lt;/code&gt; 和 &lt;code&gt;123.4567894562&lt;/code&gt; 都 round 为 &lt;code&gt;123.456789&lt;/code&gt; ，但是这么做无法精确到想要的那个 200M。&lt;/p&gt;

&lt;p&gt;然后依据上面的思路，和四舍五入的思路，我琢磨是不是可以弄一个 x 舍 x+1 入这么个逻辑，把坐标轴分为 x 等份。然后我就可以通过自己定义 x 来做到想要的精度了（通过经纬度来定义实际距离应该本身就是有误差的，这个和把球面坐标系投影到平面坐标系的方法有关系）。&lt;/p&gt;

&lt;p&gt;按照上面 x 舍 x+1 入的逻辑，实际上是把平面分成了 n 个正方形，同一个正方形里面的，可以认为他们是符合条件的。但是，很明显在相邻的区域里面的，也有可能有符合条件的点，比如两个点分别在区域的这边和另一边。这些点怎么找到呢？&lt;/p&gt;

&lt;p&gt;有一个思路是先找到点所在的区域，然后把周围 8 个区域的点也找出来，这个查找是可以索引的，是 O(1) 的，然后再循环的和找出来的点单个做比较算距离，这个过程是 O(n)，但是 n 小了很多。&lt;/p&gt;

&lt;p&gt;上面是我山寨的一个思路，找了一下发现已经有了，就是 geohash，可以看参考链接，里面比较详细了。&lt;/p&gt;

&lt;p&gt;参考链接&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Geohash&#34; title=&#34;Geohash&#34;&gt;Geohash&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/LBSer/p/3310455.html&#34; title=&#34;http://www.cnblogs.com/LBSer/p/3310455.html&#34;&gt;http://www.cnblogs.com/LBSer/p/3310455.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>SafeAreaView in RN</title>
      <link>https://wdicc.com/safeareaview-in-rn/</link>
      <pubDate>Thu, 25 Jan 2018 10:36:51 +0800</pubDate>
      
      <guid>https://wdicc.com/safeareaview-in-rn/</guid>
      <description>&lt;p&gt;iPhone X 整出来一个刘海和底部的下巴，app 需要做特殊处理，否则可能会顶部把内容显示到被刘海挡住的那部分里面，下面呢会显示到那个手势控制的里面，导致一些按钮不能点击。&lt;/p&gt;

&lt;p&gt;之前我们用的是 &lt;a href=&#34;https://www.npmjs.com/package/react-native-iphone-x-helper&#34; title=&#34;https://www.npmjs.com/package/react-native-iphone-x-helper&#34;&gt;https://www.npmjs.com/package/react-native-iphone-x-helper&lt;/a&gt; 自己计算的。前几天升级 RN 翻 0.52 的 release Note 发现 RN 0.50 新增了一个叫做 &lt;code&gt;SafeAreaView&lt;/code&gt; 的 view 来解决这个问题。&lt;/p&gt;

&lt;p&gt;用法也很简单，把你的内容包含到这里面就可以了。有下面两个方法。&lt;/p&gt;

&lt;p&gt;不用 SafeAreaView 来处理底部，比如显示的是一个列表什么的，底部不固定的，用户如果有需要点按会往上滚动出底部的手势区域然后点击。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;SafeAreaView /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 SafeAreaView 处理底部，比如底部是一排固定按钮，例如微信那样的，这个时候需要把底部区域让出来。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;SafeAreaView&amp;gt;
  ....
&amp;lt;/SafeAreaView&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SafeAreaView 本身支持设置背景色，但是不支持顶部和底部设置不同的颜色，思路是可以给 SafeAreaView 下面放两个 view 分别设置他们的颜色。代码我贴到参考链接 2 里面了。&lt;/p&gt;

&lt;p&gt;参考链接：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/facebook/react-native/commit/ad4b124&#34; title=&#34;https://github.com/facebook/react-native/commit/ad4b124&#34;&gt;https://github.com/facebook/react-native/commit/ad4b124&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/facebook/react-native/commit/983b05441d3d23809b924de2e4bf96a55c47428d&#34; title=&#34;https://github.com/facebook/react-native/commit/983b05441d3d23809b924de2e4bf96a55c47428d&#34;&gt;https://github.com/facebook/react-native/commit/983b05441d3d23809b924de2e4bf96a55c47428d&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Best Practice for React-Native and Redux</title>
      <link>https://wdicc.com/best-practice-for-react-native-redux/</link>
      <pubDate>Sun, 26 Nov 2017 09:19:11 +0800</pubDate>
      
      <guid>https://wdicc.com/best-practice-for-react-native-redux/</guid>
      <description>&lt;p&gt;从 6 月到现在，在 RN 上面摸爬滚打了一段时间了，目前总算找到了一个适合我们自我感觉还可以的开发模式。&lt;/p&gt;

&lt;p&gt;一开始，我们使用的是传统的 React 的模式，然后一个 app 页面一个文件，通过 StackNavigator 组合到一起。这么做在我们的第一个 app 里面没觉得有什么问题，每个页面维护自己的数据，页面之间需要数据共享或者通讯的时候（比如从 list 到详情页面的时候，详情里面有一个改变状态的按钮，状态改变之后希望 list 的状态也跟着变化，这样用户返回之后能看到正确的数据）有 2 个方式。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;通过 DeviceEventEmitter。&lt;/li&gt;
  需要数据的页面订阅，然后在其他页面 emit event 之后前面的页面就可以收到。这个时候可以只通知改变的数据的字段，前一个页面直接去修改，这样可以避免重新刷新页面。也可以发一个简单的通知让其他页面去自己获取数据。
&lt;/ul&gt;

&lt;ul&gt;
&lt;li&gt;通过 navigator 提供的 params 属性。&lt;/li&gt;
  StatckNavigator 提供了一个 params 属性。就是 &lt;code&gt;this.props.navigation.state.params&lt;/code&gt; ，可以通过 setParams 来改变，或者通过类似 &lt;code&gt;this.props.navigation.navigate(&#39;Login&#39;, {goBackToHome: true})&lt;/code&gt; 的方式给，那个 &lt;code&gt;goBackToHome&lt;/code&gt; 将来就会在 params 里面。
&lt;/ul&gt;

&lt;p&gt;直到我们开始做第二个 app。&lt;/p&gt;

&lt;p&gt;第二个 app 是一个单页面 app，登录之后就只有一个页面了，有一个大地图，有左侧 sidebar，sidebar 里面的按钮点击还会出其他页面。这个肯定不能按照我们前面的思路来做了，我们按照组件，拆分了不同的文件，然后组合起来。这个时候更加会需要页面之间的通讯，并且这个时候可选项只有第一个了 &lt;code&gt;DeviceEventEmitter&lt;/code&gt; ，因为都没有 navigate 什么事情。&lt;/p&gt;

&lt;p&gt;这个时候就发现一个问题，event 太多了，开始有点混乱了。emit event 之后，慢慢会发现不知道哪里有订阅，不好管理。这个 app 做完之后，就仔细研究了一下 redux。&lt;/p&gt;

&lt;p&gt;其实写第一个 app 的时候就知道 redux，但是很多概念看的云里雾里的，当时在 react 还没有吃透的情况下，根本没有能力把 redux 搞好。所以当时放弃了 redux。&lt;/p&gt;

&lt;p&gt;了解 redux 之后，感觉这个东西是我们的药。统一的 state 管理，这不就不用考虑状态传递了么？所以一门心思开始研究 redux。刚好我们第一个 app 需要全新改版，我们就借机把我们的第一个 app 也重构到了 redux 实现。整体过程还是蛮舒服的，自己也总结了几条我们自己的使用的思路。&lt;/p&gt;

&lt;h3 id=&#34;目录结构安排&#34;&gt;目录结构安排&lt;/h3&gt;

&lt;p&gt;先大概看看我们 app 的目录结构。我们把所有的 js 文件都放到了 app 目录下面。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app
ios
android
index.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后 app 目录下面，分了 &lt;code&gt;actions&lt;/code&gt; ， &lt;code&gt;reducers&lt;/code&gt; ， &lt;code&gt;sagas&lt;/code&gt; ， &lt;code&gt;selector&lt;/code&gt; 几个目录。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;actions
images
index.js
reducers
sagas
screens
selectors
utility
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;actions 里面放的是 mapDispatchToProps 这个逻辑对应的东西。&lt;/li&gt;
&lt;li&gt;reducers 里面放的是 reducers。&lt;/li&gt;
&lt;li&gt;sagas 里面放的是所有网络请求相关的 actions 的处理逻辑。&lt;/li&gt;
&lt;li&gt;seelctor 里面放的是 mapStateToProps 这个逻辑对应的东西。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每个目录里面也都有一个自己的 index.js 把本目录里面的内容组合起来。通过最外面的 index.js 把这几个目录的逻辑组合起来。&lt;/p&gt;

&lt;h3 id=&#34;给页面设计一个基类&#34;&gt;给页面设计一个基类&lt;/h3&gt;

&lt;p&gt;这样会比较方便你去做一些所有页面都需要做的事情。&lt;/p&gt;

&lt;h3 id=&#34;一个-app-一个统一的-store&#34;&gt;一个 app 一个统一的 store&lt;/h3&gt;

&lt;p&gt;我们 app 还不大，所以这么设计也还好，如果页面比较复杂，我看也有组件使用自己的 store 的例子，这个还没有经验。这么做唯一一个问题就是，那个 store 里面的数据一直都在，多少会占用一些内存。不过我是觉得没啥了，其实这点内存占用不算啥。&lt;/p&gt;

&lt;h3 id=&#34;store-设计和页面无关&#34;&gt;store 设计和页面无关&lt;/h3&gt;

&lt;p&gt;Store 参考了一个文章统一设计，和页面无关。比如我们设计了 user, orders, orderDetail 这些 state，数据所有页面共享。否则如果按照页面来划分的话，某些页面之间如果有用到共享数据就要么多复制一份，那有点浪费了，要么就是会有点乱。&lt;/p&gt;

&lt;h3 id=&#34;每个页面都使用自己的-props&#34;&gt;每个页面都使用自己的 props&lt;/h3&gt;

&lt;p&gt;不在页面间交叉使用 props ，这样不会乱。并且因为我们是一个统一的 store，所以其实每次 props 变化，所有页面都会 render。这个我使用下面的一个思路来解决了。&lt;/p&gt;

&lt;h3 id=&#34;shouldcomponentupdate&#34;&gt;shouldComponentUpdate&lt;/h3&gt;

&lt;p&gt;这个就是在页面的基类里面，通过比较判断本页面的 props 是否有变化来解决前面那个 render 问题。&lt;/p&gt;

&lt;h3 id=&#34;使用-reselect&#34;&gt;使用 reselect&lt;/h3&gt;

&lt;p&gt;因为只要 state 发生变化 redux 就会调用 mapStateToProps 来计算 props，这个计算有一些消耗，毕竟一般也就其中一个页面的 props 需要计算。我们用这个 reselect 解决这个问题，一个页面的 props 需要的 state 没变化的时候，reselect 就可以把 cache 的数据直接返回就好了。&lt;/p&gt;

&lt;h3 id=&#34;适当使用页面的-state&#34;&gt;适当使用页面的 state&lt;/h3&gt;

&lt;p&gt;redux 的理念是所有页面的 state 都放到了 store 里面，你不需要做 setState 动作了。但是实际上有些时候适当使用 state 会让你的开发更加方便。比如表单验证，用户输入数据之后点击提交 ，如果通过发送 action 改变 state 然后再通过 selector 返回页面，那就有点太费劲了。而直接通过 setState 设定页面 state，然后在提交表单的时候读出来做验证就简单多了。&lt;/p&gt;

&lt;p&gt;有时候页面的一些 state 是和 props 有关系的，这个时候可以使用 &lt;code&gt;componentWillReceiveProps(nextProps)&lt;/code&gt; 来判定，然后和 state 同步。&lt;/p&gt;

&lt;h3 id=&#34;android-的返回按钮处理&#34;&gt;Android 的返回按钮处理&lt;/h3&gt;

&lt;p&gt;android 有一个实体的返回按钮，StackNavigator 给出的&lt;a href=&#34;https://reactnavigation.org/docs/guides/redux#Handling-the-Hardware-Back-Button-in-Android&#34; title=&#34;方案&#34;&gt;方案&lt;/a&gt;是监听一个 &lt;code&gt;hardwareBackPress&lt;/code&gt; 事件，然后 &lt;code&gt;dispatch(NavigationActions.back())&lt;/code&gt; ，但是有一个问题是，有时候我们返回的时候还需要做一些自己的动作。比如清理 store 的数据，或者判断一下往哪里返什么的，比如用户刚提交了订单之后，给了一个按钮可以看订单详情，这个时候从详情返回就希望直接到首页，不要又返回新建订单的页面。&lt;/p&gt;

&lt;p&gt;我们通过下面的思路做的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;    onBackPress = () =&amp;gt; {
        const { dispatch, nav } = this.props;

        if (nav.index === 0) {
            return false;
        }
        const {routes} = nav;
        const {params} = routes[routes.length-1]

        if(params &amp;amp;&amp;amp; params.goBack) {
            params.goBack();
        } else {
            dispatch(NavigationActions.back());
        }
        return true;
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在页面的基类里面&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;    constructor(props) {
        super(props);
        if (this.goBack)
            this.props.navigation.setParams({ goBack: ()=&amp;gt;this.goBack() })
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后页面里面如果有自己的特殊逻辑，那就实现一个 &lt;code&gt;goBack&lt;/code&gt; 方法就好了。&lt;/p&gt;

&lt;h3 id=&#34;表单的弹出页面-不一定需要使用-store&#34;&gt;表单的弹出页面，不一定需要使用 store&lt;/h3&gt;

&lt;p&gt;比如一个下单页面，需要填联系人信息，这个时候我们一般会到一个联系人的页面来选择联系人。这个时候在这个页面选择的联系人，如何传递给上一个页面呢？有两个类型的方法。&lt;/p&gt;

&lt;p&gt;第一个方法自然就是 redux 的方法，在选择页面点确定的时候，触发 action 通过 reducer 设置这个页面的 store，然后通过 selector 修改上一个页面的 props，这样就达到了传递的目的。&lt;/p&gt;

&lt;p&gt;第二个方法是在新页面打开的时候，通过 navigater 传一个 callback 过去，那边选择好的时候，调用这个回调方法把数据传回来。&lt;/p&gt;

&lt;p&gt;第一个方法贴合 redux 的做法，但是存在一个问题，如果这个新的选择页面在多个地方出现，那么就需要有一个区分，当前这个选择是给哪个地方服务的(因为必须得在 redux 的 store 里面做好区分，否则两个页面总是相同的状态)。另外还有一个数据清理的问题，否则下次在别的页面打开这个页面，会有上次的数据残留。&lt;/p&gt;

&lt;p&gt;第二个方法土一点，但是没有上面的问题。不过要注意的是，如果新的页面有网络请求，那这个时候还需要和 saga thunk 这些关联，那么就总是会走到 redux 的 store，所以这个方法就不适用了。&lt;/p&gt;

&lt;h3 id=&#34;参考文章&#34;&gt;参考文章&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://wdicc.com/11-mistakes-during-use-react-native/&#34; title=&#34;11-mistakes-during-use-react-native&#34;&gt;11-mistakes-during-use-react-native&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Podcasts 推荐</title>
      <link>https://wdicc.com/podcasts/</link>
      <pubDate>Sat, 25 Nov 2017 11:38:37 +0800</pubDate>
      
      <guid>https://wdicc.com/podcasts/</guid>
      <description>

&lt;p&gt;也不知道从什么时候开始听播客的，现在几乎是 podcast 的重度用户。听播客比看东西省力，以前是上下班的时候想休息一下眼睛就听播客，现在每天开车上下班没法看东西，所以听的更多了。推荐一些我自己听的，下面排序是随机的，和推荐度无关。&lt;/p&gt;

&lt;h2 id=&#34;中文播客&#34;&gt;中文播客&lt;/h2&gt;

&lt;h3 id=&#34;迟早更新&#34;&gt;迟早更新&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://www.weareones.com/2&#34;&gt;http://www.weareones.com/2&lt;/a&gt; 这个是个夫妻档，主播任宁刚 30 岁，但是知识面还是挺广的，播客里面的内容很广，但是多与科技有些关系。主播枪枪和他是夫妻，挺有意思的。更新比较快，基本每周都有。&lt;/p&gt;

&lt;h3 id=&#34;teahour&#34;&gt;Teahour&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://teahour.fm/&#34;&gt;http://teahour.fm/&lt;/a&gt; 这个播客经常会请一些比较厉害的开发者和创始人来做访谈，谈的内容也基本是在科技圈。不过最近更新比较慢，前几天刚更新了一期，距上一期已经是 1 年左右了。但是听一听历史的 ep 有些也不过时。&lt;/p&gt;

&lt;h3 id=&#34;代码时间&#34;&gt;代码时间&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://codetimecn.com/&#34;&gt;http://codetimecn.com/&lt;/a&gt; 这个播客也是请人来做访谈，不过聊的感觉有时候有点尴尬，也不知道为啥有这个感觉。也是很久更新一期，历史的也可以听听。&lt;/p&gt;

&lt;h3 id=&#34;checked&#34;&gt;checked&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://checked.fm/&#34;&gt;http://checked.fm/&lt;/a&gt; 这个播客有三个主播，2 个少数派的雇员，还有个妹子。都是年轻人，都挺有意思的。会讨论各种科技话题，科技热点事件，APP 使用经验等，更新也比较及时。&lt;/p&gt;

&lt;h3 id=&#34;机核网&#34;&gt;机核网&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.g-cores.com/categories/9&#34;&gt;https://www.g-cores.com/categories/9&lt;/a&gt; 一个游戏播客。机核网本身是个游戏咨询站。播客内容就是各种游戏相关的东西。我之前听过《血缘》和《黑魂》相关的。不过因为我游戏玩的其实没那么多，所以他们谈的很多游戏没玩过，后来也就不听了。&lt;/p&gt;

&lt;h3 id=&#34;比特新声&#34;&gt;比特新声&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://banlan.show/bitvoice&#34;&gt;https://banlan.show/bitvoice&lt;/a&gt; 主播海龙是出国培训老师，主播有才是一个 soho 的程序员。一个文科一个理科，思想的一些碰撞还挺有意思的。谈论的话题基本是科技圈的居多，但是内容也比较广泛。&lt;/p&gt;

&lt;h3 id=&#34;ux-coffee-设计咖&#34;&gt;UX Coffee 设计咖&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://uxcoffee.co/&#34;&gt;http://uxcoffee.co/&lt;/a&gt; 主要和谈论一些设计和用户体验相关的内容。主播应该在国外，会请一些在国外的华语开发者来访谈。&lt;/p&gt;

&lt;h3 id=&#34;i-o-调频&#34;&gt;「I/O」调频&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://dailyio.net/&#34;&gt;http://dailyio.net/&lt;/a&gt; 更新不多，貌似是一个人的独白，感觉听的不多，所以我也不记得大致内容了。&lt;/p&gt;

&lt;h3 id=&#34;内核恐慌&#34;&gt;内核恐慌&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://kernelpanic.fm/&#34;&gt;https://kernelpanic.fm/&lt;/a&gt; 科技播客，内容还挺好的，可惜目前更新很少。最近几期《字谈字串》都是 4 个人串台。Rio 和吴涛其实还参加了近期的《迟早更新》，但是他们居然不更新自己的播客，发指。&lt;/p&gt;

&lt;h3 id=&#34;it-公论&#34;&gt;IT 公论&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://itgonglun.com/&#34;&gt;https://itgonglun.com/&lt;/a&gt; 李如一和 Rio 主持。李如一好像挺有名的，不过我不是很熟悉。也是科技相关的播客。&lt;/p&gt;

&lt;h3 id=&#34;两个-it-大叔&#34;&gt;两个 iT 大叔&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://podcast.lengqidong.com/podcast.xml&#34;&gt;http://podcast.lengqidong.com/podcast.xml&lt;/a&gt; 没有找到他们的网站，只有一个 rss 地址了。这个是两个男主播，聊的内容大都和科技相关。&lt;/p&gt;

&lt;h3 id=&#34;etw&#34;&gt;ETW&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://www.etw.fm/&#34;&gt;http://www.etw.fm/&lt;/a&gt; 这个是两个驻美记者做的播客，两个妹子。聊各种热点话题，还是挺有意思的。&lt;/p&gt;

&lt;h2 id=&#34;英文播客&#34;&gt;英文播客&lt;/h2&gt;

&lt;p&gt;英文播客我基本只能听英语学习类的，其他的语速和发音会导致有不少听不懂。&lt;/p&gt;

&lt;h3 id=&#34;all-ears-english&#34;&gt;All Ears English&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.allearsenglish.com/&#34;&gt;https://www.allearsenglish.com/&lt;/a&gt; 两个美国妹子，语速没有调慢，聊一些日常的用语什么的，感觉还是比较好懂的。&lt;/p&gt;

&lt;h3 id=&#34;潘吉jenny告诉你-学英语聊美国-开言英语&#34;&gt;潘吉Jenny告诉你|学英语聊美国|开言英语&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://openlanguage.com/library/learn-english/9/culture-show&#34;&gt;https://openlanguage.com/library/learn-english/9/culture-show&lt;/a&gt; 这个是一个中国人一个外国人搭配的播客。里面中文说的比较多，会讲解一些常用的词汇用语什么的。&lt;/p&gt;

&lt;h3 id=&#34;culips-english&#34;&gt;Culips English&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://esl.culips.com/&#34;&gt;https://esl.culips.com/&lt;/a&gt; 主播都是外国人，语速应该是调整过感觉比较慢。有词汇讲解，也有普通的聊天。&lt;/p&gt;

&lt;h3 id=&#34;the-english-we-speak&#34;&gt;The English We Speak&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://www.bbc.co.uk/programmes/p02pc9zn&#34;&gt;http://www.bbc.co.uk/programmes/p02pc9zn&lt;/a&gt; 主播是英国口音，内容都比较短，每次基本就是一二个词。&lt;/p&gt;

&lt;h3 id=&#34;eslpod&#34;&gt;ESLPod&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.eslpod.com/&#34;&gt;https://www.eslpod.com/&lt;/a&gt; 这个是我很早以前听过的，目前这个没有免费的更新了，必须付费，年费还不低。不过这个是我听过觉得比较好的，会仔细用英文解释对话里面的单词。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>草泥马</title>
      <link>https://wdicc.com/freedom/</link>
      <pubDate>Mon, 06 Nov 2017 18:47:41 +0800</pubDate>
      
      <guid>https://wdicc.com/freedom/</guid>
      <description>&lt;p&gt;我搜了一下我的帖子，GFW 这个 tag 最早在我的 「2006/12/01 咱也玩玩lilina」 这个帖子里面就出现了。里面提到 Google 有时候会撞墙，会导致 Google reader 也不能访问。我也忘记这个东西最早是什么时候进入我的生活的，从我的 blog 后面可以看到 09 年开始研究一些相关技术，到现在已经 8 年了。&lt;/p&gt;

&lt;p&gt;很多人说百度更懂中文。我从来没觉得，可能因为我中文搜的不多吧，不过就算是中文也更喜欢看 Google 里面的结果。百度里面巨量的重复内容，都是一个帖子被复制了很多次，浪费很多时间翻页之后你还是会发现没有你想要的结果。用 Google 的时候，如果前面 3 页（更多时候，1-2 页足够）还没有你想要的结果，那么要么是这个结果就是少，要么就是你的关键字不对，根据结果里面的一些信息，适当调整自己的关键字。&lt;/p&gt;

&lt;p&gt;因为本身是搞技术的，技术方面，国外的文章水分更少，并且自己也基本能看懂技术相关的英文内容，所以从来都不用百度。国内的各种论坛（也有一些例外的，比如 v2ex，rubychina 等），大量的顶，回复可见内容的帖子，基本没什么意义。不如直接看英文世界里面的情况来的直接。&lt;/p&gt;

&lt;p&gt;那会有一段时间还流行各种草泥马相关的东西，比如草泥马之歌。大家用这种方式自嘲，讽刺。当时总觉得这种东西不符合普世价值并不能长久，笑笑也就好了。这么一翻，就是 8 年。现在还每况愈下，一些稍微活跃一点的还有喝茶的待遇。&lt;/p&gt;

&lt;p&gt;这个帖子前几天就想写了，一忙忘记了，今天补上。我和图拉鼎同学并没有见过面。唯一的近距离接触，是当时他在北京 Canonical 公司的时候，有次要聚会，我和他在 qtalk 上面聊过，不过可惜我最后没参加（这段记忆也比较模糊了，可能会有记错），没有见面。后面更多的就是在微博看他在回到杭州后享受生活了。&lt;/p&gt;

&lt;p&gt;看看他的生活，就是一个普通宅男，聪明热爱生活，经常游荡在杭州的街巷，发现一些别人没注意到或者忽略的事物。写写代码，咖啡馆坐坐，找一个志同道合的朋友聊聊天，再普通不过了。偏偏就是这样的一个人都容不下，神经一点一点变的异常铭感，没有点神经病估计现在也不好当领导了。&lt;/p&gt;

&lt;p&gt;前两年，还有另外一个朋友开发了一款搭建高性能网站使用的服务器软件（和翻墙无关），本来一直在国外工作，回家探亲被限制出境，具体原因不聊了，后来解决了出去了。目前在国外成立的自己的公司，专门发扬自己的软件，也拿到了绿卡。估计以后也没兴趣回来了。&lt;/p&gt;

&lt;p&gt;目前这个形势下，无法预见我们自己哪天不会遇到问题，即使你自己学会了阉割自己，但你怎么知道他们的铭感点在哪里呢？也可能是「就是喜欢看你虽然不喜欢，但是又不得不一起建设社会主义的样子」呢？&lt;/p&gt;

&lt;p&gt;想起来一个大话西游里面大对白了&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;爱一个人需要理由么？&lt;/li&gt;
&lt;li&gt;需要吗？&lt;/li&gt;
&lt;li&gt;不需要吗？&lt;/li&gt;
&lt;li&gt;需要吗？&lt;/li&gt;
&lt;li&gt;不需要吗？&lt;/li&gt;
&lt;li&gt;等你真爱上一个人你就知道了&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;把里面的「爱」替换为「整」（等你真被整的时候就知道了）我感觉还是挺适合的。&lt;/p&gt;

&lt;p&gt;附送 &lt;a href=&#34;https://www.youtube.com/watch?v=01RPek5uAJ4&#34; title=&#34;草泥马之歌&#34;&gt;草泥马之歌&lt;/a&gt; 给有兴趣的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Why I Am Not at React Native Developer(节译)</title>
      <link>https://wdicc.com/why-i-am-not-at-react-native-developer/</link>
      <pubDate>Thu, 02 Nov 2017 14:00:39 +0800</pubDate>
      
      <guid>https://wdicc.com/why-i-am-not-at-react-native-developer/</guid>
      <description>&lt;p&gt;翻译自这里 &lt;a href=&#34;https://arielelkin.github.io/articles/why-im-not-a-react-native-developer.html#javascript&#34; title=&#34;Why I&#39;m not a React Native Developer&#34;&gt;Why I&#39;m not a React Native Developer&lt;/a&gt; 。&lt;/p&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;很多人把 RN 作为下一个移动 app 的开发平台。切换开发平台有可能会有巨大的消耗也可能会改变你日常的工作流程。同时平台也可能会改变你开发使用的软件，需要你掌握一些特殊的工具和工作流，把你绑定到一个新的开发生态里面。&lt;/p&gt;

&lt;p&gt;Facebook 自己想要完全切换到 RN 来代替原来的 Native 开发。RN 开发团队也在努力做这个事情，他们搞了一个软件开发平台来代替传统的 Xcode/Swift/ObjC 开发模式。RN 团队到底对这个是一个怎么的态度，貌似还不太明确。&lt;/p&gt;

&lt;p&gt;我自己搞了几个月开发之后，我感觉这个平台不是我想要的一个，也不推荐其他人往里跳。&lt;/p&gt;

&lt;h2 id=&#34;declarative-style&#34;&gt;Declarative style&lt;/h2&gt;

&lt;p&gt;在 RN 里面，UI 是一堆包含状态(state)的函数(function)和属性(props)。&lt;/p&gt;

&lt;p&gt;下面是个例子，假设我们需要在左上角有一个小正方形，如果用户连接了就显示红色，没连接显示绿色。&lt;/p&gt;

&lt;p&gt;在这种编程类型下，你指定所有更新 UI 需要的步骤。我们需要监听 isConnectd 来更新 view。我们告诉 iOS 如何计算状态。&lt;/p&gt;

&lt;p&gt;比较一下 RN 的模式。&lt;/p&gt;

&lt;p&gt;RN 让你在 render() 方法里面描述你的 UI。React 框架来保证 state 的变化会触发 re-rendering。对于数据的修改，会自动触发 UI 的改变。&lt;/p&gt;

&lt;p&gt;我想这是一种思考 UI 的很好的方式。这也是 MVC 模式的一种进化，View 只需要负责展示，不需要负责管理数据。&lt;/p&gt;

&lt;h2 id=&#34;faster-iterations&#34;&gt;Faster iterations&lt;/h2&gt;

&lt;p&gt;RN 里面开发的时候，框架会在本地启动一个 server。你只需要编译一次，然后在 iOS 模拟器或者真机上面运行，RN 会保证你在 js 里面做的任何修改都会反馈到 app 里面。&lt;/p&gt;

&lt;ul&gt;
你有两个选择:
&lt;li&gt;Live Reloading。使用 CMD + R 快捷键。&lt;/li&gt;
&lt;li&gt;Hot Reload。只更新你编辑的部分。比如你在编辑一个 table view 的一个 cell，你的修改会立刻可以看到，不用每次都从开始界面一步一步找过去。当前页面的状态也会一直保留，这就是所见即所得的编程体验。Xcode 没有这个。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个比之前在 native 里面快太多了，在 native 里面有时候还需要在 ViewController 里面加一些 debug 方法，以便快速的找到需要的界面。&lt;/p&gt;

&lt;h2 id=&#34;cross-platform&#34;&gt;Cross-platform&lt;/h2&gt;

&lt;p&gt;跨平台。&lt;/p&gt;

&lt;h2 id=&#34;uncertain-roadmap&#34;&gt;Uncertain roadmap&lt;/h2&gt;

&lt;p&gt;担心 RN 团队没有对这个项目的长期的保证。&lt;/p&gt;

&lt;p&gt;不像我们使用一些第三方库，如果那个库出点问题我们的项目也不至于出啥大问题。而 RN 是一整个软件开发平台，如果 facebook 停止维护 RN，我们的软件可能就停滞了，目前也没有一个 RN 替代。如果要自己搞，那还需要区了解 RN 的代码，React.js 的代码，RN CLI 工具，和 JavaScriptCore。社区会继续搞么？也许吧，可能不是我们熟悉的速度。&lt;/p&gt;

&lt;p&gt;Github 上面 RN 大概 2 周就会发布一个新版本。&lt;/p&gt;

&lt;h2 id=&#34;patently-daunting&#34;&gt;Patently daunting&lt;/h2&gt;

&lt;h2 id=&#34;patently-silent&#34;&gt;Patently silent&lt;/h2&gt;

&lt;h2 id=&#34;october-2017-update-facebook-relicensing&#34;&gt;October 2017 update: Facebook Relicensing&lt;/h2&gt;

&lt;h2 id=&#34;javascript&#34;&gt;Javascript&lt;/h2&gt;

&lt;ul&gt;
我们应该从 RN 切换到 Swifh 一个比较重要的原因是「技术倒退」，你应该抛弃 JavsScript，这是一门
&lt;li&gt;有缺陷的&lt;/li&gt;
&lt;li&gt;不安全的&lt;/li&gt;
&lt;li&gt;进化缓慢的语言&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面的例子都是基于 ES2016。&lt;/p&gt;

&lt;h3 id=&#34;javascript-s-inadequacy&#34;&gt;Javascript’s inadequacy&lt;/h3&gt;

&lt;p&gt;司机都喜欢开集成了很多安全措施的车。不是因为它们能让你开起来更简单，而是因为它们会降低你遇到事故的几率。&lt;/p&gt;

&lt;p&gt;类似的，一门编程语言也应该提供一些能避免编程错误的安全措施。&lt;/p&gt;

&lt;p&gt;ARC 刚加入 Object-C 的时候，我们可以选择关闭他，但是为啥不推荐呢，因为编译器可以比你更加准确的知道一个对象的生命周期。「编译器比你聪明」。&lt;/p&gt;

&lt;h3 id=&#34;type-errors&#34;&gt;Type errors&lt;/h3&gt;

&lt;p&gt;JavaScript 里面一个变量可以在任何时间编程任意类型。&lt;/p&gt;

&lt;h3 id=&#34;lack-of-optionals&#34;&gt;Lack of optionals&lt;/h3&gt;

&lt;p&gt;Objective-C 里面(以及其他语言里面)大量的错误是调用一个 nil 的对象上面的方法。&lt;/p&gt;

&lt;p&gt;Swift 里面，会强制你做 nil 检查，如果你知道一个对象可能会是 nil。&lt;/p&gt;

&lt;h3 id=&#34;lack-of-function-signature&#34;&gt;Lack of function signature&lt;/h3&gt;

&lt;p&gt;JavaScript 里面函数没有返回类型。&lt;/p&gt;

&lt;h3 id=&#34;immutability&#34;&gt;Immutability&lt;/h3&gt;

&lt;p&gt;JavaScript 里面对不可变数据的支持很弱。&lt;/p&gt;

&lt;h3 id=&#34;you-can-t-trust-arrays&#34;&gt;You can’t trust arrays&lt;/h3&gt;

&lt;h3 id=&#34;poor-error-handling&#34;&gt;Poor error handling&lt;/h3&gt;

&lt;h3 id=&#34;no-support-for-decimals&#34;&gt;No support for decimals&lt;/h3&gt;

&lt;h3 id=&#34;dodgy-maths&#34;&gt;Dodgy maths&lt;/h3&gt;

&lt;h3 id=&#34;unsafe-initialisation&#34;&gt;Unsafe initialisation&lt;/h3&gt;

&lt;h3 id=&#34;optional-curly-braces-after-an-if&#34;&gt;Optional curly braces after an if&lt;/h3&gt;

&lt;h3 id=&#34;ambiguous-curly-braces&#34;&gt;Ambiguous curly braces&lt;/h3&gt;

&lt;h3 id=&#34;switch-fallthrough&#34;&gt;Switch fallthrough&lt;/h3&gt;

&lt;h3 id=&#34;what-s-nothing&#34;&gt;What’s nothing?&lt;/h3&gt;

&lt;h3 id=&#34;poor-expressivity&#34;&gt;Poor expressivity&lt;/h3&gt;

&lt;h3 id=&#34;exceedingly-slow-evolution&#34;&gt;Exceedingly slow evolution&lt;/h3&gt;

&lt;ul&gt;
ES2016 提供了一些新的功能
&lt;li&gt;The includes method for arrays.&lt;/li&gt;
&lt;li&gt;The ** operator&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;flow-to-the-rescue&#34;&gt;Flow to the rescue!&lt;/h3&gt;

&lt;p&gt;Flow 是 Facebook 提出来解决上面那些问题的。这是一个 JavaScript 的静态类型检查工具。&lt;/p&gt;

&lt;p&gt;回忆一下那些例子。&lt;/p&gt;

&lt;h3 id=&#34;flow-s-like-flossing&#34;&gt;Flow’s like flossing&lt;/h3&gt;

&lt;p&gt;Flow 修复了 JavaScript 那些问题了么？没有。&lt;/p&gt;

&lt;p&gt;Flow 开发工程师虽然做了很多努力，但是他依然只是 JavaScript 的一个超集，基于一个很弱的根基。&lt;/p&gt;

&lt;p&gt;github 上面大量的项目都没有使用 Flow。也没有一个 RN 的例子讲到了 flow。&lt;/p&gt;

&lt;h2 id=&#34;the-javascript-ecosystem-balls-and-chains&#34;&gt;The Javascript Ecosystem: balls and chains&lt;/h2&gt;

&lt;p&gt;JavaScript 的缺点让所有人都印象深刻，除了 JavaScript 开发。对于他们来说，上面提到的问题并没有那么糟糕。这是因为 JavaScript 开发并不觉得 js 语言有什么欠缺。&lt;/p&gt;

&lt;p&gt;你说没有 immutability，那我们写一个库支持他，你说没有类型检查，那我们写一个库。&lt;/p&gt;

&lt;p&gt;&#34;自由挖掘&#34;是指选择一门健全的语言。这么挖并没有很好的利用好精力。JS 总是让你开发一些其他语言默认就支持的东西。&lt;/p&gt;

&lt;h3 id=&#34;chains&#34;&gt;Chains&lt;/h3&gt;

&lt;p&gt;有条大鱼需要 JavaScript 来处理。这门语言考虑 billions 选择升级或者不升级他们流量起和网站的网络用户。这使得这门语言的开发不健全。&lt;/p&gt;

&lt;p&gt;还记得 typeof(null) == &#39;object&#39; 么，已经有提案把 null 对象改成 null 了，但是「考虑到这会导致现有的大量网站出问题。」这个提案被否决了。ES6 里面 null 依然是个 object。&lt;/p&gt;

&lt;ul&gt;
JavaScript 的进化，需要考虑：
&lt;li&gt;大量的旧版本流量起用户&lt;/li&gt;
&lt;li&gt;一群不同的浏览器厂商&lt;/li&gt;
&lt;li&gt;大量的网站和它们的开发&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;wider-angles&#34;&gt;Wider angles&lt;/h3&gt;

&lt;h2 id=&#34;dependencies&#34;&gt;Dependencies&lt;/h2&gt;

&lt;p&gt;RN 项目有 648 项依赖(我刚看了一下是 603)。你的项目基于其他 600 多人的努力。这也就是说，你的项目也依赖于这 600 多自愿者能持续维护他们的项目。&lt;/p&gt;

&lt;h2 id=&#34;better-alternatives&#34;&gt;Better alternatives&lt;/h2&gt;

&lt;p&gt;广告时间。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>11 Mistakes During Use React Native(翻译)</title>
      <link>https://wdicc.com/11-mistakes-during-use-react-native/</link>
      <pubDate>Wed, 01 Nov 2017 19:12:24 +0800</pubDate>
      
      <guid>https://wdicc.com/11-mistakes-during-use-react-native/</guid>
      <description>&lt;p&gt;粗略的翻译自 &lt;a href=&#34;https://medium.com/dailyjs/11-mistakes-ive-made-during-react-native-redux-app-development-8544e2be9a9&#34; title=&#34;11 mistakes I’ve made during React Native / Redux app development&#34;&gt;11 mistakes I’ve made during React Native / Redux app development&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;一些可能会错误的评估&#34;&gt;一些可能会错误的评估&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;虽然有很多可以重复使用的组件，你还是需要分开考虑 iOS 和 Android 的布局。&lt;/li&gt;
&lt;li&gt;当你评估表单实现的时候，应该要同时考虑表单的验证。开发 RN 比开发例如 Cordova 这样的 hybrid 的程序需要写的代码更多。&lt;/li&gt;
&lt;li&gt;如果是基于一个已经有后端的 webapp 写代码，应该需要先去仔细看看后端提供的功能接口，因为你需要自己写逻辑，弄明白了 DB 结构数据关联，可以然你更好的规划你的 redux store。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;尽量使用已有的组件&#34;&gt;尽量使用已有的组件&lt;/h2&gt;

&lt;p&gt;Google 一下就会发现，已经有大量的现成的组件，例如 buttons, footers 等。如果你没啥特殊要求，这些你都可以直接用。你要是有自己的特殊需要，也可以包装一下这些组件成你自己的，然后在里面自定义样式。不过你自己使用 View, Text, TouchableOpacity 等这些 RN 组件来自己包装对于你理解 RN 的工作原理。你自己打包的组件的版本也不会变，不像依赖外部模块。&lt;/p&gt;

&lt;h2 id=&#34;不要分开搞-ios-和-android-的布局&#34;&gt;不要分开搞 iOS 和 Android 的布局&lt;/h2&gt;

&lt;p&gt;如果你有不同的布局需求，那就分开。否则，你可以使用 RN Platform 提供的 API 来做一些小的区分。&lt;/p&gt;

&lt;p&gt;如果布局很大不同，那就把布局内容放到不同的文件里面。&lt;/p&gt;

&lt;p&gt;你可以使用 index.ios.js 给 iOS 布局用，index.android.js 给 Android 用。&lt;/p&gt;

&lt;p&gt;共同的重复代码可以放到 helpers 里面。&lt;/p&gt;

&lt;h2 id=&#34;错误的-redux-store-规划&#34;&gt;错误的 redux store 规划&lt;/h2&gt;

&lt;p&gt;在规划你的 app 的时候可能会花很多时间在布局上，少量时间在数据规划上。这是个错误。redux 可以帮我们很好的处理数据。如果能规划好他，这会是一个很有用的工具，否则可能会带来不好的结果。&lt;/p&gt;

&lt;p&gt;在我刚开始规划的时候，想着 reducers 是每个 container 的数据层。所以，如果有登录，忘记密码，Todo 列表页面，那应该来说会有各自的 reducers: SignIn, Forgot, ToDoList。&lt;/p&gt;

&lt;p&gt;后来才发现，数据没那么好管理。我有 Todo 详情页，用这个方式规划的话，就需要有一个 ToDoDetails reducer。这是个巨大的失误。当用户在 Todo 列表页面选择了一项的时候，我们需要把数据传递给 ToDoDetails reducer。这表示需要额外的 actions 来发送数据给 reducer，这不太合理。&lt;/p&gt;

&lt;p&gt;做了一些调查之后，打算该改结构&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Auth&lt;/li&gt;
&lt;li&gt;Todos&lt;/li&gt;
&lt;li&gt;Friends&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Auth 用来存放 token。Todos 和 Friends reducers 用来存放实体数据，从名字就能理解。当从列表打开 ToDo 详情的时候，只需要根据 id 从 Todos 里面查询就可以了。&lt;/p&gt;

&lt;p&gt;不管多复杂的结构，都推荐你这么搞，这样你总是知道你应该去哪里找你的数据。&lt;/p&gt;

&lt;h2 id=&#34;错误的项目结构&#34;&gt;错误的项目结构&lt;/h2&gt;

&lt;p&gt;对于新手来说，规划项目结构是个比较难的事情。&lt;/p&gt;

&lt;p&gt;得看看你的项目是大项目？巨大的？还是小的。有多少 screen，20？30？还是 5 个，或者是只有个 Hello world？&lt;/p&gt;

&lt;p&gt;一开始我的项目结构如下：&lt;/p&gt;

&lt;p&gt;图不贴了，可以看原文。简单讲就是把 reducers actions 等分开放到不同的目录里面。&lt;/p&gt;

&lt;p&gt;如果你的项目不大，例如 10 来个 screen 这么搞是挺好的。如果比较大，可以考虑下下面这个方式：&lt;/p&gt;

&lt;p&gt;就是按照 screen 划分目录，把这个 screen 对应的 actions reducers 等放到一个目录下面。这样可以清楚的知道一个 container 和 action 等的关系。&lt;/p&gt;

&lt;p&gt;如果你有通用的 style 文件，可以建一个 styles/index.js 文件。&lt;/p&gt;

&lt;p&gt;还有很多其他的结构类型，你需要找到适合你自己的。&lt;/p&gt;

&lt;h2 id=&#34;container-里面错误的结构&#34;&gt;container 里面错误的结构&lt;/h2&gt;

&lt;p&gt;其实简单概括就是，应该尽量封装你的组件，比如 form 表单里面的东西，应该适当的做一些封装，比如搞一个 FormItem 这样的组件出来，就不用重复的写 Text 和 TextInput 的组合了。&lt;/p&gt;

&lt;p&gt;但是也要注意，不要为了封装而封装，原文里面有个例子，把组件搞了一个 setTitle 方法，然后根据 id 来设置 title。作者的意思是，Dumb 组件不应该加入业务逻辑进来，比如加一个 id 就需要修改一下这个组件。&lt;/p&gt;

&lt;h2 id=&#34;内联样式&#34;&gt;内联样式&lt;/h2&gt;

&lt;p&gt;就是这样的 &lt;code&gt;&amp;lt;View style={{flex:1, flexDirection:&#39;row&#39;, backgroundColor:&#39;transparent&#39;}}&amp;gt;&lt;/code&gt; ，慢慢会变得很难管理，也没法重用。应该一开始就把这个写入到单独的文件里面。&lt;/p&gt;

&lt;h2 id=&#34;使用-redux-验证表单&#34;&gt;使用 redux 验证表单&lt;/h2&gt;

&lt;p&gt;这个是我犯的一个错误，但也有可能适合你们。&lt;/p&gt;

&lt;p&gt;如果需要通过 redux 验证表单，我们需要创建 action， action type 和 reducer 里面单独的字段。这么做有点太麻烦了。&lt;/p&gt;

&lt;p&gt;所以我们决定使用 state。不用 reducers, types 等。只用一些在 container 范围的简单的函数。这么做让我们删除了 action，reducer 文件里面不必要的函数。也不用处理维护 store，这么做很适合我们的项目。&lt;/p&gt;

&lt;h2 id=&#34;大量依赖-zindex&#34;&gt;大量依赖 zIndex&lt;/h2&gt;

&lt;p&gt;从 web 过来的人会比较喜欢 css 里面的 z-index，可以控制显示哪一层。但是在 RN 里面，一开始没有这个，但是后来也加上了。一开始用的时候挺好的，但是直到我开始在 Android 上面跑。。。现在我都是在构建的时候就考虑好他们将来展示的顺序。&lt;/p&gt;

&lt;h2 id=&#34;不阅读依赖的模块的代码&#34;&gt;不阅读依赖的模块的代码&lt;/h2&gt;

&lt;p&gt;简单说就是用第三方模块的时候，看文档是必须的了，但是有时候也需要看看代码的。比如不工作了，或者和文档描述不一致啥的。看代码也能学习到如何构建自己的模块。&lt;/p&gt;

&lt;h2 id=&#34;使用-panresonder-和-动画-api-的时候要小心&#34;&gt;使用 PanResonder 和 动画 API 的时候要小心&lt;/h2&gt;

&lt;p&gt;RN 提供了你构建完全 native 体验的 app 的能力。例如布局，手势，动画。&lt;/p&gt;

&lt;p&gt;默认提供了布局功能，当你使用 View, Text, TextInput 这些 RN 模块的时候，手势和动画需要使用 PanResonder 和动画 API 来提供手势和动画。&lt;/p&gt;

&lt;p&gt;一开始可能会觉得好难，什么时候开始，什么时候结束，长按，短按等。RN 也确实没有把这些讲的足够清晰。作者提供了一个例子&lt;/p&gt;

&lt;p&gt;开始我们初始化一个 PanResonder 对象，针对我们感兴趣的 onPanResponderGrand(当用户点击 button 的时候调用) 和 onPanResponderRelease(当用户手指离开屏幕的时候调用) 设置了一些 handler。&lt;/p&gt;

&lt;p&gt;同时我们也设置了 Animated 对象来帮我们处理动画。设置他的取值为 0，然后定义 _setOpacity 方法来改变 this.opacityAnimated 的值。在渲染之前，给 this.opacityAnimated 赋值为通常情况下的值。我们不使用 View，使用 Animated.View 来动态修改透明度。&lt;/p&gt;

&lt;p&gt;可以看到，这没啥难理解的。当然你需要阅读这些 API 的文档让你的 app 更完美。希望这个例子可以让你有一个好的开始。&lt;/p&gt;

&lt;p&gt;React Naive 很不错，你几乎可以用它做任何事情。如果有不行的，你还可以通过 Swift/Object C 或者 Java 来配合 RN 完成。此外还有一个大的社区。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Howto Make react-redux Work With react-navigation</title>
      <link>https://wdicc.com/howto-make-react-redux-work-with-react-navigation/</link>
      <pubDate>Sat, 21 Oct 2017 08:19:28 +0800</pubDate>
      
      <guid>https://wdicc.com/howto-make-react-redux-work-with-react-navigation/</guid>
      <description>&lt;p&gt;这周花了一些时间研究 &lt;code&gt;react-redux&lt;/code&gt; 和怎么让它和 &lt;code&gt;react-navigation&lt;/code&gt; 配合一起工作，总结一下，把代码和注释直接贴这里了，也可以看这个 &lt;a href=&#34;https://gist.github.com/wd/7935c3fb20f2517280b8e050796310b3&#34; title=&#34;gist&#34;&gt;gist&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;/**
 * 一个简单的 RN 应用，有 2 个页面，使用了 react-navigation 的 StackNavigator 来做界面管理
 * 为了说明如何使用 redux，以及如何让 redux 和 StackNavigator 配合
 * 为了容易理解，把所有内容都放到了一个页面里面，实际开发的时候不要这么做
 * 参考：
 *  https://github.com/jackielii/simplest-redux-example
 *  http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_three_react-redux.html
 */

import React, { Component } from &#39;react&#39;;
import {
    StyleSheet,
    Text,
    View,
    Button
} from &#39;react-native&#39;;

import { Provider, connect } from &#39;react-redux&#39;;
import { createStore, combineReducers } from &#39;redux&#39;;
import { StackNavigator, addNavigationHelpers } from &#39;react-navigation&#39;;

// Home 页面，UI 组件
class MyHome extends Component {
    constructor(props) {
        super(props);
        console.log(&#39;init home, props&#39;, props);
    }

    _nextPage() {
        // navigation 依然在 this.props 里面获取，和不用 redux 的时候用法一样
        let {navigation} = this.props;
        navigation.navigate(&amp;quot;App&amp;quot;);
    }

    render() {
        // 所有的传递过来的状态，都需要从 this.props.screenProps 里面读取 (4)
        // 我这里给不同页面的 action 取了各自的命名空间，避免冲突，也可以直接所有 action 都在一个命名空间，这块我还在摸索如何处理比较好 (5)
        let {onIncButtonClicked} = this.props.screenProps.MyAppActions;

        // 界面有两个按钮，一个用来增加另外一个页面的计数器，一个用来访问下一个页面
        return (
            &amp;lt;View style={styles.container}&amp;gt;
                &amp;lt;Button title=&amp;quot;Inc counter&amp;quot; onPress={onIncButtonClicked}&amp;gt;&amp;lt;/Button&amp;gt;
                &amp;lt;Button title=&amp;quot;Next page&amp;quot; onPress={()=&amp;gt;this._nextPage()}&amp;gt;&amp;lt;/Button&amp;gt;
            &amp;lt;/View&amp;gt;
        )
    }
}

// 这个组件只是用来测试就算一个 props 传递给子组件，在 props 被修改的时候也会被自动刷新
class ShowText extends Component {
    render() {
        let {counter} = this.props;

        return (
            &amp;lt;Text&amp;gt;{counter}&amp;lt;/Text&amp;gt;
        )
    }
}

// App 页面，UI 组件
class MyApp extends Component {
    constructor(props) {
        super(props);
        console.log(&#39;init App, props&#39;, props);
    }

    componentWillReceiveProps(newProps) {
        console.log(&#39;myapp recive props&#39;, newProps);
    }

    render() {
        // 组件的 state/props 获取，有自己的命名空间 (1)
        let {counter} = this.props.screenProps.MyApp;
        // 组件的 action props (5)
        let {onIncButtonClicked, onDecButtonClicked} = this.props.screenProps.MyAppActions;

        // 界面有一个计数器的结果，两个按钮
        return (
            &amp;lt;View style={styles.container}&amp;gt;
                &amp;lt;ShowText counter={counter} /&amp;gt;
                &amp;lt;Button title=&amp;quot;Inc counter&amp;quot; onPress={onIncButtonClicked}&amp;gt;&amp;lt;/Button&amp;gt;
                &amp;lt;Button title=&amp;quot;Dec counter&amp;quot; onPress={onDecButtonClicked}&amp;gt;&amp;lt;/Button&amp;gt;
            &amp;lt;/View&amp;gt;
        )
    }
}

// 初始化 StackNavigator，定义页面路由
let AppNavigator = StackNavigator({
    Home: {
        screen: MyHome
    },
    App: {
        screen: MyApp
    }
});

// 包装一下 StackNavigator，因为有些参数需要定制一下
class MyStackNavigator extends Component {
    constructor(props) {
        super(props);
        console.log(&amp;quot;inside MyStackNavigator&amp;quot;, props);
    }

    render() {
        // screenProps: 使用这个往所有的页面传递 props，这个是和直接使用 redux 不同的地方 (4)
        // navigation: 因为使用 redux 之后，就不会直接操作 this.state 了，所以得告诉 StackNavigator dispatch 方法和 state 从哪里读取
        return (
            &amp;lt;AppNavigator
                screenProps={this.props}
                navigation={addNavigationHelpers({
                    dispatch: this.props.dispatch, // 通过 action props 定义 (2)
                    state: this.props.nav, // 通过 state props 定义 (3)
                })} /&amp;gt;
        )
    }
}

// 定义 state 和 props 的关系，所有 redux 应用都需要 (6)
let mapStateToProps = (state, ownProps) =&amp;gt; {
    console.log(&amp;quot;inside mapstate to props&amp;quot;, state, ownProps);
    return {
        // 这两个是不同的命名空间，和上面你使用的时候的路径对应 (1)
        &amp;quot;MyApp&amp;quot;: state.MyApp,
        &amp;quot;MyHome&amp;quot;: state.MyHome,
        // 定义 StackNavigator 的 state (3)
        &amp;quot;nav&amp;quot;: state.nav
    }
};

// 定义 action 和 props 的关系，所有 redux 应用都需要
let mapDispatchToProps = (dispatch, ownProps) =&amp;gt; {
    console.log(&amp;quot;inside map dispath to props&amp;quot;);
    return {
        // 这两个也是不同的命名空间，和上面使用的时候路径对应 (5)
        &#39;MyAppActions&#39;: {
            onIncButtonClicked: () =&amp;gt; {
                let action = {
                    type: &amp;quot;INC_COUNTER&amp;quot;,
                    payload: 1
                };

                dispatch(action);
            },
            onDecButtonClicked: () =&amp;gt; {
                let action = {
                    type: &amp;quot;DEC_COUNTER&amp;quot;,
                    payload: -1
                };

                dispatch(action);
            }
        },
        &#39;MyHomeActions&#39;: {
            onNextButtonClicked: () =&amp;gt; {
                let action = {
                    type: &amp;quot;NEXT_PAGE&amp;quot;
                };

                dispatch(action);
            }
        },
        // 定义 StackNavigator 的 action props (2)
        &#39;dispatch&#39;: dispatch
    }
}

// 定义 home 页面的 reducer，不过因为那个页面唯一的一个 action 是触发别的页面的动作的，所以这个 reducer 其实也可以没有
// 所以从这里也能看出来，reducer 并不一定按照页面去分
let homeReducer = (state, action) =&amp;gt; {
    console.log(&amp;quot;inside home reducer&amp;quot;, state, action);
    return state || {};
};

// 定义一个初始化的 state
let myAppInitState = { &#39;counter&#39;: 10};
// 定义 app 页面的 reducer
let myAppReducer = (state = myAppInitState, action) =&amp;gt; {
    // 收到的 state 实际上只是自己命名空间下的 (6)
    console.log(&amp;quot;inside myAppReducer&amp;quot;, state, action);
    let myState = state;
    // 需要处理的 action 的逻辑
    // 要注意，一个 action 被触发的时候，所有的 reducer 都会被调用，所以其实更像是订阅自己想要处理的 action
    switch (action.type) {
        case &amp;quot;DEC_COUNTER&amp;quot;:
        case &amp;quot;INC_COUNTER&amp;quot;:
            // 如果修改了 state，必须要返回一个新的对象，不能直接在原对象上修改，否则 state 变化不会触发组件的刷新
            return Object.assign({}, myState, {
                &#39;counter&#39;: myState.counter + action.payload
            });
        default:
            return state;
    }
};

// 定义一个 StackNavigator 用到的初始化状态，这个很重要
const initialState = AppNavigator.router.getStateForAction(AppNavigator.router.getActionForPathAndParams(&#39;Home&#39;));
// 定义 StackNavigator 的 reducer，代码直接复制来的
const navReducer = (state = initialState, action) =&amp;gt; {
    console.log(&amp;quot;inside nav reducer&amp;quot;, state, action);
    const nextState = AppNavigator.router.getStateForAction(action, state);

    // Simply return the original `state` if `nextState` is null or undefined.
    return nextState || state;
};

// 创建 store
let store = createStore(combineReducers({
    // 这里的 MyApp 等和前面定义 mapStateToProps 的地方对应 (6)
    // 这里也是导致 reducer 收到的 state 只有自己命名空间下数据的一个原因 (6)
    MyApp: myAppReducer,
    MyHome: homeReducer,
    nav: navReducer
}));

// 让 redux 加持一下，保佑
let App = connect(mapStateToProps, mapDispatchToProps)(MyStackNavigator);

// 其他的就是比较常见的 redux 的逻辑了，另外需要说明的是实际使用的时候，肯定会做页面拆分，如何拆分可能都会有不同的看法，我也还在摸索
export default class Root extends Component&amp;lt;{}&amp;gt; {
    constructor(props) {
        super(props);
    }

    render() {
        return (
            &amp;lt;Provider store={store}&amp;gt;
                &amp;lt;App prop1=&amp;quot;prop1&amp;quot; /&amp;gt;
            &amp;lt;/Provider&amp;gt;
        );
    }
}


const styles = StyleSheet.create({
    container: {
        flex: 1,
        justifyContent: &#39;center&#39;,
        alignItems: &#39;center&#39;,
        backgroundColor: &#39;#F5FCFF&#39;,
    },
    welcome: {
        fontSize: 20,
        textAlign: &#39;center&#39;,
        margin: 10,
    },
    instructions: {
        textAlign: &#39;center&#39;,
        color: &#39;#333333&#39;,
        marginBottom: 5,
    },
});
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>生生死死《白鹿原》</title>
      <link>https://wdicc.com/life/</link>
      <pubDate>Sat, 07 Oct 2017 18:10:00 +0800</pubDate>
      
      <guid>https://wdicc.com/life/</guid>
      <description>&lt;p&gt;之前 6 月份去上海那边的时候，偶尔看到电视里面演&lt;a href=&#34;https://movie.douban.com/subject/26322644/&#34; title=&#34;《白鹿原》&#34;&gt;《白鹿原》&lt;/a&gt;，看了几集。吸引我的，主要可能是里面的乡土气息，以及里面的几个演员演的挺好的。那会看的好像是 40 多集，并且是断续看的，剧情也不太能接的上。后来回来后，找了一个时间，就从头开始看了。直到今天才算看完。看的时候实在是感慨良多，看完了也是心情不太能平复，稍微记录一下。因为没看过书，记录以电视剧剧情为主。&lt;/p&gt;

&lt;p&gt;这剧从大清末年演到了 49 年建国后，基本是从白嘉轩娶媳妇开始讲到当了族长，到生儿育女，到孩子上学，闹革命，生孩子。到最后剧里面的人物死的死，老的老，实在是看的人很心酸。从一个上帝视角看了这么多人的生生死死，以后还是得少看这种剧了。&lt;/p&gt;

&lt;p&gt;白嘉轩一辈子，挺直了腰杆做人，做事的是非对错不评价，但是确实是可以算是不愧对自己，家教很严，但是也就导致了服从家教的孩子们活的很是平淡，这个其实也就是白嘉轩的理念，踏实种个地抱个娃，平平安安一辈子，也就是了，这也是很多老普通百姓的理念。&#34;房是招牌地是累，按下银钱是催命鬼&#34;，这就是古人对普通人生活的建议。但是这么做就可以踏实一辈子么？可以看到白嘉轩的各种经历，清兵围城，闹土匪，镇嵩军征粮征税，天灾大旱，国民党共产党互相闹，这些事情，你不去惹，事情也会找上你。这是命不好？&lt;/p&gt;

&lt;p&gt;生活这一辈子就是个社交，免不了的要和其他人产生交集，矛盾就会出现，就会遇到问题。躲不掉。所谓你抗争是一辈子，认命也是一辈子，一辈子过去了也就是过去了，没有反悔的机会，不能重新来过。&lt;/p&gt;

&lt;p&gt;鹿子霖从开头争抢族长，到后面坐牢看透人生，到后面老糊涂了，演的实在是很好。普通老百姓，有点小恶，顶多也就是占点小便宜，大恶也不敢，游说小蛾勾引白孝文成功之后，白嘉轩对孝文执行族法，是真的出来劝了，没想到这么严重。小老百姓占点便宜就回家高高兴兴的喝酒了。这人活的也很真实，那点小便宜也就是他的一点追求，能压倒族长一头，就觉得自己很有面子。反而白嘉轩那么大义，倒是有那么些不真实。&lt;/p&gt;

&lt;p&gt;这剧里面两个最悲情的人物，一个是田小蛾，一个就是冷秋月。小蛾没啥别的追求，也就是想有个人能一起踏实过日子。所以黑娃和他住在破窑里面的时候是最开心的，管他其他那些呢，只要能一起好好过日子就可以了。但是可惜，有些事情看不透，参加农协搞事情，以为是好运来了，却没想到那是送命的前兆。以为黑娃死了之后，一个弱女人开始找自己的依靠，一半是为了报仇，一半是真心觉得白孝文对自己真好，开始了自己的第二次的幸福生活。却没想到，命丧在这里。死的很悲情，这也是炮灰，要不是鹿兆鹏拉拢，可能黑娃踏实的攒钱，种地养老婆，一辈子或许平平淡淡的，但是安安全全的就过去了。有欲望，就会被人利用，当然也可以说那是自己想做的，不是利用，但是在做之前有人告诉过后果么，知道了后果，还回去做么？当然，可能也没人能预料到那个后果，还是自己的选择。&lt;/p&gt;

&lt;p&gt;传言鹿兆鹏死了的时候，秋月端着盆子给鹿子霖洗脚，说是代鹿兆鹏做这个事情，那个瞬间就泪崩了。秋月你可以说是死在封建社会下，但是鹿兆鹏也有不可原谅的责任。秋月开始可能真是按照父母之命嫁过去的，但是后面，某次对白里面也说了，那是真心喜欢兆鹏。就像兆海为了白灵终生未娶一样，秋月为了兆鹏也是守了一辈子的寡。鹿兆鹏说是为了他爷爷为了他爸，把人家娶回了家，又让人家守活寡，这个算是一个正确的价值观么？秋月出场之后一辈子，都踏踏实实的照顾兆鹏父母爷爷，为的就是哪天兆鹏可以多看她一眼，就连想要生一个孩子，也是为了说将来给兆鹏父母养老。等了一辈子，最后兆鹏回家说带她走的时候，本以为已经等到头了，结果发现兆鹏的方案还是继续让她守活寡，也就是这一刻，秋月可能才明白，兆鹏这辈子都不可能和她有什么交集了，自己守的这么一辈子，毫无意义，自杀也是她唯一的一个选择了。封建礼数是一半责任，鹿兆鹏本人也有一半责任。&lt;/p&gt;

&lt;p&gt;鹿兆鹏和白嘉轩一样的不真实。&lt;/p&gt;

&lt;p&gt;白灵这个演员确实有点嫩，但是也就是这样，估计才能演好年轻的时候。白灵有句话&#34;我的眼睛睁开了，就不会再闭回去&#34;，一个积极向上的乐观的年轻人，和命运做抗争，看过了各种生死之后，总算要过上安定日子了，死了。可能连自己的孩子都没见上几次。每次看到她，那种跳脱的状态很吸引人，不过也有人不喜欢她。&lt;/p&gt;

&lt;p&gt;看剧的时候，说实话一直担心最后是一个大家都悲惨的结局，虽然知道这是演戏，但是还是希望能有点好的结局。剧里最后也算是一个还可以的结局了，如果把后面的大跃进灾年再写了，真就有点难看了。鹿家活了一个儿子还有孙女，白家活了一个儿子和孙子孙女。&lt;/p&gt;

&lt;p&gt;其他人就不评论了，其实看的时候很多场景都有感触，但是也没记住那么多。看完之后还蛮有冲动再看一次的，但是剧集实在太长了，以后有时间看一下书吧，这个年代拍的电视剧，本身就有太多的忌讳，相信还是原著会更加精彩，而且初步估计，会感觉和电视剧是两个内容，呵呵。当年我高中的时候，拿到一本《平凡的世界》，那会简直就是一刻不停，连续看了几天把书看完了。现在不记得多少内容了，但是那会应该也是被书里描述的农村到城市的历程吸引了吧。现在看白鹿原，里面孩子们最后在县城省城工作，其实和现在的世道没个啥区别。而且其他的，比如这高房价物价，贪官私人关系，可能也可以类比。小老百姓真的可以踏实过日子么？&lt;/p&gt;

&lt;p&gt;踏实过日子，慢慢可能会让人把你玩死。另一个选择就是不甘于现状，当然也不一定求逆天改命，只求能在遇到事情的时候，能给自己多一些路。&lt;/p&gt;

&lt;p&gt;现在年纪大了，确实很多事情慢慢在看透，40 不惑不是都看明白了，是看明白的也就明白了，没看明白的就不看了，所谓看透。这个年纪看这种讲人一生的戏，看到后面那么多的生死，和自己的现实一应证，实在是有点抗不住。人生一辈子，到底是为什么活呢？越来越迷茫了。所以这帖子的英文取名为 Life。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
