<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Home on wd and cc</title>
    <link>https://wdicc.com/</link>
    <description>Recent content in Home on wd and cc</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 22 Jan 2019 18:25:37 +0800</lastBuildDate>
    
        <atom:link href="https://wdicc.com/atom.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Zero to $1B: 8 Lessons Scaling a Startup</title>
      <link>https://wdicc.com/8-lessons-scaling-a-startup/</link>
      <pubDate>Tue, 22 Jan 2019 18:25:37 +0800</pubDate>
      
      <guid>https://wdicc.com/8-lessons-scaling-a-startup/</guid>
      <description>&lt;p&gt;原文是这里 &lt;a href=&#34;https://medium.com/@swaaanson/zero-to-1b-8-lessons-scaling-a-startup-f9a4b631de61&#34; title=&#34;Zero to $1B: 8 Lessons Scaling a Startup&#34;&gt;Zero to $1B: 8 Lessons Scaling a Startup&lt;/a&gt;，这里只是部分翻译 + 我自己的理解。&lt;/p&gt;

&lt;h2 id=&#34;lesson-1-要谦虚的同时-保持自信&#34;&gt;Lesson #1: 要谦虚的同时，保持自信&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;要相信你是最牛逼的，可以搞定一切问题。&lt;/li&gt;
&lt;li&gt;也要够谦虚知道可能有不足，幼稚的地方，要听取别人的意见建议。&lt;/li&gt;
&lt;li&gt;也要谦逊的知道你自己的技能不一定适合公司的各个阶段，还需要不断提升自己的能力。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;lesson-2-可能会需要同时创立不止一个公司-可能是一系列公司&#34;&gt;Lesson #2: 可能会需要同时创立不止一个公司，可能是一系列公司&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;把你自己的领导能力看成是产品，多征求用户（也就是员工）的意见，严肃对待批评，但是不要当作是针对你自己的，对新的战略做做 A/B 测试。&lt;/li&gt;
&lt;li&gt;雇佣一个教练（？）。&lt;/li&gt;
&lt;li&gt;不管规模多大，每 6 个月给团队做一个 360 度的评测。&lt;/li&gt;
&lt;li&gt;[http://paulgraham.com/identity.html][Keep your identity small]] 这个意译似乎是说：不要给自己贴过多的标签，这会让你更陷入很多的无意义的争论。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;lesson-3-你的快乐和你创业公司的成功的关联性可能是-0-64&#34;&gt;Lesson #3: 你的快乐和你创业公司的成功的关联性可能是 0.64&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;经常锻炼身体，保证充足的睡眠，开始做做冥想。&lt;/li&gt;
&lt;li&gt;避免自娱自乐。比如某个月收益不错，就开始用这个推算我们未来三年怎么怎么样，某个月行情不行，就奔溃的不行。别着急想那么远，多看看眼前的事情吧。&lt;/li&gt;
&lt;li&gt;开始募集资金的是，根据市场反馈及早做调整。我们 A 轮的时候，被 42 次拒绝之后，我们进行了重组，更改了我们的要价，然后就找到了一家对我们有信心的投资。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;lesson-4-好的公司胜在产品创新和商业模式创新上&#34;&gt;Lesson #4: 好的公司胜在产品创新和商业模式创新上&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;获取客户的模式是商业模式的竞争。&lt;/li&gt;
&lt;li&gt;早期的创始人需要多花点时间想想商业模式创新和获取客户的策略。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;lesson-5-企业文化是用来帮助你成功的一个自我实现的故事&#34;&gt;Lesson #5: 企业文化是用来帮助你成功的一个自我实现的故事&lt;/h2&gt;

&lt;ol&gt;
如果要设计企业文化，那有几步参考
&lt;li&gt;确定你们这个行业里面成功的公司具备的特征是啥。比如共享单车企业（需要速度）和做医疗的企业（需要严谨）就不一样。&lt;/li&gt;
&lt;li&gt;确定什么样子的企业文化会带来那些特征。&lt;/li&gt;
&lt;li&gt;持续基于那些企业文化招聘和管理你的团队。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;lesson-6-有一个不合理的动机是有帮助的&#34;&gt;Lesson #6: 有一个不合理的动机是有帮助的&lt;/h2&gt;

&lt;p&gt;这里作者讲了一个自己的事情，他当年在选择去斯坦福商学院还是创业的时候，想问问斯坦福那边是不是可以晚几年去，对方说你创业啥时候都可以，斯坦福可就这么一个机会。不过作者后面还是去创业了，现在牛逼的时候说每年都会拿出了那个信看看，激励自己。。。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;有一个不合理的动机有时候不止有帮助，可能还是必须的。&lt;/li&gt;
&lt;li&gt;招聘的时候，也招聘这样有有自我实现需求的（with chips on shoulder)。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;lesson-7-创业成功的一个秘密方法是对厌倦的事情的极高的忍耐力&#34;&gt;Lesson #7: 创业成功的一个秘密方法是对厌倦的事情的极高的忍耐力&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;创业公司最值钱的工作往往是最不性感的那部分（最无聊的）。&lt;/li&gt;
&lt;li&gt;好好处理好它们。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;lesson-8-公司规模扩大也需要你自己能处理更多事情-早一点顾一个-ea-吧&#34;&gt;Lesson #8: 公司规模扩大也需要你自己能处理更多事情（早一点顾一个 EA 吧）&lt;/h2&gt;

&lt;p&gt;不少创业者都对长时间工作很自豪。那挺2的。你应该自豪的是你带来的巨大的杠杆作用（通常也会带来长时间工作）。当我每周工作 100 小时的时候，我并没有感觉的满足，我知道 1 可能是我没有委托足够的事情出去，或者 2 我没有合适的人来给我委托。&lt;/p&gt;

&lt;p&gt;这个说的没错，但是感觉是作者在给自己的一个公司做宣传。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The Year in Sound</title>
      <link>https://wdicc.com/the-year-in-sound/</link>
      <pubDate>Sun, 13 Jan 2019 13:07:44 +0800</pubDate>
      
      <guid>https://wdicc.com/the-year-in-sound/</guid>
      <description>&lt;p&gt;自从发现 &lt;a href=&#34;https://www.nytimes.com/column/the-daily&#34; title=&#34;NYTimes 的 The Daily&#34;&gt;NYTimes 的 The Daily&lt;/a&gt; 之后，听的比较多，2018 年底，他们有一期 &lt;a href=&#34;https://www.nytimes.com/2018/12/24/podcasts/the-daily/2018-year-in-sound.html&#34; title=&#34;The Year in Sound&#34;&gt;The Year in Sound&lt;/a&gt; 对 2018 年的一个总结，听的时候觉得可以总结一下里面的事件。&lt;/p&gt;

&lt;ol&gt;
&lt;li value=&#34;6&#34;&gt;月份 Trump 和三胖在新加坡会面。前后还来回磨叽了几次。三胖同意解除核装置。后面三胖和南韩总统在边界还一起握手。&lt;/li&gt;
&lt;li&gt;Robert Mueller 调查俄罗斯影响 2016 竞选。&lt;/li&gt;
&lt;li&gt;fb 爆出来用户数据被一家公司 Cambridge Analytica 拿去可能影响了竞选，并且似乎 fb 自己知道这个事情。Mark Zuckerberg 被叫去听证会询问。后面 Sundar Pichai 因为给中国定制搜索引擎的事情也被叫去过。&lt;/li&gt;
&lt;li value=&#34;2&#34;&gt;月 14 号 Florida high school 17 人死于&lt;a href=&#34;https://en.wikipedia.org/wiki/Stoneman_Douglas_High_School_shooting&#34; title=&#34;枪击案&#34;&gt;枪击案&lt;/a&gt;。学生对控枪的&lt;a href=&#34;https://edition.cnn.com/2018/02/17/us/florida-student-emma-gonzalez-speech/index.html&#34; title=&#34;抗议&#34;&gt;抗议&lt;/a&gt;。&lt;/li&gt;
&lt;li value=&#34;3&#34;&gt;月 4 号，居住在英国的前 Russian spy 和她女儿被人&lt;a href=&#34;https://www.bbc.com/news/uk-43315636&#34; title=&#34;下毒&#34;&gt;下毒&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;移民政策的变更，分开孩子和大人，起诉大人，导致很多人孩子后面找不到了。后面把这个政策取消了。&lt;/li&gt;
&lt;li&gt;Brett Kavanaugh 接替  Anthony Kennedy 成为大法官。Kavanaugh 还被一个博士爆出来说在高中时期（40年前）被试图性侵，开了听证会。&lt;/li&gt;
&lt;li&gt;Trump 的律师 Micheal Cohen 被 Trump 开掉，以及后面反过来和 Mueller 配合指证 Trump。&lt;/li&gt;
&lt;li&gt;Trump 和普京会面。&lt;/li&gt;
&lt;li&gt;California 大火。&lt;/li&gt;
&lt;li&gt;美国记者 Jamal Khashoggi 在沙特阿拉伯驻土耳其伊斯坦布尔的使馆里面被肢解。Trump 表示相信沙特王子不是他干的。&lt;/li&gt;
&lt;li&gt;中美贸易战。&lt;/li&gt;
&lt;li&gt;中期选举，民主党占了 house(似乎是众议院) 的多数。Nancy Pelosi 当选为 house 发言人。 Trump 年底嚷嚷要建墙要资金，议院不同意，直接把政府 shutdown 了，截至发稿还没谈妥。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;还有一些应该没记录，可能会有遗漏。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Iptv2</title>
      <link>https://wdicc.com/iptv2/</link>
      <pubDate>Thu, 10 Jan 2019 10:20:56 +0800</pubDate>
      
      <guid>https://wdicc.com/iptv2/</guid>
      <description>&lt;p&gt;之前写过&lt;a href=&#34;https://wdicc.com/BJ-Chinaunicom-iptv/&#34; title=&#34;一篇关于 iptv 的帖子&#34;&gt;一篇关于 iptv 的帖子&lt;/a&gt;，里面用到了一个副路由，这样我家里其实就有两个路由器，这样用了比较长一段时间。&lt;/p&gt;

&lt;p&gt;最近联通给换了一个光猫，很容易就可以 hack 进管理界面，就又折腾了一下 iptv 的事情。&lt;/p&gt;

&lt;p&gt;iptv 和上网通道都是通过一根光纤进来的，通过不同的 vlan 区分数据。vlan 是二层的，收到这些数据之后如果有必要，可以通过 vlan id 来过滤出来，比如有的光猫会提供把 iptv 流量过滤到 4 口，其他上网流量过滤到光猫的其他口。我之前的猫就这样设置的，看 iptv 只能连接光猫的 4 口。如果光猫允许设置，那可以把 iptv 流量打上 tag 继续发到比如 1 口，这样 1 口就又有上网流量，又有 iptv 流量了，下一级路由就可以只通过这一条线来收两个流量了。&lt;/p&gt;

&lt;p&gt;iptv 那个通道除了提供了组播数据（这个是具体的视频数据的来源）之外，还提供了一个只提供了必要的服务的互联网，比如提供了频道列表，各频道的节目表等等。&lt;/p&gt;

&lt;p&gt;有的光猫可能会提供 pppoe 拨号功能和 wifi，不过一般没人用，因为性能差。所以一般我们会配置光猫做桥接，把数据透传下来，让下一级来拨号和提供 wifi。&lt;/p&gt;

&lt;p&gt;（下面部分限于我自己的理解很有可能说错，欢迎指正）&lt;/p&gt;

&lt;p&gt;iptv vlan 我看也提供了路由功能，也可以桥接透传。比如我之前的方式就是使用了光猫提供的路由功能，接了一个路由器，以光猫为上级路由器，然后会获取到一个内网的 ip。然后二级路由器上通过 udpxy 提供服务给内网用户用。&lt;/p&gt;

&lt;p&gt;那这样的话，似乎可以直接在我的主路由上找一个网卡和光猫 iptv 口接起来，然后跑一个 dhcp 获取一下 ip 不就可以省掉副路由了么？不过我在 R6300v2 上尝试没成功。在新的软路由里面搞成功了。这里面也不需要跑 igmpproxy，我理解实际用的是上级光猫发过来的数据。&lt;/p&gt;

&lt;p&gt;然后 igmpproxy 是怎么回事呢，我理解比如 iptv 是接到了路由器而不是光猫的时候，那么就需要路由器把光猫的那些数据转发下去，这个时候光猫需要通过桥接方式把数据给过来，然后需要把数据发到下级路由，这个时候还不能直接让这个数据在 lan 里面乱跑，否则会影响我们的网速，通过 igmpproxy 可以把上级光猫给过来的组播数据转发到某个端口，然后下级设备比如你把 iptv 接到这个端口，就可以通过那个端口获取这些 iptv 的组播数据了。这样 iptv 就不用接到光猫了，接到你的路由器就可以了。&lt;/p&gt;

&lt;p&gt;对于 udpxy，有一个 status 页面，里面会显示一些信息，里面有一个 Multicast Address 很重要，必须是上级光猫给的 ip 才行，也就是上面讲的那个 ip，这样才能获取到数据。如果线路配置有问题，那这里的 ip 会显示 169.xx 或者 0.0.xx 啥的，那一般是不行的。&lt;/p&gt;

&lt;p&gt;我目前也没明白一点，我之前在 R6300v2 里面设置的时候，和光猫还是一条线，然后通过 udpxy 就可以看，不知道是怎么做到的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Amap Work With Code Push</title>
      <link>https://wdicc.com/amap-work-with-code-push/</link>
      <pubDate>Sat, 05 Jan 2019 09:53:09 +0800</pubDate>
      
      <guid>https://wdicc.com/amap-work-with-code-push/</guid>
      <description>&lt;p&gt;我们 app 用了高德地图和 codepush，iOS 里面之前用的高德地图 sdk 的 5.x 版本，最近想升级到最新的 6.6.0 发现和 codepush 出现了 symbol 的冲突，主要是两个函数 &lt;code&gt;aes_decrypt_key128&lt;/code&gt; 和 &lt;code&gt;aes_encrypt_key128&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;高德地图是不开源的，万幸我们有 codepush 的源码，所以思路是只需要把 codepush 里面冲突的函数改个名字就好了。&lt;/p&gt;

&lt;p&gt;改代码很简单，主要是怎么和项目集成。我用的是 &lt;a href=&#34;https://github.com/ds300/patch-package#readme&#34; title=&#34;patch-package&#34;&gt;patch-package&lt;/a&gt; ，做法如下。&lt;/p&gt;

&lt;p&gt;给 &lt;code&gt;package.json&lt;/code&gt; 的 scripts 增加一个 &lt;code&gt;postinstall&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt; &amp;quot;scripts&amp;quot;: {
  &amp;quot;postinstall&amp;quot;: &amp;quot;patch-package&amp;quot;
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后就是改 &lt;code&gt;node_modules/react-native-code-push&lt;/code&gt; 下面的文件，改完之后，执行一下 &lt;code&gt;yarn patch-package react-native-code-push&lt;/code&gt; 会生成一个类似 &lt;code&gt;patches/react-native-code-push+5.5.1.patch&lt;/code&gt; 的文件，确认一下这个文件里面是不是包含了你修改的内容。&lt;/p&gt;

&lt;p&gt;这就可以了，以后执行 &lt;code&gt;yarn install&lt;/code&gt; 的时候会自动打这个 patch。&lt;/p&gt;

&lt;p&gt;这个方式比 fork 一份对方的代码好一点，有时候有些代码发到 npm 的是编译之后的版本，fork 之后也不好用，除非你也发布一个。用 patch 的方式会好一点，安装的还是对方发布的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Android Packaging</title>
      <link>https://wdicc.com/android-packaging/</link>
      <pubDate>Sun, 02 Dec 2018 16:52:34 +0800</pubDate>
      
      <guid>https://wdicc.com/android-packaging/</guid>
      <description>&lt;p&gt;国内市场因为 android 的发布渠道比较多，所以一般我们会想要追踪一下用户使用的包是从哪里下载安装的。&lt;/p&gt;

&lt;p&gt;Android 打包支持 buildTypes ，一般这个会用来区分不同的环境，比如 dev，beta，prod 等，不同环境可能会有一些不同的设置，比如 dev 会打开更多的日志输出什么的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    android{
        buildTypes {
            debug {
                ...
            }
            release {
                ...
            }
            beta {
                ...
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有一个支持是 productFlavors，一般用这个来区分不同的渠道，不同渠道也可以有一些不同的设置，类似上面的 buildTypes。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    android {  
        productFlavors {
            xiaomi {}
            baidu {}
            wandoujia {}
            x360 {}
        }

        productFlavors.all {
            flavor -&amp;gt; flavor.manifestPlaceholders = [CHANNEL_ID: name]
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配合 &lt;code&gt;AndroidManifext.xml&lt;/code&gt; 文件的配置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   &amp;lt;meta-data android:name=&amp;quot;CHANNEL_ID&amp;quot; android:value=&amp;quot;${CHANNEL_ID}&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在代码里面取到这个，然后设置渠道。&lt;/p&gt;

&lt;p&gt;这样就可以打渠道包了 &lt;code&gt;./gradlew assembleWandoujiaRelease&lt;/code&gt; 编译 &lt;code&gt;wandoujia&lt;/code&gt; 这个渠道的 &lt;code&gt;releases&lt;/code&gt; 包。这个方式有一个问题是，每一个渠道包都需要从头编译一次，一个渠道 10 分钟，那所有渠道下来，就可能需要一个小时了，关键是很多无用功。&lt;/p&gt;

&lt;p&gt;受不了这个，然后发现了美团的思路。有一个民间的方案 https://github.com/GavinCT/AndroidMultiChannelBuildTool 。&lt;/p&gt;

&lt;p&gt;这个方案的主要思路是 apk 只编译一次，编译好之后，通过在 apk 里面增加不同名字的文件的方式来区分不同的渠道。app 运行的时候，读这个文件名字，然后设置对应的渠道。&lt;/p&gt;

&lt;p&gt;对于 v1 签名的 apk，在 META-INF 下面增加空文件不需要重新签名，所以只需要再次 zip 压缩就可以。&lt;/p&gt;

&lt;p&gt;对于 v2 签名的 apk，需要重新签名，可以使用 &lt;code&gt;apksigner&lt;/code&gt; 这个程序，这个是 android sdk 带的。我的 mac 系统路径是 &lt;code&gt;~/Library/Android/sdk/build-tools/*/apksigner&lt;/code&gt; ，因为会安装多个 build-tools 版本，所以会有多个，用哪个都可以。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    cmd = [apksigner, &amp;quot;sign&amp;quot;, &amp;quot;--ks&amp;quot;, &amp;quot;your_key_store_path&amp;quot;, &amp;quot;--ks-pass&amp;quot;, &amp;quot;pass:your_pass&amp;quot;, &amp;quot;--ks-key-alias&amp;quot;, &amp;quot;your_alias&amp;quot;, apk]
    check_call(cmd)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就可以了。&lt;/p&gt;

&lt;p&gt;我看美团似乎弄了一个新的版本 https://github.com/Meituan-Dianping/walle 看着挺复杂的，没研究过。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>A* Search Algorithm</title>
      <link>https://wdicc.com/a-star-search-algorithm/</link>
      <pubDate>Sat, 24 Nov 2018 14:48:04 +0800</pubDate>
      
      <guid>https://wdicc.com/a-star-search-algorithm/</guid>
      <description>&lt;p&gt;前段时间我们设想了一个需求，想帮助用户规划一下从 A -&gt; B 的航线。对于路径规划从来没弄过，研究了一下，基本都在提这个 &lt;a href=&#34;https://en.wikipedia.org/wiki/A*_search_algorithm&#34; title=&#34;A 星寻路算法&#34;&gt;A 星寻路算法&lt;/a&gt;。&lt;/p&gt;

&lt;ol&gt;
先贴几个文章：
&lt;li&gt;简单的讲解的文章例如 https://www.jianshu.com/p/65282bd32391&lt;/li&gt;
&lt;li&gt;这个详细一点的 https://blog.csdn.net/DinnerHowe/article/details/79380317&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我写了一个简单的程序，这个程序没有做过任何的优化，只能说是解释了这个算法的逻辑而已，在终端里面可以可视化的把计算过程显示出来。效果可以看&lt;a href=&#34;https://gist.github.com/wd/69469977bf76d9091ca01714eae08f37&#34; title=&#34;这里&#34;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/python
import sys
import random


RED = &#39;\033[31m&#39;
GREEN = &#39;\033[32m&#39;
GRAY = &#39;\033[35m&#39;
NC = &#39;\033[0m&#39;

class Point(object):
    x = 0
    y = 0
    close = False
    open = False
    start = False
    end = False
    wall = False
    H = 99
    G = 99
    parent = None

    def __init__(self, **kwargs):
        if &#39;x&#39; in kwargs:
            self.x = kwargs[&#39;x&#39;]

        if &#39;y&#39; in kwargs:
            self.y = kwargs[&#39;y&#39;]

        self.key = &#39;{}-{}&#39;.format(self.x, self.y)

    def __str__(self):
        return &#39;{},H{:2},G{:2},F{:2},P{:3}&#39;.format(
                self.key,
                self.H if self.H != 99 else &#39;&#39;,
                self.G if self.G != 99 else &#39;&#39;,
                self.G + self.H if self.G != 99 else &#39;&#39;,
                self.parent.key if self.parent else &#39;&#39;)

    def  __lt__(self, other):
        return self.x &amp;lt; other.x if self.y == other.y else self.y &amp;lt; other.y


def get_area(width, height):
    area = {}
    for i in range(width):
        for j in range(height):
            point = Point(x=i, y=j)

            area[point.key] = point
    return area

def show_result(area_hash):
    prev_y = -1

    for point in sorted(area_hash.values()):
        if ( prev_y != point.y ):
            if (prev_y != -1):
                print(&#39;&#39;)
            prev_y = point.y

        if point.start:
            format = RED + &#39;S&#39; + NC
        elif point.end:
            format = RED + &#39;E&#39; + NC
        elif point.wall:
            format = GRAY + &#39;W&#39; + NC
        elif point.close:
            format = GREEN + &#39;0&#39; + NC
        else:
            format = &#39; &#39;
        print((format + &#39;({})  &#39;).format(point), end=&#39;&#39;)
    print(&#39;&#39;)

def set_preset(area, start, end, wall):
    area[start].start = True
    area[end].end = True
    for key in wall:
        area[key].wall = True
    return area

def is_valid_point(point, width, height):
    if point.wall or point.close:
        return False

    if point.x &amp;lt; 0 or point.x &amp;gt; width:
        return False

    if point.y &amp;lt; 0 or point.y &amp;gt; height:
        return False

    return True

def get_around(area, point, width, height):
    n = &#39;{}-{}&#39;.format(point.x, point.y - 1)
    s = &#39;{}-{}&#39;.format(point.x, point.y + 1)
    l = &#39;{}-{}&#39;.format(point.x - 1, point.y)
    r = &#39;{}-{}&#39;.format(point.x + 1, point.y)

    res = {}
    for key in [n, s, l, r]:
        if key in area and is_valid_point(area[key], width, height):
            area[key].parent = point
            area[key].G = area[key].G if area[key].G != 99 else (point.G if point.G != 99 else 0) + 1
            res[key] = area[key]

    return res

def get_H(point, end_point):
    return abs(point.x - end_point.x) + abs(point.y - end_point.y)

step = 0
opened = {}

def go(area, start, end, width, height):
    global step, opened
    start_point = area[start]
    end_point= area[end]
    start_point.close = True

    if start_point.key in opened:
        del opened[start_point.key]

    points = get_around(area, start_point, width, height)
    opened.update(points)

    rnd = random.choice(list(opened))
    next_point = area[rnd]
    for key, point in opened.items():
        point.H = get_H(point, end_point)

        if point.H + point.G &amp;lt;= next_point.H + next_point.G:
            next_point = point

    print(&#39;step {}: {}&#39;.format(step, next_point))
    step += 1
    if step &amp;gt;= 3:
        pass

    if next_point and next_point.key != end:
        go(area, next_point.key, end, width, height)

def get_result(area, start, end):
    print(&#39;{}{}{} &amp;lt;- &#39;.format(RED, area[end].key, NC), end=&#39;&#39;)
    parent = area[end].parent
    if(parent.key != start):
        get_result(area, start, parent.key)
    else:
        print(&#39;{}{}{}&#39;.format(RED, area[start].key, NC), end=&#39;&#39;)

def main():
    width = 10
    height = 10
    start = &#39;1-3&#39;
    end = &#39;8-4&#39;
    wall = [&#39;2-2&#39;, &#39;3-2&#39;, &#39;3-3&#39;, &#39;3-4&#39;, &#39;3-5&#39;, &#39;3-6&#39;, &#39;5-4&#39;, &#39;2-6&#39;, &#39;1-6&#39;]

    area = get_area(width, height)
    area = set_preset(area, start, end, wall)
    go(area, start, end, width,  height)
    show_result(area)
    get_result(area, start, end)

if __name__ == &#39;__main__&#39;:
    main()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个算法通过调整 G 和 H 的计算逻辑，可以平衡寻路速度和路径是否最短。另外，对于 open 列表的维护，也可以使用一些适合自己的数据结构来得到比较快速的查找。上面第二个帖子里面比较详细的列了一些改进算法的思路。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Phpbb Auth Plugin</title>
      <link>https://wdicc.com/phpbb-auth-plugin/</link>
      <pubDate>Sat, 17 Nov 2018 21:15:50 +0800</pubDate>
      
      <guid>https://wdicc.com/phpbb-auth-plugin/</guid>
      <description>&lt;p&gt;这几天我们这里需要搞一个论坛，我搜了一些，选了 phpbb，这个毕竟年头比较久远，也支持 PostgreSQL。&lt;/p&gt;

&lt;p&gt;我们自己本身有自己的会员逻辑，所以就需要把他的登陆和我们自己的结合，而 phpbb 也支持自己作 &lt;a href=&#34;https://wiki.phpbb.com/Authentication_plugins&#34; title=&#34;Auth Plugin&#34;&gt;Auth Plugin&lt;/a&gt;。&lt;/p&gt;

&lt;ol&gt;
涉及到的文件有几个
&lt;li&gt;includes/auth/auth_foo.php：这个是具体的 auth 逻辑代码的地方。&lt;/li&gt;
&lt;li&gt;config/default/container/services_auth.yml：这个是注册这个 auth 逻辑的地方。&lt;/li&gt;
&lt;li&gt;template 模板文件：这个我没涉及到，所以没去了解。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;service 文件的配置：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;    auth.provider.skyreq:
        class: phpbb\auth\provider\foo
        arguments:
            - &#39;@dbal.conn&#39;
            - &#39;@config&#39;
            - &#39;@passwords.manager&#39;
            - &#39;@request&#39;
            - &#39;@user&#39;
            - &#39;@service_container&#39;
            - &#39;%core.root_path%&#39;
            - &#39;%core.php_ext%&#39;
        tags:
            - { name: auth.provider }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面配置里面 arguments 指定的，是 auth_foo.php 的 constructor 接受的参数。可以需要什么配置什么，个数要对应。&lt;/p&gt;

&lt;p&gt;配置这个之后，只需要在 &lt;code&gt;auth_foo.php&lt;/code&gt; 里面实现具体的逻辑就可以了。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;init_method&lt;/code&gt; 这个方法是在后台用户选中这个 auth 方法的时候执行的，比如你如果有一些配置的话就可以在这里验证。如果需要用户录入配置的话，还需要配合 template 文件，好提供录入的界面。我这里没有这个需求。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;login_method&lt;/code&gt; 这个方法是在用户登陆的时候会调用。会传入用户名和密码两个参数。实现逻辑可以参考 auth_db 这个模块。phpbb 为了安全，对于管理员用户会有一个二次验证的过程，管理员的 session 过期时间也会短一些。所以我们必须要实现这个，否则一个管理员就无法访问后台了。我这里是完全复制的 auth_db 的逻辑，里面改动了一点增加了一个硬编码只允许几个我指定的用户登陆。然后验证也完全用的 phpbb 的密码逻辑。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;autologin_method&lt;/code&gt; 这个方法是在用户 session 创建的时候通过外部逻辑实现验证的时候调用。自己实现认证主要是在这里实现。我的需求是通过 cookie 验证，如果用户不存在，会直接新建一个用户，如果已经存在，会直接用那个用户登陆。这样一个用户在我的系统的其它页面登陆之后，访问 phpbb 就会自动登陆了。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;logout_method&lt;/code&gt; 登出的逻辑。我这没有需求，不希望用户从论坛登出。所以留空就可以了。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;validate_session_method&lt;/code&gt; session 验证逻辑，这个是验证一个用户的 session 是否有效。如果无效会触发自动登陆。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Fear, trust and JavaScript: When types and functional programming fail</title>
      <link>https://wdicc.com/fear-trust-and-javascript/</link>
      <pubDate>Thu, 01 Nov 2018 12:56:20 +0800</pubDate>
      
      <guid>https://wdicc.com/fear-trust-and-javascript/</guid>
      <description>&lt;p&gt;翻译自 &lt;a href=&#34;https://www.reaktor.com/blog/fear-trust-and-javascript/&#34; title=&#34;Fear, trust and JavaScript: When types and functional programming fail&#34;&gt;Fear, trust and JavaScript: When types and functional programming fail&lt;/a&gt; , 最早是 &lt;a href=&#34;https://news.ycombinator.com/item?id=18314628&#34; title=&#34;hacker news&#34;&gt;hacker news&lt;/a&gt; 看到的。&lt;/p&gt;

&lt;p&gt;只是翻译大意。&lt;/p&gt;

&lt;p&gt;作为开发人员，我们需要减少对代码执行失败的恐惧，增强对代码的信心。很多 javascript 开发人员从函数式编程语言和强类型语言里面借鉴思路来将信任交给工具和代码来减少恐惧。类似可选类型，函数转换，和只读化这些思想可以帮助写出更好的 javascript 代码。当把这些想法都加入到 javascript 里面，会有一些妥协，协作起来比较差，并且最终会导致将信任从开发人员交给代码和工具的想法失败。&lt;/p&gt;

&lt;p&gt;举例来看看 javascript 里面是如何在两种观点下面处理数据的：理解数据的结构和修改数据。&lt;/p&gt;

&lt;h1 id=&#34;fear-and-the-shape-of-data&#34;&gt;Fear and the shape of data&lt;/h1&gt;

&lt;p&gt;在类似 javascript 的动态语言里面，很难知道你数据的结构。默认的方式是依赖公约(convention)。相信其它程序员和其它系统按照协议给你正确的数据。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;fetchUser(id).then( user =&amp;gt; {
 // Got my user!
})

// Later
render(user.name) // He has a name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我一般管这种方式叫「假装这是你要的」。在高可信的环境下，这个会工作的挺好。&lt;/p&gt;

&lt;p&gt;但是恐惧会悄悄的到来。代码的复杂度会增加。代码会是不同开发人员基于不同的公约(convention)开发的。你收到的数据来自于不可控的上游以及不稳定的格式。会开始看到空指针错误。对代码的信任会崩塌，对数据格式的疑问会引起焦虑而不是信任。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;这个数据里面到底有什么值？&lt;/li&gt;
&lt;li&gt;我可以删除里面的数据而不产生影响吗？&lt;/li&gt;
&lt;li&gt;我可以把这个数据传入这个函数吗？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例如下面这个。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;fetchUser(id).then( user =&amp;gt; {
 // Got my user!
 if(!user || !user.name) {
   throw new Error(&#39;wat&#39;)
 }
})

// Later
if(user &amp;amp;&amp;amp; user.name) {
  render(user.name)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是防御性编程(defensive programming)。在你不再信任你的代码会在适当的时候提供你期望的数据的时候会这么写。漂亮的代码会因为这些检查变得乱七八糟的，失去可读性，代码变得脆弱和很难改变。恐惧会增加，会越来越难相信代码会工作的很好。&lt;/p&gt;

&lt;h2 id=&#34;optional-types-pretend-really-hard&#34;&gt;Optional types: Pretend really hard&lt;/h2&gt;

&lt;p&gt;有一种消除恐惧的方法是通过 &lt;a href=&#34;https://www.typescriptlang.org/&#34; title=&#34;TypeScript&#34;&gt;TypeScript&lt;/a&gt; 或者 &lt;a href=&#34;https://flow.org/&#34; title=&#34;Flow&#34;&gt;Flow&lt;/a&gt; 引入可选的类型检查。接收到一个 user 之后，声明这是 User 类型，这以后只当作 User 类型用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;interface User{
  id: number
  name: string
  email?: string
}

fetchUser(id).then((user: User) =&amp;gt; {
 // Got my User!
})

// Later
render(user.name) // Compiler says he has a name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样假装其实挺难的。你把你的信任转移到其它地方了。你依然相信其它系统会给你正确的数据结构。在代码里面，你信任你给那个数据赋予的类型，在你使用不当的时候，编译器会报错。代替相信开发人员知道数据的结构并且正确的使用它，你信任开发人员会写出正确的类型，信任编译器不会对这些类型撒谎。&lt;/p&gt;

&lt;p&gt;增加类型设定并没有解决潜在的问题，它会提升数据在代码里面的一致性，但是对于外来数据没有任何限制。&lt;/p&gt;

&lt;h2 id=&#34;validation-trust-but-validate&#34;&gt;Validation: Trust but validate&lt;/h2&gt;

&lt;p&gt;在一个互相不太信任的环境里面，你或者需要在各种地方做数据校验。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;fetchUser(id).then(user =&amp;gt;{
  const validationErrors = validate(user)
  if (validationErrors) {
    throw new Error(&#39;wat&#39;)
  }
 // got my User!
})

// Later
render(user.name) //He has a name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以手动做这些，不过这些验证可能是临时的（应该是说不太通用），费力的，并且容易出错的。或者，你可以使用 &lt;a href=&#34;http://json-schema.org/&#34; title=&#34;JSON schema&#34;&gt;JSON schema&lt;/a&gt; 定义和 &lt;a href=&#34;https://github.com/epoberezkin/ajv&#34; title=&#34;ajv&#34;&gt;ajv&lt;/a&gt; 或者其它工具来验证数据是不是符合 schema 定义。这么做可以让其它用户复用，例如生成文档，但是这个似乎不那么明确也容易出错，因为你需要手动写这样的定义。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
  &amp;quot;title&amp;quot;: &amp;quot;user&amp;quot;,
  &amp;quot;type&amp;quot;: &amp;quot;object&amp;quot;,
  &amp;quot;properties&amp;quot;: {
    &amp;quot;id&amp;quot;: {
      &amp;quot;type&amp;quot;: &amp;quot;integer&amp;quot;
    },
    &amp;quot;name&amp;quot;: {
      &amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;
    },
    &amp;quot;age&amp;quot;: {
      &amp;quot;type&amp;quot;: &amp;quot;integer&amp;quot;
    }
  },
  &amp;quot;required&amp;quot;: [&amp;quot;id&amp;quot;, &amp;quot;name&amp;quot;]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;optional-types-validation&#34;&gt;Optional types + validation&lt;/h2&gt;

&lt;p&gt;或者你也可以同时使用类型检查和数据验证。类型检查减少内部对数据的恐惧，数据校验建立对外来数据的信任。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;interface User{
  id: number
  name: string
  email?: string
}

fetchUser(id).then((user: User) =&amp;gt;{
  const validationErrors = validate(user)
  if (validationErrors) {
    throw new Error(&#39;wat I trusted you&#39;)
  }
 // got my User!
})

// Later
render(user.name) //He has a name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了避免同时写两套类型定义给数据验证和类型检查，你可以使用 Typescript 和 Flow 或者使用类似 &lt;a href=&#34;https://github.com/pelotom/runtypes&#34; title=&#34;runtypes&#34;&gt;runtypes&lt;/a&gt;(TS), &lt;a href=&#34;https://github.com/seanhess/runtime-types&#34; title=&#34;runtime-types&#34;&gt;runtime-types&lt;/a&gt;(Flow) 或者 &lt;a href=&#34;https://github.com/YousefED/typescript-json-schema&#34; title=&#34;typescript-json-schema&#34;&gt;typescript-json-schema&lt;/a&gt;(TS) 这样的库。经过这几步之后，你可能开始信任你的数据了。但是这里还有更深的问题，等一会会说。&lt;/p&gt;

&lt;h1 id=&#34;fear-and-changing-data&#34;&gt;Fear and changing data&lt;/h1&gt;

&lt;p&gt;那么当改变数据的时候呢？默认情况下，javascript 里面的数据可以随意改变。举个例子，这个函数接收一个文档，然后改变了一个字段的格式，增加了一个字段。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function formatDocument(doc, source) {
  if(doc.creationDate) {
    doc.creationDate = convertTimeToUtc(doc.creationDate)
  } else {
    doc.creationDate = null
  }
  doc.source = source
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是在这种风格下，数据流就很难掌控了，恐惧会开始出现。如果我们的数据在很多地方都用了呢？数据在我这里是什么值？如何才能相信数据在此时此刻是我期望的？这个例子比较无聊，但是问题在大量代码或者同步系统里面会变得更严重。&lt;/p&gt;

&lt;p&gt;你想要依赖类型检查，但是这些类型定义也救不了你。在 typescript 和 flow 里面，下面的函数有相同的类型定义。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function formatDocument(doc: Document, source: String) {
  if(doc.creationDate) {
    doc.creationDate = convertTimeToUtc(doc.creationDate)
  } else {
    doc.creationDate = null
  }
  doc.source = source
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function formatDocument(doc: Document, source: String) {
  if(doc.creationDate) {
    doc.creationDate = convertTimeToUtc(doc.creationDate)
  } else {
    doc.creationDate = null
  }
  doc.source = source
  child_process.exec(&amp;quot;sudo rm -rf /&amp;quot;)
  launchRocket()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中一个是你想要的，另一个会把城市炸飞。类型检查对这些无能为力。&lt;/p&gt;

&lt;h2 id=&#34;convention-pretend-immutability&#34;&gt;Convention: Pretend immutability&lt;/h2&gt;

&lt;p&gt;为了写更好的代码，你们团队决定使用只读风格来写代码。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function formatDocument(doc: Document, source: String) {
  return {
    creationDate: sanitizeDate(doc.creationDate),
    source: source,
    text: doc.text
  }
  // Not mutating data
  // Not deleting root dir
  // Not launching rocket
}

function sanitizeDate(date) {
  return date ? convertTimeToUtc(date) : null
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你赞同使用 const 而不是 var，使用复制修改而不是直接修改。使用赋值来表示修改。开始使用三目运算符(ternary operator) 来代替 if 语句。函数返回新的值而不是修改。使用 map，filter，reduce 以及其它函数式的方法产生新的数据，而不是直接修改。&lt;/p&gt;

&lt;p&gt;不可改变的数据约定在 javascript 世界里面会带来便利，在 javascript 生态里面工作的挺好。但是这个严重依赖于开发人员的自律和互相信任。你相信开发人员会按照协议例如避免直接修改数据或者在数据发生改变的时候明确的指出来。你可能需要更健壮一点的东西。&lt;/p&gt;

&lt;h2 id=&#34;libraries-pretend-really-hard&#34;&gt;Libraries: Pretend really hard&lt;/h2&gt;

&lt;p&gt;你可以通过使用数据转换和只读数据结构的辅助工具来把对开发人员的信任转移到工具上。可选的有例如 &lt;a href=&#34;http://ramdajs.com/&#34; title=&#34;Ramda&#34;&gt;Ramda&lt;/a&gt;，&lt;a href=&#34;https://github.com/calmm-js/partial.lenses&#34; title=&#34;partial.lenses&#34;&gt;partial.lenses&lt;/a&gt;，&lt;a href=&#34;https://github.com/gcanti/monocle-ts&#34; title=&#34;monocle-ts&#34;&gt;monocle-ts&lt;/a&gt; 以及其它的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import * as R from &#39;ramda&#39;
function formatDocument(doc, source) {
  const creationDate = sanitizeDate(creationDate)
  // Return a new copy of the data
  return R.merge(doc, {creationDate, source})
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些工具的一个基本原则是把这些数据当作不可变的。但是 &lt;a href=&#34;http://ramdajs.com/0.14/docs/#assoc&#34; title=&#34;Ramda 也只是浅拷贝&#34;&gt;Ramda 也只是浅拷贝&lt;/a&gt;，不过如果对于不可变数据的约定足够，那大家还是可以假装它是。你可能会得到一点性能影响，但是你会得到对代码的信任。如果我们普遍使用这类工具以及这样的约定，会让这个工作的很好。&lt;/p&gt;

&lt;p&gt;强制使用只读数据结构又想避免性能影响，可以试试看 &lt;a href=&#34;https://github.com/facebook/immutable-js&#34; title=&#34;Immutable.js&#34;&gt;Immutable.js&lt;/a&gt;， &lt;a href=&#34;https://github.com/rtfeldman/seamless-immutable&#34; title=&#34;seamless-immutable&#34;&gt;seamless-immutable&lt;/a&gt; 或者 &lt;a href=&#34;http://swannodette.github.io/mori/&#34; title=&#34;Mori&#34;&gt;Mori&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import * as I from &#39;Immutablejs&#39;
function formatDocument(doc, source) {
  const creationDate = sanitizeDate(creationDate)
  // Cant&#39;t mutate doc
  return doc.merge({creationDate, source})
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这么做使得数据本身是不可变的，只能通过暴露出来的只读途径去使用数据。但是只会应用到这些数据内部的数据结构。大量的其它 javascript 代码依赖于 javascript 的原生数据结构，你得在这些数据类型间来回转换，对于原生的数据类型不再信任了。&lt;/p&gt;

&lt;p&gt;这些方法都有自己的局限性，但是大部分都和类型检查冲突。&lt;/p&gt;

&lt;h1 id=&#34;trusting-javascript&#34;&gt;Trusting JavaScript&lt;/h1&gt;

&lt;p&gt;前面的例子引入了一些可以写出更高效的 javascript 代码的工具：类型检查，函数式转换，不可变数据结构。但是这些工具都有自己的局限性，很难一起配合。&lt;/p&gt;

&lt;h2 id=&#34;optional-types-give-a-false-sense-of-security&#34;&gt;Optional types give a false sense of security&lt;/h2&gt;

&lt;p&gt;对于 javascript 来说，类型检查设计之初就是可选的，并不是所有东西都被定义了类型，你也没法相信所有东西都有类型。Flow 不可靠，而 &lt;a href=&#34;https://www.typescriptlang.org/docs/handbook/type-compatibility.html&#34; title=&#34;typescript 故意不可靠&#34;&gt;typescript 故意不可靠&lt;/a&gt;，这意味着有些情况下类型是错误的但是编译器会忽略。&lt;/p&gt;

&lt;p&gt;并且 javascript 的类型检查有时候会撒谎。javascript 有些东西很难或者说不可能通过 typescript 或者 flow 定义类型。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Higher order functions&lt;/li&gt;
&lt;li&gt;Ramda 的 &lt;a href=&#34;http://ramdajs.com/0.14/docs/#call&#34; title=&#34;call&#34;&gt;call&lt;/a&gt;, &lt;a href=&#34;http://ramdajs.com/0.14/docs/#compose&#34; title=&#34;compose&#34;&gt;compose&lt;/a&gt;, &lt;a href=&#34;http://ramdajs.com/0.14/docs/#chain&#34; title=&#34;chain&#34;&gt;chain&lt;/a&gt;, &lt;a href=&#34;http://ramdajs.com/0.14/docs/#lift&#34; title=&#34;lift&#34;&gt;lift&lt;/a&gt;, and &lt;a href=&#34;http://ramdajs.com/0.14/docs/#lens&#34; title=&#34;lenses&#34;&gt;lenses&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;partial.lenses 的 &lt;a href=&#34;https://github.com/calmm-js/partial.lenses/issues/55&#34; title=&#34;functions&#34;&gt;functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Dynamic functions&lt;/li&gt;
&lt;li&gt;Ramda 的 &lt;a href=&#34;http://ramdajs.com/0.14/docs/#invert&#34; title=&#34;invert&#34;&gt;invert&lt;/a&gt;, &lt;a href=&#34;http://ramdajs.com/0.14/docs/#dissoc&#34; title=&#34;dissoc&#34;&gt;dissoc&lt;/a&gt;, &lt;a href=&#34;http://ramdajs.com/0.14/docs/#mergeWith&#34; title=&#34;mergeWith&#34;&gt;mergeWith&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Immutable.js 的&lt;a href=&#34;https://github.com/facebook/immutable-js/blob/master/type-definitions/Immutable.d.ts&#34; title=&#34;几乎所有内容&#34;&gt;几乎所有内容&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Monkey-patched anything&lt;/li&gt;
&lt;li&gt;AWS SDK 客户端 &lt;a href=&#34;https://docs.aws.amazon.com/sdk-for-javascript/v2/developer-guide/using-promises.html#w2ab1c17c15c14c17&#34; title=&#34;promises&#34;&gt;promises&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Bluebird &lt;a href=&#34;http://bluebirdjs.com/docs/api/promisification.html&#34; title=&#34;promisified APIs&#34;&gt;promisified APIs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Highly dynamic data structures&lt;/li&gt;
&lt;li&gt;ElasticSearch &lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-get&#34; title=&#34;schemas&#34;&gt;schemas&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;winston &lt;a href=&#34;https://github.com/winstonjs/winston#creating-your-own-logger&#34; title=&#34;custom loggers&#34;&gt;custom loggers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;想要把这些的类型都痛够 typescript 或者 flow 定义出来，得牺牲下面的原则：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;牺牲类型安全，也就使用类型检查的主要原因：使用 any 来定义他们，不对他们进行类型检查。&lt;/li&gt;
&lt;li&gt;牺牲便利性：让这些方法不那么通用，以便可以定义更加准确的类型。&lt;/li&gt;
&lt;li&gt;牺牲其它开发人员的时间：让使用这些函数的人提供正确的类型，例如 &lt;code&gt;Ramda.pipe&amp;lt;User, Array&amp;lt;string&amp;gt;, string, int&amp;gt;(..)&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这样你开始混合使用这些工具，把他们的类型定义混合进来。这样把信任从工具的开发人员转移到了开发人员的类型定义上。这些库部分会包含 any 类型，调用这些方法会悄悄的失去对类型的检查。使用 Flow 的时候，如果一个文件没有 &lt;code&gt;@flow&lt;/code&gt; 注解，会默默的关闭类型检查。&lt;/p&gt;

&lt;p&gt;你可以通过广泛的使用类型检查来避免这个问题，不允许使用 any 类型，设置检查工具对没有做类型检查的文件报错，以及其它的一些严格的设置。&lt;/p&gt;

&lt;p&gt;但是这很像是在堵住一艘正在漏水的船的洞一样。问题不仅在于你不相信系统里面的类型，而是你认为可以。你依赖类型检查来告诉你修改有问题，但是因为有时候会使用 any 类型，或者使用某个库，或者某些问题导致类型检查被禁用，而并不会告诉你。JavaScript 里面的类型和其它语言里面的类型不一样：他们不能以相同的方式被信任。&lt;/p&gt;

&lt;p&gt;最终，类型检查的有效性依赖于使用的团队的知识和信念。如果团队有比较高的信念和知识，他们就可以给更高的信任到类型检查上。但这取决于团队维持这个信任的的注意力和纪律性，恐惧会从许多微妙的途径蔓延开。&lt;/p&gt;

&lt;h2 id=&#34;functional-programming-types-javascript-pick-two&#34;&gt;Functional programming. Types. JavaScript. Pick two&lt;/h2&gt;

&lt;p&gt;类型检查和基础的函数式编程方法例如 maps，filters，reducers 等可以在 javascript 里面用的还可以。但是当你想要更深入一点的时候就会遇到问题。两个例子：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/facebook/immutable-js&#34; title=&#34;Immutable.js&#34;&gt;Immutable.js&lt;/a&gt; 是一个给 javascript 用的持久的，只读数据结构类型。提供了常用的 javascript 数据结构，不依赖于就地修改数据。包括了内置的用于 &lt;a href=&#34;https://github.com/facebook/immutable-js/blob/master/type-definitions/Immutable.d.ts&#34; title=&#34;typescript&#34;&gt;typescript&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/facebook/immutable-js/blob/master/type-definitions/immutable.js.flow&#34; title=&#34;flow&#34;&gt;flow&lt;/a&gt; 的类型定义（可以点过去看看）。里面有数不清的 any 类型，禁用了对这些值的类型检查。这样依赖用户通过其它类型检查提供正确的类型的数据。基本上，你每次用这个库时，要么选择不使用类型检查，要不就需要额外的工作保证类型是正确的。这阻碍了函数式编程的使用。&lt;/p&gt;

&lt;p&gt;Ramda 是另一个给 jvascript 使用的函数式编程工具。一些类型定义可以在&lt;a href=&#34;https://github.com/types/npm-ramda#status&#34; title=&#34;这里&#34;&gt;这里&lt;/a&gt;找到，以及这个评论：&lt;/p&gt;

&lt;p&gt;“注意：很多 Ramda 里面的函数还不是很好定义类型，问题主要集中在偏函数应用(Partial Application)，柯里化(curring) 和 代码组合(composition) 上，尤其在表达通用类型上。是的，这些可能是你最初使用 Ramda 的原因，这些问题导致 Ramda 很难给 typescript 写类型定义。一些关于 TS 的链接在下面可以找到”&lt;/p&gt;

&lt;p&gt;尽管有像 &lt;a href=&#34;https://github.com/gcanti&#34; title=&#34;Giulio Canti&#34;&gt;Giulio Canti&lt;/a&gt; 这样令人印象深刻的工作，每次你选择高级一点的函数式编程概念的时候，例如不可变数据结构，函数组合，科里化，你基本上需要选择抛弃类型检查或者更多的代码来保证类型检查工作正常。这回阻碍函数式编程。&lt;/p&gt;

&lt;h2 id=&#34;why-we-can-t-have-nice-things-in-javascript&#34;&gt;Why we can’t have nice things in JavaScript&lt;/h2&gt;

&lt;p&gt;不可变数据结构在广泛被使用的时候工作的会挺好。但是 javascript 生态设计是基于可变数据结构的，&lt;a href=&#34;http://tagide.com/blog/research/constraints&#34; title=&#34;你不可能通过一个工具库来强制不可变&#34;&gt;你不可能通过一个工具库来强制不可变&lt;/a&gt;，javascript 的类型检查也不足以处理作为库工具使用的不可变数据结构。&lt;/p&gt;

&lt;p&gt;类型检查在被广泛使用的时候工作的挺好。但是 javascript 里面的类型检查在设计时就是可选的，为了兼容 javascript 做的一些妥协。&lt;/p&gt;

&lt;p&gt;类型检查，不可变数据结构，以及函数式编程都互相支持，就像他们在其它语言里面一样。类型检查可以用来加强不可变数据，即使内部的数据结构是可变的或者类型在运行时不存在。类型检查可以帮助开发人员可以在使用函数组合或者使用 lenses 转换数据的时候能更好对接。能知道支持类型的时候函数转换会更加简单一点。知道数据是不可变的时候，函数转换会更加有效。&lt;/p&gt;

&lt;h1 id=&#34;learning-to-code-with-fear&#34;&gt;Learning to code with fear&lt;/h1&gt;

&lt;p&gt;怎么伴随着恐惧编程？写更好的 javascript。一开始就假设对代码不信任，学习更多的技巧来编写功能化的 javascript 来避免琐碎的部分。有必要的话引入类型检查。使用不可变数据，不过只在有需要的时候或者想要强制约定的时候使用。只在有意义的时候使用类型检查，在功能性数据处理或者不可变类型可以提供更多好处的时候抛弃他们。当不使用类型检查的时候，多使用组合函数或者 lenses(透镜？) 。&lt;/p&gt;

&lt;p&gt;或者改变游戏使用 &lt;a href=&#34;http://www.purescript.org/&#34; title=&#34;Purescript&#34;&gt;Purescript&lt;/a&gt;。或者 &lt;a href=&#34;https://bucklescript.github.io/&#34; title=&#34;ReasonML&#34;&gt;ReasonML&lt;/a&gt;, &lt;a href=&#34;http://elm-lang.org/&#34; title=&#34;Elm&#34;&gt;Elm&lt;/a&gt;, 甚至 &lt;a href=&#34;https://clojurescript.org/&#34; title=&#34;ClojureScript&#34;&gt;ClojureScript&lt;/a&gt;。这些现在就可用。如果有需要，这些可以在 javascript 生态系统使用。这些从代码层面提供更高的信任，提供可以互相配合且工作的很好的不可变数据结构，函数式编程，以及类型系统。&lt;/p&gt;

&lt;p&gt;使用其中的任何一个语言都不能解决你的所有问题。这会引入他们自己的一下问题。但是可能会给你更高层面的对代码的信任，以及增加或者减少信任更好的工具。&lt;a href=&#34;https://www.reaktor.com/blog/fear-trust-and-purescript&#34; title=&#34;我的下一篇文章，会探讨下如何在 purescript 里面把这些思想结合起来。&#34;&gt;我的下一篇文章，会探讨下如何在 purescript 里面把这些思想结合起来。&lt;/a&gt;（这个是这个哥们的另一篇文章，标题叫 Fear, trust and PureScript: Building on trust with types and functional programming，力挺 PureScript）。&lt;/p&gt;

&lt;p&gt;但是在 javascript 里面，恐惧永远都伴随着你。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Typescript and Jest</title>
      <link>https://wdicc.com/typescript-and-jest/</link>
      <pubDate>Thu, 01 Nov 2018 11:59:29 +0800</pubDate>
      
      <guid>https://wdicc.com/typescript-and-jest/</guid>
      <description>&lt;p&gt;最近在折腾 typescript，把很多项目改成了 ts 的。有一个老项目，改的过程中感觉各种不踏实，打算还是先写点测试用例，就折腾了一下 jest。各种坑。。。&lt;/p&gt;

&lt;p&gt;首先需要加一个 &lt;code&gt;tsconfig.json&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
  &amp;quot;compilerOptions&amp;quot;: {
    &amp;quot;target&amp;quot;: &amp;quot;es2015&amp;quot;,
    &amp;quot;module&amp;quot;: &amp;quot;es2015&amp;quot;,
    &amp;quot;lib&amp;quot;: [
      &amp;quot;es2015&amp;quot;
    ],
    &amp;quot;outDir&amp;quot;: &amp;quot;./lib&amp;quot;,
    &amp;quot;declaration&amp;quot;: true,

    &amp;quot;noEmit&amp;quot;: true,
    &amp;quot;moduleResolution&amp;quot;: &amp;quot;node&amp;quot;,
    &amp;quot;esModuleInterop&amp;quot;: true,
    &amp;quot;allowSyntheticDefaultImports&amp;quot;: true,

    /* Strict Type-checking */
    &amp;quot;strict&amp;quot;: true,
    &amp;quot;strictNullChecks&amp;quot;: true,
    &amp;quot;noImplicitAny&amp;quot;: true,
    &amp;quot;noImplicitThis&amp;quot;: true,
    &amp;quot;alwaysStrict&amp;quot;: true,

    /* Additional Checks */
    &amp;quot;noUnusedLocals&amp;quot;: true,                /* Report errors on unused locals. */
    &amp;quot;noUnusedParameters&amp;quot;: true,            /* Report errors on unused parameters. */
    &amp;quot;noImplicitReturns&amp;quot;: true,             /* Report error when not all code paths in function return a value. */
    &amp;quot;noFallthroughCasesInSwitch&amp;quot;: true,    /* Report errors for fallthrough cases in switch statement. */
  },
  &amp;quot;include&amp;quot;: [
     &amp;quot;*.ts&amp;quot;
  ],
  &amp;quot;exclude&amp;quot;: [
    &amp;quot;node_modules&amp;quot;,
    &amp;quot;__tests__&amp;quot;
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后安装一个 &lt;code&gt;typescript&lt;/code&gt; 就可以通过 &lt;code&gt;yarn tsc&lt;/code&gt; 命令编译了，生成的 js 在 &lt;code&gt;lib&lt;/code&gt; 下面。&lt;/p&gt;

&lt;p&gt;测试如果是用 js 写，那么直接装 &lt;code&gt;jest&lt;/code&gt; 就可以了。但是我们既然项目都改成 ts 了，那么还是希望用 ts 写。那就需要用到 &lt;code&gt;ts-jest&lt;/code&gt; 。这货的配置可以写到 &lt;code&gt;package.json&lt;/code&gt; 里面。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
 &amp;quot;name&amp;quot;: &#39;test-projct&#39;,
 &amp;quot;version&amp;quot;: &amp;quot;0.0.1&amp;quot;,
 ........
 &amp;quot;jest&amp;quot;: {
    &amp;quot;preset&amp;quot;: &amp;quot;ts-jest&amp;quot;,
    &amp;quot;testEnvironment&amp;quot;: &amp;quot;node&amp;quot;,
    &amp;quot;testMatch&amp;quot;: [ &amp;quot;**/__tests__/*-test.ts&amp;quot; ],
    &amp;quot;globals&amp;quot;: {
      &amp;quot;ts-jest&amp;quot;: {
        &amp;quot;babelConfig&amp;quot;: true,
        &amp;quot;isolatedModules&amp;quot;: true
      }
    }
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;isolatedModules&lt;/code&gt; 表示说测试的时候先不做 type 检查。我这情况是，要改那些文件比较大一时都弄不好，可能 type 只改了部分，但是这个时候改到某个方法的时候，需要先加测试，以免改前改后不一致，所以这个时候只能忽略掉 type 检查了。&lt;/p&gt;

&lt;p&gt;这样配置之后，就可以用 ts 写 test 了。test 文件放到 &lt;code&gt;__tests__&lt;/code&gt; 目录里面，用 &lt;code&gt;*-test.ts&lt;/code&gt; 命名。这样这目录也可以放一些非测试用文件了，比如测试用例用到的一些 mock 文件之类。&lt;/p&gt;

&lt;p&gt;这样看着一切美好。直到我遇到了一个问题，我的那些需要测试的方法，有些是私有的，又不想因为这个改成 public 的，那么是不是有办法可以测试？这样就找到了 &lt;code&gt;rewire&lt;/code&gt; ，这个可以把你的模块的内容随意替换组合，方便你做 mock。我要做的也覆盖了。这样完美了。&lt;/p&gt;

&lt;p&gt;但是发现，rewire 不支持 typescript。在 ts 文件里面 rewire 一个模块之后，并没有多出来那些 &lt;code&gt;__get__&lt;/code&gt; 和 &lt;code&gt;__set__&lt;/code&gt; 方法。没仔细去研究代码，找到了 &lt;code&gt;babel-plugin-rewire&lt;/code&gt; ，给 &lt;code&gt;package.json&lt;/code&gt; 增加配置如下。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;  &amp;quot;babel&amp;quot;: {
    &amp;quot;presets&amp;quot;: [
      &amp;quot;env&amp;quot;
    ],
    &amp;quot;env&amp;quot;: {
      &amp;quot;test&amp;quot;: {
        &amp;quot;plugins&amp;quot;: [
          &amp;quot;babel-plugin-rewire&amp;quot;
        ]
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;发现还是不行，并没有什么效果。查了之后发现，是因为 ts-test 根本不会去调用 babel 的缘故，所以上面的那个 &lt;code&gt;babelConfig&lt;/code&gt; 就是这个用途，让 ts-test 去使用 babel。&lt;/p&gt;

&lt;p&gt;目前还有一个问题是怎么让这个 package 在别人安装使用的时候自动编译为 js，这样让 js 用户也可以用。尝试过在 &lt;code&gt;package.json&lt;/code&gt; 里面增加 build 发现不行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt; &amp;quot;scripts&amp;quot;: {
    &amp;quot;build&amp;quot;: &amp;quot;tsc&amp;quot;,
    &amp;quot;postinstall&amp;quot;: &amp;quot;[ -f ../../node_modules/.bin/tsc ] &amp;amp;&amp;amp; ../../node_modules/.bin/tsc || echo &#39;no typescript found, skip build&#39;&amp;quot;,
    &amp;quot;test&amp;quot;: &amp;quot;jest&amp;quot;
  },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装这个模块之后在 &lt;code&gt;./node_modules/test-module/&lt;/code&gt; 下面执行 &lt;code&gt;tsc&lt;/code&gt; 并不会产出 &lt;code&gt;lib&lt;/code&gt; 目录的编译文件。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Upgrade to React 16.3</title>
      <link>https://wdicc.com/upgrade-to-react-16.3/</link>
      <pubDate>Mon, 22 Oct 2018 16:21:30 +0800</pubDate>
      
      <guid>https://wdicc.com/upgrade-to-react-16.3/</guid>
      <description>&lt;p&gt;随着 React native 升级，React 也升级到了 16.5 了。原来的改成新的生命周期了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class ExampleComponent extends React.Component {
  static getDerivedStateFromProps(nextProps, prevState) {
    // Called after a component is instantiated or before it receives new props.
    // Return an object to update state in response to prop changes.
    // Return null to indicate no change to state.
  }

  UNSAFE_componentWillMount() {
    // New name for componentWillMount()
    // Indicates that this method can be unsafe for async rendering.
    // Prefer componentDidMount() instead.
  }

  UNSAFE_componentWillUpdate(nextProps, nextState) {
    // New name for componentWillUpdate()
    // Indicates that this method can be unsafe for async rendering.
    // Prefer componentDidUpdate() instead.
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    // New name for componentWillReceiveProps()
    // Indicates that this method can be unsafe for async rendering.
    // Prefer static getDerivedStateFromProps() instead.
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;React 在后面的版本里面，这几个方法都会被加上 &lt;code&gt;UNSAFE_&lt;/code&gt; ，直到被移除。&lt;/p&gt;

&lt;p&gt;我们在 &lt;code&gt;componentWillReceiveProps&lt;/code&gt; 里面主要是做了一个事情是根据后端反的数据来更新界面内容。因为我们用了 redux + saga，所以需要在这里做这个事情，如果是通过回调来更新数据的话，就不用这么麻烦了，直接在回调里面设置 state 就可以了。&lt;/p&gt;

&lt;p&gt;因为在 &lt;code&gt;getDerivedStateFromProps&lt;/code&gt; 里面不让接触现在的 &lt;code&gt;this.props&lt;/code&gt; ，所以也不能简单的把原来 &lt;code&gt;componentWillReceiveProps&lt;/code&gt; 的代码直接复制过来用。解决思路下面的链接都提到了很多，我自己总结有那几个。&lt;/p&gt;

&lt;h1 id=&#34;和-prevstate-做比较&#34;&gt;和 prevState 做比较&lt;/h1&gt;

&lt;p&gt;比如想象一个页面有两个按钮，一个点了之后会 setState 为 &lt;code&gt;test1&lt;/code&gt; ，另一个按钮点了之后，会通过网络请求更新 store，然后更新 props 为 &lt;code&gt;test2&lt;/code&gt; ，那这个时候只需要和当前的 state 做比较就可以决定是不是要设置新的 state 了。&lt;/p&gt;

&lt;h1 id=&#34;把-preprops-保存到-state-然后和-prevstate-做比较&#34;&gt;把 preProps 保存到 state 然后和 prevState 做比较&lt;/h1&gt;

&lt;p&gt;这么做基本就和原来使用 &lt;code&gt;componentWillReceiveProps&lt;/code&gt; 基本一样了。没什么好说的了。&lt;/p&gt;

&lt;h1 id=&#34;在-render-里面综合-state-和-props-的值&#34;&gt;在 render 里面综合 state 和 props 的值&lt;/h1&gt;

&lt;p&gt;比如有时候页面显示的是用户录入和 props 的数据综合的，那可以在 render 里面做这个合并的工作。&lt;/p&gt;

&lt;h1 id=&#34;参考链接&#34;&gt;参考链接&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/reactjs/rfcs/blob/master/text/0006-static-lifecycle-methods.md#common-problems&#34; title=&#34;React 关于新的生命周期的 rfc&#34;&gt;React 关于新的生命周期的 rfc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://reactjs.org/docs/react-component.html#unsafe_componentwillreceiveprops&#34; title=&#34;关于使用场景比较多升级的时候处理比较麻烦的 componentWillReceiveProps 方法&#34;&gt;关于使用场景比较多升级的时候处理比较麻烦的 componentWillReceiveProps 方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/reactjs/reactjs.org/issues/721&#34; title=&#34;关于 componentWillReceiveProps 方法和 getDerivedStateFromProps 的讨论&#34;&gt;关于 componentWillReceiveProps 方法和 getDerivedStateFromProps 的讨论&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/33925435&#34; title=&#34;关于新的生命周期国内人的中文解释&#34;&gt;关于新的生命周期国内人的中文解释&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/fi3ework/blog/issues/37&#34; title=&#34;另一篇国人的解释&#34;&gt;另一篇国人的解释&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html&#34; title=&#34;React 官方关于 getDerivedStateFromProps 使用的一些建议&#34;&gt;React 官方关于 getDerivedStateFromProps 使用的一些建议&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/reactjs/rfcs/pull/40&#34; title=&#34;关于为啥不在 getDerivedStateFromProps 里面加一个 prevProps 的讨论&#34;&gt;关于为啥不在 getDerivedStateFromProps 里面加一个 prevProps 的讨论&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Cleanup Your Disk Space</title>
      <link>https://wdicc.com/cleanup-your-disk-space/</link>
      <pubDate>Fri, 12 Oct 2018 12:26:47 +0800</pubDate>
      
      <guid>https://wdicc.com/cleanup-your-disk-space/</guid>
      <description>&lt;p&gt;200 多 G 的空间，说没就没。搞个开发真不容易。&lt;/p&gt;

&lt;p&gt;清理 yarn npm 开发的 cache，这些有需要的会再次下载&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yarn cache clean
npm cache clean
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;清理 gradle android 开发的 cache，这些有需要的话 android-studio 会在生成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rm -rf ~/.gradle/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;清理 xcode ios 开发的东西，这些清理掉了需要用的话 xcode 会再生成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rm -rf ~/Library/Developer/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;清理 brew 安装的软件的旧版本，这个执行之后 python 可能会不正常，执行一下 &lt;code&gt;pyenv rehash&lt;/code&gt; 之类的命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew cleanup
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>R.I.P Maomao</title>
      <link>https://wdicc.com/r.i.p-maomao/</link>
      <pubDate>Fri, 28 Sep 2018 10:33:30 +0800</pubDate>
      
      <guid>https://wdicc.com/r.i.p-maomao/</guid>
      <description>&lt;p&gt;毛毛应该是 2004 年上半年&lt;a href=&#34;https://wdicc.com/about-mao/&#34; title=&#34;我从一个人家里抱回来的&#34;&gt;我从一个人家里抱回来的&lt;/a&gt;，到现在 14 岁多一点。&lt;a href=&#34;https://wdicc.com/diabetic-cat-maomao/&#34; title=&#34;从 2013.12.29 发现得了糖尿病&#34;&gt;从 2013.12.29 发现得了糖尿病&lt;/a&gt;，到现在是 4 年多一点，等于是大概 10 岁左右的时候得的。&lt;/p&gt;

&lt;p&gt;前面 10 年是无忧无虑欢乐的 10 年，猫基本什么都不用管，只有刚开始第一次长假出去玩的时候，拜托过朋友给中间来看看。后面出去玩基本就把两只猫都扔家里了，给他们弄足够的水和吃的，最长出去玩的时间得有 10 天，回来猫只是会比较粘人，其它基本还好。&lt;/p&gt;

&lt;p&gt;自从毛毛病了之后，就和养了一个孩子一样，必须每天早晚 2 针胰岛素。参考上面的文章，通过自己学习，掌握了采血，通过稀释来配胰岛素等。所以开始还需要定期配好稀释好的胰岛素，一次大概配置 20 针左右，放到冰箱，然后每天 2 针，10 天左右就需要重新配置。配药的时候，需要注意量和不能有空气，每次和老婆就像吸毒人员一样，小心翼翼的配好。直到后面加了糖猫猫的群，发现了 bd 针，才开始不在自己稀释配药了。&lt;/p&gt;

&lt;p&gt;毛毛病了之后，我们基本就很难出远门了，因为必须要回来打针。所以出去几次远门都拜托朋友、cc 妈妈等过来给定期打针。直到今年，才开始尝试给带着猫回家，去了一趟我们家，一趟 cc 家，整体猫虽然很害怕，不过也还好，没出什么问题。&lt;/p&gt;

&lt;p&gt;这次本来打算带着他们去沈阳的，结果没想到毛毛出事了。都是我的问题，我知道猫可以活 10 到 20 年，我曾经无处次想过猫死的时候的情形，没想到昨天就这么来了。昨天一晚没有睡，我早上感觉浑身乏力，以为是饿的，去吃了早点才发现不是这个原因。下定决心给他安乐的是我，我可能太薄情了，看着他抽搐受不了。毛毛病了这几年，我们也还断断续续的去了很多次医院，也有几次病危，但是都挺过来了。&lt;/p&gt;

&lt;p&gt;糖尿病猫做无碳水疗法需要喂高蛋白的猫粮，我们家没有条件给妞妞和毛毛分开喂食，只能一起吃。前段时间妞妞身体也不舒服过一次，去医院做 b 超，说是他的有一个肾萎缩的很厉害，建议我们喂老年猫粮，少喂高蛋白的。我也很发愁怎么搞。我和老婆两个北漂，父母多不在这里不能帮忙。&lt;/p&gt;

&lt;p&gt;现在只剩妞妞一个了，打算还是带着他去沈阳，还有乌龟一起。要不一只猫在家估计很孤单也会有问题，妞妞是一个特别粘人的猫。妞妞比毛毛大一岁，今年 15 岁多一点，希望能健康活着。&lt;/p&gt;

&lt;p&gt;毛毛病了之后，我就发现经过了童年成年到中年，也到了要开始有生离死别的时候了。当你喜爱的人一个一个都离开你的时候，为了什么活着？我和老婆没有孩子，当父母都百年之后我真不知道我会不会去选择提前结束。快乐的前半生即将或者已经过去了，后面怎么面对？&lt;/p&gt;

&lt;p&gt;安息吧毛毛，我们爱你。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Typescript for React Native</title>
      <link>https://wdicc.com/typescript-for-react-native/</link>
      <pubDate>Sun, 16 Sep 2018 16:36:17 +0800</pubDate>
      
      <guid>https://wdicc.com/typescript-for-react-native/</guid>
      <description>&lt;p&gt;前几天研究 settimeout 的问题的时候，发现 &lt;a href=&#34;https://github.com/ocetnik/react-native-background-timer&#34; title=&#34;react-native-background-timer&#34;&gt;react-native-background-timer&lt;/a&gt; 自己没有 typescript 的 type 文件，但是有人给写了一个 &lt;a href=&#34;https://www.npmjs.com/package/@types/react-native-background-timer&#34; title=&#34;@types/react-native-background-timer&#34;&gt;@types/react-native-background-timer&lt;/a&gt;，这个包算偏门了，都有人写了 type 文件，我感觉是时候试试看 typescript 了。&lt;/p&gt;

&lt;p&gt;搜了一下，发现没有多少在 rn 里面使用 ts 的，有一些关于 react 的，又很奇怪，大都基于 webpack 的。后来找到一篇&lt;a href=&#34;https://facebook.github.io/react-native/blog/2018/05/07/using-typescript-with-react-native&#34; title=&#34;官方的 blog 上面的&#34;&gt;官方的 blog 上面的&lt;/a&gt;，然后结合自己的研究，找到了思路。我是基于已有项目来做的，那个 blog 是基于新项目，大同小异。&lt;/p&gt;

&lt;p&gt;首先装几个包，这几个包里面， &lt;code&gt;=typescript&lt;/code&gt; 提供 typescript 的编译器， &lt;code&gt;react-native-typescript-transformer&lt;/code&gt; 提供了从 ts 代码到 js 代码的转换支持， @types 的两个包提供了 react 和 react-native 的 type 文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ yarn add -D typescript react-native-typescript-transformer @types/react @types/react-native
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在项目的根目录还需要准几个文件。 tsconfig.json，你的目录里面可能已经有一个 &lt;code&gt;jsconfig.json&lt;/code&gt; 了，那个是给 eslint 用的。tsconfig.json 同时给 typescript 和 tslint 使用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
  &amp;quot;compilerOptions&amp;quot;: {
    &amp;quot;target&amp;quot;: &amp;quot;es2015&amp;quot;,
    &amp;quot;module&amp;quot;: &amp;quot;es2015&amp;quot;,
    &amp;quot;lib&amp;quot;: [
      &amp;quot;es2015&amp;quot;
    ],
    &amp;quot;jsx&amp;quot;: &amp;quot;react&amp;quot;,
    &amp;quot;noEmit&amp;quot;: true,
    &amp;quot;moduleResolution&amp;quot;: &amp;quot;node&amp;quot;,
    &amp;quot;strict&amp;quot;: true,
    &amp;quot;esModuleInterop&amp;quot;: true,
    &amp;quot;types&amp;quot;: [
       &amp;quot;react&amp;quot;,
       &amp;quot;react-native&amp;quot;
     ],
    &amp;quot;allowSyntheticDefaultImports&amp;quot;: true
  },
  &amp;quot;include&amp;quot;: [
     &amp;quot;./app/**/*&amp;quot;
  ],
  &amp;quot;exclude&amp;quot;: [
    &amp;quot;node_modules&amp;quot;
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里面的 include/exclude 按照需要调整，注意里面没有 output，我们并不需要 typescript 输出 js 文件。（当然，也可以用输出 js 文件的方式来做这个事情，但是这样就不太好自动化了，细节不说了）&lt;/p&gt;

&lt;p&gt;然后还需要一个 rn-cli.config.js，这个是给 &lt;code&gt;react-native-typescript-transformer&lt;/code&gt; 用的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;module.exports = {
  getTransformModulePath() {
    return require.resolve(&#39;react-native-typescript-transformer&#39;);
  },
  getSourceExts() {
    return [&#39;ts&#39;, &#39;tsx&#39;];
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后就可以写一些 &lt;code&gt;.ts&lt;/code&gt; 文件了。 &lt;code&gt;.ts&lt;/code&gt; 文件表示只有 js 代码， &lt;code&gt;.tsx&lt;/code&gt; 文件表示里面有 react 代码。写完之后可以执行一下 &lt;code&gt;yarn tsc&lt;/code&gt; 看看，是否有错误。没有错误的话，也可以在模拟器里面看看自己的 ts 代码是不是确实可以执行。&lt;/p&gt;

&lt;p&gt;你的代码可以在模拟器里面执行，主要是下面这段代码的作用。 &lt;code&gt;ts.transpileModule&lt;/code&gt; 会把 ts 代码转换成 js 代码，最终执行的是 js 代码。这里有一个需要注意的地方就是这里不管 ts 的语法错误，也就是你比如定义了一个 type 是 string 类型的变量，你给他做了 number 类型的赋值，这个在 js 里面是可以的，ts 是不允许的，但是这里并不会看到错误。执行 &lt;code&gt;yarn tsc&lt;/code&gt; 可以看到错误提示。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;module.exports.transform = function(src, filename, options) {
  if (typeof src === &#39;object&#39;) {
    // handle RN &amp;gt;= 0.46
    ;({ src, filename, options } = src)
  }

  if (filename.endsWith(&#39;.ts&#39;) || filename.endsWith(&#39;.tsx&#39;)) {
    const tsCompileResult = ts.transpileModule(src, {
      compilerOptions,
      fileName: filename,
      reportDiagnostics: true,
    })

    const errors = tsCompileResult.diagnostics.filter(
      ({ category }) =&amp;gt; category === ts.DiagnosticCategory.Error
    )
.....
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
所以保证代码符合 typescript 有下面几个方法：
&lt;li&gt;使用支持 typescript 的编辑器，依靠编辑器的提示。vs code 配合 tslint 可以做到这个。&lt;/li&gt;
&lt;li&gt;提交代码之前执行 &lt;code&gt;yarn tsc&lt;/code&gt; 验证代码没问题之后再提交。&lt;/li&gt;
&lt;li&gt;在 git 的 commit-hook 里面增加一个 hook 自动执行 &lt;code&gt;yarn tsc&lt;/code&gt; 检查。git 也可以在 server 端做这个检查。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了保证这个，我在 git 的 commit-hook 里面增加了一个 hook。放到 &lt;code&gt;.git/hooks/pre-commit&lt;/code&gt; 就可以。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/sh

has_ts_file=`git diff --cached --name-status | awk &#39;$1 != &amp;quot;D&amp;quot; { print $2 }&#39; | grep &#39;.ts$&#39; |wc -l`

exec 1&amp;gt;&amp;amp;2

if [ &amp;quot;$has_ts_file&amp;quot; -ge &#39;1&#39; ];then
    yarn tsc
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是 git 的 hooks 文件并不是 repo 的一部份，如何保证大家都是一样的配置呢？有一个 npm 包可以做这个事情。。 &lt;code&gt;yarn add -D pre-commit&lt;/code&gt; ，然后在 package.json 里面增加一些配置。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;    &amp;quot;scripts&amp;quot;: {
        &amp;quot;start&amp;quot;: &amp;quot;node node_modules/react-native/local-cli/cli.js start&amp;quot;,
        &amp;quot;test&amp;quot;: &amp;quot;jest&amp;quot;,
        &amp;quot;lint&amp;quot;: &amp;quot;node_modules/.bin/eslint app&amp;quot;,
        &amp;quot;version&amp;quot;: &amp;quot;./version-ios.sh&amp;quot;,
        &amp;quot;precommit&amp;quot;: &amp;quot;./pre-commit&amp;quot;
    },
    &amp;quot;pre-commit&amp;quot;: [
        &amp;quot;precommit&amp;quot;
    ],
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;scripts 里面的 precommit 和 pre-commit 是新加的。那个 pre-commit 就是上面的那个脚本，放到项目目录一起管理就可以。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Background Task in React Native</title>
      <link>https://wdicc.com/background-task-in-react-native/</link>
      <pubDate>Sat, 08 Sep 2018 16:06:18 +0800</pubDate>
      
      <guid>https://wdicc.com/background-task-in-react-native/</guid>
      <description>&lt;p&gt;react-native 支持 &lt;code&gt;setTimeout&lt;/code&gt; 和 &lt;code&gt;setInterval&lt;/code&gt; 这些 js 的方法来设置 timer 执行一些任务。但是对于长时间执行的任务，比如你想每 1 分钟都执行一下网络请求看看是不是有新的数据，这个时候会有一个黄条警告和你说不要这么做。&lt;/p&gt;

&lt;p&gt;我们有类似需求，就找到了 &lt;a href=&#34;https://github.com/ocetnik/react-native-background-timer&#34; title=&#34;react-native-background-timer&#34;&gt;react-native-background-timer&lt;/a&gt; 这个包。这个用起来和 js 的 setTimeout 的方法一样，可以一直运行。&lt;/p&gt;

&lt;p&gt;我们另外还使用了 websocket 来和服务器保持数据同步。这样就必须要保证有网络问题的时候，可以自动重连保证链接。我们找到了 &lt;a href=&#34;https://github.com/pladaria/reconnecting-websocket&#34; title=&#34;reconnecting-websocket&#34;&gt;reconnecting-websocket&lt;/a&gt; 这个包，他提供了自动重连功能。这个包是基于 js 写的，没有任何的 native 代码。我们用的过程中发现时不时会出现断开的情况，因为并不能稳定复现，我们一开始也没有太多时间研究这个问题，所以这个 bug 几乎是持续了几个月。另外，也主要是因为我们还有 pc 设备，也用了 websocket，但是那边表现就很稳定，所以基本可以确定是 android 的问题。&lt;/p&gt;

&lt;p&gt;我们试过自己手动断网，和手动重启服务器的方式断开 websocket，然后发现他都会重连。出现 bug 的时候，都是比如放了一个晚上，第二天来了之后，发现断开了。或者有时候似乎又不会断，总之是不很好的稳定可以复现。&lt;/p&gt;

&lt;p&gt;一开始怀疑是 android 进入省电模式之后，应用会出问题，把设备一直接着电源之后，似乎发现好像好了，但是实际上还是会出现断开的情况。后来给 app 增加了 &lt;code&gt;REQUEST_IGNORE_BATTERY_OPTIMIZATIONS&lt;/code&gt; 权限，试图解决，发现也不行。&lt;/p&gt;

&lt;p&gt;最近一个月总算有时间看看了，仔细研究了一下。给 app 增加了更多的 log，记录一下 websocket 的链接和断开的情况。发现一个情况，似乎整整 24h 的时候，会出现一个断开。断开之后有时候会连不上，有时候可以。因为是整整 24h，所以这个断开基本上可以肯定是 server 那边问题，但是断开不能重连依然是用户端这边的问题。&lt;/p&gt;

&lt;p&gt;后来我们找到了 24h 断开的原因，我们 websocket server 用的是 channel redis，&lt;a href=&#34;https://github.com/django/channels_redis/blob/master/channels_redis/core.py#L149&#34; title=&#34;里面默认是 24h 会断开&#34;&gt;里面默认是 24h 会断开&lt;/a&gt;。这个案子破了，定期倒是没问题，现在就是为啥不会重连的问题了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt; def __init__(
        self,
        hosts=None,
        prefix=&amp;quot;asgi:&amp;quot;,
        expiry=60,
        group_expiry=86400,
        capacity=100,
        channel_capacity=None,
        symmetric_encryption_keys=None,
    ):
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过分析 websocket 的日志，发现断开之后，执行重连的时候，reconnect-websocket 避免过度重连，会增加一个延时，调用 &lt;a href=&#34;https://github.com/pladaria/reconnecting-websocket/blob/master/reconnecting-websocket.ts#L326&#34; title=&#34;this._wait()&#34;&gt;this._wait()&lt;/a&gt;，问题就出在了这里，我们发现这个 promise 会卡住不能 resolve，这里面调用的就是 &lt;code&gt;setTimeout&lt;/code&gt; 。结合一开始说的，比较怀疑 rn 自己的 setTimeout 有问题，就试了一下使用 react-native-background-timer 来实现。改了之后运行了几天发现问题解决了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;    private _wait(): Promise&amp;lt;void&amp;gt; {
        return new Promise(resolve =&amp;gt; {
            setTimeout(resolve, this._getNextDelay());
        });
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;继续看看为啥 rn 自己的 timer 有问题。&lt;/p&gt;

&lt;p&gt;找到了 &lt;a href=&#34;https://github.com/facebook/react-native/blob/master/Libraries/Core/Timers/JSTimers.js&#34; title=&#34;JSTimers.js&#34;&gt;JSTimers.js&lt;/a&gt;，这里面通过调用 &lt;code&gt;Timing.createTimer&lt;/code&gt; 来创建 timer 的。Timing.createTimer 这个 native 模块的代码在&lt;a href=&#34;https://github.com/facebook/react-native/blob/master/ReactAndroid/src/main/java/com/facebook/react/modules/core/Timing.java#L324&#34; title=&#34;这里&#34;&gt;这里&lt;/a&gt;。这代码里面用到的包不熟悉，看了半天觉得看不明白，但是看到了这些。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;  @Override
  public void onHostPause() {
    isPaused.set(true);
    clearFrameCallback();
    maybeIdleCallback();
  }

  @Override
  public void onHostResume() {
    isPaused.set(false);
    // TODO(5195192) Investigate possible problems related to restarting all tasks at the same
    // moment
    setChoreographerCallback();
    maybeSetChoreographerIdleCallback();
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那个 &lt;code&gt;onHostPause&lt;/code&gt; 很可疑，我们知道 android 黑屏的时候，是会调用 app 的 onPause 的。继续找这个类实现了 &lt;a href=&#34;https://github.com/facebook/react-native/blob/master/ReactAndroid/src/main/java/com/facebook/react/bridge/LifecycleEventListener.java&#34; title=&#34;LifecycleEventListener&#34;&gt;LifecycleEventListener&lt;/a&gt; 这个接口，里面注释写和 active 切换有关系，实际就是和 onPause 这些 activity 的生命周期挂钩的。&lt;/p&gt;

&lt;p&gt;app 放到后台之后，会调用 onHostPause，然后 timer 就都不执行了，所以那个 promise 一直不能 resolve，然后 reconnect-websocket 就不会连接。&lt;/p&gt;

&lt;p&gt;RN 提供了 &lt;a href=&#34;https://facebook.github.io/react-native/docs/headless-js-android.html&#34; title=&#34;Headless JS&#34;&gt;Headless JS&lt;/a&gt; 来执行后台任务。我们就是改造了一下 reconnect-websocket 用 react-native-background-timer 就解决问题了。有需要可以用这个 https://github.com/wd/reconnecting-websocket 。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>React Native Deeplink</title>
      <link>https://wdicc.com/react-native-deeplink/</link>
      <pubDate>Mon, 03 Sep 2018 18:00:56 +0800</pubDate>
      
      <guid>https://wdicc.com/react-native-deeplink/</guid>
      <description>&lt;p&gt;App 一般都支持类似 &lt;code&gt;coolflight://list&lt;/code&gt; 这样的链接，可以直接打开 app 并打开列表，这个就是 deeplink。&lt;/p&gt;

&lt;p&gt;这个需要对 native 代码做一些修改，可以参考&lt;a href=&#34;https://reactnavigation.org/docs/en/deep-linking.html&#34; title=&#34;这里&#34;&gt;这里&lt;/a&gt;的修改，ios 和 android 都有写。这里有一个需要注意的是，对于 android 有一个配置是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;data android:scheme=&amp;quot;mychat&amp;quot; android:host=&amp;quot;mychat&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个里面配置 host 的话，后面使用的时候就需要类似 &lt;code&gt;mychat://mychat/list&lt;/code&gt; 这样的方式了，就是多了一层 mychat。这样也会导致 ios 和 android 的链接不统一，我查了&lt;a href=&#34;https://developer.android.com/training/app-links/deep-linking&#34; title=&#34;文档&#34;&gt;文档&lt;/a&gt;也没有查到没有设置 host 会有什么问题，我就去掉了，去掉之后，ios 和 android 的链接就统一了。都是 &lt;code&gt;mychat://list&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;另外 android 还有一个需要注意的地方是，activity 的 launchmod 需要设置为 &lt;code&gt;singleTask&lt;/code&gt; 要不会导致每次通过 deeplink 打开 app 都会新建一个，导致你有多个 js 在后台跑。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;activity
  android:name=&amp;quot;.MainActivity&amp;quot;
  android:launchMode=&amp;quot;singleTask&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 js 里面可以使用 &lt;code&gt;Linking.openURL(url).catch(err =&amp;gt; console.error(&#39;An error occurred&#39;, err))&lt;/code&gt; 打开一个 deeplink ，可以是别的 app 的，也可以是自己的。&lt;/p&gt;

&lt;p&gt;然后就是在 js 里面处理对应的 deeplink 了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;componentDidMount() {
  Linking.getInitialURL().then((url) =&amp;gt; {
    if (url) {
      console.log(&#39;Initial url is: &#39; + url);
    }
  }).catch(err =&amp;gt; console.error(&#39;An error occurred&#39;, err));

  Linking.addEventListener(&#39;url&#39;, this._handleOpenURL);
}

componentWillUnmount() {
  Linking.removeEventListener(&#39;url&#39;, this._handleOpenURL);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 &lt;code&gt;componentDidMount&lt;/code&gt; 里面，通过 &lt;code&gt;Linking.getInitialURL()&lt;/code&gt; 可以得到 app 冷启动的时候拿到的 link。通过 &lt;code&gt;Linking.addEventListener(&#39;url&#39;, callback)&lt;/code&gt; 可以拿到热启动 app 拿到的 link，分别处理或者统一处理都可以，看业务需求。&lt;/p&gt;

&lt;p&gt;我们用的是 React Navigation，他支持可以直接给 screen 设置 path，然后和 deeplink 匹配跳转。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const SimpleApp = createStackNavigator({
  Home: { screen: HomeScreen },
  Chat: {
    screen: ChatScreen,
    path: &#39;chat/:user&#39;,
  },
});


const prefix = &#39;mychat://&#39;; // 这里我们上面提到的统一了，所以不用区分 ios 和 android
const MainApp = () =&amp;gt; &amp;lt;SimpleApp uriPrefix={prefix} /&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样只需要定义一个 &lt;code&gt;uriPrefix&lt;/code&gt; 就可以了。&lt;/p&gt;

&lt;p&gt;我们为了把 navigation 和 redux 结合，自定义了 navigation 的 &lt;code&gt;navigation&lt;/code&gt; 属性，就不允许这么弄了。需要自己处理。&lt;/p&gt;

&lt;p&gt;主要思路是通过 &lt;code&gt;SimpleApp.router.getActionForPathAndParams(path, params)&lt;/code&gt; 得到 action，然后 dipatch 这个 action 就可以了。&lt;/p&gt;

&lt;p&gt;那个 &lt;code&gt;chat/:user&lt;/code&gt; 可以匹配到 &lt;code&gt;mychat://chat/Jim&lt;/code&gt; 这样的 deeplink，然后那个 &lt;code&gt;user: Jim&lt;/code&gt; 会以 param 的方式给到 screen，通过 param.user 可以访问到。&lt;/p&gt;

&lt;p&gt;path 的格式支持的是这个 &lt;a href=&#34;https://github.com/pillarjs/path-to-regexp&#34; title=&#34;path-to-regexp&#34;&gt;path-to-regexp&lt;/a&gt; 支持的格式，可以自定义表达式，具体可以参考那个文档。&lt;/p&gt;

&lt;p&gt;path 支持使用 &lt;code&gt;?&lt;/code&gt; 来表示一个字段是可选的，例如 &lt;code&gt;mychat://chat/:user?&lt;/code&gt; 表示会匹配到 &lt;code&gt;mychat://chat&lt;/code&gt; 和 &lt;code&gt;mychat://chat/Jim&lt;/code&gt; 。 &lt;code&gt;mychat://chat/:user?/:msg?&lt;/code&gt; 这样的，可以匹配 &lt;code&gt;mychat://chat&lt;/code&gt; &lt;code&gt;mychat://chat/Jim&lt;/code&gt; &lt;code&gt;mychat://chat/Jim/hey&lt;/code&gt; 但是不能匹配 &lt;code&gt;mychat://chat//hey&lt;/code&gt; 。默认匹配的是 &lt;code&gt;([^\\/]+)&lt;/code&gt; 可以通过自定义表达式支持。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;  path: &#39;chat/:user([^\\/]*)?/:msg?&#39;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>React Mobx</title>
      <link>https://wdicc.com/react-mobx/</link>
      <pubDate>Sun, 02 Sep 2018 19:18:16 +0800</pubDate>
      
      <guid>https://wdicc.com/react-mobx/</guid>
      <description>&lt;p&gt;我们之前用的是 redux 来做的统一 store，最近一个新项目有同学用了 mobx，就了解了一下，刚开始看的时候，感觉比 redux 好啊？&lt;/p&gt;

&lt;p&gt;mobx 的逻辑是自动收集 store 属性被哪些 dom 使用，然后在属性被改变的时候，自动更新 dom。这样的模式显然比 redux 的 action，reducer，selector 那一套简单多了。&lt;/p&gt;

&lt;p&gt;给对应的组件加上 &lt;code&gt;@observer&lt;/code&gt; 装饰器之后，store 改变就会自动重现渲染组件。store 可以用下面的模式给到组件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const store = new TodoList();
&amp;lt;TodoListView todoList={store} /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以用 &lt;code&gt;@inject&lt;/code&gt; 装饰器&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;@inject(store =&amp;gt; store)
@observer
class TodoListView {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后都通过 &lt;code&gt;this.props&lt;/code&gt; 引用。&lt;/p&gt;

&lt;p&gt;一切都很美好，直到我看到了&lt;a href=&#34;https://mobx.js.org/best/react.html&#34; title=&#34;这个&#34;&gt;这个&lt;/a&gt;，这里列了一些 mobx 的坑。比如有讲到，mobx 为了能监控到对 store 的依赖和修改，其实是把 store 属性做了修改，所以 store 有一个属性是一个 Map，那么实际得到的是一个和 ES6 Map api 类似的一个对象，但是并不是原生的 Map。比如有一个属性是 Object，你给加了一个 key，例如 store.object[&#39;a&#39;] = &#39;test&#39;，那么这个修改并不能被监视，具体看那个文档吧。&lt;/p&gt;

&lt;p&gt;写 Javascript 基本就是从一个小坑爬出来掉到一个大坑里面。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Android Custom</title>
      <link>https://wdicc.com/android-custom/</link>
      <pubDate>Sun, 02 Sep 2018 08:00:16 +0800</pubDate>
      
      <guid>https://wdicc.com/android-custom/</guid>
      <description>&lt;p&gt;我们给用户的设备，有 android pad 和 pc。pc 系统我之前基于 porteus 定制了一个，勉强可以用。apad 的系统一直没搞好。&lt;/p&gt;

&lt;p&gt;Android 系统必须要解锁之后才可以定制系统，否则没有 root 权限，system 分区的数据不能修改。&lt;/p&gt;

&lt;ul&gt;
Android 系统有四个重要的分区。
&lt;li&gt;&lt;code&gt;boot&lt;/code&gt; ，和 linux 的类似，里面有 kernel 和 ramdisk，ramdisk 应该是在启动之后会成为 / 分区&lt;/li&gt;
&lt;li&gt;&lt;code&gt;recovery&lt;/code&gt; ，恢复分区，如果想对系统分区做什么操作，可以使用这里的程序引导系统，这个时候允许你进行一些操作。默认的 recovery 只能 wipe 和刷系统。自定义的 recovery 比较厉害，可以支持备份啊啥的一堆事情，比如 twrp 还有图形界面。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;system&lt;/code&gt; ，系统分区，系统程序都在这里，包括系统自带的一些 app 等等。正常情况对这个分区是不能修改的，系统分区都是只读的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;data&lt;/code&gt; ，数据分区，这个分区是给用户使用的。用户安装的一下 app 以及一些数据都在这里。wipe 的时候就是会清空这个分区的数据。大家熟悉的 sdcard 那个分区，其实数据也是在这里的。data 分区里面 app 只能读取自己的数据，无法访问别的 app 的。但是放在 /sdcard 分区的数据，大家都可以访问（当然，还得有 sdcard 的权限）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;前三个分区都可以定制。首先需要解锁 bootloader，这个各个定制版都可能有区别，比如华为我记得还需要去他们网站获取一个解锁码，获取的时候会提示你解锁之后就不给保了。原生的 android 都是去开发者选项里面打开，然后在启动的时候进 bootloader，执行 &lt;code&gt;fastboot oem unlock-go&lt;/code&gt; 。解锁的时候会自动 reset 系统，注意先备份数据。&lt;/p&gt;

&lt;p&gt;解锁之后，就可以刷自己的 recovery 了。刷之前建议先备份一下 &lt;code&gt;boot&lt;/code&gt; &lt;code&gt;recovery&lt;/code&gt; &lt;code&gt;system&lt;/code&gt; 分区，以方便自己回头可以刷回来。我用的是 twrp，其它的好像现在也么看到。这个得找和你的手机匹配的才行。具体方法是执行 fastboot boot twrpxxxxx.img 临时使用 twrp 启动，然后用通过 &lt;code&gt;adb shell&lt;/code&gt; 登录 shell，之后用 &lt;code&gt;dd if=/dev/block/mmcblk0pXX of=/sdcard/xxx.img&lt;/code&gt; 来备份，之后用 &lt;code&gt;adb pull /sdcard/xxx.img&lt;/code&gt; 下载到本地。具体各个分区的那个 XX 是什么，可以用 &lt;code&gt;fdisk -l&lt;/code&gt; 看。&lt;/p&gt;

&lt;p&gt;这里有一个需要注意的是，我发现我这使用临时启动到 twrp 的方式还是不能修改 system 分区，必须是把 twrp 刷入 recovery 之后才可以。就是这个导致我一直没有搞好 apad 的系统，我开始一直是用临时启动到 recovery 的方式来做的，对 system 做修改就是死机。&lt;/p&gt;

&lt;p&gt;现在比较新的系统都有一个 dm-verify ，想修改 system 分区就需要关闭这个，否则任何修改都会导致系统不能启动。我在 &lt;a href=&#34;https://forum.xda-developers.com/android/software/universal-dm-verity-forceencrypt-t3817389&#34; title=&#34;xda 找到一个&#34;&gt;xda 找到一个&lt;/a&gt; 可以直接在 recovery 里面通过 sideload 刷就可以。&lt;/p&gt;

&lt;p&gt;关闭 dm-verify 之后就可以修改系统了。我还有一个需求是想系统启动之后，通过 iptables 对系统使用的网络做一些限制。想要在系统启动之后做一些事情，比较简单的就是修改 system 分区的那些 xxx.rc 加入自己的东西。我试了之后发现虽然程序可以执行，但是这种方式的程序，并不能直接操作 iptables 命令（执行不报错，但是无实际效果）。查了说大概是 kernel 级别的限制，这样难不成就去定制 kernel 了？&lt;/p&gt;

&lt;p&gt;Android 系统的 root 实际应该就是对系统 kernel 打了一个补丁，放了一个后门，允许通过 su 命令来获取 root 权限，这里获取的 root 权限可是货真价实的，可以执行 iptables 命令。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://forum.xda-developers.com/apps/magisk&#34; title=&#34;Magisk&#34;&gt;Magisk&lt;/a&gt; 可以给系统 root。recovery 里面通过 sideload 刷入之后，系统会多出来一个 app，有程序想用 su 的话，这个 app 会弹一个提示问是不是允许。magisk 应该是给 kernel 打了补丁，关闭了 dm-verify（所以用 magisk 的话，就可以不用上面那个了），然后启动的时候，会 mount 一个 su.img 提供 su 命令，会启动一个 su 的 daemon。这个可以通过看 ramdisk 里面的内容可以看到。magisk 还会在你的 /data 分区装一个 app，一起配合使用。但是要注意一点，我们 wipe 系统之后，这个 app 也会被删除。但是前面说的那些 su.img 之类都是在 boot 分区的，那些都还有，一个没有 app 配合的 su 也可以用，就是所有程序都直接使用，没有限制了。所以如果是你自己用，那最最好是和 boot 一起刷，或者就是自己安装一个 app。&lt;/p&gt;

&lt;p&gt;对于 system 的修改，拿到 root 权限就可以了。但是对于 boot 分区，只能拿到一个 boot.img，想要修改，还需要使用一些工具把里面的内容解出来，以及之后再打包。我找到一个&lt;a href=&#34;https://forum.xda-developers.com/showthread.php?t=2319018&#34; title=&#34;工具&#34;&gt;工具&lt;/a&gt; 。&lt;/p&gt;

&lt;p&gt;android 系统启动的时候会读取一些 xxx.rc，这些 rc 类似 linux 下面那些，但是不像 linux 那些都是脚本，是有一个自己的格式的内容。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;on property:sys.boot_completed=1
    start wd-post-boot

service wd-post-boot /system/bin/sh /wd.post_boot.sh
    class late_start
    user root
    disabled
    oneshot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比如我上面这个，定义了一个 service &lt;code&gt;wd-post-boot&lt;/code&gt; ，然后让他在 &lt;code&gt;sys.boot_completed&lt;/code&gt; 这个 prop 值为 1 的时候执行一次。还有很多其它的方法，可以找 android 的文档看，我说的不能执行 iptables 就是这里的脚本里面不能执行。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Boot Linux Through PXE</title>
      <link>https://wdicc.com/boot-linux-through-pxe/</link>
      <pubDate>Mon, 02 Jul 2018 16:47:31 +0800</pubDate>
      
      <guid>https://wdicc.com/boot-linux-through-pxe/</guid>
      <description>&lt;p&gt;测试 porteus 的时候，每次都是做好 iso 之后写到一个 u 盘，然后用 u 盘启动看看效果，发现有点蛋疼，这浪费时间不说，我的 u 盘寿命估计也得少一截。就研究了一下 pxe 启动，这样每次改完之后通过 pxe 直接读取我改了之后的 iso 引导 linux 就好了。&lt;/p&gt;

&lt;p&gt;我这看 pxe 启动主要需要做两个事情，一个是 dhcp 的时候广播 tftp 的信息，一个是通过 nfs 共享给那个系统需要读取的文件。nfs 共享也可以改用 http 等其他服务。&lt;/p&gt;

&lt;h2 id=&#34;dnsmasq&#34;&gt;dnsmasq&lt;/h2&gt;

&lt;p&gt;广播 tftp 的信息，可以通过 dnsmasq 来做。dhcp 部分就不贴了，只贴 tftp 相关的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tftp-root=/srv/pxe/boot
dhcp-boot=/pxelinux.0
enable-tftp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;网卡启动的时候会获取 &lt;code&gt;/pxelinux.0&lt;/code&gt; 然后获取 &lt;code&gt;/pxelinux.cfg/default&lt;/code&gt; （这个实际上有一个判断顺序，方便给不同的机器不同的配置）。然后根据这里面的配置，获取内核信息。然后加载内核。&lt;/p&gt;

&lt;h2 id=&#34;nfs&#34;&gt;nfs&lt;/h2&gt;

&lt;p&gt;加载内核之后还需要系统文件，这个时候貌似有几个选择，比如通过 http 发送。我这用的是 nfs。想要通过 nfs 发送，内核得能支持 nfs mount。各 linux 的做法貌似不太一样。&lt;/p&gt;

&lt;p&gt;配置 nfs 的目录，在 &lt;code&gt;/etc/exports&lt;/code&gt; 里面加入类似这样的信息。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/srv/pxe/porteus *(ro,fsid=0,no_subtree_check)
/srv/pxe/storage *(rw,fsid=1,no_root_squash,no_subtree_check)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后 &lt;code&gt;exportfs -rv&lt;/code&gt; ，这样 nfs 设置好了。&lt;/p&gt;

&lt;p&gt;我这 export 的目录和上面 tftp-root 的目录不一样，有的发行版可能会按照 tftp-root 的设置来读取，这个还得区分发行版看。&lt;/p&gt;

&lt;h2 id=&#34;其他&#34;&gt;其他&lt;/h2&gt;

&lt;p&gt;上面的例子只是写了一个大高，是实际使用相差很大。比如如何得到 &lt;code&gt;pxelinux.0&lt;/code&gt; ，如何让内核支持 nfs，以及在内核启动的时候加载 nfs 并使用 nfs 的数据启动，这些都和发行版有关系，还需要单看。&lt;/p&gt;

&lt;ul&gt;
参考
&lt;li&gt;&lt;a href=&#34;https://www.syslinux.org/wiki/index.php?title=PXELINUX&#34; title=&#34;PXELINUX&#34;&gt;PXELINUX&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Install Porteus to HD</title>
      <link>https://wdicc.com/install-porteus-to-hd/</link>
      <pubDate>Mon, 02 Jul 2018 16:23:54 +0800</pubDate>
      
      <guid>https://wdicc.com/install-porteus-to-hd/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://porteus.org/&#34; title=&#34;Porteus&#34;&gt;Porteus&lt;/a&gt; 是一个很好玩的系统，他基于 aufs 弄出来的一个「只读」系统，说是只读，实际上他也可以把修改保存到一个硬盘目录，然后启动的时候自动加载这些修改，这样就修改都还在。但是如果把这个目录删除，那么修改就都没有了，这就是所谓的只读。&lt;/p&gt;

&lt;p&gt;我开始的需求是需要搞一个 linux，然后给用户使用，并且希望用户只能用浏览器，不能使用其他东西，因为我们提供的服务就是一个网页。不能使用其他东西是为了避免使用的时候导致系统奔溃什么的，还得派人花时间去维护。然后看到有人推荐 &lt;a href=&#34;http://porteus-kiosk.org/index.html&#34; title=&#34;Kiosk&#34;&gt;Kiosk&lt;/a&gt;，看了一下感觉这个东西太完美了，就是我想要的东西。然后就开始研究这个系统。研究的过程中发现了他是基于 Porteus 的，就开始看 porteus。&lt;/p&gt;

&lt;p&gt;Kiosk 确实也不错，但是我使用的时候想要定制支持中文输入法，打印机等设备，然后发现他阉割加定制的太多了，导致我看了几天居然还没有找到他的入口在哪里，尝试想搞定输入法，费了很多劲。kiosk 使用的是 openbox + tint2 ，后面看了 porteus 之后，他支持 mate，kde 这些桌面，并且也直接就支持 scim，所以打算还是基于这个定制比较简单一点。&lt;/p&gt;

&lt;p&gt;具体定制就不多说了，主要是定制好 iso 之后，怎么安装到硬盘。&lt;/p&gt;

&lt;p&gt;其实也相当简单，只需要把 u 盘上面的内容复制到一个硬盘分区，然后安装一个 bootloader 就可以了。&lt;/p&gt;

&lt;p&gt;安装 bootloader 的时候由于对这个东西不是特别熟悉，以及这么多年不搞 linux 之后又出来很多新的概念，所以走了一些弯路，一番&lt;a href=&#34;https://wdicc.com/grub2-and-uefi/&#34; title=&#34;学习&#34;&gt;学习&lt;/a&gt;之后，发现简单的很。可以参考&lt;a href=&#34;https://wdicc.com/grub2-and-uefi/#grub&#34; title=&#34;这里&#34;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;然后就是需要弄一个 &lt;code&gt;grub.cfg&lt;/code&gt; 就可以了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set timeout=1
set superusers=root
password_pbkdf2 root grub.pbkdf2.sha512.10000.xxxxxxxx
password guest guest

if [ x&amp;quot;$default&amp;quot; = xsaved ];then
 load_env;
 set default=&amp;quot;$saved_entry&amp;quot;;
fi

insmod vbe
insmod efi_gop
insmod efi_uga

insmod font
insmod part_gpt

search --label --no-floppy --set kgzx KGZX
set prefix=($kgzx)/boot/grub

if loadfont $prefix/fonts/unicode.pf2
then
    insmod gfxterm
    set gfxmode=auto
    set gfxpayload=keep
    terminal_output gfxterm
    insmod png
    background_image $prefix/grub.png
fi

menuentry &#39;我的系统&#39; --unrestricted {
  set root=&amp;quot;($kgzx)&amp;quot;
  linux /boot/syslinux/vmlinuz changes=/mnt/sda4/
  initrd /boot/syslinux/initrd.xz
  boot
}

menuentry &#39;Cleanup&#39; --users &amp;quot;guest&amp;quot; {
  set root=&amp;quot;($kgzx)&amp;quot;
  linux   /boot/syslinux/vmlinuz 3 restore=1
  initrd /boot/syslinux/initrd.xz
  boot
}

menuentry &#39;Backup&#39; --users &amp;quot;root&amp;quot; {
  search --file --set root /efi/Microsoft/Boot/bootmgfw.efi
  chainloader /efi/Microsoft/Boot/bootmgfw.efi
  boot
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果只是使用 mbr 方式，也可以用 grub-legacy 也就是 0.97 那个版本，安装操作类似的，grub.cfg 不一样，那个是叫做 &lt;code&gt;menu.lst&lt;/code&gt; 。然后那个版本不支持 uefi boot 和中文菜单。好像也不支持菜单设置密码？没啥特别的建议还是 grub2 吧。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Compile Kernel Module</title>
      <link>https://wdicc.com/compile-kernel-module/</link>
      <pubDate>Mon, 02 Jul 2018 16:13:56 +0800</pubDate>
      
      <guid>https://wdicc.com/compile-kernel-module/</guid>
      <description>&lt;p&gt;使用 porteus 的时候，发现网卡不支持，找了一下发现有内核驱动可以用，那就需要编译一下内核的模块。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.porteus.org/component/content/article/20-tutorials/development/91-compilation-and-usage-of-custom-porteus-kernel.html&#34; title=&#34;这里&#34;&gt;这里&lt;/a&gt;有一个帖子写了如何编译内核，主要步骤是先给内核打 aufs 的补丁，然后就是正常的 make config &amp;&amp; make &amp;&amp; make modules_install 了。&lt;/p&gt;

&lt;p&gt;我这只是编译一个网卡驱动，操作步骤大概如下，把内核解压放到 /mnt/sda1/kernel 下面，然后把网卡驱动代码放到 /mnt/sda1/kernel/linux-4.16.3/drivers/net/wireless/rtl8821ce 下面。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# cd /mnt/sda1/kernel/linux-4.16.3/
# modprobe configs &amp;amp;&amp;amp; zcat /proc/config.gz &amp;gt; .config
# make oldconfig
# make prepare
# make modules_prepare
# export srctree=/mnt/sda1/kernel/linux-4.16.3
# ln -s /mnt/sda1/kernel/linux-4.16.3 /usr/src/linux
# cd drivers/net/wireless/rtl8821ce
# make
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在这个目录下面会产生一个 rtl8821ce.ko 的文件。&lt;/p&gt;

&lt;p&gt;如果是遇到自己用的内核有一个模块没编译，那可以用下面的方式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# after make modules_prepare
# make modules SUBDIRS=drivers/firmware/efi/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样会在 drivers/firmware/efi/ 目录下面产生一个 xx.ko 之类的文件。&lt;/p&gt;

&lt;p&gt;把上面产生的 ko 文件放到你的 linux 的对应目录就可以使用 modprob 加载了，例如 &lt;code&gt;/lib/modules/4.16.3-porteus/kernel/drivers/net/wireless/8821ce.ko&lt;/code&gt; 。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Geodesy</title>
      <link>https://wdicc.com/geodesy/</link>
      <pubDate>Sun, 01 Jul 2018 08:10:05 +0800</pubDate>
      
      <guid>https://wdicc.com/geodesy/</guid>
      <description>&lt;p&gt;坐标点之间的距离角度计算不能简单的用平面几何来算，得按照球面计算，PostgreSQL 提供了 gis 数据的计算支持，各种图形关系判断，距离计算等等。但是我们有时候也需要在 js 里面计算，开始的时候尝试自己按照公式写来着，写了一些发现太蛋疼了，因为只是单纯的看公式，缺少空间概念，算的对不对啥的都不知道。后来发现了这个 &lt;a href=&#34;https://github.com/chrisveness/geodesy&#34; title=&#34;js 库&#34;&gt;js 库&lt;/a&gt;，简直太贴心了。&lt;/p&gt;

&lt;ol&gt;
提供了我用过的几个功能
&lt;li&gt;度数表示转换，小数点形式到度分秒形式的互转。在 utm.js 里面。&lt;/li&gt;
&lt;li&gt;计算线的真北角。point1.bearingTo(point2)，真北角计算是和线的方向有关系的。&lt;/li&gt;
&lt;li&gt;和当前点夹角是 x，距离是 y 的点，point1.destinationPoint(y, x)。&lt;/li&gt;
&lt;li&gt;两点之间的距离，point1.distanceTo(point2)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;然后顺便记录一些东西。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 两条线的夹角的一半，普通角度
let angle = (360 + 180 + bearing1 - bearing2) % 360 // 360 保证只有正的
let halfAngle = angle &amp;gt; 180 ? (360 - angle)/2 : angle/2 // 只要锐角

// 计算两条线夹角中线的真北角
// left,right bearing 需要是真北角
let rightBearing = 90 + (bearing1 + bearing2)/2
let leftBearing = 180 + rightBearing

// Math.sin 之类的方法使用的应该是小数形式的度数表示
let angleToDecimal = halfAngle*Math.PI/180
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>UEFI Bootable Usb</title>
      <link>https://wdicc.com/uefi-bootable-usb/</link>
      <pubDate>Sat, 30 Jun 2018 07:30:58 +0800</pubDate>
      
      <guid>https://wdicc.com/uefi-bootable-usb/</guid>
      <description>&lt;h1 id=&#34;uefi-shell&#34;&gt;UEFI shell&lt;/h1&gt;

&lt;p&gt;UEFI firmware 应该会读取设备里面的分区，找到 ESP 然后再读里面的内容。我看到最简单的方式是把 u 盘格式化成 fat 然后建一个目录 &lt;code&gt;/boot/efi&lt;/code&gt; 然后下载一个 &lt;a href=&#34;https://wiki.archlinux.org/index.php/Unified_Extensible_Firmware_Interface#UEFI_Shell&#34; title=&#34;uefi shell&#34;&gt;uefi shell&lt;/a&gt; 把 .efi 文件放到这个目录 &lt;code&gt;/boot/efi/shellx64.efi&lt;/code&gt; ，然后启动的时候就多了一个 uefi 菜单了，选择之后可以进入一个 uefi shell。&lt;/p&gt;

&lt;p&gt;uefi shell 里面有几个命令可以用。&lt;/p&gt;

&lt;h2 id=&#34;map&#34;&gt;map&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;map&lt;/code&gt; 可以列出来当前机器的磁盘情况，找到你的 esp 分区。&lt;/p&gt;

&lt;h2 id=&#34;ls&#34;&gt;ls&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;ls&lt;/code&gt; 可以列出来磁盘目录里面的内容，比如 &lt;code&gt;ls fs0:\boot&lt;/code&gt; ，注意磁盘和目录之间用 &lt;code&gt;:&lt;/code&gt; ，目录层级之间用 &lt;code&gt;\&lt;/code&gt; 。&lt;/p&gt;

&lt;h2 id=&#34;bcfg&#34;&gt;bcfg&lt;/h2&gt;

&lt;p&gt;可以通过 &lt;code&gt;bcfg boot dump -v&lt;/code&gt; 列出来当前所有的 efi 菜单，注意每个项目都有一个序号，后面会用到。&lt;/p&gt;

&lt;p&gt;比如我想自己加一个菜单进去，那就找到最后那个的序号，然后执行 &lt;code&gt;bcfg add 8 fs0:\boot\grub\grubx64.efi GRUB&lt;/code&gt; (fat 系统不区分大小写)，指向我自己通过 &lt;code&gt;grub-install --efi-directory=/mnt/sda1/&lt;/code&gt; 放到 esp 分区的 grub 的 efi ，这样启动的时候就多了一个 GRUB 的选项，通过这个选项就可以进入 linux，然后使用更方便的 efibootmgr 来编辑这个菜单了。&lt;/p&gt;

&lt;ul&gt;
参考:
&lt;li&gt;&lt;a href=&#34;https://wiki.archlinux.org/index.php/EFISTUB#UEFI_Shell&#34; title=&#34;UEFI Shell&#34;&gt;UEFI Shell&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;自己制作-iso&#34;&gt;自己制作 iso&lt;/h1&gt;

&lt;p&gt;通过 &lt;a href=&#34;https://www.syslinux.org/wiki/index.php?title=Isohybrid#UEFI&#34; title=&#34;isohybrid&#34;&gt;isohybrid&lt;/a&gt; 可以把一个 iso 做成支持 uefi 的格式，然后通过 dd 写入 u 盘之后，这个 u 盘就支持 uefi 启动了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkisofs \
 -o output.iso \
 -c boot/syslinux/isolinux.boot \
 -b boot/syslinux/isolinux.bin \
  -no-emul-boot -boot-load-size 4 -boot-info-table \
 -eltorito-alt-boot \
 -eltorito-platform 0xEF -eltorito-boot isolinux/efiboot.img \
  -no-emul-boot \
 CD_ROOT
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;efiboot.img 实际是一个 iso 格式的磁盘 img，可以通过下面的方式产生&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ dd if=/dev/zero of=./efiboot.img bs=1M count=4
$ mount efiboot.img ./mnt
$ cp -r EFI /mnt
$ umount /mnt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;EFI/boot 目录是 efi 启动你自己定义的内容，然后执行 &lt;code&gt;isohybrid --uefi output.iso&lt;/code&gt; 。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Grub2 and UEFI</title>
      <link>https://wdicc.com/grub2-and-uefi/</link>
      <pubDate>Fri, 29 Jun 2018 20:03:54 +0800</pubDate>
      
      <guid>https://wdicc.com/grub2-and-uefi/</guid>
      <description>&lt;p&gt;这几天搞 Linux 又学习了一些新的东西。&lt;/p&gt;

&lt;p&gt;以前都是把 grub 装到 MBR，然后通过 grub 可以 chainloader 启动 windows。现在发现我装了之后并不能启动我的 windows 10 了，就只好研究了一下。&lt;/p&gt;

&lt;h2 id=&#34;gpt-分区&#34;&gt;GPT 分区&lt;/h2&gt;

&lt;p&gt;以前都是 MBR(Master Boot Record) 形式的分区，主分区 4 个，如果想要建更多，需要建扩展分区，然后再在扩展分区里面建立逻辑分区。现在发现有了 GPT(GUID Partition Table) 分区。这个方式呢，比 MBR 方式有好处，支持更多分区，支持大于 2.2TB 容量的磁盘。&lt;/p&gt;

&lt;p&gt;我看我的 windows 10 机器预装就是用的这个分区格式。&lt;/p&gt;

&lt;h2 id=&#34;uefi-系统&#34;&gt;UEFI 系统&lt;/h2&gt;

&lt;p&gt;UEFI(Unified Extensible Firmware Interface) 是基于 BIOS 的 MBR 启动方式不同的东西，是基于单独的 EFI System Partition(ESP) 里面的数据启动的。里面的程序都需要和 UEFI firmware 的 bitness 一致，x86_64 啥的。&lt;/p&gt;

&lt;p&gt;所以我的 windows 10 在 ESP 分区里面已经放了一个自己的起动器。Linux 启动之后，可以查看 &lt;code&gt;/sys/firmware/efi&lt;/code&gt; 看看是不是有，有的话表示 kernel 支持 efi，且和 firmware 的 bitness 一致。&lt;/p&gt;

&lt;p&gt;ESP 分区是 fat16/fat32 格式的，不像 mbr 在固定位置，到底是哪个分区是呢？是通过通过分区的 boot flag 这个标志来识别的。&lt;/p&gt;

&lt;h2 id=&#34;efibootmgr&#34;&gt;efibootmgr&lt;/h2&gt;

&lt;p&gt;Linux 下面可以使用 efibootmgr 管理 efi 菜单，当然得 kernel 支持，主要看 &lt;code&gt;/sys/firmware/efi&lt;/code&gt; 目录吧。具体内核参数可以看&lt;a href=&#34;https://wiki.archlinux.org/index.php/Unified_Extensible_Firmware_Interface#Linux_kernel_config_options_for_UEFI&#34; title=&#34;这个&#34;&gt;这个&lt;/a&gt;。我看着应该是只有通过 efi 启动的系统，才能读取 efi firmware 的信息。否则就算有内核模块也不能读取。&lt;/p&gt;

&lt;p&gt;我还发现我这的机器上面通过 efibootmgr 删除了 windows 的行之后，启动的时候按 F12 出来的启动选项里面还有 windwos，会自动加回来，不知道是主板的保护还是哪里的问题，bios 里面没找到可以关闭这个功能的地方。&lt;/p&gt;

&lt;h2 id=&#34;grub&#34;&gt;Grub&lt;/h2&gt;

&lt;p&gt;grub 支持安装到 MBR 也支持安装到 ESP 分区。不过只是把内容放到那个分区，最后给 efi 加启动的菜单，还需要 efibootmgr，就是需要相应的内核支持。&lt;/p&gt;

&lt;p&gt;类似这样，就是通过 uefi 启动了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# grub-install --target=x86_64-efi --efi-directory=/mnt/sda1 --bootloader-id=GRUB --boot-directory=/mnt/sda4/boot /dev/sda
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以装到 MBR，就是通过传统的 bios 启动。可能需要加 &lt;code&gt;--force&lt;/code&gt; ，我遇到的情况会提示 gpt 分区的 boot flag 没有，我这直接不理他加 force 就可以。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# grub-install --boot-directory=/mnt/sda4/boot /dev/sda
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;grub 实际上是放到第一个分区前面的一部分空间里面的，传统的 MBR 方式分区软件一般会预留 31kb 从第 63 个扇区开始分区。对于 GPT 分区，因为会有一个 ESP 分区，grub 也可以直接利用这个，装到这个分区，ESP 分区会有一个 bootable flag，因为这等于是单独给 grub 用的分区，所以 grub 也不客气会直接覆盖里面的东西，用自己的文件系统格式，一般系统都不支持，这样也可以防止你自己或者被其他软件误操作。所以要注意，如果你打算用 efi 模式启动，那通过第一个方式用 &lt;code&gt;--efi-directory&lt;/code&gt; 把 grub 装到这个分区，或者就还是用 mbr 方式好了。参考&lt;a href=&#34;https://www.gnu.org/software/grub/manual/grub/html_node/BIOS-installation.html#BIOS-installation&#34; title=&#34;这个&#34;&gt;这个&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;加载-windows&#34;&gt;加载 windows&lt;/h2&gt;

&lt;p&gt;我看可以通过 chainloader 加载 windows，也有 ntldr 加载，不太清楚具体区别。chainloader 是通过读取指定设备的块来的，比如 chainloader +1 读第一个块。或者 chainloader /EFI/Microsoft/Boot/bootmgfw.efi。&lt;/p&gt;

&lt;p&gt;UEFI 模式安装的 windows 可以参考&lt;a href=&#34;https://wiki.archlinux.org/index.php/GRUB#Windows_installed_in_UEFI.2FGPT_Mode_menu_entry&#34; title=&#34;这里&#34;&gt;这里&lt;/a&gt;，传统 MBR 方式的，参考&lt;a href=&#34;https://wiki.archlinux.org/index.php/GRUB#Windows_installed_in_BIOS.2FMBR_mode&#34; title=&#34;这里&#34;&gt;这里&lt;/a&gt;，这个用的是 ntldr 的方式，估计用 chainloader +1 应该也可以。&lt;/p&gt;

&lt;h2 id=&#34;怎么通过-uefi-启动-grub&#34;&gt;怎么通过 uefi 启动 grub&lt;/h2&gt;

&lt;p&gt;想要使用 efibootmgr 编辑 efi 的菜单，就得通过 efi 模式启动到一个 linux。那一种方式是找一个支持 efi 启动的 live cd。另外一种是使用一个 &lt;a href=&#34;https://wiki.archlinux.org/index.php/Unified_Extensible_Firmware_Interface#UEFI_Shell&#34; title=&#34;uefi shell&#34;&gt;uefi shell&lt;/a&gt;，可以参考&lt;a href=&#34;https://wdicc.com/uefi-bootable-usb/&#34; title=&#34;这里&#34;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;设备名称是变的怎么办&#34;&gt;设备名称是变的怎么办&lt;/h2&gt;

&lt;p&gt;我发现我这插了 u 盘之后，u 盘就成了 hd0 了，这样写在 grub.cfg 里面的 &lt;code&gt;set root=&amp;quot;(hd0,1)&amp;quot;&lt;/code&gt; 这样的代码就有问题了。grub2 提供了一个 &lt;a href=&#34;https://www.gnu.org/software/grub/manual/grub/grub.html#search&#34; title=&#34;search&#34;&gt;search&lt;/a&gt; 命令来查找你想要的东西，然后把结果设置到一个变量。&lt;/p&gt;

&lt;p&gt;文档里面写了 &lt;code&gt;search.file&lt;/code&gt; 是 &lt;code&gt;search --file&lt;/code&gt; 的 alias，但实际上还有坑在这里。区别的地方看下面&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;search.file /efi/Microsoft/Boot/bootmgfw.efi root
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;search --file /efi/Microsoft/Boot/bootmgfw.efi --set root
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看到区别了吧，那个 root 相当于是自己定义的变量（实际上 grub2 会隐含的用到 root 变量，所以也不能完全说是自己定义的）。我在这个坑上面花了一些时间。&lt;/p&gt;

&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.rodsbooks.com/efi-bootloaders/index.html&#34; title=&#34;Managing EFI Boot Loaders for Linux&#34;&gt;Managing EFI Boot Loaders for Linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.rodsbooks.com/efi-bootloaders/grub2.html&#34; title=&#34;Managing EFI Boot Loaders for Linux: Using GRUB 2&#34;&gt;Managing EFI Boot Loaders for Linux: Using GRUB 2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.gnu.org/software/grub/manual/grub/html_node/Installing-GRUB-using-grub_002dinstall.html&#34; title=&#34;4.1 Installing GRUB using grub-install&#34;&gt;4.1 Installing GRUB using grub-install&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Redux Selector</title>
      <link>https://wdicc.com/redux-selector/</link>
      <pubDate>Sun, 13 May 2018 10:43:28 +0800</pubDate>
      
      <guid>https://wdicc.com/redux-selector/</guid>
      <description>&lt;p&gt;redux 应用可以通过 selector 来做 state -&gt; props 的映射工作。selector 本身有缓存效果，所以可以一定意义上加速。我用的是这个 &lt;a href=&#34;https://github.com/reduxjs/reselect&#34; title=&#34;https://github.com/reduxjs/reselect&#34;&gt;https://github.com/reduxjs/reselect&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;selector 主要是一个纯函数，给同样的输入，得到同样的输出，只处理数据，没有其他附加影响。这样就可以缓存中间结果了。&lt;/p&gt;

&lt;p&gt;新建 selector 有两个方法，一个是直接定义函数，例如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const s1 = (state) =&amp;gt; {
    // 经过计算
    return state.user
}
const s2 = state =&amp;gt; state.data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外一个方法是通过 &lt;code&gt;createSelector&lt;/code&gt; 函数来创建，例如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const s3 = createSelector(s1, s2, (s1, s2) =&amp;gt;{
    // 经过计算
    return xx
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际上 selector 都是一些函数，具体用的是侯会执行这些函数，第一个方法创建的还好理解，第二个方法里面，会传什么参数呢？输入是什么呢？&lt;/p&gt;

&lt;p&gt;实际上，第二个方法定义的 selector 执行的时候类似这样。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const res = s3(s1(state), s2(state))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输入是里面 selector 的输入，然后不停嵌套到最初的数据。这样一个 selector 使用的方法就广泛了。比如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const s1_res = s1(state) // 从其他地方或者逻辑获取到这个值

const res = s3(s1_res, s2(state)) // 直接用来作为 s3 的输入
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Openwrt</title>
      <link>https://wdicc.com/openwrt/</link>
      <pubDate>Sun, 13 May 2018 10:01:39 +0800</pubDate>
      
      <guid>https://wdicc.com/openwrt/</guid>
      <description>&lt;p&gt;前段时间还搞了一下 openwrt 定制，记录一下。&lt;/p&gt;

&lt;p&gt;openwrt 提供了很方便的方式让你可以在 x86 机器上面定制路由器固件，到 &lt;a href=&#34;https://archive.openwrt.org/&#34; title=&#34;https://archive.openwrt.org/&#34;&gt;https://archive.openwrt.org/&lt;/a&gt; 下载对应的源码就可以。&lt;/p&gt;

&lt;p&gt;比如我用的是这个 &lt;a href=&#34;https://archive.openwrt.org/barrier_breaker/14.07/ar71xx/generic/OpenWrt-ImageBuilder-ar71xx_generic-for-linux-x86_64.tar.bz2&#34; title=&#34;https://archive.openwrt.org/barrier_breaker/14.07/ar71xx/generic/OpenWrt-ImageBuilder-ar71xx_generic-for-linux-x86_64.tar.bz2&#34;&gt;https://archive.openwrt.org/barrier_breaker/14.07/ar71xx/generic/OpenWrt-ImageBuilder-ar71xx_generic-for-linux-x86_64.tar.bz2&lt;/a&gt; ， &lt;code&gt;barrier_breaker&lt;/code&gt; 是版本， &lt;code&gt;ar71xx&lt;/code&gt; 是 cpu 架构。解压之后目录类似如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;drwxr-xr-x 12 wd wd 4.0K Mar 29 17:18 .
drwxr-xr-x  3 wd wd 4.0K Mar 26 20:32 ..
drwxr-xr-x  3 wd wd 4.0K Mar 27 10:40 bin
drwxr-xr-x  3 wd wd 4.0K Oct  1  2014 build_dir
-rw-r--r--  1 wd wd  94K Oct  1  2014 .config
drwxr-xr-x  2 wd wd 4.0K Oct  1  2014 dl
drwxr-xr-x  3 wd wd 4.0K Mar 26 20:37 include
-rw-r--r--  1 wd wd 5.0K Sep 21  2014 Makefile
-rw-r--r--  1 wd wd 570K Oct  1  2014 .packageinfo
drwxr-xr-x  4 wd wd 4.0K Oct  1  2014 packages
-rw-r--r--  1 wd wd  331 Oct  1  2014 repositories.conf
-rw-r--r--  1 wd wd  11K Sep 21  2014 rules.mk
drwxr-xr-x  4 wd wd 4.0K Sep 21  2014 scripts
drwxr-xr-x  3 wd wd 4.0K Oct  1  2014 staging_dir
drwxr-xr-x  3 wd wd 4.0K Oct  1  2014 target
-rw-r--r--  1 wd wd 128K Sep 21  2014 .targetinfo
drwxr-xr-x  2 wd wd 4.0K Mar 27 10:40 tmp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译的命令如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make image \
    PROFILE=TLWR703 \
    PACKAGES=&amp;quot;firewall -ip6tables -kmod-ip6tables -kmod-ipv6 -odhcp6c -ppp -ppp-mod-pppoe -liblua -libubus-lua -libuci-lua -luci-app-firewall -luci-i18n-english -luci-lib-ipkg -luci-lib-lmo -luci-lib-sys -luci-proto-core -luci-proto-ppp -luci-sgi-cgi -luci-theme-base -luci-theme-openwrt kmod-mii kmod-usb-net kmod-usb-net-cdc-ether usb-modeswitch curl&amp;quot; \
    FILES=files/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译结果会放在 &lt;code&gt;bin/ar71xx/&lt;/code&gt; 下面&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-rw-r--r-- 1 wd wd  827 May 13 10:08 md5sums
-rw-r--r-- 1 wd wd 2.2M May 13 10:08 openwrt-ar71xx-generic-root.squashfs
-rw-r--r-- 1 wd wd 1.9M May 13 10:08 openwrt-ar71xx-generic-root.squashfs-64k
-rw-r--r-- 1 wd wd 3.8M May 13 10:08 openwrt-ar71xx-generic-tl-wr703n-v1-squashfs-factory.bin
-rw-r--r-- 1 wd wd 2.9M May 13 10:08 openwrt-ar71xx-generic-tl-wr703n-v1-squashfs-sysupgrade.bin
-rw-r--r-- 1 wd wd 1.5M May 13 10:08 openwrt-ar71xx-generic-uImage-gzip.bin
-rw-r--r-- 1 wd wd 1.1M May 13 10:08 openwrt-ar71xx-generic-uImage-lzma.bin
-rwxr-xr-x 1 wd wd 3.2M May 13 10:08 openwrt-ar71xx-generic-vmlinux.bin
-rwxr-xr-x 1 wd wd 3.3M May 13 10:08 openwrt-ar71xx-generic-vmlinux.elf
-rw-r--r-- 1 wd wd 1.5M May 13 10:08 openwrt-ar71xx-generic-vmlinux.gz
-rw-r--r-- 1 wd wd 1.1M May 13 10:08 openwrt-ar71xx-generic-vmlinux.lzma
-rwxr-xr-x 1 wd wd 1.2M May 13 10:08 openwrt-ar71xx-generic-vmlinux-lzma.elf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那个 &lt;code&gt;openwrt-ar71xx-generic-tl-wr703n-v1-squashfs-factory.bin&lt;/code&gt; 就是我那个路由器的出厂固件。简直简单到没法说了。&lt;/p&gt;

&lt;p&gt;前面那个编译命令里面， &lt;code&gt;PROFILE&lt;/code&gt; 是指定要编译的路由器，这个必须得是固件支持的，可以在 &lt;code&gt;target/linux/ar71xx/generic/profiles/&lt;/code&gt; 目录看到。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;00-default.mk  8devices.mk  atheros.mk   buffalo.mk  dragino.mk   ew.mk          jjplus.mk   netgear.mk   pcs.mk      rosewill.mk  tp-link.mk   wd.mk
01-minimal.mk  alfa.mk      atlantis.mk  compex.mk   easylink.mk  gl-connect.mk  linksys.mk  oolite.mk    planex.mk   senao.mk     trendnet.mk  zcomax.mk
02-ath5k.mk    allnet.mk    bhu.mk       d-link.mk   engenius.mk  hiwifi.mk      nclink.mk   openmesh.mk  redwave.mk  sitecom.mk   ubnt.mk      zyxel.mk
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;PACKAGES&lt;/code&gt; 指定了要包含的包，可以在 &lt;code&gt;packages/&lt;/code&gt; 目录下面看到有的包。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;FILES&lt;/code&gt; 指定了自己定义要包含到固件里面的文件。可以把这个目录当作 &lt;code&gt;/&lt;/code&gt; 来放文件，比如你放到 &lt;code&gt;files/abc&lt;/code&gt; 下面的文件，将来会在路由器的 &lt;code&gt;/abc&lt;/code&gt; 下面。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.:
etc

./etc:
banner  config  crontabs  dropbear  run.sh

./etc/config:
dropbear  firewall  network  system  wireless

./etc/crontabs:
root

./etc/dropbear:
authorized_keys
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;后面还给 wr703n 接了一个华为 4g usb E8372h 型号，支持了 4g 上网。需要的包是这些， &lt;code&gt;kmod-mii kmod-usb-net kmod-usb-net-cdc-ether usb-modeswitch&lt;/code&gt; ，华为这个 usb 支持 ether 方式使用，并且 usb-modeswitch 直接就支持，不用自己配置。把 eth1 作为 wan 就可以了。&lt;/p&gt;

&lt;p&gt;中国联通的信道&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;3G: WCDMA Band 1/8&lt;/li&gt;
&lt;li&gt;4G: LTE-FDD 1/3/8  LTE-TDD 40/41&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考的一些文章&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://soha.moe/post/make-4g-wifi-ap-with-openwrt.html&#34; title=&#34;https://soha.moe/post/make-4g-wifi-ap-with-openwrt.html&#34;&gt;https://soha.moe/post/make-4g-wifi-ap-with-openwrt.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://right.com.cn/forum/forum.php?mod=viewthread&amp;amp;action=printable&amp;amp;tid=209854&#34; title=&#34;http://right.com.cn/forum/forum.php?mod=viewthread&amp;amp;action=printable&amp;amp;tid=209854&#34;&gt;http://right.com.cn/forum/forum.php?mod=viewthread&amp;action=printable&amp;tid=209854&lt;/a&gt; 这个论坛里面之前有一个帖子帮助很大没保存&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Develop Plugin for Asuswrt Merlin</title>
      <link>https://wdicc.com/develop-plugin-for-asuswrt-merlin/</link>
      <pubDate>Sun, 13 May 2018 08:03:28 +0800</pubDate>
      
      <guid>https://wdicc.com/develop-plugin-for-asuswrt-merlin/</guid>
      <description>&lt;p&gt;换华硕路由器之后，一直用的是梅林（merlin）的固件（rom）。基于这个固件，有一个 &lt;a href=&#34;http://koolshare.cn/forum-96-1.html&#34; title=&#34;koolshare&#34;&gt;koolshare&lt;/a&gt; 的团队做了很多插件，并且做了一个通用的软件中心，可以方便的管理插件，还挺不错的。&lt;/p&gt;

&lt;p&gt;打算用 v2ray 的时候，就想着如何才能无缝替换掉 ss。因为 v2ray 在路由器上面跑效率不高内存占用比较高，ss 作者开始说不打算支持 v2ray。后来研究了 ss 原理之后发现替换很简单，只需要具备 2 个功能就可以，一个是可以支持 socks 代理，一个是可以透明转发流量的端口。这两个协议在 v2ray 都支持，所以要做的其实就是在启动 ss 相应软件的时候启动 v2ray 的就可以了。&lt;/p&gt;

&lt;p&gt;基于这个逻辑写了一个&lt;a href=&#34;https://gist.github.com/wd/e0bc83b33ce63506a9bdbc3b81658c52&#34; title=&#34;文档&#34;&gt;文档&lt;/a&gt; ，能弄明白的话，自己用应该也够了。后来一时兴起，做了一个&lt;a href=&#34;https://gist.github.com/wd/1445e3fcf0c9bc535a6e70d2de1d1624&#34; title=&#34;改进版&#34;&gt;改进版&lt;/a&gt;。这个版本基本上就傻瓜化了。做的时候对基于 merlin 开发有了一些经验记录一下，发现讲这个的东西不多。&lt;/p&gt;

&lt;h1 id=&#34;一些基础知识&#34;&gt;一些基础知识&lt;/h1&gt;

&lt;p&gt;路由器上面的内容是只读的，修改之后重启就会重置。但是 JFFS 分区里面的内容是会保留的。想要保存数据有两个方法。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;存一个文件放到 JFFS 分区上面。&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;dbus&lt;/code&gt; 命令储存。(这个命令具体会把数据存哪里我还没仔细看。)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;文件方式没什么好说的，储存和读取解析需要你自己做。 &lt;code&gt;dbus&lt;/code&gt; 命令提供了 key-value 的形式储存数据，可以通过例如 &lt;code&gt;dbus list v2ray&lt;/code&gt; 列出来所有 &lt;code&gt;v2ray&lt;/code&gt; 开头的 key 的情况，执行 &lt;code&gt;dbus&lt;/code&gt; 命令不带参数会有使用方法提示。&lt;/p&gt;

&lt;p&gt;一般开发插件还有一个设置也需要开启，就是允许执行 JFFS 的自定义脚本。这个指的是路由器启动的时候，自动执行 &lt;code&gt;/jffs/scripts/&lt;/code&gt; 下面的一些文件，也并不是任意文件都会执行，merlin 自己的 &lt;a href=&#34;https://github.com/RMerl/asuswrt-merlin/wiki/User-scripts&#34; title=&#34;wiki&#34;&gt;wiki&lt;/a&gt; 有比较详细的说明。&lt;/p&gt;

&lt;p&gt;所以实际上一个插件的工作方式实际上是这样&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;路由器启动&lt;/li&gt;
&lt;li&gt;读取 dbus 配置的数据&lt;/li&gt;
&lt;li&gt;执行 &lt;code&gt;/jffs/scripts/&lt;/code&gt; 目录下面相应的脚本&lt;/li&gt;
&lt;li&gt;这些脚本里面会执行你的插件的脚本&lt;/li&gt;
&lt;li&gt;你的脚本会读取 dbus 配置的数据，以及读取你存储的文件&lt;/li&gt;
&lt;li&gt;不管是你的界面还是脚本有新的数据需要保存，通过 dbus 或者文件存下来&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;每次路由器启动都是这样一个从头初始化的过程。&lt;/p&gt;

&lt;h1 id=&#34;基于-koolshare-软件中心的离线包&#34;&gt;基于 koolshare 软件中心的离线包&lt;/h1&gt;

&lt;p&gt;我开发是基于 koolshare 软件中心的，他提供了一个离线安装的功能，以及很多好用的小工具，可以方便开发。想支持离线安装，需要你提供一个 &lt;a href=&#34;https://github.com/wd/koolshare_plugin_v2ray/blob/master/install.sh&#34; title=&#34;install.sh&#34;&gt;install.sh&lt;/a&gt;，你上传的包的名字必须是 &lt;code&gt;name.tar.gz&lt;/code&gt; ， &lt;code&gt;name&lt;/code&gt; 名字还得和解压之后的目录名字对应，有些人多次下载系统可能会给他改成 &lt;code&gt;name(1).tar.gz&lt;/code&gt; 这种会失败。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;install.sh&lt;/code&gt; 里面底部定义的那几个 &lt;code&gt;softcenter_module_v2ray_&lt;/code&gt; 开头的配置是给软件中心用的。 &lt;code&gt;home_url&lt;/code&gt; 是软件中心里面点击你插件的图标的时候打开的页面。&lt;/p&gt;

&lt;p&gt;安装离线包的时候不会自动处理 &lt;code&gt;uninstall.sh&lt;/code&gt; ，需要你自己把这个放到&lt;a href=&#34;https://github.com/wd/koolshare_plugin_v2ray/blob/master/install.sh#L61&#34; title=&#34;对应地方&#34;&gt;对应地方&lt;/a&gt;，并且需要有对的名字。&lt;/p&gt;

&lt;p&gt;整个安装完全是你自己控制自己要做的事情。卸载也一样，需要自己删除自己复制的脚本文件和产生的数据等。&lt;/p&gt;

&lt;h1 id=&#34;界面功能&#34;&gt;界面功能&lt;/h1&gt;

&lt;p&gt;merlin 的界面文件是 &lt;code&gt;.asp&lt;/code&gt; 结尾，里面唯一相关的标记是类似这样的 &lt;code&gt;&amp;lt;% nvram_get(&amp;quot;firmver&amp;quot;); %&amp;gt;&lt;/code&gt; ，不记得是不是 asp 语法里面的东西了。基本上都是一些 js 和 html 的东西。&lt;/p&gt;

&lt;h2 id=&#34;初始化&#34;&gt;初始化&lt;/h2&gt;

&lt;p&gt;一般是在界面的 body 的 onload 方法里面执行&lt;a href=&#34;https://github.com/wd/koolshare_plugin_v2ray/blob/master/webs/Module_v2ray.asp#L463&#34; title=&#34;自己的函数&#34;&gt;自己的函数&lt;/a&gt;。&lt;a href=&#34;https://github.com/wd/koolshare_plugin_v2ray/blob/master/webs/Module_v2ray.asp#L500&#34; title=&#34;这里&#34;&gt;这里&lt;/a&gt;是预留左侧系统原有的导航按钮的地方。&lt;/p&gt;

&lt;h2 id=&#34;保存配置&#34;&gt;保存配置&lt;/h2&gt;

&lt;p&gt;界面里面可以通过 post 给 &lt;code&gt;applydb.cgi&lt;/code&gt; 的方式保存给 dbus，类似&lt;a href=&#34;https://github.com/wd/koolshare_plugin_v2ray/blob/master/webs/Module_v2ray.asp#L251&#34; title=&#34;这里&#34;&gt;这里&lt;/a&gt;。先把表单里面的值都读出来做适当的处理，然后存到 &lt;code&gt;dbus&lt;/code&gt; 这个变量里面， &lt;code&gt;SystemCmd&lt;/code&gt; 定义的是执行 post 的之后需要执行的脚本。 &lt;code&gt;action_mode&lt;/code&gt; 是执行脚本之后界面的动作。&lt;/p&gt;

&lt;p&gt;这个里面你的脚本会被调用，你需要处理的事情，比如保存配置到文件什么的就可以在这里做了。&lt;/p&gt;

&lt;p&gt;这里有一个问题是执行命令的时候，不能得到执行的结果反馈。&lt;/p&gt;

&lt;h2 id=&#34;执行命令的时候显示反馈&#34;&gt;执行命令的时候显示反馈&lt;/h2&gt;

&lt;p&gt;上面保存配置是通过 ajax 异步执行的，ajax 的执行结果立刻就会反馈，脚本调用也是异步的，调用脚本的执行结果需要你自己想办法获取。&lt;/p&gt;

&lt;p&gt;类似我&lt;a href=&#34;https://github.com/wd/koolshare_plugin_v2ray/blob/master/webs/Module_v2ray.asp#L300&#34; title=&#34;这里&#34;&gt;这里&lt;/a&gt;，在 ajax 执行成功之后获取执行的结果。先显示一个图层，在里面再&lt;a href=&#34;https://github.com/wd/koolshare_plugin_v2ray/blob/master/webs/Module_v2ray.asp#L305&#34; title=&#34;无限执行另外一个 ajax&#34;&gt;无限执行另外一个 ajax&lt;/a&gt;，把 ajax 的执行结果放到刚才那个图层里面，这样用户就可以看到了。然后通过检查结果里面是否&lt;a href=&#34;https://github.com/wd/koolshare_plugin_v2ray/blob/master/webs/Module_v2ray.asp#L316&#34; title=&#34;包含特定字符&#34;&gt;包含特定字符&lt;/a&gt;来判断脚本是不是执行完毕。&lt;/p&gt;

&lt;p&gt;ajax 请求的是一个 &lt;a href=&#34;https://github.com/wd/koolshare_plugin_v2ray/blob/master/webs/Module_v2ray.asp#L307&#34; title=&#34;url&#34;&gt;url&lt;/a&gt;，这个 url 对应的文件是&lt;a href=&#34;https://github.com/wd/koolshare_plugin_v2ray/blob/master/res/v2ray_status.htm&#34; title=&#34;这个&#34;&gt;这个&lt;/a&gt;。里面其实很简单，就是把 &lt;code&gt;/tmp/v2ray_status.log&lt;/code&gt; 的内容显示出来。&lt;/p&gt;

&lt;p&gt;所以通过这个方式，上面的脚本自需要把想要反馈的内容放到这个 log 文件就可以了，整个逻辑就这样。我这里为了简单所有的脚本执行都复用了这个 log 文件，所以为了避免被上次执行的命令影响，每次执行脚本写入这个文件前都先把这个文件里面的历史数据清楚掉。&lt;/p&gt;

&lt;h2 id=&#34;其他命令执行结果的方式&#34;&gt;其他命令执行结果的方式&lt;/h2&gt;

&lt;p&gt;merlin 还提供了一个 &lt;code&gt;apply.cgi&lt;/code&gt; 可以执行脚本，例如&lt;a href=&#34;https://github.com/wd/koolshare_plugin_v2ray/blob/master/webs/Module_v2ray.asp#L136&#34; title=&#34;这里&#34;&gt;这里&lt;/a&gt;。我忘记是不是同步执行的了，好像是命令执行完毕之后才会执行 ajax 的回调。&lt;/p&gt;

&lt;p&gt;依然还是通过请求刚才那个 &lt;code&gt;/res/v2ray_status.html&lt;/code&gt; 文件来&lt;a href=&#34;https://github.com/wd/koolshare_plugin_v2ray/blob/master/webs/Module_v2ray.asp#L147&#34; title=&#34;取结果&#34;&gt;取结果&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;这里还不有一个坑，如果长时间没有从登录界面进入过路由器管理界面，那执行这个可能会遇到获取到的数据是一个 html 的到 Login 页面的 redirect。&lt;/p&gt;

&lt;h2 id=&#34;读取保存的数据&#34;&gt;读取保存的数据&lt;/h2&gt;

&lt;h3 id=&#34;通过-js-读取&#34;&gt;通过 js 读取&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;/dbconf?p=v2ray&amp;amp;v=&amp;lt;% uptime(); %&amp;gt;&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那个 p 会只显示匹配那个前缀的数据。上面这个 url 直接打开看看就知道了，会产生一个 &lt;code&gt;db_v2ray&lt;/code&gt; 这个变量。在界面里面就可以使用例如 &lt;code&gt;db_v2ray[&amp;quot;v2ray_module_version&amp;quot;]&lt;/code&gt; 来获取 dbus 的数据了。&lt;/p&gt;

&lt;h3 id=&#34;通过页面标签获取&#34;&gt;通过页面标签获取&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;input type=&amp;quot;hidden&amp;quot; id=&amp;quot;ss_basic_enable&amp;quot; name=&amp;quot;ss_basic_enable&amp;quot; value=&amp;quot;&amp;lt;% dbus_get_def(&amp;quot;ss_basic_enable&amp;quot;, &amp;quot;&amp;quot;); %&amp;gt;&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如上面这个，通过 &lt;code&gt;&amp;lt;% dbus_get_def()/&amp;gt;&lt;/code&gt; 这样的标签就可以获取到相应的变量。&lt;/p&gt;

&lt;h1 id=&#34;cron&#34;&gt;Cron&lt;/h1&gt;

&lt;p&gt;如果想要定时执行一些任务，可以添加 cron。merlin 管理界面的用户不一定都是 admin，所以 cron 的用户也不一定是什么，可以用 &lt;code&gt;cru&lt;/code&gt; &lt;a href=&#34;https://github.com/wd/koolshare_plugin_v2ray/blob/master/scripts/v2ray_watchdog.sh#L91&#34; title=&#34;命令&#34;&gt;命令&lt;/a&gt;来管理 cron。&lt;/p&gt;

&lt;h1 id=&#34;自己的启动脚本&#34;&gt;自己的启动脚本&lt;/h1&gt;

&lt;p&gt;前面也说过，可以放到&lt;a href=&#34;https://github.com/RMerl/asuswrt-merlin/wiki/User-scripts&#34; title=&#34;这些对应的脚本&#34;&gt;这些对应的脚本&lt;/a&gt;里面。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Self Hosted Blog</title>
      <link>https://wdicc.com/self-hosted-blog/</link>
      <pubDate>Fri, 06 Apr 2018 14:59:49 +0800</pubDate>
      
      <guid>https://wdicc.com/self-hosted-blog/</guid>
      <description>&lt;p&gt;给 checked 的一个反馈。&lt;/p&gt;

&lt;p&gt;给播客写反馈是个很奇怪的事情，当我听完博客觉得心潮澎湃的写反馈的时候，其实主播们应该已经对那些说过的事情的兴趣估计已经没有了。所以感觉是像是一个很激动兴奋的人找别人聊天，结果人家波澜不惊的和你说：嗯嗯嗯。。一样。。&lt;/p&gt;

&lt;p&gt;有两点反馈，一点关于文章格式，一点关于自建博客。&lt;/p&gt;

&lt;p&gt;语言这个东西，发明出来就是为了交流用的，如果某种流行的东西有助于交流，那我觉得没有什么问题。比如空行代替头部空两个字，感觉好很多。比如使用 &#39;。。。。&#39; 代替 &#39;……&#39; 也没什么（其实是给我下面标点乱用打埋伏。。。:p ）。&lt;/p&gt;

&lt;p&gt;直角引号的讨论有很多，随便搜了&lt;a href=&#34;https://www.zhihu.com/question/19589668&#34; title=&#34;一个&#34;&gt;一个&lt;/a&gt; 。我记得最早流行这个好像就是知乎，后来搜狗输入法还提供了一个选项是在知乎输入引号的时候输入直角引号。我个人喜欢看直角的，因为很多时候那个蝌蚪样子的，有好几个编码，比如 ‘ ’、“ ”、&#39; &#39;、&#34; &#34;、 这几个都是半角的，左右不好区分开。但是直角的，再怎么也比较好区分左右，并且对竖排文字，比如广告图什么的里面也很有好。可以参考下&lt;a href=&#34;https://zh.wikipedia.org/wiki/%25E5%25BC%2595%25E5%258F%25B7&#34; title=&#34;这个&#34;&gt;这个&lt;/a&gt; 。&lt;/p&gt;

&lt;p&gt;下面聊自建博客。这个 20 年前我和 hum 的看法是一样的，有病才去自己弄，需要自己搞服务器，自己维护，成本很高。但是使用别人搞的，也并不是没有问题。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;网站倒闭。最初的 MSN Live Space，然后新浪博客，然后国外的 wordpress，然后国内牛博网等等很多，那会博客风起来的时候，非常多这种网站，目前这些都不能访问或者死掉了。死掉的时候，你的文章怎么办？良心一点的提供一个导出，要不然就是你自己想办法解决。写的时候可能文本，最后拿到的没准是一堆的 HTML，很难处理。&lt;/li&gt;
&lt;li&gt;流氓的版权协议。国内各大网站都会要你发的帖子的著作权，可以找找看有没有说版权归你，使用的时候会找你协商以及给你版权费的。&lt;/li&gt;
&lt;li&gt;格式样式不可控。各网站都有自己的风格，比如我们程序员经常会想贴一点代码，想要一个高亮，但是人家不给你提供的话，你就很难做到。还有比如想要在文章顶部显示一个大纲方便看的人一目了然的需求。不过目前因为 markdown 的兴起，还算是对程序员友好，也算有希望统一这个格式的问题。同时 markdown 还能一定意义上解决上面提到的导出迁移的问题（当然，前提是人家让你导出），不过呢，还有另一个问题是 markdown 原定的标准实际是个残废，很多常用的东西都不支持，比如表格，比如 footnote，然后各家必定会对他扩展，那就会导致你从这家导出来的别家不一定支持。这里顺便安利一下 org-mode。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我自己使用自建博客很多年了，以后应该也不会使用其他商业的博客。我自己的博客的用途是留存我自己的经历，本身只分享文本内容，因为图片的流量问题，一般免费服务的空间都会限制，这些图片你自己维护起来也很费劲。就算是付费的，也很少有终身的，以后的事情谁能说的清。所以我都是用文字来表达，好处一方面是整站打包也就几M，另一方面，分享出去的东西别人也很方便的可以留存。&lt;/p&gt;

&lt;p&gt;如果用途不止我那个，那平台名气是可以借用的，用平台肯定是最好的选择。&lt;/p&gt;

&lt;p&gt;自建博客目前其实也很简单，空间在 github 开个账号就可以，只需要传 HTML 内容就可以，可以通过一些工具把文章转成 HTML 就可以。就算没有这种商业服务，自己搞一个 vps 跑一个 nginx 之类的，服务这些 HTML 也是一个很简单的事情。比如我用的是 hugo，支持 markdown，org-mode。类似的还有 hexo。&lt;/p&gt;

&lt;p&gt;最后说忍不住补充一下 org-mode。org-mode 一直被认为是 Emacs 用户才能用，其实并不是，目前也也有一些支持他的文本处理工具，比如 hugo 和 pandoc 就支持 org-mode 文件输入，输出 HTML。目测目前 markdown 的那个表格就是学习的 org-mode 的，org-mode 的表格还支持写公式计算。别的不多说了，org-mode 基本是 markdown 的一个超集，有兴趣可以了解一下。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Beijing Traffic</title>
      <link>https://wdicc.com/beijing-traffic/</link>
      <pubDate>Fri, 06 Apr 2018 14:51:19 +0800</pubDate>
      
      <guid>https://wdicc.com/beijing-traffic/</guid>
      <description>&lt;p&gt;给比特新声的一个反馈，记录一下。&lt;/p&gt;

&lt;p&gt;北京最初的时候，应该只有二环里面四个区（崇文，宣武，东西城）可能才算城区，后面慢慢的，加上海淀，朝阳等几个区，那会通州区还是通县，类似的大兴，密云县。到目前的大北京的情况，东边繁华地带都和河北接壤了（就是燕郊）。&lt;/p&gt;

&lt;p&gt;北京实在太大了。&lt;/p&gt;

&lt;p&gt;我在中关村上班的时候，家在东五环外面，去公司上班，开车单程需要 35 公里。快的话 40 分钟，慢的话 1.5 小时。我也有同事住在燕郊，长阳，你们可以查查有多远。&lt;/p&gt;

&lt;p&gt;大概 10 年左右，我从中关村 7 点下班了开车回家是 40 分钟。基本不堵车，全程 4 环加 5 环路，基本没有红绿灯，开的还是挺快的。但是现在就不行了，即使在 1/5 车限行的情况下，堵车也很厉害。可能只有单双号还能和以前一比了。&lt;/p&gt;

&lt;p&gt;北京特别大，但是走哪里都有一个比较集中的生活区，会有一些大的商场，超市，方便你购买生活用品和吃饭。但是随着年轻人不在家里做饭或者很少做饭，这些商场现在也是人满为患，到了饭点吃饭基本都需要排队。&lt;/p&gt;

&lt;p&gt;北京喜欢建大路。二环到现在的六环。这种规划我认为比较脑残，可能能体现出来一些气派的感觉，毕竟第一次看到能让 10 辆车并行通过的路，还是会觉得：哇，比我们那的土路确实牛逼多了。这种路，刚修好的几年里面，确实会爽，只要开上去，一路没有红绿灯困扰，不堵车还是挺快的。尤其领导开上来的时候，把路一封，其他车上不来，领导的自豪感估计挺强的。&lt;/p&gt;

&lt;ol&gt;
说说脑残的地方。
&lt;li&gt;这种路非常怕扰动。为了快速，肯定要减少出入口，因为车辆出入的时候，速度肯定会比较慢，多了就容易影响其他不出入的车。这样，一旦遇到点情况，大家都出不去，只能在里面堵着。我说的情况包括不限于车祸，恶劣天气，路况的变化。&lt;/li&gt;
  这种路一般都有应急车道。但是有时候遇到比如桥梁啥的，可能那一小段会没有应急车道。而就这个情况，会导致拥堵。怎么发生的呢？车辆一旦稍微多一点，就会有车开应急车道，这些车到了没有应急车道的地方，必然需要并到路里面来，因为车辆本身多，他一并入，必然导致后车需要减速让行，然后连锁反应，后面的车觉得这个车道好像比旁边的车道慢，就会并入旁边车道或者进入应急车道。恶性循环，而这个情况的出现，可能值需要一辆走应急的车来触发一下，这条路立刻就不行了。
  讲一个搞笑的事情，我每天都路过环路的一个桥，这个桥就没有应急车道。而且这个桥上桥是个上坡，那一些货车到了这里就起不来速度，就会导致这个地方产生那个连锁反应开始拥堵。这个拥堵，一般到了下桥的地方就恢复了。感觉道路设计应该也是一个比较有意思的事情。
  五环路之前是收费的，所以出入口就更加少了，每次开上去遇到堵车都没有办法绕开。
&lt;li&gt;过马路很头大。马路太宽，要么建天桥，要么地道，或者就是绕道到一个立交桥的地方过。拿着重物的话，天桥和地道上下会觉得不方便。绕道立交桥又会比较远。很难受。&lt;/li&gt;
  这里还想起来另外一个事情，就是北京也喜欢建大的小区。然后小区物业为了管理方便，自然把能关的门都关掉，这样可以开那么几个门派少量的保安看着。如果一个小区在大路边上，大概率是没有临路的门的，所以过了马路还得绕道到另外一边进小区。
&lt;li&gt;这种大路，还会导致临路的屋子住的很难受。大路上面一般车多且速度快，噪音很大，灰尘也很大。&lt;/li&gt;
&lt;li&gt;这个因为一旦开上去后路就比较，往往都是一直大路开就可以，所以这个很多人会首选往这里开，尤其新手怕开错路，这也就导致这种路更容易拥堵。而且，因为修大路会导致很多小路给大路让行，在小路上面开很难受。&lt;/li&gt;
  也因为这个思路，主路一旦堵了之后，很多排队上主路的车，会继续把辅路也堵住。然后往那些方向走的路就彻底都废掉了。
&lt;/ol&gt;

&lt;p&gt;上面是我觉得几个大路不好的地方。我 6 月份去上海，发现很喜欢上海的路。另外当时觉得上海好像比北京小多了。我是住在静安寺附近，去了田子坊，人民公园，外滩一路玩，发现骑摩拜就可以。&lt;/p&gt;

&lt;p&gt;上海的路大都有树荫，骑车很舒服。自行车道也都有，另外很多的单行线。和香港的路有点类似。不知道像北京这么大的城市，是不是也适合这样的设计。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Bitcoin</title>
      <link>https://wdicc.com/bitcoin/</link>
      <pubDate>Sun, 25 Mar 2018 20:10:44 +0800</pubDate>
      
      <guid>https://wdicc.com/bitcoin/</guid>
      <description>&lt;p&gt;比特币上万刀一个之后，简直已经没人不知道这个东西了。有的东西只要号称要搞比特币，股票就得涨 30%。我简单讲讲我的理解。&lt;/p&gt;

&lt;ul&gt;
比特币相关概念，有两个重要的要点。
&lt;li&gt;区块链&lt;/li&gt;
&lt;li&gt;去中心化&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;区块链&#34;&gt;区块链&lt;/h2&gt;

&lt;p&gt;大家都知道区块链是一个账本。普通的账本，比如银行存折，每笔交易都会记录本次交易的金额，也会记录操作之后的余额。这样多次交易之后，你也无法只修改其中一条记录，因为一旦修改，和这条记录之后的记录就对不上了。但是其实抛开存折这回事的话，在你的记录中间插入一些记录是没有人会发现的。不过我们因为有存折，存折上面一行记录一条记录，中间也没法插入其他的。但是目前存折其实用的人不多了。&lt;/p&gt;

&lt;p&gt;区块链的特点是把一些数据以链条一样的形式串起来。不过和链条有区别的地方是，链条每个节点是相同的，其实切断链条，取掉一个节点，然后接上，看着并没有什么不同。但是区块链任何一个节点都是不同的，去掉一个，后面的就无法连接起来了。因为每一个节点都是唯一的，且每一个节点都包含了他上一个节点的信息。某一个节点丢失或者被修改，那下一个节点保存的这个节点的信息和实际情况就对不上了。&lt;/p&gt;

&lt;p&gt;这样的一个链条下来，能达到防止中间某条记录被篡改，保证了数据的可靠性。&lt;/p&gt;

&lt;h2 id=&#34;去中心化&#34;&gt;去中心化&lt;/h2&gt;

&lt;p&gt;我们的账本，交易记录，大多是存放在银行的。银行开放了一些接口可以让你查账。但是实际上如果银行如果记录了一笔你认为错误的记录，你很难提供一个方法来证明银行出错了。这个就是中心化的方式存在的问题。当然，现实环境里面，银行也不会主动去做损坏自己名誉的事情，比如做假账错账。银行也会想办法防止自己内部的员工因为某些自己的目的来作恶，比如系统会记录各种审计记录，系统开发人员和使用人员权限分离，使用的时候需要授权鉴权等，这些都是防止银行自己出错的措施。&lt;/p&gt;

&lt;p&gt;去中心化，就是把银行这个节点拿掉，所有参与记账的人员（就是旷工）都共享一份账本。每个人都可以验证账本数据的正确性，大家互相不信任，通过博弈来实现这个账本的记录和传递。&lt;/p&gt;

&lt;p&gt;因为去中心化，大家数据同步是需要时间的，那么实际上一个账本的记录走向是会分叉的，一个博弈是大家都会挑选长的分支走。因为如果其他旷工不选短的，那么他自己选短的链条对他没有任何好处，他将得不到自己的挖矿奖励。所以旷工都会保证自己确认的交易都是没问题的。那么整个网络才是一个可信的，可持续的。&lt;/p&gt;

&lt;p&gt;如果是有大量的旷工（算力）联合起来了，那么其实他们就可以控制链条走向了。现在很多时候挖矿是加入了矿池，走向可能是会被矿池控制的。&lt;/p&gt;

&lt;p&gt;目前很多的公司都搞区块链，基本都不讲如何实现去中心化，如果没有去中心化，那还是一个大公司记录的话，实际上只是是用了一部分比特币的概念。没有去中心化思维的区块链就是耍流氓，千万别信。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>BJ Chinaunicom Iptv</title>
      <link>https://wdicc.com/bj-chinaunicom-iptv/</link>
      <pubDate>Sun, 25 Mar 2018 09:21:39 +0800</pubDate>
      
      <guid>https://wdicc.com/bj-chinaunicom-iptv/</guid>
      <description>&lt;p&gt;刚入住现在的房子的时候，只有朝阳有线，当时还没有高清台，机顶盒也很烂。后来大家争取来了歌华有线，好了很多。再之后，我买了华为盒子之后，发现有线电视简直就是情怀了，很少开了，都是在线看视频。尤其后来装了一个 HDP 直播之后，电视节目也可以看了，就更少开有线了。就去把有线盒子给退了。&lt;/p&gt;

&lt;p&gt;有段时间岳母在北京住着，离不开有线，HDP 直播很不稳定，节目有时候还打不开什么的，岳母老抱怨。后来想起来，装了北京联通宽带好像会送一个 iptv 的盒子，可以看电视节目。就联系了一下联通，给过来装了一个盒子。&lt;/p&gt;

&lt;p&gt;这个盒子只能直接接到光猫的 lan4 口，我的上网的路由器是接在 lan1 口的。盒子虽然支持无线，但是不能直接连我 lan1 口的路由器。这个盒子有自带的遥控器，不好用，并且系统里面会诱导你用点播什么的，不是很爽。前段时间看到一个水木的&lt;a href=&#34;http://www.newsmth.net/bbscon.php?bid=1050&amp;amp;id=757772&amp;amp;ftype=3&amp;amp;num=3435&#34; title=&#34;帖子讲折腾 iptv 的&#34;&gt;帖子讲折腾 iptv 的&lt;/a&gt; ，自己想尝试在任意设备看，就了解了一下。&lt;/p&gt;

&lt;p&gt;光猫有的带路由功能，可以直接光猫拨号，以及可以登录后台修改网络结构。有的不带，等于啥功能都没有。IPTV 和通常的上网通道在猫里面是隔离的，不同的 vlan 走不同的网络。所以这也是为什么盒子只能接 lan4，而且这个 lan4 口并不能正常的访问我们的互联网，限制了只能访问那个 iptv 运转需要的网络。而 lan1 可以访问互联网，但是不能访问 iptv 的网络。我家的电视和光猫分别在客厅的两个面对的墙，因为盒子只能直连光猫，那光猫到盒子，盒子到电视都必须是有线，经过客厅线就没法走了。类似下面这样的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;光猫 lan4 --- 网线 ---&amp;gt; iptv 盒子 --- HDMI ---&amp;gt; 电视
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;后来找到了一个通过电力猫解决的办法。买一对就可以了。类似下面这样。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;光猫 lan4 -- 网线 --&amp;gt; 电力猫1  ........电网..... 电力猫2 ---- 网线 ---&amp;gt;  iptv 盒子 ---- HDMI ---&amp;gt; 电视
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样基本就可以了。但是那个盒子用起来不爽，所以打算折腾一下。按照那个帖子我试了，我这无法配置光猫，无法控制光猫的 ip 段。这样那个方案似乎就没法用了。后来又找了一些方案，比如&lt;a href=&#34;https://github.com/phorcys/merlin-BJ-Unicomm-IPTV-scripts&#34; title=&#34;这个方案&#34;&gt;这个方案&lt;/a&gt;可以单路由搞这个事情，但是我发现也有问题，里面需要知道光猫里面的 vlan 划分，我这没法知道，也没法弄了。&lt;/p&gt;

&lt;p&gt;后来发现了&lt;a href=&#34;http://www.newsmth.net/bbscon.php?bid=1050&amp;amp;id=760517&#34; title=&#34;另外一个思路&#34;&gt;另外一个思路&lt;/a&gt;，解决了我的问题。线路连接思路大概如下。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;光猫 lan1 -- 主路由 WAN
光猫 lan4 -- 辅路由 WAN
辅路由 LAN（任意一个口） --- 主路由 LAN（任意一个口）
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后主路由就以前的设置就可以，假设主路由的 LAN 的网段是 192.168.8.x。辅路由需要设置几个地方。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;辅路由 LAN 关闭 DHCP。辅路由 LAN 部分 ip 比如设置为 192.168.8.4 (数值可以自己定，不要和其他设备 ip 冲突了)。&lt;/li&gt;
&lt;li&gt;辅路由 LAN 里面设置 IPTV 的 Udpxy 端口比如 8012。&lt;/li&gt;
&lt;li&gt;辅路由 WAN 设置为通过 DHCP 自动获取 ip。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这个时候，连接到主路由的设备应该就可以通过访问 192.168.8.4 来访问到辅路由的配置界面了。到&lt;a href=&#34;https://opengg.github.io/bj-unicom-iptv/&#34; title=&#34;这里&#34;&gt;这里&lt;/a&gt; udpxy address 输入 192.168.8.4:8012 生成一个 m3u 列表，就可以在连接到主路由的设备里面，通过各种支持的软件里面看了。&lt;/p&gt;

&lt;p&gt;如果还想使用 iptv 看，可以在 iptv 的无线设置里面连接辅路由的无线就可以。&lt;/p&gt;

&lt;p&gt;这个方案巧妙的使用了路由器自带的交换机功能，把主路由和辅路由放到了一个 LAN 里面。虽然多了一个路由器，但是节省了电力猫，iptv 盒子，电视的一个 HDMI 口。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
