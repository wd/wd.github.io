<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Home on wd and cc</title>
    <link>https://wdicc.com/</link>
    <description>Recent content in Home on wd and cc</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 26 Nov 2017 09:19:11 +0800</lastBuildDate>
    
        <atom:link href="https://wdicc.com/atom.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Best Practice for React-Native and Redux</title>
      <link>https://wdicc.com/best-practice-for-react-native-redux/</link>
      <pubDate>Sun, 26 Nov 2017 09:19:11 +0800</pubDate>
      
      <guid>https://wdicc.com/best-practice-for-react-native-redux/</guid>
      <description>&lt;p&gt;从 6 月到现在，在 RN 上面摸爬滚打了一段时间了，目前总算找到了一个适合我们自我感觉还可以的开发模式。&lt;/p&gt;

&lt;p&gt;一开始，我们使用的是传统的 React 的模式，然后一个 app 页面一个文件，通过 StackNavigator 组合到一起。这么做在我们的第一个 app 里面没觉得有什么问题，每个页面维护自己的数据，页面之间需要数据共享或者通讯的时候（比如从 list 到详情页面的时候，详情里面有一个改变状态的按钮，状态改变之后希望 list 的状态也跟着变化，这样用户返回之后能看到正确的数据）有 2 个方式。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;通过 DeviceEventEmitter。&lt;/li&gt;
  需要数据的页面订阅，然后在其他页面 emit event 之后前面的页面就可以收到。这个时候可以只通知改变的数据的字段，前一个页面直接去修改，这样可以避免重新刷新页面。也可以发一个简单的通知让其他页面去自己获取数据。
&lt;/ul&gt;

&lt;ul&gt;
&lt;li&gt;通过 navigator 提供的 params 属性。&lt;/li&gt;
  StatckNavigator 提供了一个 params 属性。就是 &lt;code&gt;this.props.navigation.state.params&lt;/code&gt; ，可以通过 setParams 来改变，或者通过类似 &lt;code&gt;this.props.navigation.navigate(&#39;Login&#39;, {goBackToHome: true})&lt;/code&gt; 的方式给，那个 &lt;code&gt;goBackToHome&lt;/code&gt; 将来就会在 params 里面。
&lt;/ul&gt;

&lt;p&gt;直到我们开始做第二个 app。&lt;/p&gt;

&lt;p&gt;第二个 app 是一个单页面 app，登录之后就只有一个页面了，有一个大地图，有左侧 sidebar，sidebar 里面的按钮点击还会出其他页面。这个肯定不能按照我们前面的思路来做了，我们按照组件，拆分了不同的文件，然后组合起来。这个时候更加会需要页面之间的通讯，并且这个时候可选项只有第一个了 &lt;code&gt;DeviceEventEmitter&lt;/code&gt; ，因为都没有 navigate 什么事情。&lt;/p&gt;

&lt;p&gt;这个时候就发现一个问题，event 太多了，开始有点混乱了。emit event 之后，慢慢会发现不知道哪里有订阅，不好管理。这个 app 做完之后，就仔细研究了一下 redux。&lt;/p&gt;

&lt;p&gt;其实写第一个 app 的时候就知道 redux，但是很多概念看的云里雾里的，当时在 react 还没有吃透的情况下，根本没有能力把 redux 搞好。所以当时放弃了 redux。&lt;/p&gt;

&lt;p&gt;了解 redux 之后，感觉这个东西是我们的药。统一的 state 管理，这不就不用考虑状态传递了么？所以一门心思开始研究 redux。刚好我们第一个 app 需要全新改版，我们就借机把我们的第一个 app 也重构到了 redux 实现。整体过程还是蛮舒服的，自己也总结了几条我们自己的使用的思路。&lt;/p&gt;

&lt;h3 id=&#34;目录结构安排&#34;&gt;目录结构安排&lt;/h3&gt;

&lt;p&gt;先大概看看我们 app 的目录结构。我们把所有的 js 文件都放到了 app 目录下面。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
app
ios
android
index.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后 app 目录下面，分了 &lt;code&gt;actions&lt;/code&gt; ， &lt;code&gt;reducers&lt;/code&gt; ， &lt;code&gt;sagas&lt;/code&gt; ， &lt;code&gt;selector&lt;/code&gt; 几个目录。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
actions
images
index.js
reducers
sagas
screens
selectors
utility
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;actions 里面放的是 mapDispatchToProps 这个逻辑对应的东西。&lt;/li&gt;
&lt;li&gt;reducers 里面放的是 reducers。&lt;/li&gt;
&lt;li&gt;sagas 里面放的是所有网络请求相关的 actions 的处理逻辑。&lt;/li&gt;
&lt;li&gt;seelctor 里面放的是 mapStateToProps 这个逻辑对应的东西。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每个目录里面也都有一个自己的 index.js 把本目录里面的内容组合起来。通过最外面的 index.js 把这几个目录的逻辑组合起来。&lt;/p&gt;

&lt;h3 id=&#34;给页面设计一个基类&#34;&gt;给页面设计一个基类&lt;/h3&gt;

&lt;p&gt;这样会比较方便你去做一些所有页面都需要做的事情。&lt;/p&gt;

&lt;h3 id=&#34;一个-app-一个统一的-store&#34;&gt;一个 app 一个统一的 store&lt;/h3&gt;

&lt;p&gt;我们 app 还不大，所以这么设计也还好，如果页面比较复杂，我看也有组件使用自己的 store 的例子，这个还没有经验。这么做唯一一个问题就是，那个 store 里面的数据一直都在，多少会占用一些内存。不过我是觉得没啥了，其实这点内存占用不算啥。&lt;/p&gt;

&lt;h3 id=&#34;store-设计和页面无关&#34;&gt;store 设计和页面无关&lt;/h3&gt;

&lt;p&gt;Store 参考了一个文章统一设计，和页面无关。比如我们设计了 user, orders, orderDetail 这些 state，数据所有页面共享。否则如果按照页面来划分的话，某些页面之间如果有用到共享数据就要么多复制一份，那有点浪费了，要么就是会有点乱。&lt;/p&gt;

&lt;h3 id=&#34;每个页面都使用自己的-props&#34;&gt;每个页面都使用自己的 props&lt;/h3&gt;

&lt;p&gt;不在页面间交叉使用 props ，这样不会乱。并且因为我们是一个统一的 store，所以其实每次 props 变化，所有页面都会 render。这个我使用下面的一个思路来解决了。&lt;/p&gt;

&lt;h3 id=&#34;shouldcomponentupdate&#34;&gt;shouldComponentUpdate&lt;/h3&gt;

&lt;p&gt;这个就是在页面的基类里面，通过比较判断本页面的 props 是否有变化来解决前面那个 render 问题。&lt;/p&gt;

&lt;h3 id=&#34;使用-reselect&#34;&gt;使用 reselect&lt;/h3&gt;

&lt;p&gt;因为只要 state 发生变化 redux 就会调用 mapStateToProps 来计算 props，这个计算有一些消耗，毕竟一般也就其中一个页面的 props 需要计算。我们用这个 reselect 解决这个问题，一个页面的 props 需要的 state 没变化的时候，reselect 就可以把 cache 的数据直接返回就好了。&lt;/p&gt;

&lt;h3 id=&#34;适当使用页面的-state&#34;&gt;适当使用页面的 state&lt;/h3&gt;

&lt;p&gt;redux 的理念是所有页面的 state 都放到了 store 里面，你不需要做 setState 动作了。但是实际上有些时候适当使用 state 会让你的开发更加方便。比如表单验证，用户输入数据之后点击提交 ，如果通过发送 action 改变 state 然后再通过 selector 返回页面，那就有点太费劲了。而直接通过 setState 设定页面 state，然后在提交表单的时候读出来做验证就简单多了。&lt;/p&gt;

&lt;p&gt;有时候页面的一些 state 是和 props 有关系的，这个时候可以使用 &lt;code&gt;componentWillReceiveProps(nextProps)&lt;/code&gt; 来判定，然后和 state 同步。&lt;/p&gt;

&lt;h3 id=&#34;android-的返回按钮处理&#34;&gt;Android 的返回按钮处理&lt;/h3&gt;

&lt;p&gt;android 有一个实体的返回按钮，StackNavigator 给出的&lt;a href=&#34;https://reactnavigation.org/docs/guides/redux#Handling-the-Hardware-Back-Button-in-Android&#34; title=&#34;方案&#34;&gt;方案&lt;/a&gt;是监听一个 &lt;code&gt;hardwareBackPress&lt;/code&gt; 事件，然后 &lt;code&gt;dispatch(NavigationActions.back())&lt;/code&gt; ，但是有一个问题是，有时候我们返回的时候还需要做一些自己的动作。比如清理 store 的数据，或者判断一下往哪里返什么的，比如用户刚提交了订单之后，给了一个按钮可以看订单详情，这个时候从详情返回就希望直接到首页，不要又返回新建订单的页面。&lt;/p&gt;

&lt;p&gt;我们通过下面的思路做的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
    onBackPress = () =&amp;gt; {
        const { dispatch, nav } = this.props;

        if (nav.index === 0) {
            return false;
        }
        const {routes} = nav;
        const {params} = routes[routes.length-1]

        if(params &amp;amp;&amp;amp; params.goBack) {
            params.goBack();
        } else {
            dispatch(NavigationActions.back());
        }
        return true;
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在页面的基类里面&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
    constructor(props) {
        super(props);
        if (this.goBack)
            this.props.navigation.setParams({ goBack: ()=&amp;gt;this.goBack() })
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后页面里面如果有自己的特殊逻辑，那就实现一个 &lt;code&gt;goBack&lt;/code&gt; 方法就好了。&lt;/p&gt;

&lt;h3 id=&#34;参考文章&#34;&gt;参考文章&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://wdicc.com/11-mistakes-during-use-react-native/&#34; title=&#34;11-mistakes-during-use-react-native&#34;&gt;11-mistakes-during-use-react-native&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Podcasts 推荐</title>
      <link>https://wdicc.com/podcasts/</link>
      <pubDate>Sat, 25 Nov 2017 11:38:37 +0800</pubDate>
      
      <guid>https://wdicc.com/podcasts/</guid>
      <description>

&lt;p&gt;也不知道从什么时候开始听播客的，现在几乎是 podcast 的重度用户。听播客比看东西省力，以前是上下班的时候想休息一下眼睛就听播客，现在每天开车上下班没法看东西，所以听的更多了。推荐一些我自己听的，下面排序是随机的，和推荐度无关。&lt;/p&gt;

&lt;h2 id=&#34;中文播客&#34;&gt;中文播客&lt;/h2&gt;

&lt;h3 id=&#34;迟早更新&#34;&gt;迟早更新&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://www.weareones.com/2&#34;&gt;http://www.weareones.com/2&lt;/a&gt; 这个是个夫妻档，主播任宁刚 30 岁，但是知识面还是挺广的，播客里面的内容很广，但是多与科技有些关系。主播枪枪和他是夫妻，挺有意思的。更新比较快，基本每周都有。&lt;/p&gt;

&lt;h3 id=&#34;teahour&#34;&gt;Teahour&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://teahour.fm/&#34;&gt;http://teahour.fm/&lt;/a&gt; 这个播客经常会请一些比较厉害的开发者和创始人来做访谈，谈的内容也基本是在科技圈。不过最近更新比较慢，前几天刚更新了一期，距上一期已经是 1 年左右了。但是听一听历史的 ep 有些也不过时。&lt;/p&gt;

&lt;h3 id=&#34;代码时间&#34;&gt;代码时间&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://codetimecn.com/&#34;&gt;http://codetimecn.com/&lt;/a&gt; 这个播客也是请人来做访谈，不过聊的感觉有时候有点尴尬，也不知道为啥有这个感觉。也是很久更新一期，历史的也可以听听。&lt;/p&gt;

&lt;h3 id=&#34;checked&#34;&gt;checked&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://checked.fm/&#34;&gt;http://checked.fm/&lt;/a&gt; 这个播客有三个主播，2 个少数派的雇员，还有个妹子。都是年轻人，都挺有意思的。会讨论各种科技话题，科技热点事件，APP 使用经验等，更新也比较及时。&lt;/p&gt;

&lt;h3 id=&#34;机核网&#34;&gt;机核网&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.g-cores.com/categories/9&#34;&gt;https://www.g-cores.com/categories/9&lt;/a&gt; 一个游戏播客。机核网本身是个游戏咨询站。播客内容就是各种游戏相关的东西。我之前听过《血缘》和《黑魂》相关的。不过因为我游戏玩的其实没那么多，所以他们谈的很多游戏没玩过，后来也就不听了。&lt;/p&gt;

&lt;h3 id=&#34;比特新声&#34;&gt;比特新声&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://banlan.show/bitvoice&#34;&gt;https://banlan.show/bitvoice&lt;/a&gt; 主播海龙是出国培训老师，主播有才是一个 soho 的程序员。一个文科一个理科，思想的一些碰撞还挺有意思的。谈论的话题基本是科技圈的居多，但是内容也比较广泛。&lt;/p&gt;

&lt;h3 id=&#34;ux-coffee-设计咖&#34;&gt;UX Coffee 设计咖&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://uxcoffee.co/&#34;&gt;http://uxcoffee.co/&lt;/a&gt; 主要和谈论一些设计和用户体验相关的内容。主播应该在国外，会请一些在国外的华语开发者来访谈。&lt;/p&gt;

&lt;h3 id=&#34;i-o-调频&#34;&gt;「I/O」调频&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://dailyio.net/&#34;&gt;http://dailyio.net/&lt;/a&gt; 更新不多，貌似是一个人的独白，感觉听的不多，所以我也不记得大致内容了。&lt;/p&gt;

&lt;h3 id=&#34;内核恐慌&#34;&gt;内核恐慌&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://kernelpanic.fm/&#34;&gt;https://kernelpanic.fm/&lt;/a&gt; 科技播客，内容还挺好的，可惜目前更新很少。最近几期《字谈字串》都是 4 个人串台。Rio 和吴涛其实还参加了近期的《迟早更新》，但是他们居然不更新自己的播客，发指。&lt;/p&gt;

&lt;h3 id=&#34;it-公论&#34;&gt;IT 公论&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://itgonglun.com/&#34;&gt;https://itgonglun.com/&lt;/a&gt; 李如一和 Rio 主持。李如一好像挺有名的，不过我不是很熟悉。也是科技相关的播客。&lt;/p&gt;

&lt;h3 id=&#34;两个-it-大叔&#34;&gt;两个 iT 大叔&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://podcast.lengqidong.com/podcast.xml&#34;&gt;http://podcast.lengqidong.com/podcast.xml&lt;/a&gt; 没有找到他们的网站，只有一个 rss 地址了。这个是两个男主播，聊的内容大都和科技相关。&lt;/p&gt;

&lt;h3 id=&#34;etw&#34;&gt;ETW&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://www.etw.fm/&#34;&gt;http://www.etw.fm/&lt;/a&gt; 这个是两个驻美记者做的播客，两个妹子。聊各种热点话题，还是挺有意思的。&lt;/p&gt;

&lt;h2 id=&#34;英文播客&#34;&gt;英文播客&lt;/h2&gt;

&lt;p&gt;英文播客我基本只能听英语学习类的，其他的语速和发音会导致有不少听不懂。&lt;/p&gt;

&lt;h3 id=&#34;all-ears-english&#34;&gt;All Ears English&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.allearsenglish.com/&#34;&gt;https://www.allearsenglish.com/&lt;/a&gt; 两个美国妹子，语速没有调慢，聊一些日常的用语什么的，感觉还是比较好懂的。&lt;/p&gt;

&lt;h3 id=&#34;潘吉jenny告诉你-学英语聊美国-开言英语&#34;&gt;潘吉Jenny告诉你|学英语聊美国|开言英语&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://openlanguage.com/library/learn-english/9/culture-show&#34;&gt;https://openlanguage.com/library/learn-english/9/culture-show&lt;/a&gt; 这个是一个中国人一个外国人搭配的播客。里面中文说的比较多，会讲解一些常用的词汇用语什么的。&lt;/p&gt;

&lt;h3 id=&#34;culips-english&#34;&gt;Culips English&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://esl.culips.com/&#34;&gt;https://esl.culips.com/&lt;/a&gt; 主播都是外国人，语速应该是调整过感觉比较慢。有词汇讲解，也有普通的聊天。&lt;/p&gt;

&lt;h3 id=&#34;the-english-we-speak&#34;&gt;The English We Speak&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://www.bbc.co.uk/programmes/p02pc9zn&#34;&gt;http://www.bbc.co.uk/programmes/p02pc9zn&lt;/a&gt; 主播是英国口音，内容都比较短，每次基本就是一二个词。&lt;/p&gt;

&lt;h3 id=&#34;eslpod&#34;&gt;ESLPod&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.eslpod.com/&#34;&gt;https://www.eslpod.com/&lt;/a&gt; 这个是我很早以前听过的，目前这个没有免费的更新了，必须付费，年费还不低。不过这个是我听过觉得比较好的，会仔细用英文解释对话里面的单词。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>草泥马</title>
      <link>https://wdicc.com/freedom/</link>
      <pubDate>Mon, 06 Nov 2017 18:47:41 +0800</pubDate>
      
      <guid>https://wdicc.com/freedom/</guid>
      <description>&lt;p&gt;我搜了一下我的帖子，GFW 这个 tag 最早在我的 「2006/12/01 咱也玩玩lilina」 这个帖子里面就出现了。里面提到 Google 有时候会撞墙，会导致 Google reader 也不能访问。我也忘记这个东西最早是什么时候进入我的生活的，从我的 blog 后面可以看到 09 年开始研究一些相关技术，到现在已经 8 年了。&lt;/p&gt;

&lt;p&gt;很多人说百度更懂中文。我从来没觉得，可能因为我中文搜的不多吧，不过就算是中文也更喜欢看 Google 里面的结果。百度里面巨量的重复内容，都是一个帖子被复制了很多次，浪费很多时间翻页之后你还是会发现没有你想要的结果。用 Google 的时候，如果前面 3 页（更多时候，1-2 页足够）还没有你想要的结果，那么要么是这个结果就是少，要么就是你的关键字不对，根据结果里面的一些信息，适当调整自己的关键字。&lt;/p&gt;

&lt;p&gt;因为本身是搞技术的，技术方面，国外的文章水分更少，并且自己也基本能看懂技术相关的英文内容，所以从来都不用百度。国内的各种论坛（也有一些例外的，比如 v2ex，rubychina 等），大量的顶，回复可见内容的帖子，基本没什么意义。不如直接看英文世界里面的情况来的直接。&lt;/p&gt;

&lt;p&gt;那会有一段时间还流行各种草泥马相关的东西，比如草泥马之歌。大家用这种方式自嘲，讽刺。当时总觉得这种东西不符合普世价值并不能长久，笑笑也就好了。这么一翻，就是 8 年。现在还每况愈下，一些稍微活跃一点的还有喝茶的待遇。&lt;/p&gt;

&lt;p&gt;这个帖子前几天就想写了，一忙忘记了，今天补上。我和图拉鼎同学并没有见过面。唯一的近距离接触，是当时他在北京 Canonical 公司的时候，有次要聚会，我和他在 qtalk 上面聊过，不过可惜我最后没参加（这段记忆也比较模糊了，可能会有记错），没有见面。后面更多的就是在微博看他在回到杭州后享受生活了。&lt;/p&gt;

&lt;p&gt;看看他的生活，就是一个普通宅男，聪明热爱生活，经常游荡在杭州的街巷，发现一些别人没注意到或者忽略的事物。写写代码，咖啡馆坐坐，找一个志同道合的朋友聊聊天，再普通不过了。偏偏就是这样的一个人都容不下，神经一点一点变的异常铭感，没有点神经病估计现在也不好当领导了。&lt;/p&gt;

&lt;p&gt;前两年，还有另外一个朋友开发了一款搭建高性能网站使用的服务器软件（和翻墙无关），本来一直在国外工作，回家探亲被限制出境，具体原因不聊了，后来解决了出去了。目前在国外成立的自己的公司，专门发扬自己的软件，也拿到了绿卡。估计以后也没兴趣回来了。&lt;/p&gt;

&lt;p&gt;目前这个形势下，无法预见我们自己哪天不会遇到问题，即使你自己学会了阉割自己，但你怎么知道他们的铭感点在哪里呢？也可能是「就是喜欢看你虽然不喜欢，但是又不得不一起建设社会主义的样子」呢？&lt;/p&gt;

&lt;p&gt;想起来一个大话西游里面大对白了&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;爱一个人需要理由么？&lt;/li&gt;
&lt;li&gt;需要吗？&lt;/li&gt;
&lt;li&gt;不需要吗？&lt;/li&gt;
&lt;li&gt;需要吗？&lt;/li&gt;
&lt;li&gt;不需要吗？&lt;/li&gt;
&lt;li&gt;等你真爱上一个人你就知道了&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;把里面的「爱」替换为「整」（等你真被整的时候就知道了）我感觉还是挺适合的。&lt;/p&gt;

&lt;p&gt;附送 &lt;a href=&#34;https://www.youtube.com/watch?v=01RPek5uAJ4&#34; title=&#34;草泥马之歌&#34;&gt;草泥马之歌&lt;/a&gt; 给有兴趣的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Why I Am Not at React Native Developer(节译)</title>
      <link>https://wdicc.com/why-i-am-not-at-react-native-developer/</link>
      <pubDate>Thu, 02 Nov 2017 14:00:39 +0800</pubDate>
      
      <guid>https://wdicc.com/why-i-am-not-at-react-native-developer/</guid>
      <description>&lt;p&gt;翻译自这里 &lt;a href=&#34;https://arielelkin.github.io/articles/why-im-not-a-react-native-developer.html#javascript&#34; title=&#34;Why I&#39;m not a React Native Developer&#34;&gt;Why I&#39;m not a React Native Developer&lt;/a&gt; 。&lt;/p&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;很多人把 RN 作为下一个移动 app 的开发平台。切换开发平台有可能会有巨大的消耗也可能会改变你日常的工作流程。同时平台也可能会改变你开发使用的软件，需要你掌握一些特殊的工具和工作流，把你绑定到一个新的开发生态里面。&lt;/p&gt;

&lt;p&gt;Facebook 自己想要完全切换到 RN 来代替原来的 Native 开发。RN 开发团队也在努力做这个事情，他们搞了一个软件开发平台来代替传统的 Xcode/Swift/ObjC 开发模式。RN 团队到底对这个是一个怎么的态度，貌似还不太明确。&lt;/p&gt;

&lt;p&gt;我自己搞了几个月开发之后，我感觉这个平台不是我想要的一个，也不推荐其他人往里跳。&lt;/p&gt;

&lt;h2 id=&#34;declarative-style&#34;&gt;Declarative style&lt;/h2&gt;

&lt;p&gt;在 RN 里面，UI 是一堆包含状态(state)的函数(function)和属性(props)。&lt;/p&gt;

&lt;p&gt;下面是个例子，假设我们需要在左上角有一个小正方形，如果用户连接了就显示红色，没连接显示绿色。&lt;/p&gt;

&lt;p&gt;在这种编程类型下，你指定所有更新 UI 需要的步骤。我们需要监听 isConnectd 来更新 view。我们告诉 iOS 如何计算状态。&lt;/p&gt;

&lt;p&gt;比较一下 RN 的模式。&lt;/p&gt;

&lt;p&gt;RN 让你在 render() 方法里面描述你的 UI。React 框架来保证 state 的变化会触发 re-rendering。对于数据的修改，会自动触发 UI 的改变。&lt;/p&gt;

&lt;p&gt;我想这是一种思考 UI 的很好的方式。这也是 MVC 模式的一种进化，View 只需要负责展示，不需要负责管理数据。&lt;/p&gt;

&lt;h2 id=&#34;faster-iterations&#34;&gt;Faster iterations&lt;/h2&gt;

&lt;p&gt;RN 里面开发的时候，框架会在本地启动一个 server。你只需要编译一次，然后在 iOS 模拟器或者真机上面运行，RN 会保证你在 js 里面做的任何修改都会反馈到 app 里面。&lt;/p&gt;

&lt;ul&gt;
你有两个选择:
&lt;li&gt;Live Reloading。使用 CMD + R 快捷键。&lt;/li&gt;
&lt;li&gt;Hot Reload。只更新你编辑的部分。比如你在编辑一个 table view 的一个 cell，你的修改会立刻可以看到，不用每次都从开始界面一步一步找过去。当前页面的状态也会一直保留，这就是所见即所得的编程体验。Xcode 没有这个。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个比之前在 native 里面快太多了，在 native 里面有时候还需要在 ViewController 里面加一些 debug 方法，以便快速的找到需要的界面。&lt;/p&gt;

&lt;h2 id=&#34;cross-platform&#34;&gt;Cross-platform&lt;/h2&gt;

&lt;p&gt;跨平台。&lt;/p&gt;

&lt;h2 id=&#34;uncertain-roadmap&#34;&gt;Uncertain roadmap&lt;/h2&gt;

&lt;p&gt;担心 RN 团队没有对这个项目的长期的保证。&lt;/p&gt;

&lt;p&gt;不像我们使用一些第三方库，如果那个库出点问题我们的项目也不至于出啥大问题。而 RN 是一整个软件开发平台，如果 facebook 停止维护 RN，我们的软件可能就停滞了，目前也没有一个 RN 替代。如果要自己搞，那还需要区了解 RN 的代码，React.js 的代码，RN CLI 工具，和 JavaScriptCore。社区会继续搞么？也许吧，可能不是我们熟悉的速度。&lt;/p&gt;

&lt;p&gt;Github 上面 RN 大概 2 周就会发布一个新版本。&lt;/p&gt;

&lt;h2 id=&#34;patently-daunting&#34;&gt;Patently daunting&lt;/h2&gt;

&lt;h2 id=&#34;patently-silent&#34;&gt;Patently silent&lt;/h2&gt;

&lt;h2 id=&#34;october-2017-update-facebook-relicensing&#34;&gt;October 2017 update: Facebook Relicensing&lt;/h2&gt;

&lt;h2 id=&#34;javascript&#34;&gt;Javascript&lt;/h2&gt;

&lt;ul&gt;
我们应该从 RN 切换到 Swifh 一个比较重要的原因是「技术倒退」，你应该抛弃 JavsScript，这是一门
&lt;li&gt;有缺陷的&lt;/li&gt;
&lt;li&gt;不安全的&lt;/li&gt;
&lt;li&gt;进化缓慢的语言&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面的例子都是基于 ES2016。&lt;/p&gt;

&lt;h3 id=&#34;javascript-s-inadequacy&#34;&gt;Javascript’s inadequacy&lt;/h3&gt;

&lt;p&gt;司机都喜欢开集成了很多安全措施的车。不是因为它们能让你开起来更简单，而是因为它们会降低你遇到事故的几率。&lt;/p&gt;

&lt;p&gt;类似的，一门编程语言也应该提供一些能避免编程错误的安全措施。&lt;/p&gt;

&lt;p&gt;ARC 刚加入 Object-C 的时候，我们可以选择关闭他，但是为啥不推荐呢，因为编译器可以比你更加准确的知道一个对象的生命周期。「编译器比你聪明」。&lt;/p&gt;

&lt;h3 id=&#34;type-errors&#34;&gt;Type errors&lt;/h3&gt;

&lt;p&gt;JavaScript 里面一个变量可以在任何时间编程任意类型。&lt;/p&gt;

&lt;h3 id=&#34;lack-of-optionals&#34;&gt;Lack of optionals&lt;/h3&gt;

&lt;p&gt;Objective-C 里面(以及其他语言里面)大量的错误是调用一个 nil 的对象上面的方法。&lt;/p&gt;

&lt;p&gt;Swift 里面，会强制你做 nil 检查，如果你知道一个对象可能会是 nil。&lt;/p&gt;

&lt;h3 id=&#34;lack-of-function-signature&#34;&gt;Lack of function signature&lt;/h3&gt;

&lt;p&gt;JavaScript 里面函数没有返回类型。&lt;/p&gt;

&lt;h3 id=&#34;immutability&#34;&gt;Immutability&lt;/h3&gt;

&lt;p&gt;JavaScript 里面对不可变数据的支持很弱。&lt;/p&gt;

&lt;h3 id=&#34;you-can-t-trust-arrays&#34;&gt;You can’t trust arrays&lt;/h3&gt;

&lt;h3 id=&#34;poor-error-handling&#34;&gt;Poor error handling&lt;/h3&gt;

&lt;h3 id=&#34;no-support-for-decimals&#34;&gt;No support for decimals&lt;/h3&gt;

&lt;h3 id=&#34;dodgy-maths&#34;&gt;Dodgy maths&lt;/h3&gt;

&lt;h3 id=&#34;unsafe-initialisation&#34;&gt;Unsafe initialisation&lt;/h3&gt;

&lt;h3 id=&#34;optional-curly-braces-after-an-if&#34;&gt;Optional curly braces after an if&lt;/h3&gt;

&lt;h3 id=&#34;ambiguous-curly-braces&#34;&gt;Ambiguous curly braces&lt;/h3&gt;

&lt;h3 id=&#34;switch-fallthrough&#34;&gt;Switch fallthrough&lt;/h3&gt;

&lt;h3 id=&#34;what-s-nothing&#34;&gt;What’s nothing?&lt;/h3&gt;

&lt;h3 id=&#34;poor-expressivity&#34;&gt;Poor expressivity&lt;/h3&gt;

&lt;h3 id=&#34;exceedingly-slow-evolution&#34;&gt;Exceedingly slow evolution&lt;/h3&gt;

&lt;ul&gt;
ES2016 提供了一些新的功能
&lt;li&gt;The includes method for arrays.&lt;/li&gt;
&lt;li&gt;The ** operator&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;flow-to-the-rescue&#34;&gt;Flow to the rescue!&lt;/h3&gt;

&lt;p&gt;Flow 是 Facebook 提出来解决上面那些问题的。这是一个 JavaScript 的静态类型检查工具。&lt;/p&gt;

&lt;p&gt;回忆一下那些例子。&lt;/p&gt;

&lt;h3 id=&#34;flow-s-like-flossing&#34;&gt;Flow’s like flossing&lt;/h3&gt;

&lt;p&gt;Flow 修复了 JavaScript 那些问题了么？没有。&lt;/p&gt;

&lt;p&gt;Flow 开发工程师虽然做了很多努力，但是他依然只是 JavaScript 的一个超集，基于一个很弱的根基。&lt;/p&gt;

&lt;p&gt;github 上面大量的项目都没有使用 Flow。也没有一个 RN 的例子讲到了 flow。&lt;/p&gt;

&lt;h2 id=&#34;the-javascript-ecosystem-balls-and-chains&#34;&gt;The Javascript Ecosystem: balls and chains&lt;/h2&gt;

&lt;p&gt;JavaScript 的缺点让所有人都印象深刻，除了 JavaScript 开发。对于他们来说，上面提到的问题并没有那么糟糕。这是因为 JavaScript 开发并不觉得 js 语言有什么欠缺。&lt;/p&gt;

&lt;p&gt;你说没有 immutability，那我们写一个库支持他，你说没有类型检查，那我们写一个库。&lt;/p&gt;

&lt;p&gt;&#34;自由挖掘&#34;是指选择一门健全的语言。这么挖并没有很好的利用好精力。JS 总是让你开发一些其他语言默认就支持的东西。&lt;/p&gt;

&lt;h3 id=&#34;chains&#34;&gt;Chains&lt;/h3&gt;

&lt;p&gt;有条大鱼需要 JavaScript 来处理。这门语言考虑 billions 选择升级或者不升级他们流量起和网站的网络用户。这使得这门语言的开发不健全。&lt;/p&gt;

&lt;p&gt;还记得 typeof(null) == &#39;object&#39; 么，已经有提案把 null 对象改成 null 了，但是「考虑到这会导致现有的大量网站出问题。」这个提案被否决了。ES6 里面 null 依然是个 object。&lt;/p&gt;

&lt;ul&gt;
JavaScript 的进化，需要考虑：
&lt;li&gt;大量的旧版本流量起用户&lt;/li&gt;
&lt;li&gt;一群不同的浏览器厂商&lt;/li&gt;
&lt;li&gt;大量的网站和它们的开发&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;wider-angles&#34;&gt;Wider angles&lt;/h3&gt;

&lt;h2 id=&#34;dependencies&#34;&gt;Dependencies&lt;/h2&gt;

&lt;p&gt;RN 项目有 648 项依赖(我刚看了一下是 603)。你的项目基于其他 600 多人的努力。这也就是说，你的项目也依赖于这 600 多自愿者能持续维护他们的项目。&lt;/p&gt;

&lt;h2 id=&#34;better-alternatives&#34;&gt;Better alternatives&lt;/h2&gt;

&lt;p&gt;广告时间。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>11 Mistakes During Use React Native(翻译)</title>
      <link>https://wdicc.com/11-mistakes-during-use-react-native/</link>
      <pubDate>Wed, 01 Nov 2017 19:12:24 +0800</pubDate>
      
      <guid>https://wdicc.com/11-mistakes-during-use-react-native/</guid>
      <description>&lt;p&gt;粗略的翻译自 &lt;a href=&#34;https://medium.com/dailyjs/11-mistakes-ive-made-during-react-native-redux-app-development-8544e2be9a9&#34; title=&#34;11 mistakes I’ve made during React Native / Redux app development&#34;&gt;11 mistakes I’ve made during React Native / Redux app development&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;一些可能会错误的评估&#34;&gt;一些可能会错误的评估&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;虽然有很多可以重复使用的组件，你还是需要分开考虑 iOS 和 Android 的布局。&lt;/li&gt;
&lt;li&gt;当你评估表单实现的时候，应该要同时考虑表单的验证。开发 RN 比开发例如 Cordova 这样的 hybrid 的程序需要写的代码更多。&lt;/li&gt;
&lt;li&gt;如果是基于一个已经有后端的 webapp 写代码，应该需要先去仔细看看后端提供的功能接口，因为你需要自己写逻辑，弄明白了 DB 结构数据关联，可以然你更好的规划你的 redux store。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;尽量使用已有的组件&#34;&gt;尽量使用已有的组件&lt;/h2&gt;

&lt;p&gt;Google 一下就会发现，已经有大量的现成的组件，例如 buttons, footers 等。如果你没啥特殊要求，这些你都可以直接用。你要是有自己的特殊需要，也可以包装一下这些组件成你自己的，然后在里面自定义样式。不过你自己使用 View, Text, TouchableOpacity 等这些 RN 组件来自己包装对于你理解 RN 的工作原理。你自己打包的组件的版本也不会变，不像依赖外部模块。&lt;/p&gt;

&lt;h2 id=&#34;不要分开搞-ios-和-android-的布局&#34;&gt;不要分开搞 iOS 和 Android 的布局&lt;/h2&gt;

&lt;p&gt;如果你有不同的布局需求，那就分开。否则，你可以使用 RN Platform 提供的 API 来做一些小的区分。&lt;/p&gt;

&lt;p&gt;如果布局很大不同，那就把布局内容放到不同的文件里面。&lt;/p&gt;

&lt;p&gt;你可以使用 index.ios.js 给 iOS 布局用，index.android.js 给 Android 用。&lt;/p&gt;

&lt;p&gt;共同的重复代码可以放到 helpers 里面。&lt;/p&gt;

&lt;h2 id=&#34;错误的-redux-store-规划&#34;&gt;错误的 redux store 规划&lt;/h2&gt;

&lt;p&gt;在规划你的 app 的时候可能会花很多时间在布局上，少量时间在数据规划上。这是个错误。redux 可以帮我们很好的处理数据。如果能规划好他，这会是一个很有用的工具，否则可能会带来不好的结果。&lt;/p&gt;

&lt;p&gt;在我刚开始规划的时候，想着 reducers 是每个 container 的数据层。所以，如果有登录，忘记密码，Todo 列表页面，那应该来说会有各自的 reducers: SignIn, Forgot, ToDoList。&lt;/p&gt;

&lt;p&gt;后来才发现，数据没那么好管理。我有 Todo 详情页，用这个方式规划的话，就需要有一个 ToDoDetails reducer。这是个巨大的失误。当用户在 Todo 列表页面选择了一项的时候，我们需要把数据传递给 ToDoDetails reducer。这表示需要额外的 actions 来发送数据给 reducer，这不太合理。&lt;/p&gt;

&lt;p&gt;做了一些调查之后，打算该改结构&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Auth&lt;/li&gt;
&lt;li&gt;Todos&lt;/li&gt;
&lt;li&gt;Friends&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Auth 用来存放 token。Todos 和 Friends reducers 用来存放实体数据，从名字就能理解。当从列表打开 ToDo 详情的时候，只需要根据 id 从 Todos 里面查询就可以了。&lt;/p&gt;

&lt;p&gt;不管多复杂的结构，都推荐你这么搞，这样你总是知道你应该去哪里找你的数据。&lt;/p&gt;

&lt;h2 id=&#34;错误的项目结构&#34;&gt;错误的项目结构&lt;/h2&gt;

&lt;p&gt;对于新手来说，规划项目结构是个比较难的事情。&lt;/p&gt;

&lt;p&gt;得看看你的项目是大项目？巨大的？还是小的。有多少 screen，20？30？还是 5 个，或者是只有个 Hello world？&lt;/p&gt;

&lt;p&gt;一开始我的项目结构如下：&lt;/p&gt;

&lt;p&gt;图不贴了，可以看原文。简单讲就是把 reducers actions 等分开放到不同的目录里面。&lt;/p&gt;

&lt;p&gt;如果你的项目不大，例如 10 来个 screen 这么搞是挺好的。如果比较大，可以考虑下下面这个方式：&lt;/p&gt;

&lt;p&gt;就是按照 screen 划分目录，把这个 screen 对应的 actions reducers 等放到一个目录下面。这样可以清楚的知道一个 container 和 action 等的关系。&lt;/p&gt;

&lt;p&gt;如果你有通用的 style 文件，可以建一个 styles/index.js 文件。&lt;/p&gt;

&lt;p&gt;还有很多其他的结构类型，你需要找到适合你自己的。&lt;/p&gt;

&lt;h2 id=&#34;container-里面错误的结构&#34;&gt;container 里面错误的结构&lt;/h2&gt;

&lt;p&gt;其实简单概括就是，应该尽量封装你的组件，比如 form 表单里面的东西，应该适当的做一些封装，比如搞一个 FormItem 这样的组件出来，就不用重复的写 Text 和 TextInput 的组合了。&lt;/p&gt;

&lt;p&gt;但是也要注意，不要为了封装而封装，原文里面有个例子，把组件搞了一个 setTitle 方法，然后根据 id 来设置 title。作者的意思是，Dumb 组件不应该加入业务逻辑进来，比如加一个 id 就需要修改一下这个组件。&lt;/p&gt;

&lt;h2 id=&#34;内联样式&#34;&gt;内联样式&lt;/h2&gt;

&lt;p&gt;就是这样的 &lt;code&gt;&amp;lt;View style={{flex:1, flexDirection:&#39;row&#39;, backgroundColor:&#39;transparent&#39;}}&amp;gt;&lt;/code&gt; ，慢慢会变得很难管理，也没法重用。应该一开始就把这个写入到单独的文件里面。&lt;/p&gt;

&lt;h2 id=&#34;使用-redux-验证表单&#34;&gt;使用 redux 验证表单&lt;/h2&gt;

&lt;p&gt;这个是我犯的一个错误，但也有可能适合你们。&lt;/p&gt;

&lt;p&gt;如果需要通过 redux 验证表单，我们需要创建 action， action type 和 reducer 里面单独的字段。这么做有点太麻烦了。&lt;/p&gt;

&lt;p&gt;所以我们决定使用 state。不用 reducers, types 等。只用一些在 container 范围的简单的函数。这么做让我们删除了 action，reducer 文件里面不必要的函数。也不用处理维护 store，这么做很适合我们的项目。&lt;/p&gt;

&lt;h2 id=&#34;大量依赖-zindex&#34;&gt;大量依赖 zIndex&lt;/h2&gt;

&lt;p&gt;从 web 过来的人会比较喜欢 css 里面的 z-index，可以控制显示哪一层。但是在 RN 里面，一开始没有这个，但是后来也加上了。一开始用的时候挺好的，但是直到我开始在 Android 上面跑。。。现在我都是在构建的时候就考虑好他们将来展示的顺序。&lt;/p&gt;

&lt;h2 id=&#34;不阅读依赖的模块的代码&#34;&gt;不阅读依赖的模块的代码&lt;/h2&gt;

&lt;p&gt;简单说就是用第三方模块的时候，看文档是必须的了，但是有时候也需要看看代码的。比如不工作了，或者和文档描述不一致啥的。看代码也能学习到如何构建自己的模块。&lt;/p&gt;

&lt;h2 id=&#34;使用-panresonder-和-动画-api-的时候要小心&#34;&gt;使用 PanResonder 和 动画 API 的时候要小心&lt;/h2&gt;

&lt;p&gt;RN 提供了你构建完全 native 体验的 app 的能力。例如布局，手势，动画。&lt;/p&gt;

&lt;p&gt;默认提供了布局功能，当你使用 View, Text, TextInput 这些 RN 模块的时候，手势和动画需要使用 PanResonder 和动画 API 来提供手势和动画。&lt;/p&gt;

&lt;p&gt;一开始可能会觉得好难，什么时候开始，什么时候结束，长按，短按等。RN 也确实没有把这些讲的足够清晰。作者提供了一个例子&lt;/p&gt;

&lt;p&gt;开始我们初始化一个 PanResonder 对象，针对我们感兴趣的 onPanResponderGrand(当用户点击 button 的时候调用) 和 onPanResponderRelease(当用户手指离开屏幕的时候调用) 设置了一些 handler。&lt;/p&gt;

&lt;p&gt;同时我们也设置了 Animated 对象来帮我们处理动画。设置他的取值为 0，然后定义 _setOpacity 方法来改变 this.opacityAnimated 的值。在渲染之前，给 this.opacityAnimated 赋值为通常情况下的值。我们不使用 View，使用 Animated.View 来动态修改透明度。&lt;/p&gt;

&lt;p&gt;可以看到，这没啥难理解的。当然你需要阅读这些 API 的文档让你的 app 更完美。希望这个例子可以让你有一个好的开始。&lt;/p&gt;

&lt;p&gt;React Naive 很不错，你几乎可以用它做任何事情。如果有不行的，你还可以通过 Swift/Object C 或者 Java 来配合 RN 完成。此外还有一个大的社区。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Howto Make react-redux Work With react-navigation</title>
      <link>https://wdicc.com/howto-make-react-redux-work-with-react-navigation/</link>
      <pubDate>Sat, 21 Oct 2017 08:19:28 +0800</pubDate>
      
      <guid>https://wdicc.com/howto-make-react-redux-work-with-react-navigation/</guid>
      <description>&lt;p&gt;这周花了一些时间研究 &lt;code&gt;react-redux&lt;/code&gt; 和怎么让它和 &lt;code&gt;react-navigation&lt;/code&gt; 配合一起工作，总结一下，把代码和注释直接贴这里了，也可以看这个 &lt;a href=&#34;https://gist.github.com/wd/7935c3fb20f2517280b8e050796310b3&#34; title=&#34;gist&#34;&gt;gist&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
/**
 * 一个简单的 RN 应用，有 2 个页面，使用了 react-navigation 的 StackNavigator 来做界面管理
 * 为了说明如何使用 redux，以及如何让 redux 和 StackNavigator 配合
 * 为了容易理解，把所有内容都放到了一个页面里面，实际开发的时候不要这么做
 * 参考：
 *  https://github.com/jackielii/simplest-redux-example
 *  http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_three_react-redux.html
 */

import React, { Component } from &#39;react&#39;;
import {
    StyleSheet,
    Text,
    View,
    Button
} from &#39;react-native&#39;;

import { Provider, connect } from &#39;react-redux&#39;;
import { createStore, combineReducers } from &#39;redux&#39;;
import { StackNavigator, addNavigationHelpers } from &#39;react-navigation&#39;;

// Home 页面，UI 组件
class MyHome extends Component {
    constructor(props) {
        super(props);
        console.log(&#39;init home, props&#39;, props);
    }

    _nextPage() {
        // navigation 依然在 this.props 里面获取，和不用 redux 的时候用法一样
        let {navigation} = this.props;
        navigation.navigate(&amp;quot;App&amp;quot;);
    }

    render() {
        // 所有的传递过来的状态，都需要从 this.props.screenProps 里面读取 (4)
        // 我这里给不同页面的 action 取了各自的命名空间，避免冲突，也可以直接所有 action 都在一个命名空间，这块我还在摸索如何处理比较好 (5)
        let {onIncButtonClicked} = this.props.screenProps.MyAppActions;

        // 界面有两个按钮，一个用来增加另外一个页面的计数器，一个用来访问下一个页面
        return (
            &amp;lt;View style={styles.container}&amp;gt;
                &amp;lt;Button title=&amp;quot;Inc counter&amp;quot; onPress={onIncButtonClicked}&amp;gt;&amp;lt;/Button&amp;gt;
                &amp;lt;Button title=&amp;quot;Next page&amp;quot; onPress={()=&amp;gt;this._nextPage()}&amp;gt;&amp;lt;/Button&amp;gt;
            &amp;lt;/View&amp;gt;
        )
    }
}

// 这个组件只是用来测试就算一个 props 传递给子组件，在 props 被修改的时候也会被自动刷新
class ShowText extends Component {
    render() {
        let {counter} = this.props;

        return (
            &amp;lt;Text&amp;gt;{counter}&amp;lt;/Text&amp;gt;
        )
    }
}

// App 页面，UI 组件
class MyApp extends Component {
    constructor(props) {
        super(props);
        console.log(&#39;init App, props&#39;, props);
    }

    componentWillReceiveProps(newProps) {
        console.log(&#39;myapp recive props&#39;, newProps);
    }

    render() {
        // 组件的 state/props 获取，有自己的命名空间 (1)
        let {counter} = this.props.screenProps.MyApp;
        // 组件的 action props (5)
        let {onIncButtonClicked, onDecButtonClicked} = this.props.screenProps.MyAppActions;

        // 界面有一个计数器的结果，两个按钮
        return (
            &amp;lt;View style={styles.container}&amp;gt;
                &amp;lt;ShowText counter={counter} /&amp;gt;
                &amp;lt;Button title=&amp;quot;Inc counter&amp;quot; onPress={onIncButtonClicked}&amp;gt;&amp;lt;/Button&amp;gt;
                &amp;lt;Button title=&amp;quot;Dec counter&amp;quot; onPress={onDecButtonClicked}&amp;gt;&amp;lt;/Button&amp;gt;
            &amp;lt;/View&amp;gt;
        )
    }
}

// 初始化 StackNavigator，定义页面路由
let AppNavigator = StackNavigator({
    Home: {
        screen: MyHome
    },
    App: {
        screen: MyApp
    }
});

// 包装一下 StackNavigator，因为有些参数需要定制一下
class MyStackNavigator extends Component {
    constructor(props) {
        super(props);
        console.log(&amp;quot;inside MyStackNavigator&amp;quot;, props);
    }

    render() {
        // screenProps: 使用这个往所有的页面传递 props，这个是和直接使用 redux 不同的地方 (4)
        // navigation: 因为使用 redux 之后，就不会直接操作 this.state 了，所以得告诉 StackNavigator dispatch 方法和 state 从哪里读取
        return (
            &amp;lt;AppNavigator
                screenProps={this.props}
                navigation={addNavigationHelpers({
                    dispatch: this.props.dispatch, // 通过 action props 定义 (2)
                    state: this.props.nav, // 通过 state props 定义 (3)
                })} /&amp;gt;
        )
    }
}

// 定义 state 和 props 的关系，所有 redux 应用都需要 (6)
let mapStateToProps = (state, ownProps) =&amp;gt; {
    console.log(&amp;quot;inside mapstate to props&amp;quot;, state, ownProps);
    return {
        // 这两个是不同的命名空间，和上面你使用的时候的路径对应 (1)
        &amp;quot;MyApp&amp;quot;: state.MyApp,
        &amp;quot;MyHome&amp;quot;: state.MyHome,
        // 定义 StackNavigator 的 state (3)
        &amp;quot;nav&amp;quot;: state.nav
    }
};

// 定义 action 和 props 的关系，所有 redux 应用都需要
let mapDispatchToProps = (dispatch, ownProps) =&amp;gt; {
    console.log(&amp;quot;inside map dispath to props&amp;quot;);
    return {
        // 这两个也是不同的命名空间，和上面使用的时候路径对应 (5)
        &#39;MyAppActions&#39;: {
            onIncButtonClicked: () =&amp;gt; {
                let action = {
                    type: &amp;quot;INC_COUNTER&amp;quot;,
                    payload: 1
                };

                dispatch(action);
            },
            onDecButtonClicked: () =&amp;gt; {
                let action = {
                    type: &amp;quot;DEC_COUNTER&amp;quot;,
                    payload: -1
                };

                dispatch(action);
            }
        },
        &#39;MyHomeActions&#39;: {
            onNextButtonClicked: () =&amp;gt; {
                let action = {
                    type: &amp;quot;NEXT_PAGE&amp;quot;
                };

                dispatch(action);
            }
        },
        // 定义 StackNavigator 的 action props (2)
        &#39;dispatch&#39;: dispatch
    }
}

// 定义 home 页面的 reducer，不过因为那个页面唯一的一个 action 是触发别的页面的动作的，所以这个 reducer 其实也可以没有
// 所以从这里也能看出来，reducer 并不一定按照页面去分
let homeReducer = (state, action) =&amp;gt; {
    console.log(&amp;quot;inside home reducer&amp;quot;, state, action);
    return state || {};
};

// 定义一个初始化的 state
let myAppInitState = { &#39;counter&#39;: 10};
// 定义 app 页面的 reducer
let myAppReducer = (state = myAppInitState, action) =&amp;gt; {
    // 收到的 state 实际上只是自己命名空间下的 (6)
    console.log(&amp;quot;inside myAppReducer&amp;quot;, state, action);
    let myState = state;
    // 需要处理的 action 的逻辑
    // 要注意，一个 action 被触发的时候，所有的 reducer 都会被调用，所以其实更像是订阅自己想要处理的 action
    switch (action.type) {
        case &amp;quot;DEC_COUNTER&amp;quot;:
        case &amp;quot;INC_COUNTER&amp;quot;:
            // 如果修改了 state，必须要返回一个新的对象，不能直接在原对象上修改，否则 state 变化不会触发组件的刷新
            return Object.assign({}, myState, {
                &#39;counter&#39;: myState.counter + action.payload
            });
        default:
            return state;
    }
};

// 定义一个 StackNavigator 用到的初始化状态，这个很重要
const initialState = AppNavigator.router.getStateForAction(AppNavigator.router.getActionForPathAndParams(&#39;Home&#39;));
// 定义 StackNavigator 的 reducer，代码直接复制来的
const navReducer = (state = initialState, action) =&amp;gt; {
    console.log(&amp;quot;inside nav reducer&amp;quot;, state, action);
    const nextState = AppNavigator.router.getStateForAction(action, state);

    // Simply return the original `state` if `nextState` is null or undefined.
    return nextState || state;
};

// 创建 store
let store = createStore(combineReducers({
    // 这里的 MyApp 等和前面定义 mapStateToProps 的地方对应 (6)
    // 这里也是导致 reducer 收到的 state 只有自己命名空间下数据的一个原因 (6)
    MyApp: myAppReducer,
    MyHome: homeReducer,
    nav: navReducer
}));

// 让 redux 加持一下，保佑
let App = connect(mapStateToProps, mapDispatchToProps)(MyStackNavigator);

// 其他的就是比较常见的 redux 的逻辑了，另外需要说明的是实际使用的时候，肯定会做页面拆分，如何拆分可能都会有不同的看法，我也还在摸索
export default class Root extends Component&amp;lt;{}&amp;gt; {
    constructor(props) {
        super(props);
    }

    render() {
        return (
            &amp;lt;Provider store={store}&amp;gt;
                &amp;lt;App prop1=&amp;quot;prop1&amp;quot; /&amp;gt;
            &amp;lt;/Provider&amp;gt;
        );
    }
}


const styles = StyleSheet.create({
    container: {
        flex: 1,
        justifyContent: &#39;center&#39;,
        alignItems: &#39;center&#39;,
        backgroundColor: &#39;#F5FCFF&#39;,
    },
    welcome: {
        fontSize: 20,
        textAlign: &#39;center&#39;,
        margin: 10,
    },
    instructions: {
        textAlign: &#39;center&#39;,
        color: &#39;#333333&#39;,
        marginBottom: 5,
    },
});
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>生生死死《白鹿原》</title>
      <link>https://wdicc.com/life/</link>
      <pubDate>Sat, 07 Oct 2017 18:10:00 +0800</pubDate>
      
      <guid>https://wdicc.com/life/</guid>
      <description>&lt;p&gt;之前 6 月份去上海那边的时候，偶尔看到电视里面演&lt;a href=&#34;https://movie.douban.com/subject/26322644/&#34; title=&#34;《白鹿原》&#34;&gt;《白鹿原》&lt;/a&gt;，看了几集。吸引我的，主要可能是里面的乡土气息，以及里面的几个演员演的挺好的。那会看的好像是 40 多集，并且是断续看的，剧情也不太能接的上。后来回来后，找了一个时间，就从头开始看了。直到今天才算看完。看的时候实在是感慨良多，看完了也是心情不太能平复，稍微记录一下。因为没看过书，记录以电视剧剧情为主。&lt;/p&gt;

&lt;p&gt;这剧从大清末年演到了 49 年建国后，基本是从白嘉轩娶媳妇开始讲到当了族长，到生儿育女，到孩子上学，闹革命，生孩子。到最后剧里面的人物死的死，老的老，实在是看的人很心酸。从一个上帝视角看了这么多人的生生死死，以后还是得少看这种剧了。&lt;/p&gt;

&lt;p&gt;白嘉轩一辈子，挺直了腰杆做人，做事的是非对错不评价，但是确实是可以算是不愧对自己，家教很严，但是也就导致了服从家教的孩子们活的很是平淡，这个其实也就是白嘉轩的理念，踏实种个地抱个娃，平平安安一辈子，也就是了，这也是很多老普通百姓的理念。&#34;房是招牌地是累，按下银钱是催命鬼&#34;，这就是古人对普通人生活的建议。但是这么做就可以踏实一辈子么？可以看到白嘉轩的各种经历，清兵围城，闹土匪，镇嵩军征粮征税，天灾大旱，国民党共产党互相闹，这些事情，你不去惹，事情也会找上你。这是命不好？&lt;/p&gt;

&lt;p&gt;生活这一辈子就是个社交，免不了的要和其他人产生交集，矛盾就会出现，就会遇到问题。躲不掉。所谓你抗争是一辈子，认命也是一辈子，一辈子过去了也就是过去了，没有反悔的机会，不能重新来过。&lt;/p&gt;

&lt;p&gt;鹿子霖从开头争抢族长，到后面坐牢看透人生，到后面老糊涂了，演的实在是很好。普通老百姓，有点小恶，顶多也就是占点小便宜，大恶也不敢，游说小蛾勾引白孝文成功之后，白嘉轩对孝文执行族法，是真的出来劝了，没想到这么严重。小老百姓占点便宜就回家高高兴兴的喝酒了。这人活的也很真实，那点小便宜也就是他的一点追求，能压倒族长一头，就觉得自己很有面子。反而白嘉轩那么大义，倒是有那么些不真实。&lt;/p&gt;

&lt;p&gt;这剧里面两个最悲情的人物，一个是田小蛾，一个就是冷秋月。小蛾没啥别的追求，也就是想有个人能一起踏实过日子。所以黑娃和他住在破窑里面的时候是最开心的，管他其他那些呢，只要能一起好好过日子就可以了。但是可惜，有些事情看不透，参加农协搞事情，以为是好运来了，却没想到那是送命的前兆。以为黑娃死了之后，一个弱女人开始找自己的依靠，一半是为了报仇，一半是真心觉得白孝文对自己真好，开始了自己的第二次的幸福生活。却没想到，命丧在这里。死的很悲情，这也是炮灰，要不是鹿兆鹏拉拢，可能黑娃踏实的攒钱，种地养老婆，一辈子或许平平淡淡的，但是安安全全的就过去了。有欲望，就会被人利用，当然也可以说那是自己想做的，不是利用，但是在做之前有人告诉过后果么，知道了后果，还回去做么？当然，可能也没人能预料到那个后果，还是自己的选择。&lt;/p&gt;

&lt;p&gt;传言鹿兆鹏死了的时候，秋月端着盆子给鹿子霖洗脚，说是代鹿兆鹏做这个事情，那个瞬间就泪崩了。秋月你可以说是死在封建社会下，但是鹿兆鹏也有不可原谅的责任。秋月开始可能真是按照父母之命嫁过去的，但是后面，某次对白里面也说了，那是真心喜欢兆鹏。就像兆海为了白灵终生未娶一样，秋月为了兆鹏也是守了一辈子的寡。鹿兆鹏说是为了他爷爷为了他爸，把人家娶回了家，又让人家守活寡，这个算是一个正确的价值观么？秋月出场之后一辈子，都踏踏实实的照顾兆鹏父母爷爷，为的就是哪天兆鹏可以多看她一眼，就连想要生一个孩子，也是为了说将来给兆鹏父母养老。等了一辈子，最后兆鹏回家说带她走的时候，本以为已经等到头了，结果发现兆鹏的方案还是继续让她守活寡，也就是这一刻，秋月可能才明白，兆鹏这辈子都不可能和她有什么交集了，自己守的这么一辈子，毫无意义，自杀也是她唯一的一个选择了。封建礼数是一半责任，鹿兆鹏本人也有一半责任。&lt;/p&gt;

&lt;p&gt;鹿兆鹏和白嘉轩一样的不真实。&lt;/p&gt;

&lt;p&gt;白灵这个演员确实有点嫩，但是也就是这样，估计才能演好年轻的时候。白灵有句话&#34;我的眼睛睁开了，就不会再闭回去&#34;，一个积极向上的乐观的年轻人，和命运做抗争，看过了各种生死之后，总算要过上安定日子了，死了。可能连自己的孩子都没见上几次。每次看到她，那种跳脱的状态很吸引人，不过也有人不喜欢她。&lt;/p&gt;

&lt;p&gt;看剧的时候，说实话一直担心最后是一个大家都悲惨的结局，虽然知道这是演戏，但是还是希望能有点好的结局。剧里最后也算是一个还可以的结局了，如果把后面的大跃进灾年再写了，真就有点难看了。鹿家活了一个儿子还有孙女，白家活了一个儿子和孙子孙女。&lt;/p&gt;

&lt;p&gt;其他人就不评论了，其实看的时候很多场景都有感触，但是也没记住那么多。看完之后还蛮有冲动再看一次的，但是剧集实在太长了，以后有时间看一下书吧，这个年代拍的电视剧，本身就有太多的忌讳，相信还是原著会更加精彩，而且初步估计，会感觉和电视剧是两个内容，呵呵。当年我高中的时候，拿到一本《平凡的世界》，那会简直就是一刻不停，连续看了几天把书看完了。现在不记得多少内容了，但是那会应该也是被书里描述的农村到城市的历程吸引了吧。现在看白鹿原，里面孩子们最后在县城省城工作，其实和现在的世道没个啥区别。而且其他的，比如这高房价物价，贪官私人关系，可能也可以类比。小老百姓真的可以踏实过日子么？&lt;/p&gt;

&lt;p&gt;踏实过日子，慢慢可能会让人把你玩死。另一个选择就是不甘于现状，当然也不一定求逆天改命，只求能在遇到事情的时候，能给自己多一些路。&lt;/p&gt;

&lt;p&gt;现在年纪大了，确实很多事情慢慢在看透，40 不惑不是都看明白了，是看明白的也就明白了，没看明白的就不看了，所谓看透。这个年纪看这种讲人一生的戏，看到后面那么多的生死，和自己的现实一应证，实在是有点抗不住。人生一辈子，到底是为什么活呢？越来越迷茫了。所以这帖子的英文取名为 Life。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Encrypt and Security</title>
      <link>https://wdicc.com/encrypt-and-security/</link>
      <pubDate>Mon, 02 Oct 2017 13:26:39 +0800</pubDate>
      
      <guid>https://wdicc.com/encrypt-and-security/</guid>
      <description>&lt;p&gt;上周有同学分享了一下加密解密，感觉自己学到了一些东西，记录一下。&lt;/p&gt;

&lt;h2 id=&#34;加密-解密&#34;&gt;加密 &amp; 解密&lt;/h2&gt;

&lt;p&gt;有时候面试的时候会遇到有人讲自己搞过的一些加密方法，会提到「对于 xx 我们使用 md5 加密」，md5 是一种加密方法么？我觉得不是。所谓加密，是对应解密的，不能还原原文的方法，就不应该算加密了吧。&lt;/p&gt;

&lt;p&gt;常常可以听到的，有对称加密和非对称加密。对称加密是指加密解密使用的是同一个密钥的方法，非对称的是指使用不同的密钥的方法。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%25E5%25B0%258D%25E7%25A8%25B1%25E5%25AF%2586%25E9%2591%25B0%25E5%258A%25A0%25E5%25AF%2586&#34; title=&#34;对称密钥加密&#34;&gt;对称密钥加密&lt;/a&gt;的方法有 DES、3DES、AES、Blowfish、IDEA、RC5、RC6。我之前用过其中的 3DES 和 Blowfish。特点是速度快。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%25E5%2585%25AC%25E5%25BC%2580%25E5%25AF%2586%25E9%2592%25A5%25E5%258A%25A0%25E5%25AF%2586&#34; title=&#34;非对称加密&#34;&gt;非对称加密&lt;/a&gt;也叫公开密钥加密，方法有 RSA、ElGamal、背包算法、Rabin（RSA的特例）、迪菲－赫尔曼密钥交换协议中的公钥加密算法、椭圆曲线加密算法（英语：Elliptic Curve Cryptography, ECC）。基本都没怎么用过。。他的特点是其中一个公钥可以公开，公钥加密的信息只能通过私钥解密，只要保证私钥安全就可以。但是这个方法加解密速度较慢。&lt;/p&gt;

&lt;h2 id=&#34;分组模式&#34;&gt;分组模式&lt;/h2&gt;

&lt;p&gt;加密算法并不能说一次给多少数据都可以一次加密完毕，实际处理的时候是按块处理的，先按照一定逻辑分组。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%25E5%2588%2586%25E7%25BB%2584%25E5%25AF%2586%25E7%25A0%2581%25E5%25B7%25A5%25E4%25BD%259C%25E6%25A8%25A1%25E5%25BC%258F&#34; title=&#34;分组模式&#34;&gt;分组模式&lt;/a&gt;有 ECB, CBC, CFB, OFB, CTR等。ECB 就是最简单的，分组之后每块分别加密，然后组合起来。这个方法导致可以任意替换各组的位置而不影响解密。比如原来加密是「A 欠 B 1 万」，每个字刚好一个分组，那即使在不能解密的情况下，也可能导致收到的消息是 「B 欠 A 1 万」。所以就有了其它的那几个加密分组模式，其它的几个模式都会和前后的数据有一定的关系，这样就不能这样调换了。对于第一组数据，加密的时候会需要一个初始化的数据，就是 IV。&lt;/p&gt;

&lt;h2 id=&#34;散列算法&#34;&gt;散列算法&lt;/h2&gt;

&lt;p&gt;也就是 hash 算法。常见的 md5, sha1, sha256, sha512 等。这种是对内容产生一个摘要，是一个有损的过程，根据摘要值，不能得到原文。但是可以通过比对摘要来确认摘要是不是来自相同的内容(有一定的碰撞几率)。&lt;/p&gt;

&lt;h2 id=&#34;https&#34;&gt;https&lt;/h2&gt;

&lt;p&gt;https 是指基于 tls/ssl 协议基础上面跑的 http 协议。建立 ssl 握手之后，就是基于 http 协议的逻辑来在这个 ssl 通道上面传输了。&lt;/p&gt;

&lt;p&gt;握手验证过程中，有两个证书需要用到，一个是 CA Root certificate，还有一个是经过 CA 签名的 Web server certificate。CA 根证书是权威的 CA 机构给到各个浏览器和操作系统内置的一个公钥。Web 服务器证书是权威 CA 机构验证了网站的身份之后，使用 CA 的私钥对证书签名，签名就是根据证书内容先进行 Hash，然后使用私钥加密，把结果作为签名一起放到证书里面。&lt;/p&gt;

&lt;p&gt;Client 访问服务器，会收到服务器返回的 Web 服务器证书，浏览器会根据 CA 根证书对这个证书的签名进行验证，因为那个跟证书其实就是一个公钥，所以可以使用他解开前面加密的签名，然后也使用相同的 Hash 算法把证书内容 hash，比对结果看是否一致，这个会在后面说数字签名的时候再讲。另外，浏览器也会检查比如有效期，域名等，没问题就认为证书有效。然后浏览器会使用证书里面的公钥，继续和 Web 服务器做握手，浏览器会产生一个随机数，用公钥加密然后返回给 Web 服务器。后续双方会使用这个随机数作为密钥，使用一种对称加密方法做后续的加密。&lt;/p&gt;

&lt;p&gt;整个过程中，前面使用非对称加密，协商好一个密钥，后面使用这个密钥来使用对称加密来加密后续的大量的内容。&lt;/p&gt;

&lt;h3 id=&#34;client-hello&#34;&gt;Client hello&lt;/h3&gt;

&lt;p&gt;CLient hello 消息包括&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;TLS 版本&lt;/li&gt;
&lt;li&gt;随机数，时间戳&lt;/li&gt;
&lt;li&gt;Session Id，用来减少握手次数&lt;/li&gt;
&lt;li&gt;支持的加密方式 Cipher Suites&lt;/li&gt;
&lt;li&gt;Server name&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;server-hello&#34;&gt;Server hello&lt;/h3&gt;

&lt;p&gt;Server hello 消息包括&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;TLS 版本，表示同意&lt;/li&gt;
&lt;li&gt;时间戳&lt;/li&gt;
&lt;li&gt;Session Id&lt;/li&gt;
&lt;li&gt;Cipher Suites&lt;/li&gt;
&lt;li&gt;Web 服务器证书&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;验证-web-服务器证书&#34;&gt;验证 Web 服务器证书&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Not Before Time&lt;/li&gt;
&lt;li&gt;Not After Time&lt;/li&gt;
&lt;li&gt;Common Name&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;验证权威-ca-机构的签名&#34;&gt;验证权威 CA 机构的签名&lt;/h3&gt;

&lt;h3 id=&#34;pre-master-secret&#34;&gt;Pre-Master Secret&lt;/h3&gt;

&lt;h2 id=&#34;数字签名&#34;&gt;数字签名&lt;/h2&gt;

&lt;p&gt;比如 A 向 B 借了 100 块钱，这个时候 B 就需要 A 给打一个欠条。一方面，如何保证借条可以安全传输，另一方面，如何保证 A 将来不赖掉这个借条呢？可以使用前面提到的私钥公钥的方法来解决。&lt;/p&gt;

&lt;p&gt;首先 A 把自己的公钥公开，然后把借条内容做一个 Hash，把 hash 结果使用自己的私钥来加密得到一个签名，同时把借条内容和签名给 B。B 拿到借条内容和签名之后，可以用那个公钥解密签名，然后对借条内容 Hash 得到一个 hash 值，比对这两个结果看是否一致。这个过程就完成了。&lt;/p&gt;

&lt;p&gt;如果借条或者是签名在传输过程中被串改，那么 B 就能发现内容的 hash 值和签名解密之后的值不一致。这样就保证了安全。(当然，这里还有个问题是如何保证 B 拿到的公钥是对的，这个感觉肯能是通过其他途径保证的。)&lt;/p&gt;

&lt;p&gt;因为公钥是公开的，任何一个第三方都可以做这个验证，可以验证一致就表示是 A 自己用私钥加密的。这个就保证了 A 无法赖掉这个借条。（我们讨论过，如果公钥不公开，并且没有第三方对这个公钥做了公证，那么是无法保证 A 赖账的。）&lt;/p&gt;

&lt;p&gt;在这个过程里面，我们把借条内容先做一个 Hash，拿到一个 hash 值，然后再加密，这个结果就是一个数字签名了。任何人拿到了公钥，都可以将签名解密，然后可以对借条做相同的 Hash，比对解密出来的值是否等同于那个 hash 值。&lt;/p&gt;

&lt;p&gt;前面 https 里面提到的 CA 权威机构对证书签名，其实就是类似的事。&lt;/p&gt;

&lt;h2 id=&#34;参考连接&#34;&gt;参考连接&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.moserware.com/2009/06/first-few-milliseconds-of-https.html&#34; title=&#34;http://www.moserware.com/2009/06/first-few-milliseconds-of-https.html&#34;&gt;http://www.moserware.com/2009/06/first-few-milliseconds-of-https.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/188266/how-are-ssl-certificates-verified&#34; title=&#34;https://stackoverflow.com/questions/188266/how-are-ssl-certificates-verified&#34;&gt;https://stackoverflow.com/questions/188266/how-are-ssl-certificates-verified&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://crypto.stackexchange.com/questions/5332/how-does-a-client-verify-a-server-certificate&#34; title=&#34;https://crypto.stackexchange.com/questions/5332/how-does-a-client-verify-a-server-certificate&#34;&gt;https://crypto.stackexchange.com/questions/5332/how-does-a-client-verify-a-server-certificate&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Change Blog Theme to Hugo Classic</title>
      <link>https://wdicc.com/change-blog-theme-to-hugo-classic/</link>
      <pubDate>Sat, 30 Sep 2017 21:47:20 +0800</pubDate>
      
      <guid>https://wdicc.com/change-blog-theme-to-hugo-classic/</guid>
      <description>&lt;p&gt;一个主题看久了会腻，原来用的 &lt;a href=&#34;https://github.com/wd/hugo-fabric&#34; title=&#34;hugo-fabric&#34;&gt;hugo-fabric&lt;/a&gt; 也是我在最早的 jeklly 的 fabric 主题上修改的。那个主题偏暗，我把一些颜色调亮了一点，但是还是不是很舒服，对颜色搭配还是没有感觉。&lt;/p&gt;

&lt;p&gt;今天折腾了一下，把 theme 换到了 &lt;a href=&#34;https://github.com/wd/hugo-classic&#34; title=&#34;hugo-classic&#34;&gt;hugo-classic&lt;/a&gt;，这个也是 fork 自一个别人的主题，增加了一些缺失的内容&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;首页分页&lt;/li&gt;
&lt;li&gt;disqus 支持&lt;/li&gt;
&lt;li&gt;code 块颜色不是很明显的问题&lt;/li&gt;
&lt;li&gt;css 全文输出&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;del&gt;后面可能还想把 tags 页面做成横向的列表，目前那个有点太占位置了。不过目前还没找到比较好看一点的设计，遇到再说了。另外刚发现那个 code 块的空白太多了，可能回头也调整一下。&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;已经弄了一个 tag 的样式，先这么看着吧。另外也修正了一下 code 的空白。发现 org 的 &lt;code&gt;BEGIN_SRC&lt;/code&gt; 输出的时候，会加一个换行在第一行，这个导致多了一个空白行，稍微有点丑了，回头有时间再看看是哪里的问题吧。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Dpi dp and px</title>
      <link>https://wdicc.com/dpi-dp-and-px/</link>
      <pubDate>Sat, 16 Sep 2017 10:18:50 +0800</pubDate>
      
      <guid>https://wdicc.com/dpi-dp-and-px/</guid>
      <description>&lt;p&gt;这几天折腾了一下 android 上面的布局，了解了一些基础概念。&lt;/p&gt;

&lt;p&gt;首先有两个概念，一个是分辨率，一个是屏幕的实际尺寸。我们一般讲的 &lt;code&gt;800x600&lt;/code&gt; 像素(px)，&lt;code&gt;1024x768&lt;/code&gt; 像素(px)这些，都是分辨率。然后 &lt;code&gt;5.5&lt;/code&gt; 寸(iPhone 6/7/8 plus)，&lt;code&gt;4.7&lt;/code&gt; 寸(iPhone 6/7/8)，&lt;code&gt;10.1&lt;/code&gt; 寸(iPad) 这些是实际尺寸，并且指的是屏幕对角线尺寸。&lt;/p&gt;

&lt;p&gt;一般来讲，除非是 5.5 和  10.1 这么大的差异，我们大多会在比如 5.5 和 4.7 上面使用同一个设计。比如在最上面 1cm (为什么说物理距离呢，因为手机屏幕就那么大，你不能把内容显示的太小，否则会看不清楚) 显示一个黄色的提示条。那么接下来的问题就是，1cm 对应的像素，就算在同一个设备的不同的分辨率下面，都是不一样的。那图怎么做？&lt;/p&gt;

&lt;p&gt;如果 20px 的图放到 800x600 的分辨率下面刚好，那么这个图放到了 1600x1200 的分辨率下面（这里说的是屏幕物理尺寸不变的情况下，因为如果物理尺寸如果也变大了，那就是另外一个情况了），不做缩放的话，就是会得到比 800x600 小一倍的效果。如果缩放的话，那就大小一样了，但是可能因为缩放导致失真。实际做法就是针对不同分辨率做不同的尺寸的图。比如针对 800x600 分辨率，做一个 20px 的图，那对于 1600x1200 分辨率的，做一个 40px 的图。以此类推。&lt;/p&gt;

&lt;p&gt;这样，三个概念就出来了&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;density&lt;/code&gt; 也就是 dpi，屏幕密度。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dp&lt;/code&gt; 是一个长度单位。&lt;/li&gt;
&lt;li&gt;常见的 &lt;code&gt;1x&lt;/code&gt;, &lt;code&gt;2x&lt;/code&gt;, &lt;code&gt;@2x&lt;/code&gt; 这些。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;density(dpi，屏幕密度) = 屏幕对角线的像素/对角线的物理尺寸 = (屏幕长的像素的平方 + 屏幕宽的像素的平方)开根号/对角线的物理尺寸&lt;/code&gt;，比如 iphone 3G/3GS 是 160, iphone 4 是 320。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;dp = px x 160 / dpi&lt;/code&gt;。比如 160dp 在 160 dpi 下面是 160px，在 320 dpi 下面是 320px。其实就是说，160dp 我们在 iphone 3g 上和在 iphone 4 上看到的物理长度是一样的。&lt;/p&gt;

&lt;p&gt;而 &lt;code&gt;1x&lt;/code&gt;, &lt;code&gt;2x&lt;/code&gt; 是 &lt;code&gt;px/dp = dpi/160&lt;/code&gt;。从上面那个例子也能看到，这个其实就是指 px 和 dp 的换算关系。一般我们要在某个手机上面开发，主要弄清楚的就是这个倍率就可以了。在 1x 的设备上面，想要展示 10px 的图，那么给 2x 的设备就得切一个 20px 的图，才能达到和 1x 上面一样的视觉效果。&lt;/p&gt;

&lt;p&gt;那我们一个 app 是需要同时准备展示在很多类型的设备上面的，1x, 1.5x, 2x 3x 等，总不能靠程序去计算然后决定用什么图吧。各系统其实已经做好了简单的适配方法了。比如 ios 里面，是通过给图取不同的名字来解决的，例如 example@2x.png，example@3x.png，ios 系统会自动去用对应的图。而 android 系统里面，是通过把图放入不同的目录来解决的，例如 drawable，drawable-hdpi, drawable-xhdbi，这几个分别对应 1x, 1.5x, 2x。&lt;/p&gt;

&lt;p&gt;其中要注意的是不要放错目录。如果把一个 1.5x 的图，放到了 1x 的目录下面，然后展示在一个 1.5x 的设备下面，会发现图会被缩放到 1.5 倍大小。&lt;/p&gt;

&lt;p&gt;参考链接:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.jianshu.com/p/913943d25829&#34;&gt;http://www.jianshu.com/p/913943d25829&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/20697111&#34;&gt;https://www.zhihu.com/question/20697111&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Add float debug button for react native</title>
      <link>https://wdicc.com/add-float-debug-button-for-react-native/</link>
      <pubDate>Sat, 02 Sep 2017 18:22:47 +0800</pubDate>
      
      <guid>https://wdicc.com/add-float-debug-button-for-react-native/</guid>
      <description>

&lt;p&gt;React-native 里面在模拟器里面可以通过快捷键打开开发菜单，在设备里面可以通过摇晃设备打开开发菜单。但是摇晃有时候并不是一个好的操作，比如是个 pad，或者比如你自己的设备本身会触发晃动动作。那么如何在开发模式下面增加一个按钮打开这个菜单呢？可惜官方对这个功能没有兴趣多做开发 &lt;a href=&#34;https://github.com/facebook/react-native/issues/10191&#34;&gt;https://github.com/facebook/react-native/issues/10191&lt;/a&gt; 。&lt;/p&gt;

&lt;h2 id=&#34;ios&#34;&gt;iOS&lt;/h2&gt;

&lt;p&gt;ios 里面直接就把这个接口暴露出来了，可以直接在 js 里面调用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import {NativeModules} from &#39;react-native&#39;;

// 在某个按钮的动作里面
const {DevMenu} = NativeModules;
DevMenu.show();
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;android&#34;&gt;Android&lt;/h2&gt;

&lt;p&gt;iOS 是 react-native 的亲儿子，Android 里面并没有那么方便的方法，得自己通过 native 代码加。&lt;/p&gt;

&lt;p&gt;下面两种方式加的都是 &lt;code&gt;android.support.design.widget.FloatingActionButton&lt;/code&gt; 按钮，其它的类似。需要增加好编译依赖 &lt;code&gt;compile &#39;com.android.support:design:23.0.0&#39;&lt;/code&gt;，版本号按照自己的修改下。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;        private void addDevButton() {

            MainApplication application = (MainApplication) getApplication();
            ReactNativeHost reactNativeHost = application.getReactNativeHost();
            ReactInstanceManager reactInstanceManager = reactNativeHost.getReactInstanceManager();
            final DevSupportManager devSupportManager = reactInstanceManager.getDevSupportManager();

            // 这里是增加一个自定义菜单
//            devSupportManager.addCustomDevOption(&amp;quot;Custom dev option&amp;quot;, new DevOptionHandler() {
//                @Override
//                public void onOptionSelected() {
//                    Toast.makeText(MainActivity.this, &amp;quot;Hello from custom dev option&amp;quot;, Toast.LENGTH_SHORT).show();
//                }
//            });


            // Fake empty container dev_button_layout
            // 创建一个 layout
            RelativeLayout lContainerLayout = new RelativeLayout(mActivity.getApplicationContext());
            lContainerLayout.setLayoutParams(new RelativeLayout.LayoutParams(
                    ViewGroup.LayoutParams.MATCH_PARENT , ViewGroup.LayoutParams.MATCH_PARENT ));

            // custom view
            // 创建一个 button
            FloatingActionButton button = new FloatingActionButton(mActivity);
            button.setImageResource(R.drawable.ga_airplane);

            RelativeLayout.LayoutParams lButtonParams = new RelativeLayout.LayoutParams(
                    ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT
            );
            lButtonParams.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);
            lButtonParams.addRule(RelativeLayout.ALIGN_PARENT_BOTTOM);
            button.setLayoutParams(lButtonParams);

            ViewGroup.MarginLayoutParams mp = (ViewGroup.MarginLayoutParams) button.getLayoutParams();
            mp.setMargins(0, 0, 0, dpToPx(mActivity, 125));

            button.setLayoutParams(mp);

            //设定拖动动作
            button.setOnTouchListener(new View.OnTouchListener() {
                @Override
                public boolean onTouch(View v, MotionEvent event) {
                    switch (event.getActionMasked()) {
                        case MotionEvent.ACTION_DOWN:
                            dX = v.getX() - event.getRawX();
                            dY = v.getY() - event.getRawY();
                            lastAction = MotionEvent.ACTION_DOWN;
                            break;

                        case MotionEvent.ACTION_MOVE:
                            v.setY(event.getRawY() + dY);
                            v.setX(event.getRawX() + dX);
                            lastAction = MotionEvent.ACTION_MOVE;
                            break;

                        case MotionEvent.ACTION_UP:
                            if (lastAction == MotionEvent.ACTION_DOWN)
                                // 点击的时候打开菜单
                                devSupportManager.showDevOptionsDialog();
                            break;

                        default:
                            return false;
                    }
                    return true;
                }
            });

            lContainerLayout.addView(button);
            addContentView(lContainerLayout, new ViewGroup.LayoutParams(
                    ViewGroup.LayoutParams.MATCH_PARENT , ViewGroup.LayoutParams.MATCH_PARENT ));
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面是纯代码方式，还可以通过 xml 文件方式搞定。&lt;/p&gt;

&lt;p&gt;新建一个 layout 文件，取名比如叫做 &lt;code&gt;dev_button_layout.xml&lt;/code&gt;， rootTag 是 &lt;code&gt;RelativeLayout&lt;/code&gt;。然后在里面添加一个 &lt;code&gt;FloatingActionButton&lt;/code&gt;，id 设置为 &lt;code&gt;dev_button&lt;/code&gt;，然后设置好属性和位置。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;        private void addDevButton() {
            MainApplication application = (MainApplication) getApplication();
            ReactNativeHost reactNativeHost = application.getReactNativeHost();
            ReactInstanceManager reactInstanceManager = reactNativeHost.getReactInstanceManager();
            final DevSupportManager devSupportManager = reactInstanceManager.getDevSupportManager();

            View view = View.inflate(mActivity, R.layout.dev_button_layout, null);
            FloatingActionButton button = (FloatingActionButton) view.findViewById(R.id.dev_button);
            //button.setImageResource(R.drawable.ga_airplane);

            button.setOnTouchListener(new View.OnTouchListener() {
                @Override
                public boolean onTouch(View v, MotionEvent event) {
                    switch (event.getActionMasked()) {
                        case MotionEvent.ACTION_DOWN:
                            dX = v.getX() - event.getRawX();
                            dY = v.getY() - event.getRawY();
                            lastAction = MotionEvent.ACTION_DOWN;
                            break;

                        case MotionEvent.ACTION_MOVE:
                            v.setY(event.getRawY() + dY);
                            v.setX(event.getRawX() + dX);
                            lastAction = MotionEvent.ACTION_MOVE;
                            break;

                        case MotionEvent.ACTION_UP:
                            if (lastAction == MotionEvent.ACTION_DOWN)
                                devSupportManager.showDevOptionsDialog();
                            break;

                        default:
                            return false;
                    }
                    return true;
                }
            });

            addContentView(view, new ViewGroup.LayoutParams(
                    ViewGroup.LayoutParams.MATCH_PARENT , ViewGroup.LayoutParams.MATCH_PARENT ));
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在你的 &lt;code&gt;MainActivity&lt;/code&gt; 的 &lt;code&gt;onCreate&lt;/code&gt; 里面，在 &lt;code&gt;super.onCreate(savedInstanceState);&lt;/code&gt; 后面增加&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;            // debug 环境下才显示
            if(BuildConfig.DEBUG)
                addDevButton();
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Emacs as react native ide</title>
      <link>https://wdicc.com/emacs-as-react-native-ide/</link>
      <pubDate>Mon, 24 Jul 2017 20:02:00 +0800</pubDate>
      
      <guid>https://wdicc.com/emacs-as-react-native-ide/</guid>
      <description>

&lt;p&gt;最近又在写 &lt;code&gt;react-native&lt;/code&gt; 了，对自己的环境又作了一番配置。记录一下。&lt;/p&gt;

&lt;h2 id=&#34;web-mode&#34;&gt;web-mode&lt;/h2&gt;

&lt;p&gt;我主要用的 mode 是 web-mode。这个 mode 简直万能，能处理 html，jsx，js 等。具体配置如下。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(use-package web-mode
  :ensure t
  :config
  (add-to-list &#39;auto-mode-alist &#39;(&amp;quot;\\.html\\&#39;&amp;quot; . web-mode))
  (add-to-list &#39;auto-mode-alist &#39;(&amp;quot;\\.js\\&#39;&amp;quot; . web-mode))
  (add-to-list &#39;auto-mode-alist &#39;(&amp;quot;\\.ejs\\&#39;&amp;quot; . web-mode))
  (setq web-mode-markup-indent-offset 4)
  (setq web-mode-css-indent-offset 4)
  (setq web-mode-code-indent-offset 4)

  (setq web-mode-content-types-alist
        &#39;((&amp;quot;jsx&amp;quot; . &amp;quot;.*\\.js\\&#39;&amp;quot;))
        )
)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;主要是那个 &lt;code&gt;web-mode-content-types-alist&lt;/code&gt; 的配置，让 web-mode 处理 js 文件的时候，把 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 代码段识别成 jsx。这样能把缩进处理好。&lt;/p&gt;

&lt;p&gt;我还试过 rjsx-mode，这个用起来也可以，基于 js2-mdoe，js2-mode 有的一些用法都支持，并且 flycheck 都不用做多余的配置。但是主要问题是，jsx 的代码缩进有问题。&lt;/p&gt;

&lt;h2 id=&#34;flycheck&#34;&gt;flycheck&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;(use-package flycheck
  :ensure t
  :config
  (global-flycheck-mode t)
  (flycheck-add-mode &#39;javascript-eslint &#39;web-mode)
)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;把 web-mode 的 checker 设置为 &lt;code&gt;javascript-eslint&lt;/code&gt;，如果你用别的就设置成对应的。配合用的 .eslintrc 文件如下，可以根据自己需求调整。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &amp;quot;parser&amp;quot;: &amp;quot;babel-eslint&amp;quot;,
    &amp;quot;env&amp;quot;: {
        &amp;quot;es6&amp;quot;: true
    },
    &amp;quot;parserOptions&amp;quot;: {
        &amp;quot;ecmaVersion&amp;quot;: 6,
        &amp;quot;sourceType&amp;quot;: &amp;quot;module&amp;quot;,
        &amp;quot;ecmaFeatures&amp;quot;: {
            &amp;quot;jsx&amp;quot;: true
        }
    },
    &amp;quot;plugins&amp;quot;: [
        &amp;quot;react&amp;quot;
    ],
    &amp;quot;globals&amp;quot;: {
        &amp;quot;require&amp;quot;: false,
        &amp;quot;module&amp;quot;: false,
        &amp;quot;setInterval&amp;quot;: false,
        &amp;quot;clearInterval&amp;quot;: false,
        &amp;quot;setTimeout&amp;quot;: false,
        &amp;quot;clearTimeout&amp;quot;: false,
        &amp;quot;console&amp;quot;: false
    },
    &amp;quot;extends&amp;quot;: [
        &amp;quot;eslint:recommended&amp;quot;,
        &amp;quot;plugin:react/recommended&amp;quot;
    ],
    &amp;quot;rules&amp;quot;: {
        // overrides
        &amp;quot;react/prop-types&amp;quot;: 0,
        &amp;quot;indent&amp;quot;: [&amp;quot;error&amp;quot;, 4],
        &amp;quot;react/jsx-indent&amp;quot;: [&amp;quot;error&amp;quot;, 4],
        &amp;quot;no-trailing-spaces&amp;quot;: 2,
        &amp;quot;no-console&amp;quot;: 0,
        &amp;quot;comma-dangle&amp;quot;: [&amp;quot;error&amp;quot;, &amp;quot;never&amp;quot;]
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;补全&#34;&gt;补全&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;(use-package tern
  :ensure t
  :config
  (add-hook &#39;web-mode-hook (lambda () (tern-mode t)))
  :bind (:map tern-mode-keymap
              (&amp;quot;M-*&amp;quot; . tern-pop-find-definition))
  )

(use-package company-tern
  :ensure t
  :config
  (add-to-list &#39;company-backends &#39;company-tern)
  )

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我用的是 company 后端用的是 tern。.tern-project 的内容如下，可以根据自己的情况调整下。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;ecmaVersion&amp;quot;: 6,
  &amp;quot;libs&amp;quot;: [
    &amp;quot;browser&amp;quot;
  ],
  &amp;quot;loadEagerly&amp;quot;: [
    &amp;quot;Controller/*.js&amp;quot;,
    &amp;quot;Utility/*.js&amp;quot;,
    &amp;quot;App.js&amp;quot;
  ],
  &amp;quot;dontLoad&amp;quot;: [
    &amp;quot;node_modules/**&amp;quot;
  ],
  &amp;quot;plugins&amp;quot;: {
    &amp;quot;node&amp;quot;: {},
    &amp;quot;es_modules&amp;quot;: {},
    &amp;quot;jsx&amp;quot;: {}
  }
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Django middleware</title>
      <link>https://wdicc.com/django-middleware/</link>
      <pubDate>Wed, 05 Jul 2017 18:07:50 +0800</pubDate>
      
      <guid>https://wdicc.com/django-middleware/</guid>
      <description>&lt;p&gt;Django 提供了 &lt;a href=&#34;https://docs.djangoproject.com/en/1.11/topics/http/middleware/&#34; title=&#34;middleware&#34;&gt;middleware&lt;/a&gt; 来让你 hack Request 和 Response。用的时候有几个问题需要注意一下。&lt;/p&gt;

&lt;h1 id=&#34;call-方法&#34;&gt;&lt;code&gt;__call__&lt;/code&gt; 方法&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;__call__&lt;/code&gt; 方法实际上就是最早收到 request 的地方，如果不关心 view，那么就可以在这里做你想要做的事情。比如认证用户啥的。这个实际上应该就是早期的 &lt;code&gt;process_request&lt;/code&gt; 。&lt;/p&gt;

&lt;h1 id=&#34;process-view-方法&#34;&gt;process_view 方法&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;process_view&lt;/code&gt; 方法会接收到 view_func 和其参数，如果想要针对这些东西处理，可以在这里动作。比如我们所有 api 请求的 POST 的 body 里面都是固定格式的 json 数据，我就在这里检查了 json 的格式，并把解析结果给到了 view_func。&lt;/p&gt;

&lt;p&gt;如果不打算对 view_func 做什么事情，那就最好做完想做的事情，直接返回 &lt;code&gt;None&lt;/code&gt; 就可以。否则处理完毕之后，返回一个 response 对象。&lt;/p&gt;

&lt;p&gt;要注意的是，这里最好不要产生 exception，产生了会把逻辑跑到 Middleware 的 exception 逻辑里面。所以最好对自己的代码段加上 try-except 逻辑。&lt;/p&gt;

&lt;p&gt;另外，这里可以对 view_func 做调用，直接返回 view_func 的结果或者处理之后的结果，只要保证是个 response 对象就可以了。也可以不做调用，返回 &lt;code&gt;None&lt;/code&gt; ，后续 django 也会调用。要注意的是，如果你对 view_func 做了调用，那么在捕捉到错误的时候，except 里面应该也需要返回一个 response 对象，不能返回 &lt;code&gt;None&lt;/code&gt; 了，否则 djangon 还会再次调用这个 view_func 。&lt;/p&gt;

&lt;h1 id=&#34;process-exception-方法&#34;&gt;process_exception 方法&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;process_exception&lt;/code&gt; 方法是在 view 报错的情况下会调用。我在这里统一返回了 server error 的 json，http 状态是 200 的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Emacs as python IDE</title>
      <link>https://wdicc.com/emacs-as-python-ide/</link>
      <pubDate>Fri, 30 Jun 2017 20:47:56 +0800</pubDate>
      
      <guid>https://wdicc.com/emacs-as-python-ide/</guid>
      <description>&lt;p&gt;最近 python 写的比较多，比较了几个编辑器，最后还是留下了 emacs。&lt;/p&gt;

&lt;p&gt;主要比较了 emacs 和 pycharm。pycharm 绝对是一个很强的 IDE，几乎可以补全任何东西，写代码各种提示。比如 Django 里面定义一个 model User 之后，就可以 &lt;code&gt;User.&lt;/code&gt; 之后提示 &lt;code&gt;objects&lt;/code&gt; ，这个是依据 metaclass 来补全的。另外还有比如写 &lt;code&gt;User.objects.get(|)&lt;/code&gt; 的时候，光标在竖线那个位置，会提示 &lt;code&gt;User&lt;/code&gt; 的字段，这个相当好用。这两个只是皮毛，实在是太好用了。&lt;/p&gt;

&lt;p&gt;但是为什么还要用 emacs 呢？emacs 的编辑器功能太好用了。比如 &lt;code&gt;&amp;lt;&lt;/code&gt; 到页首， &lt;code&gt;&amp;gt;&lt;/code&gt; 到页尾， &lt;code&gt;C-x b&lt;/code&gt; 切换 buffer，还有切换 frame，等等快捷键非常舒服，完全不用鼠标。不过也可能是我习惯了 emacs 的快捷键了。在 pycharm 里面时不时就不行，比如选择一段文字，纯键盘需要按 &lt;code&gt;-&amp;gt;&lt;/code&gt; 配合才可以，那还不如用鼠标算了。&lt;/p&gt;

&lt;p&gt;其实如果一上手就用 pycharm，那绝对会觉得很爽。&lt;/p&gt;

&lt;p&gt;emacs 写 python 在原生的 &lt;code&gt;python-mode&lt;/code&gt; 基础上有两个好用的选择，一个是 &lt;a href=&#34;https://github.com/proofit404/anaconda-mode&#34; title=&#34;anaconda-mode&#34;&gt;anaconda-mode&lt;/a&gt;，一个是 &lt;a href=&#34;https://github.com/jorgenschaefer/elpy&#34; title=&#34;elpy&#34;&gt;elpy&lt;/a&gt;。 &lt;code&gt;anaconda-mode&lt;/code&gt; 相对来说比较简陋一点，但是补全什么的没问题，缺少重构功能。两个的工作模式都是会启动一个补全用的进程，然后通过 lisp 和这个进程交互获取补全信息。&lt;/p&gt;

&lt;h2 id=&#34;anaconda-mode-遇到的问题和解决&#34;&gt;anaconda-mode 遇到的问题和解决&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;anaconda-mode&lt;/code&gt; 我遇到一个问题，为了下载 emacs 的 package 方便，我设置了代理，这个代理导致 &lt;code&gt;anaconda-mode&lt;/code&gt; 和补全进程交互的时候，连接不能断开，就会不停的新建连接，一会就打开文件数满了，可以参观这个 &lt;a href=&#34;https://github.com/proofit404/anaconda-mode/issues/255&#34; title=&#34;issue&#34;&gt;issue&lt;/a&gt;。主要是设置了 &lt;code&gt;no_proxy&lt;/code&gt; 解决。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
 (setq url-proxy-services
       &#39;((&amp;quot;no_proxy&amp;quot; . &amp;quot;^\\(127.0.0.1\\|localhost\\|10.*\\)&amp;quot;)
         (&amp;quot;http&amp;quot; . &amp;quot;127.0.0.1:6152&amp;quot;)
         (&amp;quot;https&amp;quot; . &amp;quot;127.0.0.1:6152&amp;quot;)))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;auto-virtualenv&#34;&gt;auto-virtualenv&lt;/h2&gt;

&lt;p&gt;我的 python 项目使用了 &lt;code&gt;virtualenv&lt;/code&gt; ，会在项目目录下面建一个 &lt;code&gt;.venv&lt;/code&gt; 的目录，把虚拟环境放进去。 &lt;code&gt;anaconda-mode&lt;/code&gt; 提供了 &lt;code&gt;pythonic-activate&lt;/code&gt; 命令， &lt;code&gt;elpy&lt;/code&gt; 提供了 &lt;code&gt;pyvenv-activate&lt;/code&gt; 来切换环境。但是每次打开项目都需要搞一下就挺恶心了。&lt;/p&gt;

&lt;p&gt;然后找到了 &lt;a href=&#34;https://github.com/marcwebbie/auto-virtualenv&#34; title=&#34;auto-virtualenv&#34;&gt;auto-virtualenv&lt;/a&gt; 这个工具。安装之后，他会自动查找你的项目里面的可能的虚拟环境。项目根目录识别是通过 &lt;code&gt;.git&lt;/code&gt; ， &lt;code&gt;.hg&lt;/code&gt; 等一些逻辑来判定的，具体可以看代码。然后虚拟环境识别是通过根目录下面的 &lt;code&gt;.python-version&lt;/code&gt; &lt;code&gt;.venv&lt;/code&gt; 等来识别的。&lt;/p&gt;

&lt;p&gt;我的项目是建了一个 &lt;code&gt;.venv&lt;/code&gt; 目录，所以每次打开一个 python 文件，会自动配置好 virtualenv 的环境，这样 &lt;code&gt;elpy&lt;/code&gt; 在 django 自带的 model 上面也可以查找 defination。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
(use-package auto-virtualenv
  :ensure t
  :config
  (add-hook &#39;python-mode-hook &#39;auto-virtualenv-set-virtualenv)
)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;elpy&#34;&gt;elpy&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;elpy&lt;/code&gt; 其实没有什么好配置的，主要注意的是，因为我们用了 virtualenv 环境，所以需要他依赖的包都装在 &lt;code&gt;.venv&lt;/code&gt; 环境或者装在 python 自己的目录下面应该都可以。启动 emacs 之后可以使用 &lt;code&gt;M-x elpy-config&lt;/code&gt; 看看还有什么没配置好。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
(use-package elpy
  :ensure t
  :init
  (setq elpy-rpc-backend &amp;quot;jedi&amp;quot;)
  (elpy-enable)
  :config
  (add-hook &#39;python-mode-hook &#39;elpy-mode)
  (with-eval-after-load &#39;elpy
  (add-hook &#39;elpy-mode-hook &#39;elpy-use-ipython))
  :bind ((&amp;quot;M-*&amp;quot; . pop-tag-mark))
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;elpy-rpc-backend&lt;/code&gt; 有两个选择，一个 &lt;code&gt;jedi&lt;/code&gt; ，一个 &lt;code&gt;rope&lt;/code&gt; ，我试了感觉区别不大，另外 rope 感觉要死了。所以我用了 &lt;code&gt;jedi&lt;/code&gt; 。&lt;/p&gt;

&lt;h2 id=&#34;flycheck&#34;&gt;flycheck&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/flycheck/flycheck&#34; title=&#34;flycheck&#34;&gt;flycheck&lt;/a&gt; 可以配合 &lt;code&gt;flake8&lt;/code&gt; 实时显示出来你的代码有不符合 flake8 要求的地方，很方便。这个工具我也遇到一个坑 &lt;a href=&#34;https://github.com/flycheck/flycheck/issues/1228#issuecomment-311706873&#34; title=&#34;issue&#34;&gt;issue&lt;/a&gt;，有兴趣可以看看。主要原因是 flycheck 是使用 &lt;code&gt;flake8 &amp;lt; xxx.py&lt;/code&gt; 这种方式检查的，而这种方式下 flake8 不会考虑文件头部的 &lt;code&gt;coding&lt;/code&gt; 设置，来识别文件编码，而是根据 &lt;code&gt;LC_CTYPE&lt;/code&gt; 环境变量来的，所以只要正确设置这个变量就可以了。 issue 里面提到的设置 emacs 的编码屁用么有的。&lt;/p&gt;

&lt;p&gt;flycheck 可以配合 flake8 和 pylint 来做 python 代码的检查，如果装了前者，就不会考虑后者了。我试过 pylint，这货默认要求有点高，比如 class 和 method 没有 doc string 也会提示，代码一堆问题，我就赶紧换掉了。。。&lt;/p&gt;

&lt;h2 id=&#34;python-outline&#34;&gt;python outline&lt;/h2&gt;

&lt;p&gt;好处是打开 python 文件的时候，会把代码都折叠起来，按照需要你自己打开就好。elpa 里面没有，网上搜到的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
(use-package python-magic
  :ensure outline-magic
  :config
  (add-hook &#39;python-mode-hook &#39;my-python-outline-hook)
  (add-hook &#39;python-mode-hook
            (lambda ()
              (setq outline-regexp &amp;quot;def\\|class &amp;quot;)))

  )
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;indent-tools&#34;&gt;indent-tools&lt;/h2&gt;

&lt;p&gt;这个工具是用来锁进 python 代码和浏览代码用的。搜一下有动图，看看就知道了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
(use-package indent-tools
  :ensure t
  :init
  (add-hook &#39;python-mode-hook
            (lambda () (define-key python-mode-map (kbd &amp;quot;C-c i&amp;quot;) &#39;indent-tools-hydra/body))
            )
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;yasnippet-和-company&#34;&gt;yasnippet 和 company&lt;/h2&gt;

&lt;p&gt;elpy 是使用这两个补全的。有几个有用的配置， &lt;code&gt;C-s&lt;/code&gt; 那个，可以在补全候选菜单出来的时候，用关键词过滤结果。&lt;/p&gt;

&lt;p&gt;我没搞定在 company 里面直接显示出来 yasnippet 可用的 snippet，只好设置了一个快捷键 &lt;code&gt;C-c y&lt;/code&gt; 来提示。可以提示出来一大堆。比如我经常写错的 &lt;code&gt;-*- coding:utf8 -*-&lt;/code&gt; 有一个 snippet 叫做 &lt;code&gt;utf8&lt;/code&gt; ，直接输入之后 tab 就可以了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
(use-package company
  :ensure t
  :init
  (setq company-minimum-prefix-length 2)
  (setq company-dabbrev-ignore-case t)
  :config
  (add-hook &#39;after-init-hook &#39;global-company-mode)
  (define-key company-active-map (kbd &amp;quot;C-n&amp;quot;) #&#39;company-select-next)
  (define-key company-active-map (kbd &amp;quot;C-p&amp;quot;) #&#39;company-select-previous)
  (define-key company-active-map (kbd &amp;quot;C-s&amp;quot;) #&#39;company-filter-candidates)

  (global-set-key (kbd &amp;quot;C-c y&amp;quot;) &#39;company-yasnippet)
  )
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Run ssserver on VPS</title>
      <link>https://wdicc.com/run-ssserver-on-vps/</link>
      <pubDate>Fri, 09 Jun 2017 10:55:44 +0800</pubDate>
      
      <guid>https://wdicc.com/run-ssserver-on-vps/</guid>
      <description>&lt;p&gt;VPS 上面好早以前用过 docker 跑了一个 container 运行了一个 ssserver, 是从 debian 基本系统创建, 然后手动安装各种软件弄好的. 最近朋友升级了 docker, 那个工作有点问题了,就重新搞了一下, 发现现在好方便.&lt;/p&gt;

&lt;p&gt;我用的是这里提供的 dockerfile https://github.com/EasyPi/docker-shadowsocks-libev, 他的例子里面使用了 &lt;code&gt;docker-compose&lt;/code&gt; 来创建, 发现很简单, 不过遇到了一个问题, 说一下解决办法.&lt;/p&gt;

&lt;p&gt;这个 docker 本地监听的端口是固定的 8388 不能修改, 例如 docker-compose.yml 里面&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
server:
  image: easypi/shadowsocks-libev
  container_name: wd-ss
  ports:
    - &amp;quot;HOST_PORT:8388/tcp&amp;quot;
    - &amp;quot;HOST_PORT:8388/udp&amp;quot;
  environment:
    - METHOD=aes-256-cfb
    - PASSWORD=5ouMnqPyzseL
  restart: always
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要配置的是 &lt;code&gt;HOST_PORT&lt;/code&gt; &lt;code&gt;METHOD&lt;/code&gt; &lt;code&gt;PASSWORD&lt;/code&gt; 这三个变量, 然后我还指定了 &lt;code&gt;container_name&lt;/code&gt; 方便以后的操作, 不指定会自动产生一个.&lt;/p&gt;

&lt;p&gt;启动服务之后,可以使用 &lt;code&gt;docker logs wd-ss&lt;/code&gt; 来看 log, 类似于下面, 这个 docker 启用了 udp relay 和 tcp fast open, 差不多也就够了.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
 2017-06-09 03:13:17 INFO: using tcp fast open
 2017-06-09 03:13:17 INFO: UDP relay enabled
 2017-06-09 03:13:17 INFO: initializing ciphers... aes-256-cfb
 2017-06-09 03:13:17 INFO: using nameserver: 8.8.8.8
 2017-06-09 03:13:17 INFO: tcp server listening at 0.0.0.0:8388
 2017-06-09 03:13:17 INFO: udp server listening at 0.0.0.0:8388
 2017-06-09 03:13:17 INFO: running from root user
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果想要开启更多选项, 可以在 compose 文件里面使用 command 自定义启动命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
  command:
    ss-server -s 0.0.0.0
              -p 8338
              -k 5C4D5403-31C9
              -m aes-256-cfb
              -t 30
              --fast-open
              -u
              -a nobody
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;自己实验过程中, 如果可以随时删除自己的 container 重建, 将来 ss 升级的话, 只需要把 image 更新一下,然后删除再新建一下 container 就好了.用起来还是相当简单方便的.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Meetings and meetings</title>
      <link>https://wdicc.com/meetings-and-meetings/</link>
      <pubDate>Sat, 08 Apr 2017 15:16:49 +0800</pubDate>
      
      <guid>https://wdicc.com/meetings-and-meetings/</guid>
      <description>&lt;p&gt;前几天&lt;a href=&#34;https://haohailong.net/&#34; title=&#34;海龙&#34;&gt;海龙&lt;/a&gt; 在 twitter 的提了一个问题“这个世界上有喜欢开会的人吗？能和我说说理由吗？”。作为开了很多会的人，由不住想说两句。&lt;/p&gt;

&lt;ul&gt;
首先，高质量的会应该具备什么呢？我也没看过《罗伯特议事规则》这样的书（放在 kindle 里面好久了一直没看过，汗颜。。），就是自己按照自己参与的情况总结下：
&lt;li&gt;会议前必要的沟通，好确认是不是需要你参加。当然也有一定可能性组织会议的人确认需要你参加而不做沟通（当然也不排除判断错误的时候 QAQ）。&lt;/li&gt;
&lt;li&gt;组织会议的人做好前期调研，会议讨论的一些相关方案的基本情况应该需要比较了解。避免好容易召集齐人之后，发现要讨论的内容本身自己互相矛盾，或者需要参会的人没有通知等情况。&lt;/li&gt;
&lt;li&gt;邮件通知与会人会议要沟通的内容，和希望达成的目标，让大家提前了解事情的原委。也给大家一个机会提前确认下是不是真的和自己有关系。&lt;/li&gt;
&lt;li&gt;有了希望达成的目标，就应该会比较明确具体需要谁参与，比如想要一个明确的决定的时候，却约一个不能拍板的人来，这会议注定不能成功。&lt;/li&gt;
&lt;li&gt;会议中有可以控制会议节奏的人主持。能适时的阻止一些无关话题，扯皮，控制会议节奏，避免开大长会和会上吵架。&lt;/li&gt;
&lt;li&gt;会议中有人记录会议记录，结束后有人会把会议记录和结论(这个很重要，没有结论的会就是没必要开的会)发给所有人。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面列几个我作为技术人员常见的一些烂会。&lt;/p&gt;

&lt;p&gt;产品总监派一个刚入职几天业务都没摸清的人召集一帮干了好几年的工程师开会。这种情况下，产品经理大概率会被工程师各种怼，因为他不可能真的熟悉产品，工程师提到的很多可能的问题都不太可能圆满回答，最后会发现要讨论的问题各种依赖性，A 功能不确定的情况下，B 功能可能直接就不存在而没必要讨论了。最后会导致会议非常低效。这个时候所有人都会不爽，技术工程师会认为浪费他的时间，产品经理会认为这些人好难配合。其实锅应该是在产品总监头上。&lt;/p&gt;

&lt;p&gt;跨部门的会议。很多时候莫名其妙就招呼你去开会，到了之后也不知道是讨论什么的，最后听半天发现貌似和自己一毛钱关系都没有，浪费几个小时。当然浪费的是你的时间，组织会议的人其实是有收获的，他明白这事情和你无关。&lt;/p&gt;

&lt;p&gt;头脑风暴会议当作需求讨论会来开。有时候对方可能根本没有明确的想法，你当成最终需求讨论半天指出来其中各种问题，最后发现其实他们根本就确定怎么做呢。这种情况其实就是那个网传的“产品经理找你聊一天，他的需求有了，你的程序还没写”的情况。毕竟需求会的优先级会比头脑风暴要稍微高一点。&lt;/p&gt;

&lt;p&gt;如果作为组织者，就是尽量做到前面提到的好的会议应该具备的条件，避免浪费别人时间。作为参与者，如果有能力，遇到有问题的会议，应该想办法协助会议组织者把会议变高效，提高效率的同时，自己也会节省不必要的时间，我经常这么干，毕竟年轻人不容易。。。。当然，我有时候不一定那么有耐心，遇到垃圾会有时候直接就走了，留他们继续浪费时间。&lt;/p&gt;

&lt;p&gt;再回到海龙的问题，我的回答是有些人为了合理的浪费时间，是会喜欢开会的，因为这样会让别人觉得他的时间安排很充实，因为整天不在座位，在忙。不知道各位开会的时候有没有遇到一些人全部时间都是在刷手机，只是偶尔说一两句话？这些人就是我说的这种人。我如果遇到我没兴趣的会或者和我无关的会议，我会直接和组织的人申请离开，如果确实后面和我有关系，那麻烦到了时间点叫我（当然你也得保证下到时可以随叫随到，避免浪费其他参会人的时间等你），当然，呃…… 如果我碰巧也想合理的浪费一下时间。。。。&lt;/p&gt;

&lt;p&gt;这些人一般都需要是 leader，至少有人在给他创造 GDP 的，否则一个手头很多工作要干的人，你让他开这种无意义的会他自己也不答应，否则其他工作完不成无法交代的。不过某种意义上讲，这些人也是有贡献的，至少能组织一些人贡献 GDP 就是贡献。&lt;/p&gt;

&lt;p&gt;感觉跨职业跨部门的会比较容易产生垃圾会，因为看问题角度不一样，有时候会比较难互相理解。我们技术人员很多时候开会，都是找一块白板，画几个图，大家就都明白了，很快就能出决议，不能定的一般可能是需要 leader 拍板的。&lt;/p&gt;

&lt;p&gt;同一个部门的会大家会接触比较多比较容易妥协，能接受自己多花点时间或者吃点小亏来完成一个事情。这其实也是所谓的拓展，团队活动，年会想要达到的目的，如果大家都很熟悉的情况下，就比较容易站在对方的角度想问题，遇到事情容易妥协。&lt;/p&gt;

&lt;p&gt;上面提到的这些问题其实越大的公司问题越多，反而小公司比较少，因为头绪少，并且大家都比较熟悉的缘故。当然实在遇到一个比较弱的会议组织者，烂会也不可避免。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Something about cruise tour</title>
      <link>https://wdicc.com/something-about-cruise-tour/</link>
      <pubDate>Mon, 20 Mar 2017 20:41:10 +0800</pubDate>
      
      <guid>https://wdicc.com/something-about-cruise-tour/</guid>
      <description>&lt;p&gt;之前知道邮轮游一直没有体验过，据说是在上面各种滚来滚去看书，因为手机没有信号，没有网络。前几天体验了一把，总结一下。&lt;/p&gt;

&lt;h1 id=&#34;一句话总结&#34;&gt;一句话总结&lt;/h1&gt;

&lt;p&gt;这上面有你讨厌的所有因素，大妈，广场舞，广场卡拉 ok，小孩子，无序，占座，插队，甚至最后一天还目睹了两起吵架。&lt;/p&gt;

&lt;h1 id=&#34;邮轮游玩什么&#34;&gt;邮轮游玩什么&lt;/h1&gt;

&lt;p&gt;我参加的是歌诗达幸运号（Costa Fortun），邮轮上面估计 80% 都是各种大爷大妈，带着女儿外孙。你可以想象一下，平时最不喜欢的组合在这里最全了。&lt;/p&gt;

&lt;p&gt;邮轮上面有免费的自助餐和一些特别的餐食，比如批萨，面条，猪排什么的。也有收费的餐食，当然你可以不去。酒和软饮都是收费的，开饭的时候有免费的白水给你喝，屋子里面是没有的。&lt;/p&gt;

&lt;p&gt;邮轮上面一般有大量的娱乐设施，比如赌场，游戏机，泳池，桑拿，剧场等。还定期有各种娱乐活动，比如猜个字啊，跳个舞什么的。所以第一次去还是可以看个新鲜的，尤其可能还有一些漂亮的陪玩 mm，看着也还可以。游戏机赌场是收费的，恩。&lt;/p&gt;

&lt;p&gt;此外剧场每天基本都会有一场大型的演出，30-40 分钟，可以让你打发时间。但是剧场虽然每天演出内容不一样，但是演员总是那一波，看多了其实也会腻味。&lt;/p&gt;

&lt;p&gt;房间里面也有电视，不过我观察电视都是反复重播录下来的一些电视，然后有一个电影台还是只有那么几部反复重复播放，《x man 天启》我看了不下 10 遍。&lt;/p&gt;

&lt;p&gt;小孩也有人给带着玩游戏，有专门的儿童俱乐部。还有健身房，健身房是我唯一对这次邮轮活动满意的地方，当然肯定不是对环境满意，毕竟里面充满了大爷大妈，满意的地方主要是在设备，设备真心不错。浴室和换衣间地板异常干净，比起我家楼下的奥力，简直天上地下。&lt;/p&gt;

&lt;p&gt;邮轮一般有那么1，2天是下船，我们这次的安排很屎，景点很无聊，低接导游也只是对购物有兴趣，购物店虽然不贵，但是东西比较少，挺没意思的。&lt;/p&gt;

&lt;h1 id=&#34;让人反感的几个瞬间&#34;&gt;让人反感的几个瞬间&lt;/h1&gt;

&lt;p&gt;排队上邮轮的时候，过安检的时候就一条队排的特别粗，到了最后那变细互相挤着往前走。我们后面有个阿姨就各种急着往你前面走，我老婆发现之后就故意挤着不让，我看的笑死，呵呵。&lt;/p&gt;

&lt;p&gt;第一天必须做逃生演习。有个大爷一家推着小车带着孩子，孩子可能没一会睡着了。而演习是需要所有人参加的，所以就不得不等比较慢的人。大爷就生气了，开始呵斥工作人员，「孩子都睡着了，啥时候开始」之类的，声音巨大。工作人员大都是外籍，估计也吓了一跳。最后结束的时候，大爷还过去指着那个工作人员不知道说了什么。&lt;/p&gt;

&lt;p&gt;剧院演出，基本前三四排上面都是东西占座的。除非你提前半个小时到。另外就是各种小孩大声说话也没人管。有时候酒吧做游戏，工作人员都明确说了游戏可能比较激烈，让大家把小孩弄走，但是看着一个女的抱着小孩几次被劝离之后还是要上去玩，貌似还是上去让小孩参与。&lt;/p&gt;

&lt;p&gt;昨天有个游戏，几个被淘汰的大妈，悄悄的跑回去继续参与，也有跑回去被发现之后赶走，再次跑回去的，当着一百来号人目睹就那么做，真的无语。&lt;/p&gt;

&lt;p&gt;今天下船之前大家集中在一个地方等着，有个姥爷带着孙女玩气球。有个哥们玩心重，带了个面具就冲那小孩过去了，小孩吓的赶紧跑到了姥爷后面，那个哥们就走了。过了半分钟小孩反映过来开始哭，那姥爷就开始不爽了。后来他们全家，追着那小伙骂，最后把面具也抢过来了，还要护照说要以后有啥毛病要找他。纠缠了能有10分钟。&lt;/p&gt;

&lt;p&gt;这只是记得起来的几个，反正年轻人真的不建议去邮轮了。如果是自己父母，倒是可以推荐去，他们应该喜欢。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>My way to keep fit</title>
      <link>https://wdicc.com/my-way-to-keep-fit/</link>
      <pubDate>Mon, 13 Mar 2017 15:19:30 +0800</pubDate>
      
      <guid>https://wdicc.com/my-way-to-keep-fit/</guid>
      <description>&lt;p&gt;目前第一阶段减肥基本告一段落，后面目标是保持目前体重 6 个月。&lt;/p&gt;

&lt;h1 id=&#34;先聊聊结果&#34;&gt;先聊聊结果&lt;/h1&gt;

&lt;p&gt;2014 年 9 月份前，我的体重最高到 98kg，甚至有时候超过了 100kg。第一阶段减肥可能截止到 2016 年中，减到体重大概是 92kg。第二阶段开始于 2016 年 2 月底，截止到今天体重 80kg。整体算下来减掉 40 斤。&lt;/p&gt;

&lt;h1 id=&#34;第一阶段&#34;&gt;第一阶段&lt;/h1&gt;

&lt;p&gt;2014 年开始我发现一种比较简单的减肥方法，就是不吃或者少吃晚饭。&lt;/p&gt;

&lt;p&gt;这个方法应该不一定对所有人适用。我估计应该只对 BMI(Body Mass Index, 身体质量指数，注意和体脂率不是一个东西)比较高的人有用吧。&lt;/p&gt;

&lt;p&gt;我当时 BMI 是 &lt;code&gt;98/1.77^2=31.28&lt;/code&gt; 是属于比较高的，坚持了上面的方法半年之后，大概最瘦的时候是 28，我查了是刚好脱离了肥胖那一档，进入了过重。&lt;/p&gt;

&lt;p&gt;我当时所在的公司的上班时间是 10:00 - 19:00，但是经常出现 20:00 以后才从公司走的情况，这样我到家经常是 21:30 或者 22:00 以后。这个时候吃晚饭就太晚了，基本吃饭完了就睡觉了。并且，中午吃饭到这个时候，一般其实已经饿过劲了，那个时间反而没有那么饿了，我就慢慢开始晚上到家之后只吃几个水果。后来慢慢转为不吃东西，或者只吃很少的水果。有时候也会遇到快下班的时候非常饿，这个时候吃点小零食，也就可以了。这种方式减肥，早上和中午基本不控制自己，还是吃的比较好的。&lt;/p&gt;

&lt;p&gt;上面说了，这个阶段减掉了大概 10 多斤。中午饮食基本不控制，晚上不吃，或者很少吃（一个月有那么一两次推不开的）。&lt;/p&gt;

&lt;h1 id=&#34;第二阶段&#34;&gt;第二阶段&lt;/h1&gt;

&lt;p&gt;大概是从今年 2 月底从日本回来，开始实施，方法是锻炼加节食。&lt;/p&gt;

&lt;p&gt;锻炼的内容是 60 分钟椭圆机（我用的机器难度是 5，不同机器可能不一样），30 分钟运动后拉伸，30 分钟游泳。大概是每周 1，2，4，5 去，一周会休息三天。锻炼毕竟比较枯燥，所以需要中间休息一下调剂一下心情，如果你的体力耐力跟的上，可以不休息。&lt;/p&gt;

&lt;p&gt;上面的强度下来，进度大概是一周 3kg。我的情况 3 月 25 是 88.6kg，5 月 2 是 81.7kg，5.5 是 80kg。为什么比较慢呢？在这两个月内，我参加了一趟邮轮游大概一周，去了一趟沈阳，大概一周，还去了一趟日本大概一周。所以如果坚持应该可以更快，但是快速减重我感觉应该可能会有副作用，所以我也基本也是控制减一点，保持几天这样子，不让这个减重太快。另外，这段时间我是全职减肥，所以没有工作上面的压力，可能速度相对快一点。&lt;/p&gt;

&lt;h1 id=&#34;方法细节&#34;&gt;方法细节&lt;/h1&gt;

&lt;h2 id=&#34;mhr&#34;&gt;MHR&lt;/h2&gt;

&lt;p&gt;按照一些理论，在有氧运动一定时间 T 之后，保持一定的心率 HR 继续运动，就会开始消耗脂肪。所谓的 &lt;a href=&#34;https://www.douban.com/note/228079030/&#34; title=&#34;fat burning zone&#34;&gt;fat burning zone&lt;/a&gt; (搜索到的，仅供参考)。&lt;/p&gt;

&lt;p&gt;对于 T，我看有的说是 20 分钟，有的是 40 分钟。我一般的做法是持续运动 40-50 分钟，不超过一小时。&lt;/p&gt;

&lt;p&gt;对于心率，先看下面的公式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
MHR(最大心率) = 220 - age
MHR = 206 - (0.88 x age)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面是最大心率，有多种算法最后应该结果大致有个范围，然后你的减脂的 HR 范围就是 &lt;code&gt;MHR x (0.7 到 0.8)&lt;/code&gt; 之间。我算出来我的是大概 130-145.&lt;/p&gt;

&lt;p&gt;所以注意并不是越累越好，比如天天跑 5km 还追求速度，那个思路不对，那个不是减肥。只要心率到了加持续时间够长。，不管做什么都减肥。&lt;/p&gt;

&lt;h2 id=&#34;节食&#34;&gt;节食&lt;/h2&gt;

&lt;p&gt;如果想要减脂，必须要节食，并且节食之后，我发现不运动体重也会降，直到降到一个平衡点。&lt;/p&gt;

&lt;p&gt;节食并不是一下子就从原来中午晚上吃两碗米饭变成只吃一个苹果，这个也是应该有个循序渐进的过程，要不不说身体是否能接受，你自己就坚持不下来。&lt;/p&gt;

&lt;p&gt;我的建议是，逐步减少饭量，花 1-2 个月来完成这个过程，一定要给自己定一个什么时间点达到什么目标的方案，否则面对一个自己都觉得无法达到的目标，也会容易被各种诱惑吸引，然后放弃。&lt;/p&gt;

&lt;p&gt;节食期间，并非就一直得是清淡饮食，偶尔吃一次大餐也不是不行，但是最好安排在中午，并且吃了之后第二天早餐午餐一定要减少量。另外注意是「偶尔」，千万别当成常态。&lt;/p&gt;

&lt;p&gt;此外，也得注意要按时吃饭，节食本身就很痛苦了，如果不能按时吃饭，比如过了平时饭点再吃，容易吃多，影响节食效果。&lt;/p&gt;

&lt;p&gt;我自己的方案，如果今天上午不出门，那就最多喝一杯牛奶做早餐。如果要出门，可以接受大概半个馒头那么多的饮食量。中午也类似，如果不出门就少吃，如果要出门，可以适当比平时多一点点，避免晚上的时候很难熬，或者路上出现低血糖。&lt;/p&gt;

&lt;p&gt;我自己控制的结果，是在中午大概3点一顿自助餐的基础上，晚上6点又有不能推掉的酒局的情况下，中午一杯啤酒，晚上一杯红酒，然后第二天重量维持不变。自己感觉还是挺有成就感的，当然也很痛苦。&lt;/p&gt;

&lt;p&gt;我目前体重还没有到平台期，还不清楚节食结束之后反弹的情况，但是我自己的打算是平台期或者达到我的目标体重之后，我再继续维持低饮食量一段时间巩固下，把自己的饮食习惯培养好，不再能暴饮暴食的情况下，应该是可以适当放开饮食的。&lt;/p&gt;

&lt;ul&gt;
总结下：
&lt;li&gt;节食要循序渐进，不要一次就到位，食量可以比如每周减 1/4 的节奏安排。&lt;/li&gt;
&lt;li&gt;设定自己的目标，一阶段一阶段完成，不要一次设定一个看着无法做到的目标&lt;/li&gt;
&lt;li&gt;饮食要准时定量，实在受不了的时候，可以允许自己来一次暴食（不要暴饮，尤其是甜的饮料，酒等），但要注意控制次数&lt;/li&gt;
&lt;li&gt;毅力坚持很重要。我节食期间参加各种自助餐，火锅，聚餐等都能很好的控制自己的食欲。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关于低血糖，特别讲一下，节食非常容易产生低血糖，建议按照自己的体力，健身之前最好吃一口东西（不要多），或者随身携带一些吃的，一旦感觉低血糖头晕，就补充一点。别产生什么危险。&lt;/p&gt;

&lt;p&gt;低血糖的时候，也会影响你做事情的效率，会发现什么事情都不想做，所以这个时候最好就吃点吧，不过要注意是这也是有控制的吃。&lt;/p&gt;

&lt;h2 id=&#34;跑步机-vs-椭圆机-vs-动感单车&#34;&gt;跑步机 vs 椭圆机 vs 动感单车&lt;/h2&gt;

&lt;ul&gt;
我自己家里买了一台动感单车，实际实践过之后，用这个有几个缺陷
&lt;li&gt;自己练没有动感。在操课房里面教练会带着不停的变换速度，动作，一方面让你觉得没那么无聊，另一方面也是能增加运动量。&lt;/li&gt;
&lt;li&gt;自己练容易损坏脚踝和膝盖。我自己在家练的时候，基本就是站上面运动 30+ 分钟，脚一直在单车上面脚尖踩着，练完之后脚会疼痛。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我其实挺喜欢在外面跑步，尤其早上，但是因为体重大，好几次都是跑一周之后双腿膝盖会开始疼痛，只好作罢。健身房里面的跑步机冲击比路面跑步小，可以试试看。&lt;/p&gt;

&lt;p&gt;最近尝试了跑步机上面跑，坚持 2 周之后，还是出现了一只腿的膝盖疼痛，只好暂停。开始尝试椭圆机。&lt;/p&gt;

&lt;p&gt;跑步机上面跑强度比椭圆机肯定强很多，跑步机上面在一个不快的速度下面，我持续跑 15 分钟之后，心率就会达到 150，其实已经有点高了。&lt;/p&gt;

&lt;ul&gt;
跑步机的几个问题
&lt;li&gt;容易心率过快&lt;/li&gt;
&lt;li&gt;不方便听音乐看片子分散注意力&lt;/li&gt;
&lt;li&gt;不容易不间断坚持跑 30 - 40 分钟&lt;/li&gt;
&lt;li&gt;膝盖损伤&lt;/li&gt;
&lt;/ul&gt;

&lt;ul&gt;
最后发现椭圆机实在是很不错
&lt;li&gt;运动速度慢，不妨碍你看片子听音乐(这个非常重要，否则坚持50分钟很难)&lt;/li&gt;
&lt;li&gt;速度恒定，也就是心率恒定，你只需要选择一个适合你的减脂的心率的难度就可以了&lt;/li&gt;
&lt;li&gt;对膝盖冲击比较小&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我用实际使用的就是椭圆机 Elliptical Trainer。一次 60 分钟，控制心率在 140 左右。高了就换近一点的把手，低了就换远一点的。&lt;/p&gt;

&lt;h2 id=&#34;运动后拉伸&#34;&gt;运动后拉伸&lt;/h2&gt;

&lt;p&gt;这个一定要做，可以参考 keep 这个 app 里面的一些教程做，另外就是自己看着健身房的设备练练。注意设定好节奏，比如一组 10 次，做 3 组。&lt;/p&gt;

&lt;p&gt;这个是拉伸，不是力量训练，所以不需要挑战自己的极限。控制好设备的重量。&lt;/p&gt;

&lt;h2 id=&#34;饮食注意&#34;&gt;饮食注意&lt;/h2&gt;

&lt;p&gt;我本身血压高，所以需要低盐。然后减脂的话，一般的讲法是不要吃或者少吃和糖类有关系的食物，比如糖，西瓜这些，以及很容易转换为糖类的食物，比如谷物，大米这些。可以吃肉类（瘦肉或者白肉，比如鸡肉鱼肉）。&lt;/p&gt;

&lt;p&gt;我以前基本没炒过青菜，这次发现光是做到不难吃的话，其实很简单。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;不用水煮直接凉拌：黄瓜，西红柿等，莴笋&lt;/li&gt;
&lt;li&gt;白水煮了就能接受的：西兰花，菜花&lt;/li&gt;
&lt;li&gt;水煮之后过油炒一下加点盐或者酱油的：油菜，蘑菇，小白菜，菠菜&lt;/li&gt;
&lt;li&gt;直接过油炒一下加盐或者酱油：芹菜&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;之前看了一本书，里面讲到几个低盐的方法，就是比如放入火腿肠等本身自带咸味的食材，或者往酸的方向走。对于凉拌菜，可以适当考虑加一点醋，发现还挺不错的。&lt;/p&gt;

&lt;h1 id=&#34;update&#34;&gt;Update&lt;/h1&gt;

&lt;p&gt;有上面这几招，应该可以让你短时间不会吃腻了。我中午基本就是吃一盘青菜，不吃主食。&lt;/p&gt;

&lt;h2 id=&#34;2017-6-9&#34;&gt;2017.6.9&lt;/h2&gt;

&lt;p&gt;更新一下, 从停止运动到现在已经大概一个多月了, 之前最低到了 78kg. 这一个月发现如果还按照之前的食量, 体重还会降. 但是我不打算继续让它降的, 所以也开始提升食量.&lt;/p&gt;

&lt;p&gt;最近两周我还出去国内玩了一趟, 吃饭吃的也挺多的, 时间也不固定, 到了当地还会尝试喝当地的一些米酒啤酒之类的, 到今天早上称重是 79kg. 感觉还可以.&lt;/p&gt;

&lt;h2 id=&#34;2017-6-30&#34;&gt;2017.6.30&lt;/h2&gt;

&lt;p&gt;再次更新一下，目前体重 77kg。目前吃喝的内容基本已经不需要太注意了，只是有意不要多吃，也避免吃谷物类。不过我也吃过几次米饭，面条，大饼什么的，目前体重还是保持住了。&lt;/p&gt;

&lt;h2 id=&#34;2017-11-26&#34;&gt;2017.11.26&lt;/h2&gt;

&lt;p&gt;目前又开始尝试减体重。因为发现工作的时候确实不是很好减，毕竟饿了的话工作都不能专心。上周我尝试吃了一周的 711 沙拉和水果，貌似这几天早上称重到了 74.8，低于了 75 了都，感觉也是有效果的，还在尝试。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Use org mode to publish blog</title>
      <link>https://wdicc.com/use-org-mode-to-publish-blog/</link>
      <pubDate>Sun, 12 Mar 2017 08:59:19 +0800</pubDate>
      
      <guid>https://wdicc.com/use-org-mode-to-publish-blog/</guid>
      <description>&lt;p&gt;a test&lt;/p&gt;

&lt;p&gt;啊哈哈哈哈，超棒唉。markdown 里面写代码都没有高亮，org 里面是可以把代码部分高亮的。
效果可以看 &lt;a href=&#34;https://goo.gl/photos/E8p1WX34rfAQn31v9&#34; title=&#34;这里&#34;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;title1&#34;&gt;Title1&lt;/h2&gt;

&lt;h3 id=&#34;title2&#34;&gt;title2&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;list1&lt;/li&gt;
&lt;li&gt;list2&lt;/li&gt;
&lt;li&gt;list3&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
import sys

class Hugo(object):
    def __init__(self):
        pass

hugo = Hugo()
print(hugo)
print(&amp;quot;just a test&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Migrate blog to hugo</title>
      <link>https://wdicc.com/migrate-blog-to-hugo/</link>
      <pubDate>Sat, 11 Mar 2017 16:29:40 +0800</pubDate>
      
      <guid>https://wdicc.com/migrate-blog-to-hugo/</guid>
      <description>&lt;p&gt;折腾了好几天，把 blog 从 hexo 迁移到了 &lt;a href=&#34;http://gohugo.io/&#34;&gt;hugo&lt;/a&gt; 上面。hexo 是使用 nodejs 写出来的，hugo 是使用的 go。主要基于下面几个原因吧。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;个人不太喜欢 nodejs 那一坨依赖。&lt;/li&gt;
&lt;li&gt;hugo 也比 nodejs 速度快很多。&lt;/li&gt;
&lt;li&gt;hugo 用起来比较简洁。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;首先写了一个迁移工具 &lt;a href=&#34;https://github.com/wd/hexo2hugo&#34;&gt;hexo2hugo&lt;/a&gt;。网上还有一个 nodejs 版本的&lt;a href=&#34;http://nodejh.com/post/Migrate-to-Hugo-from-Hexo/&#34;&gt;迁移工具&lt;/a&gt;可以参考。其实就是简单的把头部信息处理一下就可以。我还有一些特殊需求，比如把老早以前的一些 html 格式的文档顺道处理一下格式，还有一些小的修正和兼容工作，所以自己写了一个。另外也主要是好久没有写代码了，熟悉下。。&lt;/p&gt;

&lt;p&gt;把文档迁移过去之后，找了几个主题看了一下，发现没有很喜欢的，就本着蛋疼的原则，把原来用的主题也&lt;a href=&#34;https://github.com/wd/hugo-fabric&#34;&gt;迁移过来了&lt;/a&gt;，这个花的时间比较长一点。主要还得熟悉 hugo 的模板语法，还得想办法适配 hugo 的体系。比如 hugo 里面没有 archive 一说，不过通过万能的 google 搜索到了一个解决办法，也勉强还好。&lt;/p&gt;

&lt;p&gt;目前这个 blog 已经是由 hugo 产生了，和以前外观，访问地址完全一模一样，rss 地址都一样。我测试了 google 里面的搜索结果，是都可以跳转的。今天算是基本都迁移完毕了。&lt;/p&gt;

&lt;p&gt;这几天没事也总想记录一点想法，但是无奈新本子上面的 hexo 挂了，又不想搞 nodejs 那一坨依赖，就折腾了这个事情。不过折腾完毕之后发现想记录的事情都忘记了，nnd。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Upgrade kernel to 4.9 for linode</title>
      <link>https://wdicc.com/upgrade-kernel-to-4-9-for-linode/</link>
      <pubDate>Mon, 16 Jan 2017 18:37:56 +0800</pubDate>
      
      <guid>https://wdicc.com/upgrade-kernel-to-4-9-for-linode/</guid>
      <description>&lt;p&gt;bbr 那么牛逼，赶紧赶一个潮流。其实我之前用了 kcp，也是类似的东西，不过那个要求服务器端和客户端都需要跑 kcp 服务才可以。bbr 就不用了，只需要服务器配置好就可以了。&lt;/p&gt;

&lt;p&gt;Linode 实际上已经提供了 4.9 的内核。打开 &lt;code&gt;Dashboard&lt;/code&gt;，然后点击你使用的 profile 右侧的 edit，在出来的界面里面，Kernel 右侧的列表里面，有个 4.9 的选项，不过我测试这个内核并不能打开 bbr，不知道是怎么回事，有兴趣的可以试试看，要注意选对架构（就是 64 还是 32）。&lt;/p&gt;

&lt;p&gt;所以还是需要自己装内核。debian 官方已经打包好了 kernel 4.9，访问 &lt;a href=&#34;http://mirrors.kernel.org/debian/pool/main/l/linux/&#34;&gt;http://mirrors.kernel.org/debian/pool/main/l/linux/&lt;/a&gt; ，然后找到适合自己的 linux-image-4.9，我的是 &lt;a href=&#34;http://mirrors.kernel.org/debian/pool/main/l/linux/linux-image-4.9.0-1-amd64-unsigned_4.9.2-2_amd64.deb&#34;&gt;http://mirrors.kernel.org/debian/pool/main/l/linux/linux-image-4.9.0-1-amd64-unsigned_4.9.2-2_amd64.deb&lt;/a&gt; ，下载到 vps 上面。&lt;/p&gt;

&lt;p&gt;然后执行 &lt;code&gt;sudo dkpg -i ./linux-image-4.9.0-1-amd64-unsigned_4.9.2-2_amd64.deb&lt;/code&gt;，最后应该会提示一个错误，缺少依赖的包。这个时候执行 &lt;code&gt;sudo apt-get -f install&lt;/code&gt;，会提示安装缺失的包。&lt;/p&gt;

&lt;p&gt;然后，还需要安装 &lt;code&gt;grub&lt;/code&gt;。看你的情况。就刚才 profile 编辑的页面里面，kernel 右侧的选项里面，你看看你的是 &lt;code&gt;grub2&lt;/code&gt; 还是 &lt;code&gt;pv-grub&lt;/code&gt;。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;grub2&lt;/code&gt;: 参考&lt;a href=&#34;https://www.linode.com/docs/tools-reference/custom-kernels-distros/run-a-distribution-supplied-kernel-with-kvm&#34;&gt;这个&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install grub2
$ sudo update-grub
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;pv-grub&lt;/code&gt;: 参考&lt;a href=&#34;https://www.linode.com/docs/tools-reference/custom-kernels-distros/run-a-distributionsupplied-kernel-with-pvgrub&#34;&gt;这个&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install grub
$ sudo mkdir /boot/grub
$ sudo update-grub
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;然后在 profile 编辑页面里面，kernel 右侧选择对应的 grub 选项，重启 vps 就可以了。如果启动失败了，就在这个选项里面，选择之前的选项重启就可以恢复。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Python __new__</title>
      <link>https://wdicc.com/python-new/</link>
      <pubDate>Mon, 16 Jan 2017 15:47:59 +0800</pubDate>
      
      <guid>https://wdicc.com/python-new/</guid>
      <description>&lt;p&gt;翻译一点 &lt;a href=&#34;https://www.python.org/download/releases/2.2/descrintro/#__new__&#34;&gt;https://www.python.org/download/releases/2.2/descrintro/#__new__&lt;/a&gt; 有些感觉还是挺生硬的，方便自己理解吧。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;__new__&lt;/code&gt; 的一些规则:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;__new__&lt;/code&gt; 是一个静态方法。定义它的时候并不需要执行 &lt;code&gt;__new__ = staticmethod(__new__)&lt;/code&gt;，因为它的名字就包含了这个含义（这个对于类构造方法来说是个特殊的函数）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__new__&lt;/code&gt; 的第一个参数，必须是一个类，其余的参数是留给构造方法的。&lt;/li&gt;
&lt;li&gt;覆盖了基类的 &lt;code&gt;__new__&lt;/code&gt; 方法的类有可能会调用基类的 &lt;code&gt;__new__&lt;/code&gt; 方法。传递给基类的 &lt;code&gt;__new__&lt;/code&gt; 方法的第一个参数，应该是覆盖基类的 &lt;code&gt;__new__&lt;/code&gt; 方法的类，而不是基类，如果传递了基类，你得到的将是基类的示例。&lt;/li&gt;
&lt;li&gt;除非你想要按照后面两条描述的方法来使用，否则 &lt;code&gt;__new__&lt;/code&gt; 方法必须要调用基类的 &lt;code&gt;__new__&lt;/code&gt; 方法，这个是创建你的对象的实例的唯一方法。子类的 &lt;code&gt;__new__&lt;/code&gt; 方法可以从两个方面影响产生的实例：传递不同的参数给基类的 &lt;code&gt;__new__&lt;/code&gt;，以及修改基类产生的对象（例如初始化一些实例变量）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__new__&lt;/code&gt; 方法必须返回一个对象。并不一定必须返回一个新的对象，虽然通常都那么做。如果你返回一个已经存在的对象，依然会有对于 &lt;code&gt;__init__&lt;/code&gt; 构造函数的调用。如果你返回一个其他函数的对象，那个对象的 &lt;code&gt;__init__&lt;/code&gt; 也会被调用。如果忘记返回，python 会给你返回 None，你程序的调用方也许会觉得很奇怪。&lt;/li&gt;
&lt;li&gt;对于不可变对象，&lt;code&gt;__new__&lt;/code&gt; 可以返回一个之前缓存的对象。对于一些比较小的 int, str, tuple 类型就是这么做的。这也是为什么他们的 &lt;code&gt;__init__&lt;/code&gt; 什么都没做：否则之前缓存的对象会被 init 很多次。（另外一个原因是本身页没有东西可以给 &lt;code&gt;__init__&lt;/code&gt; 初始化的了，&lt;code&gt;__new__&lt;/code&gt; 返回的就是一个已经初始化的对象）。&lt;/li&gt;
&lt;li&gt;如果你想要给一个内置的不可变类型增加一些可变的状态（例如给 string 类型增加一个默认的转换方法），最好是在 &lt;code&gt;__init__&lt;/code&gt; 方法里面初始化可变状态，而不要在 &lt;code&gt;__new__&lt;/code&gt; 里面。&lt;/li&gt;
&lt;li&gt;如果你想要修改构造方法的签名，一般需要覆盖 &lt;code&gt;__new__&lt;/code&gt; 和 &lt;code&gt;__init__&lt;/code&gt; 方法来接受心的签名。然而，大部分内置类型都会忽视自己不用的参数，尤其是不可变类型（int，long，float，complex，str，unicode，tuple）都有一个假的 &lt;code&gt;__init__&lt;/code&gt;，而可变类型（dict，list，file，super，classmethod，staticmethd，property）有一个假的 &lt;code&gt;__new__&lt;/code&gt;。内置类型 &lt;code&gt;object&lt;/code&gt; 有假的 &lt;code&gt;__init__&lt;/code&gt; 和 &lt;code&gt;__new__&lt;/code&gt; （给其他对象继承）。内置类型 &lt;code&gt;type&lt;/code&gt; 在很多方面都很特别，请参考 metaclasses。&lt;/li&gt;
&lt;li&gt;（这条和 &lt;code&gt;__new__&lt;/code&gt; 没关系，但是页应该了解一下）如果新建一个 &lt;code&gt;type&lt;/code&gt; 的子类，实例会自动给 &lt;code&gt;__dict__&lt;/code&gt; 和 &lt;code&gt;__weakrefs__&lt;/code&gt; 预留空间（ &lt;code&gt;__dict__&lt;/code&gt; 在你使用前不会初始化，所以你不需要担心创建的所有实例被一个空的字典所占用的空间）。如果不需要这个多余的空间，可以给你的类设置 &lt;code&gt;__slots__ = []&lt;/code&gt;（更多信息可以参考 &lt;code&gt;__slots__&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;Factoid: &lt;code&gt;__new__&lt;/code&gt; 是一个静态方法，不是类方法。我开始的时候觉得他应该是一个类方法，and that&amp;rsquo;s why I added the classmethod primitive。不幸的是，对于一个类方法，在这种情况下面 upcalls 不工作，所以我只好把他设计成一个第一个参数是一个 class 的静态方法。讽刺的是，there are now no known uses for class methods in the Python distribution (other than in the test suite). I might even get rid of classmethod in a future release if no good use for it can be found!&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Python inherit and super</title>
      <link>https://wdicc.com/python-inherit-and-super/</link>
      <pubDate>Mon, 16 Jan 2017 11:53:04 +0800</pubDate>
      
      <guid>https://wdicc.com/python-inherit-and-super/</guid>
      <description>&lt;p&gt;又学习了一个 python 的继承。有很多帖子都有介绍，比如&lt;a href=&#34;https://laike9m.com/blog/li-jie-python-super,70/&#34;&gt;理解 Python super&lt;/a&gt;，&lt;a href=&#34;http://www.cnblogs.com/lovemo1314/archive/2011/05/03/2035005.html&#34;&gt;python super()&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;先看一个例子，这个是第一个文章里面的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Root(object):
    def __init__(self):
        print(&amp;quot;this is Root&amp;quot;)


class B(Root):
    def __init__(self):
        print(&amp;quot;enter B&amp;quot;)
        super(B, self).__init__()
        print(&amp;quot;leave B&amp;quot;)


class C(Root):
    def __init__(self):
        print(&amp;quot;enter C&amp;quot;)
        super(C, self).__init__()
        print(&amp;quot;leave C&amp;quot;)


class D(C):
    def __init__(self):
        print(&amp;quot;enter D&amp;quot;)
        super(D, self).__init__()
        print(&amp;quot;leave D&amp;quot;)


class E(D, B):
    def __init__(self):
        print(&amp;quot;enter E&amp;quot;)
        super(E, self).__init__()
        print(&amp;quot;leave E&amp;quot;)

e = E()
print(e.__class__.mro())

# results:
# enter E
# enter D
# enter C
# enter B
# this is Root
# leave B
# leave C
# leave D
# leave E
# [&amp;lt;class &#39;__main__.E&#39;&amp;gt;, &amp;lt;class &#39;__main__.D&#39;&amp;gt;, &amp;lt;class &#39;__main__.C&#39;&amp;gt;, &amp;lt;class &#39;__main__.B&#39;&amp;gt;, &amp;lt;class &#39;__main__.Root&#39;&amp;gt;, &amp;lt;class &#39;object&#39;&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;没有什么问题，所有的类都做了初始化，很完美。接着再看一个例子，这个例子其实是上面第二篇文章里面的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class A(object):
    def __init__(self):
        print(&amp;quot;enter A&amp;quot;)
        print(&amp;quot;leave A&amp;quot;)


class B(object):
    def __init__(self):
        print(&amp;quot;enter B&amp;quot;)
        print(&amp;quot;leave B&amp;quot;)


class C(A):
    def __init__(self):
        print(&amp;quot;enter C&amp;quot;)
        super(C, self).__init__()
        print(&amp;quot;leave C&amp;quot;)


class D(A):
    def __init__(self):
        print(&amp;quot;enter D&amp;quot;)
        super(D, self).__init__()
        print(&amp;quot;leave D&amp;quot;)


class E(B, C):
    def __init__(self):
        print(&amp;quot;enter E&amp;quot;)
        super(E, self).__init__()
        print(&amp;quot;leave E&amp;quot;)


class F(E, D):
    def __init__(self):
        print(&amp;quot;enter F&amp;quot;)
        super(F, self).__init__()
        print(&amp;quot;leave F&amp;quot;)


f = F()
print(f.__class__.mro())

# results:
# enter F
# enter E
# enter B
# leave B
# leave E
# leave F
# [&amp;lt;class &#39;__main__.F&#39;&amp;gt;, &amp;lt;class &#39;__main__.E&#39;&amp;gt;, &amp;lt;class &#39;__main__.B&#39;&amp;gt;, &amp;lt;class &#39;__main__.C&#39;&amp;gt;, &amp;lt;class &#39;__main__.D&#39;&amp;gt;, &amp;lt;class &#39;__main__.A&#39;&amp;gt;, &amp;lt;class &#39;object&#39;&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我发现和文章里面贴的结果不一样，里面缺少对 C，D，A 的初始化。琢磨半天才弄明白，主要原因就是，&lt;code&gt;A&lt;/code&gt;，&lt;code&gt;B&lt;/code&gt; 其实也是继承自 &lt;code&gt;object&lt;/code&gt;，然而我们并没有调用 &lt;code&gt;super&lt;/code&gt; 来初始化，所以只需要加上就可以了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class A(object):
    def __init__(self):
        print(&amp;quot;enter A&amp;quot;)
        super(A, self).__init__()
        print(&amp;quot;leave A&amp;quot;)


class B(object):
    def __init__(self):
        print(&amp;quot;enter B&amp;quot;)
        super(B, self).__init__()
        print(&amp;quot;leave B&amp;quot;)


class C(A):
    def __init__(self):
        print(&amp;quot;enter C&amp;quot;)
        super(C, self).__init__()
        print(&amp;quot;leave C&amp;quot;)


class D(A):
    def __init__(self):
        print(&amp;quot;enter D&amp;quot;)
        super(D, self).__init__()
        print(&amp;quot;leave D&amp;quot;)


class E(B, C):
    def __init__(self):
        print(&amp;quot;enter E&amp;quot;)
        super(E, self).__init__()
        print(&amp;quot;leave E&amp;quot;)


class F(E, D):
    def __init__(self):
        print(&amp;quot;enter F&amp;quot;)
        super(F, self).__init__()
        print(&amp;quot;leave F&amp;quot;)


f = F()
print(f.__class__.mro())

# results:
# enter F
# enter E
# enter B
# enter C
# enter D
# enter A
# leave A
# leave D
# leave C
# leave B
# leave E
# leave F
# [&amp;lt;class &#39;__main__.F&#39;&amp;gt;, &amp;lt;class &#39;__main__.E&#39;&amp;gt;, &amp;lt;class &#39;__main__.B&#39;&amp;gt;, &amp;lt;class &#39;__main__.C&#39;&amp;gt;, &amp;lt;class &#39;__main__.D&#39;&amp;gt;, &amp;lt;class &#39;__main__.A&#39;&amp;gt;, &amp;lt;class &#39;object&#39;&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就完美了。目测这个会是一个隐藏的坑。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Python metaclass</title>
      <link>https://wdicc.com/python-metaclass/</link>
      <pubDate>Thu, 12 Jan 2017 18:26:22 +0800</pubDate>
      
      <guid>https://wdicc.com/python-metaclass/</guid>
      <description>&lt;p&gt;又理解了一下 python 的 metaclass 可以做什么，尝试记录一下。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Meta(type):
    register = []

    def __new__(cls, class_name, parrent_class, params):
        print(&amp;quot;In meta new: {}, {}, {}, {}&amp;quot;.format(cls, class_name, parrent_class, params))
        cls.register.append(class_name)
        params[&#39;test_prop&#39;] = True
        # return super(Meta, cls).__new__(cls, class_name, parrent_class, params)
        # return type.__new__(cls, class_name, parrent_class, params)
        # return super(Meta, cls).__new__(type, class_name, parrent_class, params)
        # return type.__new__(type, class_name, parrent_class, params)
        return type(class_name, parrent_class, params)

    def __init__(self, class_name, parrent_class, params):
        print(&amp;quot;In meta init: {}, {}, {}&amp;quot;.format(class_name, parrent_class, params))
        super(Meta, self).__init__(class_name, parrent_class, params)


class A(object, metaclass=Meta):
    pass

print(&amp;quot;register: {}&amp;quot;.format(Meta.register))
print(&amp;quot;prop: {}&amp;quot;.format(A.test_prop))
print(&amp;quot;register: {}&amp;quot;.format(A.register))  # Error

# outputs:
# In meta new: &amp;lt;class &#39;__main__.Meta&#39;&amp;gt;, A, (&amp;lt;class &#39;object&#39;&amp;gt;,), {&#39;__module__&#39;: &#39;__main__&#39;, &#39;__qualname__&#39;: &#39;A&#39;}
# In meta init: A, (&amp;lt;class &#39;object&#39;&amp;gt;,), {&#39;__module__&#39;: &#39;__main__&#39;, &#39;__qualname__&#39;: &#39;A&#39;}
# register: [&#39;A&#39;]
# prop: True
# AttributeError: type object &#39;A&#39; has no attribute &#39;register&#39;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，在构造 &lt;code&gt;A&lt;/code&gt; 的时候，&lt;code&gt;Meta&lt;/code&gt; 这个类里面，&lt;code&gt;__new__&lt;/code&gt; 和 &lt;code&gt;__init__&lt;/code&gt; 都会被调用到。上面代码往 &lt;code&gt;A&lt;/code&gt; 里面塞了一个属性。&lt;/p&gt;

&lt;p&gt;在 &lt;code&gt;__new__&lt;/code&gt; 里面，有几个注释，可以去掉注释看看不同的效果。目前还有点疑惑，传给 &lt;code&gt;__new__&lt;/code&gt; 第一个参数到底是什么。另外，开始对 &lt;code&gt;super&lt;/code&gt; 也有点疑惑了，还在学习。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Reinvent the wheel</title>
      <link>https://wdicc.com/reinvent-the-wheel/</link>
      <pubDate>Thu, 12 Jan 2017 16:16:20 +0800</pubDate>
      
      <guid>https://wdicc.com/reinvent-the-wheel/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Reinventing_the_wheel&#34;&gt;Reinvent the wheel&lt;/a&gt; 估计技术人员都知道这个典故。&lt;/p&gt;

&lt;p&gt;刚才突然想谈这个，是看到图拉鼎参加 &lt;a href=&#34;https://weex-project.io/&#34;&gt;weex&lt;/a&gt; 的聚会有感而发。我要是没理解错，这个应该是类似于 React native 的一套实现，我没有仔细看过他的实现，不过说他重复造轮子应该也不为过，毕竟，大家普遍赞成的是在已有的轮子上面添砖加瓦，而不是另起一套。&lt;/p&gt;

&lt;p&gt;重复造轮子到底应该不应该支持？&lt;/p&gt;

&lt;p&gt;之前我司来了一个发明了 avalon 框架的牛人，之后我看好像就在很多的推介这个，新人来了先学习这个。后来还有很多这种框架，新人来了都是先学习这些框架。&lt;/p&gt;

&lt;p&gt;这个事情上面，我看有几个好处
* 发明的人可以在公司内部得到很高的地位，以及相应的奖励。不管好用不好用，推行一版，一波人升天。后人再升级一版，又一波人升天。
* 学会了使用这些框架的人，如果自己本身不太灵活，到了其他公司会发现无法干活，因为使用多了会有一个很深的烙印。这样离职起来就没那么方便。
* 比较好规范和控制公司内部的技术方向。&lt;/p&gt;

&lt;p&gt;坏处
* 和最新的技术方向可能有割裂，因为并不一定能及时更新适应。
* 问题解决只能依赖内部的这些人来解决，这种东西想要推广出去毕竟还是难。
* 浪费人力做基础建设。&lt;/p&gt;

&lt;p&gt;其实看起来，对于基层员工来看好处还是大于坏处的。毕竟如果老板不关心这个成本或者不清楚可以节约这个成本的话，那些好处还是实实在在的，牛逼有的吹。&lt;/p&gt;

&lt;p&gt;在老板关心的方面，可能还有一个点，就是创新有时候是比较难的，但是所谓的微创新其实是简单一些，造轮子的时候，一般多少都会有一些微创新。如果搞的人确实有能力，避免一些原来设计里面的鸡肋冗余的部分，让新的设计更加轻快，其实也算是有好处。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Beansdb merge tools</title>
      <link>https://wdicc.com/beansdb-merge-tools/</link>
      <pubDate>Mon, 26 Dec 2016 18:36:11 +0800</pubDate>
      
      <guid>https://wdicc.com/beansdb-merge-tools/</guid>
      <description>

&lt;p&gt;Beansdb 是豆瓣开源出来的一个高效的支持 memcached 协议的文件存储 db。按 key 查找的时候，会有索引定位到磁盘位置。不过貌似前段时间看到说他们搞了一个新的替代这个，我找了一下没找到链接。&lt;/p&gt;

&lt;p&gt;使用 beansdb 的时候，有 2 个问题需要解决
* 冗余问题
* 数据过期删除问题&lt;/p&gt;

&lt;h2 id=&#34;数据冗余问题&#34;&gt;数据冗余问题&lt;/h2&gt;

&lt;p&gt;先说第一个问题。beansdb 本身不提供分布式 hash 逻辑，它就是个单机的程序。冗余需要你自己搞定，如果你使用标准的 memcache 协议，可以有多 server 的配置，读的时候其中一个失败会自动找下一个 server，写的时候就不会了，需要你自己写到多个 server。如果你所有的 server 都是一模一样的，那多写就可以了。如果不一样，你还需要考虑自己的 hash 策略。&lt;/p&gt;

&lt;p&gt;豆瓣提供了一个 python 的&lt;a href=&#34;https://github.com/douban/beansdb/blob/master/python/dbclient.py&#34;&gt;客户端&lt;/a&gt;，这个客户端里面其实包含了 hash 策略。通过把 key 和 server 分桶来做 hash。摘一点代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;BEANSDBCFG = {
    &amp;quot;localhost:7901&amp;quot;: range(16),
    &amp;quot;localhost:7902&amp;quot;: range(16),
    &amp;quot;localhost:7903&amp;quot;: range(16),
}

db = Beansdb(BEANSDBCFG, 16)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面定义了三个 server，每个包含 16 个桶（你可以根据你的需求比如定义第一个 server 只包含某些桶）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def __init__(self, servers, buckets_count=16, N=3, W=1, R=1):
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里是定义写入数据的时候的逻辑，那个 &lt;code&gt;buckets_count&lt;/code&gt; 是桶的数量，&lt;code&gt;N&lt;/code&gt; 和 &lt;code&gt;R&lt;/code&gt; 貌似没用。。。，&lt;code&gt;W&lt;/code&gt; 是改动的时候要求成功的最小 server 数量，包括删除和写入的时候。&lt;/p&gt;

&lt;p&gt;读取的时候，会循环从包含这个 key 的桶的 server 列表里面循环读取，这里还有一个「自愈」的逻辑，循环读取直到遇到一个成功的 server，会同时把前面失败的 server 都写入一份数据。&lt;/p&gt;

&lt;p&gt;这样下来基本就解决了读写分布式和故障恢复的逻辑了，非常巧妙。&lt;/p&gt;

&lt;p&gt;其实针对这个问题，豆瓣还开源了个 &lt;a href=&#34;https://github.com/douban/beanseye&#34;&gt;beanseye&lt;/a&gt;，具体功能没有仔细研究，不过应该是上面需要客户端处理的事情都不需要考虑了。&lt;/p&gt;

&lt;p&gt;我们开始用的时候，不知道有 beanseye，我的场景是在 perl 环境下面使用，把 python 的客户端翻译了一个 perl 的版本出来。[1] 有兴趣可以看看。&lt;/p&gt;

&lt;h2 id=&#34;数据过期删除问题&#34;&gt;数据过期删除问题&lt;/h2&gt;

&lt;p&gt;beansdb 设计之初写入用的是 append 模式，就是说，遇到删除也是写入一条新的记录，并不会返回去修改原来的数据，所以能达到合理的 IO 速度。如果场景是大量不会删除的小文件，那么 beansdb 使用起来非常合适。&lt;/p&gt;

&lt;p&gt;如果有数据过期或者删除的需求，就需要想办法处理这些数据了，否则的话，beandb 的数据文件里面会慢慢的有大量的无用数据，浪费磁盘空间。&lt;/p&gt;

&lt;p&gt;这个删除过期数据的过程，我看豆瓣叫做 merge。思路其实就是把所有数据遍历一次，把有效的数据写入一个新的 data 文件，然后旧的删掉，就可以了。beansdb 的数据文件有 2 种，一种是 &lt;code&gt;xxx.data&lt;/code&gt;，这种文件是数据文件，另外一种是 &lt;code&gt;xxx.hint.qlz&lt;/code&gt; 这种是索引文件。&lt;/p&gt;

&lt;p&gt;针对这个需求，我写了两版程序，第一版就是单纯的解读一下数据文件，把其中的数据的信息读出来，主要是版本号和创建时间，然后根据版本号只写入高版本的，根据创建时间把过期的数据丢弃。生成新的 data 文件之后，要删除 hint 文件，启动的时候会自动产生 hint 文件。然后在 beansdb 的机器上面定期跑这个脚本就好了，注意跑之前应该先关闭 beansdb。&lt;/p&gt;

&lt;p&gt;第一个版本的程序只是解读了每个块的数据头，程序用起来也勉强还行，但是主要问题是，每次启动都需要重新产生 hint 文件，导致启动到提供服务很慢，所以就有了第二版程序。第二版包含了第一版的全部功能，还提供了按照文件大小来定义删除时限的功能。&lt;/p&gt;

&lt;p&gt;第二个版本程序基本把 data 和 hint 文件产生的逻辑都用 perl 实现了（不过还没有经过太多测试）。下面简单讲讲逻辑。&lt;/p&gt;

&lt;h3 id=&#34;data-文件&#34;&gt;data 文件&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;‌typedef struct data_record
{
    char *value;
    union
    {
        bool free_value;    // free value or not
        uint32_t crc;
    };
    int32_t tstamp;
    int32_t flag;
    int32_t version;
    uint32_t ksz;
    uint32_t vsz;
    char key[0];
‌} DataRecord;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;数据文件里面，每个 key 对应的数据的长度是 &lt;code&gt;4*6 + key_size + value_size + padding&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;read($fh, my $header, 4*6);
my ( $crc, $tstamp, $flag, $ver, $ksz, $vsz ) = unpack(&#39;I i i i I I&#39;, $header);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;头部是 24 个字节，依次包括校验数据，写入时间戳，标记位，版本号，key 的长度，value 的长度。上面 &lt;code&gt;unpack&lt;/code&gt; 方法第一个参数里面的含义，可以参考&lt;a href=&#34;http://perldoc.perl.org/functions/pack.html&#34;&gt;perl 的文档&lt;/a&gt;。每个 4 字节，32bit 整数。&lt;/p&gt;

&lt;p&gt;然后是读取 &lt;code&gt;$ksz&lt;/code&gt; 的长度的 key，读取 &lt;code&gt;$vsz&lt;/code&gt; 长度 value。如果 &lt;code&gt;$flag&lt;/code&gt; 标记表明 value 有压缩，压缩用的是 QLZ 算法，真实的值需要用 qlz 解压缩之后才能得到。&lt;/p&gt;

&lt;p&gt;最后是 padding 部分，整个数据长度需要是 256 的整数倍。不足的部分，会写入 &lt;code&gt;\0&lt;/code&gt; 做 padding。&lt;/p&gt;

&lt;p&gt;merge 的过程不关心 value 的真实值，所以不需要解压缩，把读取到的原样写回去就可以了。另外就是 merge 的时候遇到同一个 key 多个 version 出现的时候，只保留大的那个就可以了。这样操作之后 data 文件会变小。&lt;/p&gt;

&lt;h3 id=&#34;hint-文件&#34;&gt;hint 文件&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;‌typedef struct hint_record
{
    uint32_t ksize:8;
    uint32_t pos:24;
    int32_t version;
    uint16_t hash;
    char key[NAME_IN_RECORD]; // allign
‌} HintRecord;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;hint 文件比 data 文件稍微复杂一点，每一条记录是 &lt;code&gt;key_size + data_pos + ver + hash + key + padding&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my ( $ksz, $datapos, $ver, $hash ) = unpack(&amp;quot;B8 B24 i B16&amp;quot;, $header);

$ksz = unpack(&amp;quot;I&amp;quot;, pack(&amp;quot;B32&amp;quot;, $ksz));
$datapos = unpack(&amp;quot;I&amp;quot;, pack(&amp;quot;B32&amp;quot;, $datapos));
$datapos = $datapos &amp;lt;&amp;lt; 8;
$hash = unpack(&amp;quot;I&amp;quot;, pack(&amp;quot;B32&amp;quot;, $hash));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;头部的 10 个字节如上面代码，第一个 8 bit 是 key 的长度，接下来 24 个 bit 是这个 key 对应数据在 data 文件里面的位置。然后是 4 字节版本，16 bit 的 hash。&lt;/p&gt;

&lt;p&gt;padding 和上面 data 里面的逻辑一样，按照 256 的倍数补全。&lt;/p&gt;

&lt;p&gt;hint 文件结尾有个 &lt;code&gt;.qlz&lt;/code&gt;，表示整个 hint 里面的数据是压缩的，所以在处理前需要先解压缩一下。（不过我看到我代码里面在读取 hint 的时候，是全部数据解压，写入的时候，是按照 record 压缩的，很奇怪）。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Release some staff at github</title>
      <link>https://wdicc.com/release-some-staff-at-github/</link>
      <pubDate>Tue, 13 Dec 2016 17:00:31 +0800</pubDate>
      
      <guid>https://wdicc.com/release-some-staff-at-github/</guid>
      <description>&lt;p&gt;把 blog 用到的模板整理了一下，放到了 &lt;a href=&#34;https://github.com/wd/hexo-fabric&#34;&gt;https://github.com/wd/hexo-fabric&lt;/a&gt; ，这个最开始是 fork 别人的代码改的，后来发现原来那个人已经不用了，就整理一下，增加了一个 tag 支持，修改了一下字体和背景色，还有代码颜色等，都是一些小修改。同时也提交到了官方的 theme 库，不过 pull request 还没有通过。。&lt;/p&gt;

&lt;p&gt;另外，还把之前写的一个给 ngx-lua 用的一个使用 mcrypt 加密解密的库 &lt;a href=&#34;https://github.com/wd/lua-resty-mcrypt&#34;&gt;https://github.com/wd/lua-resty-mcrypt&lt;/a&gt; ，整理出来单独弄了一个模块。代码其实非常简单，这个也能看出来 ngx_lua 里面使用 ffi 调用 C 模块开发多舒服，不过因为 C 知识有限，可能还是会有一些问题，不过至少自己测试是 ok 的，也在线上跑了好久，只能遇到有问题的再说了。这个同时也提交到了春哥的 opm 仓库，那个倒没有审核，提交就被索引了，使用的话应该可以用 opm 命令直接安装。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Bloat and Query Speed in PostgreSQL</title>
      <link>https://wdicc.com/bloat-and-query-speed-in-postgresql/</link>
      <pubDate>Fri, 09 Dec 2016 12:12:21 +0800</pubDate>
      
      <guid>https://wdicc.com/bloat-and-query-speed-in-postgresql/</guid>
      <description>&lt;p&gt;内容反义自 &lt;a href=&#34;https://www.citusdata.com/blog/2016/11/04/autovacuum-not-the-enemy/&#34;&gt;https://www.citusdata.com/blog/2016/11/04/autovacuum-not-the-enemy/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;pg 的 mvcc 会导致表索引的 bloat 就不多说了。说一下不合理处理这种 bloat 害处是啥。&lt;/p&gt;

&lt;p&gt;首先肯定是会浪费空间。然后也会影响查询速度。表和索引存储的时候都是 8kB 一个 page，如果一个查询一些行，数据库会加载这些 pages 到内存。一个 page 里面的 dead rows 越多，在加载的时候就越浪费 I/O。例如全表扫描会加载所有的 dead rows。&lt;/p&gt;

&lt;p&gt;Bloat 还会导致热门的查询会一下塞满内存。会导致相同的 live rows 需要更多 pages。This causes swapping and makes certain query plans and algorithms ineligible for execution.&lt;/p&gt;

&lt;p&gt;还有一个影响是，pg 的系统表也会有可能 bloat，因为他们也是表。导致这个的一种情况是频繁的创建和删除临时表。这个进一步会导致一些管理命令执行变慢，甚至比如 &lt;code&gt;\d&lt;/code&gt; 这种命令。&lt;/p&gt;

&lt;p&gt;索引也有可能会 bloat。索引是 tuple 标识和数据之间的一个映射。这些标识指向的是某个 page 里面的 offset。每个 tuple 都是一个独立的对象，需要自己的索引条目。更新一行的时候总是会创建这行的新的索引条目。&lt;/p&gt;

&lt;p&gt;索引的 bloat 的影响比 table 小一点。索引里面指向 dead tuple 的可以直接标记为 dead. 这会使得索引膨胀，但是不会导致不必要的堆查找。同时更新堆中的 tuples 不影响已经索引的列，使用一种叫做 HOT 的技术来把指向 dead tuples 的指针指向新的。这允许查询可以通过这些指针复用旧的索引条目。(Also updates to tuples in the heap that do not affect the indexed column(s) use a technique called HOT to provide pointers from the dead tuple to its replacement. This allows queries to reuses old index entries by following pointers across the heap.) (没太看明白.)&lt;/p&gt;

&lt;p&gt;索引 bloat 的问题还是应该需要重视。例如 btree 索引是由二叉树组成()。叶子节点包含值和 tuple 标识（应该是指在 data file 的 offset）。随机更新因为会重用 page，所以可以保持 btree 维持一个良好的形状。但是，如果是单侧更新，会导致大量的空页。&lt;/p&gt;

&lt;p&gt;The size considerations of index bloat are still significant. For instance a btree index consists of binary tree of pages (the same sized pages as you find holding tuples in the heap). The leaf node pages contain values and tuple identifiers. Uniform random table updates tend to keep a btree index in pretty good shape because it can reuse pages. However lopsided inserts/updates affecting one side of the tree while preserving a few straggling entries can lead to lots of mostly empty pages.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Full page write in PostgreSQL</title>
      <link>https://wdicc.com/full-page-write-in-postgresql/</link>
      <pubDate>Thu, 08 Dec 2016 18:02:14 +0800</pubDate>
      
      <guid>https://wdicc.com/full-page-write-in-postgresql/</guid>
      <description>

&lt;p&gt;读了一篇&lt;a href=&#34;http://blog.2ndquadrant.com/on-the-impact-of-full-page-writes/&#34;&gt;文章&lt;/a&gt;，简单翻译总结下。&lt;/p&gt;

&lt;h2 id=&#34;partial-writes-torn-pages&#34;&gt;Partial Writes / Torn Pages&lt;/h2&gt;

&lt;p&gt;pg 默认是 8kB 一个 page。linux 文件系统一般是 4kB（x86 里面最大是 4kB)，老设备驱动一般是 512B 一个扇区，新的设备有些支持 4kB 或者 8kB。&lt;/p&gt;

&lt;p&gt;当 pg 写入一个 page 8kB 的时候，系统的底层会拆分小一点块，这里涉及到写入的原子性。8kB 的 pg page，会被文件系统拆分成 4kB 的块，然后拆分成 512B 扇区大小。这个时候如果系统崩溃（比如停电，内核 bug）会发生什么？&lt;/p&gt;

&lt;p&gt;即使系统的存储有针对这种情况的设计（比如 SSD 自带电容器，RAID 控制器自带电池），内核那块也是会拆分成 4kB 的 page，所以还是有一定可能性，pg 写了 8kB，但是只有部分写入成功。&lt;/p&gt;

&lt;p&gt;这个时候你可能意识到这就是为啥我们要有事务日志（WAL）。所以当系统崩溃重启之后，数据库会读取 WAL（从最后一次 checkpoint），然后重新写入一遍，以保证数据文件是完整的。&lt;/p&gt;

&lt;p&gt;恢复的时候，在修改一个 page 之前，还是会读取一下。&lt;/p&gt;

&lt;p&gt;在 checkpoint 之后第一次修改一个 page 的时候，会把整个 page 写入 WAL。这是为了保证在恢复的时候，能保证这些被修改的 page 能完全恢复到他原有的样子。&lt;/p&gt;

&lt;h2 id=&#34;写放大&#34;&gt;写放大&lt;/h2&gt;

&lt;p&gt;如果打开 Full page write，很显然会导致 WAL 文件增加，因为就算修改一个字节，也会导致 8kB page 的写入。因为 Full page write 只发生在 checkpoint 之后的第一次写入，所以减少 checkpoint 的发生频率是可以减少写入的。&lt;/p&gt;

&lt;h2 id=&#34;uuid-vs-bigserial-主键&#34;&gt;UUID vs BIGSERIAL 主键&lt;/h2&gt;

&lt;p&gt;比较了一下使用 UUID 或者 bigserial 做主键对写入的影响。可以看原链接的图，会发现在 INSERT 语句的情况下 UUID 产生的 WAL 文件量比较多。主要原因是 Btree 索引的情况下，bigserial 是顺序的维护这个索引，UUID 是无顺序的，会导致维护索引产生的数据量不同。&lt;/p&gt;

&lt;p&gt;如果是使用 UPDATE 随机修改，那么会发现产生的 WAL 数量就差不多了。&lt;/p&gt;

&lt;h2 id=&#34;8kb-and-4kb-pages&#34;&gt;8kB and 4kB pages&lt;/h2&gt;

&lt;p&gt;如果减小 pg 的 page 的大小，可以减小 WAL 数量。从 8kB 减小到 4kB，上面 UUID 那个例子，可以减少大概 35% 的量。&lt;/p&gt;

&lt;h2 id=&#34;需要-full-page-write-吗&#34;&gt;需要 full-page write 吗？&lt;/h2&gt;

&lt;p&gt;首先，这个参数是 2005 年 pg 8.1 引入的，那么现代的文件系统是不是已经不用操心部分写入的情况了？作者尝试了一些测试没有测试出来部分写入的情况，当然这不表示不会存在。但是就算是存在，数据的一致性校验也会是有效的保护（虽然并不能修复这个问题，但是至少能让你知道有坏的 page）&lt;/p&gt;

&lt;p&gt;其次，现在很多系统都依赖于流式同步，并不会等着有问题的服务器在有硬件问题的时候重启，并且花费很多时间恢复，一般都直接切换到热备服务器上面了。这个时候部分写就不是什么问题了。但是如果我们都推荐这么做，那么「我也不知道为啥数据损坏了，我只是设置了 full_page_writes=off」这种会是 DBA 死前最常见的言论了。(类似于「这种蛇我之前在 reddit 看见过，无毒的」)&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;对于 full-page write 你没法直接优化。大部分情况下，full-page write 都是发生在 checkpoint 之后，直到下一次 checkpoint。所以调整 checkpoint 的发生频率不要太频繁很重要。&lt;/p&gt;

&lt;p&gt;有些应用层的操作，可能会导致对表或者索引的随机写入的增加，例如上面的 UUID 的值就是随机的，会让简单的 INSERT 也会导致索引的随机 update。使用 Bigserial 做主键(让 UUID 做替代键)可以减少写放大。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用 pgrepup 跨版本升级 pg</title>
      <link>https://wdicc.com/use-pgrepup-to-upgrade-your-postgres/</link>
      <pubDate>Thu, 08 Dec 2016 11:55:33 +0800</pubDate>
      
      <guid>https://wdicc.com/use-pgrepup-to-upgrade-your-postgres/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://gasparin.net/2016/11/pgrepup-upgrade-postgresql-using-logical-replication/&#34;&gt;pgrepup&lt;/a&gt; 其实是一个支持 pg 跨版本复制的工具。而 pg 大版本升级需要停机是个比较郁闷的事情，如果能通过这个解决就实在太好了。下面测试了一下。&lt;/p&gt;

&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;

&lt;p&gt;需要安装 &lt;code&gt;pgrepup&lt;/code&gt; 和 &lt;code&gt;pglogical&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&#34;安装-pgrepup&#34;&gt;安装 pgrepup&lt;/h3&gt;

&lt;p&gt;pgrepup 官方说是支持 python &amp;gt;= 2.7 的版本，我自己测试的结果，python 3.5 里面执行有点问题，需要修改几个地方。但是在 python 2.7 里面，不需要做任何修改，所以建议使用 python 2.7。安装很简单，执行 &lt;code&gt;pip install pgprepup&lt;/code&gt; 就可以了。&lt;/p&gt;

&lt;h3 id=&#34;安装-pglogical&#34;&gt;安装 pglogical&lt;/h3&gt;

&lt;p&gt;需要给你的 pg 安装这个扩展。高版本的和低版本的都需要安装。&lt;/p&gt;

&lt;p&gt;安装也很简单，下载源码，执行 &lt;code&gt;PATH=/opt/pg96/bin:$PATH make USE_PGXS=1 install&lt;/code&gt; 就好了。如果是给 pg95 装，那就把路径改成 pg95。&lt;/p&gt;

&lt;p&gt;可以参考&lt;a href=&#34;https://2ndquadrant.com/it/resources/pglogical/pglogical-installation-instructions/&#34;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;配置&#34;&gt;配置&lt;/h2&gt;

&lt;h3 id=&#34;配置-db&#34;&gt;配置 db&lt;/h3&gt;

&lt;p&gt;先给几个 db 定义一下角色。db1 假设为 9.5 版本，db2 假设为 9.6 版本。&lt;/p&gt;

&lt;p&gt;pgrepup 允许 db1, db2 和执行 pgrepup 所在的机器分别在不同的机器，也可以在相同的机器，看机器情况。&lt;/p&gt;

&lt;p&gt;对于 db，最小配置的 postgres.conf 修改如下，我测试的时候两个 db 在一台机器上面，只需要修改 port 不一样就可以了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;listen_addresses = &#39;*&#39;          # what IP address(es) to listen on;
port = 5495
wal_level = logical # minimal, archive, hot_standby, or logical
max_wal_senders = 3             # max number of walsender processes
max_replication_slots = 3       # max number of replication slots
shared_preload_libraries = &#39;pglogical&#39;          # (change requires restart)

## 下面几个参数不是必须设置的
logging_collector = on          # Enable capturing of stderr and csvlog
log_filename = &#39;postgresql-%Y-%m-%d.log&#39;        # log file name pattern,
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;pg_hba.conf 如下，修改其中的 client_ip 和 db_ip 为对应的真实 ip。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;host all all client_ip/32 md5
host replication pgrepup_replication db_ip/32 md5
host all pgrepup_replication db_ip/32 md5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置好之后，启动 db1 和 db2 看看是不是可以正常连接。&lt;/p&gt;

&lt;p&gt;还需要建立用户。如果已经存在一个 super 的用户，那也可以直接用那个用户，没有的话，就建一个。db1 和 db2 都需要建立，可以是不同的用户。&lt;/p&gt;

&lt;h4 id=&#34;hint&#34;&gt;hint&lt;/h4&gt;

&lt;p&gt;当然，如果我们在生产环境里面做这个事情，那肯定会是 db1 已经是一个存在的 db，只需要增加原来没有的配置就好了。db2 会是一个全新的 db，使用 initdb 初始化，之后配置上面的配置项（当然，如果是将来要给生产用，那应该是复制 db1 的配置文件过来，修改端口就可以了，其他都一样）。&lt;/p&gt;

&lt;h3 id=&#34;配置-pgrepup&#34;&gt;配置 pgrepup&lt;/h3&gt;

&lt;p&gt;执行一下 &lt;code&gt;pgrepup config&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;❯❯❯ pgrepup config
Pgrepup 0.3.7
Create a new pgrepup config
Configuration filename [~/.pgrepup] ./pgrepup.config
Security
Do you want to encrypt database credentials using a password? [Y/n] n
Folder where pgrepup store temporary dumps and pgpass file [/tmp] ./tmp
Source Database configuration
Ip address or Dns name: db_ip
Port: 5495
Connect Database: [template1]
Username: wd
Password:
Destination Database configuration
Ip address or Dns name: db_ip
Port: 5496
Connect Database: [template1]
Username: wd
Password:
Configuration saved to ./pgrepup.config.
You can now use the check command to verify setup of source and destination databases
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后会产生一个配置文件 pgrepup.config，有修改的话，可以打开再次编辑。&lt;/p&gt;

&lt;p&gt;之后，可以执行一下 &lt;code&gt;pgrepup check&lt;/code&gt; 来检查一下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;❯❯❯ pgrepup -c pgrepup.config check
Pgrepup 0.3.7
Global checkings...
 &amp;gt;  Folder ./tmp exists and is writable ..........................................OK
Checking Source...
 &amp;gt;  Connection PostgreSQL connection to db_ip:5495 with user wd OK
 &amp;gt;  pglogical installation .......................................................KO

    Hint: Install docs at https://2ndquadrant.com/it/resources/pglogical/pglogical-installation-instructions/

 &amp;gt;  Needed wal_level setting .....................................................OK
 &amp;gt;  Needed max_worker_processes setting ..........................................OK
 &amp;gt;  Needed max_replication_slots setting .........................................OK
 &amp;gt;  Needed max_wal_senders setting ...............................................OK
 &amp;gt;  pg_hba.conf settings .........................................................KO
    Hint: Add the following lines to /home/wd/data95/pg_hba.conf:
        host replication pgrepup_replication db_ip/32 md5
        host all pgrepup_replication db_ip/32 md5
    After adding the lines, remember to reload postgreSQL
 &amp;gt;  Local pg_dumpall version .....................................................OK
 &amp;gt;  Source cluster tables without primary keys
 &amp;gt;      template1 ................................................................OK
 &amp;gt;      testdb
 &amp;gt;          public.t1 ............................................................OK
 &amp;gt;      postgres .................................................................OK
Checking Destination...
 &amp;gt;  Connection PostgreSQL connection to db_ip:5496 with user wd OK
 &amp;gt;  pglogical installation .......................................................KO

    Hint: Install docs at https://2ndquadrant.com/it/resources/pglogical/pglogical-installation-instructions/

 &amp;gt;  Needed wal_level setting .....................................................KO
    Hint: Set wal_level to logical
 &amp;gt;  Needed max_worker_processes setting ..........................................OK
 &amp;gt;  Needed max_replication_slots setting .........................................KO
    Hint: Increase max_replication_slots to 3
 &amp;gt;  Needed max_wal_senders setting ...............................................OK
 &amp;gt;  pg_hba.conf settings .........................................................KO
    Hint: Add the following lines to /home/wd/data96/pg_hba.conf:
        host replication pgrepup_replication db_ip/32 md5
        host all pgrepup_replication db_ip/32 md5
    After adding the lines, remember to reload postgreSQL
 &amp;gt;  Local pg_dumpall version .....................................................OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面是我第一次执行 check 的结果，可以看到很多红色的 &lt;code&gt;KO&lt;/code&gt;，有些下面还有 hint 提示告诉你怎么修复，针对红色的信息进行修复就好了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;❯❯❯ pgrepup -c pgrepup.config check
Pgrepup 0.3.7
Global checkings...
 &amp;gt;  Folder ./tmp exists and is writable ..........................................OK
Checking Source...
 &amp;gt;  Connection PostgreSQL connection to db_ip:5495 with user wd ...OK
 &amp;gt;  pglogical installation .......................................................OK
 &amp;gt;  Needed wal_level setting .....................................................OK
 &amp;gt;  Needed max_worker_processes setting ..........................................OK
 &amp;gt;  Needed max_replication_slots setting .........................................OK
 &amp;gt;  Needed max_wal_senders setting ...............................................OK
 &amp;gt;  pg_hba.conf settings .........................................................OK
 &amp;gt;  Local pg_dumpall version .....................................................OK
 &amp;gt;  Source cluster tables without primary keys
 &amp;gt;      template1 ................................................................OK
 &amp;gt;      testdb
 &amp;gt;          public.t1 ............................................................OK
 &amp;gt;      postgres .................................................................OK
Checking Destination...
 &amp;gt;  Connection PostgreSQL connection to db_ip:5496 with user wd ...OK
 &amp;gt;  pglogical installation .......................................................OK
 &amp;gt;  Needed wal_level setting .....................................................OK
 &amp;gt;  Needed max_worker_processes setting ..........................................OK
 &amp;gt;  Needed max_replication_slots setting .........................................OK
 &amp;gt;  Needed max_wal_senders setting ...............................................OK
 &amp;gt;  pg_hba.conf settings .........................................................OK
 &amp;gt;  Local pg_dumpall version .....................................................OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面是我修复之后执行的结果。其中会提示会被同步的 db（上面是 template1, testdb, postgres）。之后执行 setup&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;❯❯❯ pgrepup -c pgrepup.config setup
Pgrepup 0.3.7
Check if there are active subscriptions in Destination nodes .....................OK
Global tasks
 &amp;gt;  Remove nodes from Destination cluster
 &amp;gt;      postgres .................................................................OK
 &amp;gt;      template1 ................................................................OK
 &amp;gt;      testdb ...................................................................OK
 &amp;gt;  Create temp pgpass file ......................................................OK
 &amp;gt;  Drop pg_logical extension in all databases of Source cluster
 &amp;gt;      template1 ................................................................OK
 &amp;gt;      postgres .................................................................OK
 &amp;gt;      testdb ...................................................................OK
 &amp;gt;  Drop pg_logical extension in all databases of Destination cluster
 &amp;gt;      postgres .................................................................OK
 &amp;gt;      template1 ................................................................OK
 &amp;gt;      testdb ...................................................................OK
Setup Source
 &amp;gt;  Create user for replication ..................................................OK
 &amp;gt;  Dump globals and schema of all databases .....................................OK
 &amp;gt;  Setup pglogical replication sets on Source node name
 &amp;gt;      template1 ................................................................OK
 &amp;gt;      postgres .................................................................OK
 &amp;gt;      testdb ...................................................................OK
Setup Destination
 &amp;gt;  Create and import source globals and schema ..................................OK
 &amp;gt;  Setup pglogical Destination node name
 &amp;gt;      postgres .................................................................OK
 &amp;gt;      testdb ...................................................................OK
 &amp;gt;      template1 ................................................................OK
Cleaning up
 &amp;gt;  Remove temporary pgpass file .................................................OK
 &amp;gt;  Remove other temporary files .................................................OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后执行 start&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;❯❯❯ pgrepup -c pgrepup.config start
Pgrepup 0.3.7
Start replication and upgrade
 &amp;gt;  postgres .................................................................OK
 &amp;gt;  template1 ................................................................OK
 &amp;gt;  testdb ...................................................................OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以通过 status 看同步状态&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;❯❯❯ pgrepup -c pgrepup.config status
Pgrepup 0.3.7
Configuration
 &amp;gt;  Source database cluster ......................................................OK
 &amp;gt;  Destination database cluster .................................................OK
Pglogical setup
 &amp;gt;  Source database cluster
 &amp;gt;      template1 ................................................................OK
 &amp;gt;      postgres .................................................................OK
 &amp;gt;      testdb ...................................................................OK
 &amp;gt;  Destination database cluster
 &amp;gt;      postgres .................................................................OK
 &amp;gt;      testdb ...................................................................OK
 &amp;gt;      template1 ................................................................OK
Replication status
 &amp;gt;  Database postgres
 &amp;gt;      Replication status ..............................................replicating
 &amp;gt;  Database testdb
 &amp;gt;      Replication status ..............................................replicating
 &amp;gt;  Database template1
 &amp;gt;      Replication status ..............................................replicating
 &amp;gt;  Xlog difference (bytes) ...................................................57816
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到三个 db 都在同步。这个时候在 db1 上面插入数据，能在 db2 上面看到会同步过去。&lt;/p&gt;

&lt;p&gt;状态有三种情况
* initializing: pglogical 正在 copy 数据
* replication: 同步状态
* down: 同步断开了，需要检查日志修复&lt;/p&gt;

&lt;h2 id=&#34;需要注意的问题&#34;&gt;需要注意的问题&lt;/h2&gt;

&lt;h3 id=&#34;db-里面的表都需要有主键&#34;&gt;db 里面的表都需要有主键&lt;/h3&gt;

&lt;p&gt;如果存在没有主键的表，执行 check 的时候会看到下面的信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; &amp;gt;  Source cluster tables without primary keys
 &amp;gt;      template1 ................................................................OK
 &amp;gt;      testdb
 &amp;gt;          public.t2 ............................................................KO
    Hint: Add a primary key or unique index or use the pgrepup fix command
 &amp;gt;          public.t1 ............................................................OK
 &amp;gt;      postgres .................................................................OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果不解决就执行 setup，会提示下面的信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Setup Source ........................................Skipped, configuration problems
Setup Destination
 &amp;gt;  Create and import source globals and schema .............................Skipped
 &amp;gt;  Setup pglogical Destination node name
 &amp;gt;      postgres .................................................................OK
 &amp;gt;      template1 ................................................................OK
 &amp;gt;      testdb ...................................................................OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以自己创建一个主键重新 check，也可以执行 fix 来修复，然后再次执行 setup。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ❯❯❯ pgrepup -c pgrepup.config fix
Pgrepup 0.3.7
Find Source cluster&#39;s databases with tables without primary key/unique index...
 &amp;gt;  template1 ....................................................................OK
 &amp;gt;  postgres .....................................................................OK
 &amp;gt;  testdb
 &amp;gt;      Found public.t2 without primary key ................Added __pgrepup_id field
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过 fix 加的主键，在 uninstall 的时候会被删除。&lt;/p&gt;

&lt;h3 id=&#34;replication-status-down&#34;&gt;Replication status .. down&lt;/h3&gt;

&lt;p&gt;有时候会遇到有的 db 的状态是好的，有的 db 是 down 的情况&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Replication status
 &amp;gt;  Database postgres
 &amp;gt;      Replication status ..............................................replicating
 &amp;gt;  Database testdb
 &amp;gt;      Replication status .....................................................down
 &amp;gt;  Database template1
 &amp;gt;      Replication status ..............................................replicating
 &amp;gt;  Xlog difference (bytes) ..................................................614096
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在同步状态下面，如果给某个 db 加一个没有主键的表，就会导致同步断掉。修复方法是先 stop，然后执行 check，按照提示修复，然后执行 setup，然后 start 就可以了。&lt;/p&gt;

&lt;h3 id=&#34;官方列出来的几个问题&#34;&gt;官方列出来的几个问题&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;DDL 命令。不会同步 DDL 命令，可以在 db1 试试看 &lt;code&gt;pglogical.replicate_ddl_command&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;seq 序列。执行 stop 命令的时候，会在目标 db 的 seq 上面加 1000。&lt;/li&gt;
&lt;li&gt;有大量的 db。执行 start 命令之后，pglogical 会每个 db 启动一个 worker 来同步数据，要是 db 比较多会导致比较高的负载。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因为这个是基于 pglogical 的，所以还需要关注 pglogical 列出来的一些&lt;a href=&#34;https://2ndquadrant.com/it/resources/pglogical/pglogical-docs/&#34;&gt;限制&lt;/a&gt; 第 4 部分 Limitations and Restrictions。
* 4.1 Superuser is required
* 4.2 UNLOGGED and TEMPORARY not replicated
* 4.3 One database at a time
* 4.4 PRIMARY KEY or REPLICA IDENTITY required
* 4.5 Only one unique index/constraint/PK
* 4.6 DDL
* 4.7 No replication queue flush
* 4.8 FOREIGN KEYS
* 4.9 TRUNCATE
* 4.10 Sequences
* 4.11 Triggers
* 4.12 PostgreSQL Version differences
* 4.13 Doesn&amp;rsquo;t replicate DDL&lt;/p&gt;

&lt;h3 id=&#34;pgrepup-uninstall&#34;&gt;pgrepup uninstall&lt;/h3&gt;

&lt;p&gt;uninstall 会清理 pgrepup 创建的一些信息，比如安装的 pglogical 扩展，创建用来同步的用户，和通过 fix 命令添加的 seq。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;❯❯❯ pgrepup -c pgrepup.config uninstall
Pgrepup 0.3.7
Check active subscriptions in Destination nodes
 &amp;gt;  template1 ...............................................................Stopped
 &amp;gt;  testdb ..................................................................Stopped
 &amp;gt;  postgres ................................................................Stopped
Uninstall operations
 &amp;gt;  Remove nodes from Destination cluster
 &amp;gt;      postgres .................................................................OK
 &amp;gt;      testdb ...................................................................OK
 &amp;gt;      template1 ................................................................OK
 &amp;gt;  Drop pg_logical extension in all databases
 &amp;gt;      Source
 &amp;gt;          template1 ............................................................OK
 &amp;gt;          postgres .............................................................OK
 &amp;gt;          testdb ...............................................................OK
 &amp;gt;      Destination
 &amp;gt;          postgres .............................................................OK
 &amp;gt;          testdb ...............................................................OK
 &amp;gt;          template1 ............................................................OK
 &amp;gt;  Drop user for replication ....................................................OK
 &amp;gt;  Drop unique fields added by fix command
 &amp;gt;          template1
 &amp;gt;          postgres
 &amp;gt;          testdb
 &amp;gt;              public.t1 ........................................................OK
 &amp;gt;              public.t2 ........................................................OK
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;升级&#34;&gt;升级&lt;/h2&gt;

&lt;p&gt;如果前面配置好了同步状态，那剩下的事情就简单了。
* 停止应用链接 db1
* 确保 db1 已经没有任何链接
* 使用 &lt;code&gt;pgrepup stop&lt;/code&gt; 停止 replication
* 修改应用链接到 db2
* 启动应用
* 剩下的就是处理掉停止的 db1&lt;/p&gt;

&lt;h2 id=&#34;参考文档&#34;&gt;参考文档&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://qiita.com/yteraoka/items/e82e4d28f6a23915d190&#34;&gt;http://qiita.com/yteraoka/items/e82e4d28f6a23915d190&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
