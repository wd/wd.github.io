<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Home on wd and cc</title>
    <link>https://wdicc.com/</link>
    <description>Recent content in Home on wd and cc</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 26 Apr 2019 11:46:27 +0800</lastBuildDate>
    
        <atom:link href="https://wdicc.com/atom.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>How to Create an Index in Django Without Downtime</title>
      <link>https://wdicc.com/how-to-create-an-index-in-django-without-downtime/</link>
      <pubDate>Fri, 26 Apr 2019 11:46:27 +0800</pubDate>
      
      <guid>https://wdicc.com/how-to-create-an-index-in-django-without-downtime/</guid>
      <description>&lt;p&gt;django 自己带了一个 ORM 实现，基本可以通过 ORM 管理数据库，这样用户可以在不会 SQL 的情况下使用数据库。在对 model 的属性（字段）做了修改之后，通过执行 &lt;code&gt;makemigrations&lt;/code&gt; 可以生成一个 migrate 文件，然后执行 &lt;code&gt;migrate&lt;/code&gt; 命令可以把这些修改应用到数据库。同时在数据库里面，也会记录当前 migrate 执行的状态，这样能保证数据库的状态和 django 自己认为的数据库的状态是一致的。&lt;/p&gt;

&lt;p&gt;但是这里可能会有一个问题，我们有多个数据库环境，也有多个人一起开发，这样就会导致这个有点混乱，多个人修改 model 后都执行了 &lt;code&gt;makemigrations&lt;/code&gt; 的话，可能会有冲突和问题（实际上 django 已经考虑过这个问题的，migrate 文件都是按照时间戳来命名的，冲突可能性也不大，但是为了避免新手加入弄不好，所以我们采取了另外一个方法做这个事情）。&lt;/p&gt;

&lt;p&gt;下面的内容翻译自 https://realpython.com/create-django-index-without-downtime/ ，我们使用了里面提到的 &lt;code&gt;sqlmigrate&lt;/code&gt; 的方式。&lt;/p&gt;

&lt;p&gt;管理数据库变更在软件开发中是一个比较大的挑战。幸运的是，从 django 1.7 开始有了内置的数据库变更处理框架。这个框架对于处理数据库变更来说很强大很好用。但是为了保证框架提供的灵活性，有一些妥协在里面。为了理解 django 数据库变更框架的限制，我们将解决一个有名的问题：如何在不停机情况下通过 django 创建索引。&lt;/p&gt;

&lt;ul&gt;
在这个教程里面，你将学习到：
&lt;li&gt;django 是什么时候和如何产生数据库变更的&lt;/li&gt;
&lt;li&gt;django 是如何执行变更的&lt;/li&gt;
&lt;li&gt;如何按照需要编辑这些变更&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这篇文章面向的是对 django 数据库变更（migrations）已经有所了解的人的。如果对这些还不了解，那可以先看看 &lt;a href=&#34;https://realpython.com/django-migrations-a-primer/&#34; title=&#34;Django Migrations: A Primer&#34;&gt;Django Migrations: A Primer&lt;/a&gt; 。&lt;/p&gt;

&lt;h1 id=&#34;在-django-里面创建索引存在的问题&#34;&gt;在 django 里面创建索引存在的问题&lt;/h1&gt;

&lt;p&gt;一个常见的变更是当你的数据增加的时候会需要建索引。索引可以查询的速度和应用的响应速度。&lt;/p&gt;

&lt;p&gt;大部分数据库里面增加索引需要在表上面加一个排它锁。当索引创建的时候，排它锁不允许进行数据修改（DML）操作，例如 UPDATE, INSERT, 和 DELETE 。&lt;/p&gt;

&lt;p&gt;当数据库执行这些操作的时候，会立刻加锁。例如如果一个用户登录的时候，django 会更新 auth_user 表的 last_login 字段。为了执行这个操作，数据库会先请求一个行锁，如果这行被其他连接加了锁，那你可能会得到一个&lt;a href=&#34;https://docs.djangoproject.com/en/2.1/ref/exceptions/#database-exceptions&#34; title=&#34;数据库异常&#34;&gt;数据库异常&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;锁表会让系统在做变更的时候不可用。表越大，创建索引的时间越长，系统不可用时间越长。&lt;/p&gt;

&lt;p&gt;一些数据库提供了不锁表建索引的方法。例如，在 PostgreSQL 里面可以使用 &lt;a href=&#34;https://www.postgresql.org/docs/current/sql-createindex.html&#34; title=&#34;CONCURRENTLY&#34;&gt;CONCURRENTLY&lt;/a&gt; 关键字：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE INDEX CONCURRENTLY ix ON table (column);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 Oracle 里面，有一个 ONLINE 选项允许在创建索引的时候执行 DML 操作：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE INDEX ix ON table (column) ONLINE;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在生成数据库变更的时候，django 不会使用这些关键字。执行这些变更创建索引会导致数据库增加表的排他锁，而阻止 DML 操作。&lt;/p&gt;

&lt;p&gt;异步创建索引也有一些潜在的问题。最好提前了解一下自己数据库可能存在的问题。例如，在 PostgreSQL 里面异步创建索引的时候时间会比较长，因为它需要对表做一些额外的扫描。&lt;/p&gt;

&lt;p&gt;这篇文章里面，会使用 django 的数据库变更在一个大表上面创建索引而不会带来停机时间。&lt;/p&gt;

&lt;h1 id=&#34;配置&#34;&gt;配置&lt;/h1&gt;

&lt;p&gt;这里将在一个叫 app 的应用里面使用一个 Sale 模型。在真实世界，类似 Sale 这样的模型一般是数据库的主要的表，会存储大量的数据。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# models.py

from django.db import models

class Sale(models.Model):
    sold_at = models.DateTimeField(
        auto_now_add=True,
    )
    charged_amount = models.PositiveIntegerField()
To create the table, generate the initial migration and apply it:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成初始的数据库变更，并创建这个表：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ python manage.py makemigrations
Migrations for &#39;app&#39;:
  app/migrations/0001_initial.py
    - Create model Sale

$ python manage migrate
Operations to perform:
  Apply all migrations: app
Running migrations:
  Applying app.0001_initial... OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;过一段时间，sales 表会变的很大，用户会开始抱怨访问起来比较慢。通过监控数据库，发现大量查询都使用了 sold_at 列。为了提速，你决定给这列加一个索引。&lt;/p&gt;

&lt;p&gt;为了给 sold_at 加索引，对模型做如下变更：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# models.py

from django.db import models

class Sale(models.Model):
    sold_at = models.DateTimeField(
        auto_now_add=True,
        db_index=True,  # 变更在这里
    )
    charged_amount = models.PositiveIntegerField()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你执行这个数据库变更，django 会在表上面创建索引，表会加锁直到索引创建完毕。在一个很大的表上面创建索引的时候会需要一些时间，你想要避免停机。&lt;/p&gt;

&lt;p&gt;在本地开发环境的时候，数据库比较小连接也不多，这个变更会很快执行完毕。但是，在有很多连接的大数据库，加锁创建索引会需要一些时间。&lt;/p&gt;

&lt;p&gt;下面的步骤会讲如何通过修改 django 生成的数据库变更来达到不停机创建索引的操作。&lt;/p&gt;

&lt;h1 id=&#34;fake-migration&#34;&gt;Fake Migration&lt;/h1&gt;

&lt;p&gt;首先尝试手工建立这个索引。我们将生成这个数据库变更，但是并不用 django 执行。而使用在数据库里面手动执行的方式，然后让 django 相信我们已经做了这个变更。&lt;/p&gt;

&lt;p&gt;首先，生成数据库变更：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;$ python manage.py makemigrations --name add_index_fake
Migrations for &#39;app&#39;:
  app/migrations/0002_add_index_fake.py
    - Alter field sold_at on sale
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 sqlmigrate 命令查看 django 在这次变更里面打算使用的 SQL：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ python manage.py sqlmigrate app 0002

BEGIN;
--
-- Alter field sold_at on sale
--
CREATE INDEX &amp;quot;app_sale_sold_at_b9438ae4&amp;quot; ON &amp;quot;app_sale&amp;quot; (&amp;quot;sold_at&amp;quot;);
COMMIT;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了不加锁创建索引，需要对准备在数据执行的命令做一个修改，增加 CONCURRENTLY 关键字：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;app=# CREATE INDEX CONCURRENTLY &amp;quot;app_sale_sold_at_b9438ae4&amp;quot;
ON &amp;quot;app_sale&amp;quot; (&amp;quot;sold_at&amp;quot;);

CREATE INDEX
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意这里没有执行 BEGIN 和 COMMIT 部分，忽略掉这个可以避免数据库创建事务来执行，关于事务后面会讨论。&lt;/p&gt;

&lt;p&gt;After you executed the command, if you try to apply migrations, then you will get the following error:
执行之后，如果执行生成的数据库变更，会遇到下面的错误：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ python manage.py migrate

Operations to perform:
  Apply all migrations: app
Running migrations:
  Applying app.0002_add_index_fake...Traceback (most recent call last):
  File &amp;quot;venv/lib/python3.7/site-packages/django/db/backends/utils.py&amp;quot;, line 85, in _execute
    return self.cursor.execute(sql, params)


psycopg2.ProgrammingError: relation &amp;quot;app_sale_sold_at_b9438ae4&amp;quot; already exists
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;django 会报错说这个索引已经存在了，所以没法继续执行这个数据库变更了。因为我们已经在数据库里面创建了这个索引，所以需要告诉 django 已经执行了。&lt;/p&gt;

&lt;h2 id=&#34;how-to-fake-a-migration&#34;&gt;How to Fake a Migration&lt;/h2&gt;

&lt;p&gt;django 提供了一个内置的方法来标记一个变更已经执行过了，就是使用 --fake 参数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ python manage.py migrate --fake
Operations to perform:
  Apply all migrations: app
Running migrations:
  Applying app.0002_add_index_fake... FAKED
Django didn’t raise an error this time. In fact, Django didn’t really apply any migration. It just marked it as executed (or FAKED).

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
使用 fake 的时候需要注意的几个问题：
&lt;li&gt;手动执行的命令必须要和 django 生成的有相同的效果：记得使用 sqlmigrate 来生成 SQL。如果两个命令不一致，会导致数据库和 django 里面的模型之间的状态不一致。&lt;/li&gt;
&lt;li&gt;其他没有执行的数据库变更也会 faked：如果有多个没有应用的数据库变更的时候，它们也会被 fake。执行变更前，确认是不是只有你想要的变更被 fake，否则可能会导致数据库和 django 不一致。有一个方式是指定需要 fake 的变更。&lt;/li&gt;
&lt;li&gt;需要有直接连接数据库的权限：你需要在数据库执行那个 SQL。同时，在生产数据库执行命令是危险的，应该尽量避免。&lt;/li&gt;
&lt;li&gt;自动化的工具可能需要调整：如果你有自动部署工具（例如 CI，CD 或者其他工具），可能需要对它们进行调整。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;cleanup&#34;&gt;Cleanup&lt;/h2&gt;

&lt;p&gt;继续下一步之前，需要把数据库回复到初始的状态。执行下面的操作：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ python manage.py migrate 0001
Operations to perform:
  Target specific migration: 0001_initial, from app
Running migrations:
  Rendering model states... DONE
  Unapplying app.0002_add_index_fake... OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;django 把第二步做的修改回滚了，现在可以安全的把变更文件也删除了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ rm app/migrations/0002_add_index_fake.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;确认下是不是都 ok 了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ python manage.py showmigrations app
app
 [X] 0001_initial
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只有第一个变更被执行了，并且也没有其他变更了。&lt;/p&gt;

&lt;h1 id=&#34;execute-raw-sql-in-migrations&#34;&gt;Execute Raw SQL in Migrations&lt;/h1&gt;

&lt;p&gt;在上一个小节里面，通过在数据库直接执行 SQL 然后 fake 那个数据库变更达到我们的目的。还有一个更好的办法。&lt;/p&gt;

&lt;p&gt;Django 提供了一个方法可以在数据库变更的时候通过 RunSQL 来执行原始 SQL。这里我们试着使用它来代替我们直接在数据库执行 sql。&lt;/p&gt;

&lt;p&gt;首先，生成一个空的数据库变更：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ python manage.py makemigrations app --empty --name add_index_runsql
Migrations for &#39;app&#39;:
  app/migrations/0002_add_index_runsql.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编辑变更文件，增加一个 RunSQL 操作：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# migrations/0002_add_index_runsql.py

from django.db import migrations, models

class Migration(migrations.Migration):
    atomic = False

    dependencies = [
        (&#39;app&#39;, &#39;0001_initial&#39;),
    ]

    operations = [
        migrations.RunSQL(
            &#39;CREATE INDEX &amp;quot;app_sale_sold_at_b9438ae4&amp;quot; &#39;
            &#39;ON &amp;quot;app_sale&amp;quot; (&amp;quot;sold_at&amp;quot;);&#39;,
        ),
    ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行这个变更的时候，会有如下的输出：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ python manage.py migrate
Operations to perform:
  Apply all migrations: app
Running migrations:
  Applying app.0002_add_index_runsql... OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看着好像没啥问题，但是其实有一个问题，再次生成数据库变更：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ python manage.py makemigrations --name leftover_migration
Migrations for &#39;app&#39;:
  app/migrations/0003_leftover_migration.py
    - Alter field sold_at on sale
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;django 又生成了一次相同的变更，这是怎么回事呢？&lt;/p&gt;

&lt;h2 id=&#34;cleanup-1&#34;&gt;Cleanup&lt;/h2&gt;

&lt;p&gt;Before we can answer that question, you need to clean up and undo the changes you made to the database. Start by deleting the last migration. It was not applied, so it’s safe to delete:
回答那个问题前，先回滚一下对数据库做的操作。因为最后那个变更没有执行，所以可以直接删除：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ rm app/migrations/0003_leftover_migration.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;列出所有的变更：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ python manage.py showmigrations app
app
 [X] 0001_initial
 [X] 0002_add_index_runsql
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第三个变更消失了，但是第二个变更已经执行了，所以还在。我们需要回滚到初始的状态，执行回滚的变更看看：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ python manage.py migrate app 0001
Operations to perform:
  Target specific migration: 0001_initial, from app
Running migrations:
  Rendering model states... DONE
  Unapplying app.0002_add_index_runsql...Traceback (most recent call last):

NotImplementedError: You cannot reverse this operation
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;django 无法回滚那个数据库变更。&lt;/p&gt;

&lt;h1 id=&#34;reverse-migration-operation&#34;&gt;Reverse Migration Operation&lt;/h1&gt;

&lt;p&gt;To reverse a migration, Django executes an opposite action for every operation. In this case, the reverse of adding an index is to drop it. As you’ve already seen, when a migration is reversible, you can unapply it. Just like you can use checkout in Git, you can reverse a migration if you execute migrate to an earlier migration.
回滚一个数据库变更，django 会执行一个反向的操作。我们这种情况下，增加索引的反向操作就是删除这个索引。就是你看到的，如果一个变更是可回滚的，那你可以回滚它。就和你可以在 git 里面使用 checkout 一样，你可以通过执行前一个变更来回滚后面的变更。&lt;/p&gt;

&lt;p&gt;很多内置的变更都定义了回滚的操作。例如，增加一个字段的回滚操作是删除那个字段。增加一个模型的反向操作是删除那个对于的数据库表。&lt;/p&gt;

&lt;p&gt;有一个操作是无法回滚的。例如，删除一个字段或者删除一个模型是无法回滚的，因为一旦这个操作执行了，数据就没了，回滚不了了。&lt;/p&gt;

&lt;p&gt;在前一个小节，我们使用了 RunSQL 操作。当尝试回滚的时候遇到了错误。通过错误信息可知，有一些操作无法回滚。默认情况下 django 无法回滚原始 SQL。因为 django 不知道实际执行的是什么，不能自动产生回滚对应的操作。&lt;/p&gt;

&lt;h2 id=&#34;how-to-make-a-migration-reversible&#34;&gt;How to Make a Migration Reversible&lt;/h2&gt;

&lt;p&gt;想要一个数据库变更可以回滚，那里面的所有操作必须都是可以回滚的。不能只回滚一部分，所以某一个不可回滚的操作，会导致整个数据库变更都不能回滚。&lt;/p&gt;

&lt;p&gt;为了使得 RunSQL 操作可以回滚，需要提供在回滚的时候执行的 SQL。可以通过 reverse_sql 参数提供。&lt;/p&gt;

&lt;p&gt;增加索引的回滚操作是删除它。增加一个 reverse_sql 参数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# migrations/0002_add_index_runsql.py

from django.db import migrations, models

class Migration(migrations.Migration):
    atomic = False

    dependencies = [
        (&#39;app&#39;, &#39;0001_initial&#39;),
    ]

    operations = [
        migrations.RunSQL(
            &#39;CREATE INDEX &amp;quot;app_sale_sold_at_b9438ae4&amp;quot; &#39;
            &#39;ON &amp;quot;app_sale&amp;quot; (&amp;quot;sold_at&amp;quot;);&#39;,

            reverse_sql=&#39;DROP INDEX &amp;quot;app_sale_sold_at_b9438ae4&amp;quot;;&#39;,
        ),
    ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再执行一下回滚看看：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ python manage.py showmigrations app
app
 [X] 0001_initial
 [X] 0002_add_index_runsql

$ python manage.py migrate app 0001
Operations to perform:
  Target specific migration: 0001_initial, from app
Running migrations:
  Rendering model states... DONE
 Unapplying app.0002_add_index_runsql... OK

$ python manage.py showmigrations app
app
 [X] 0001_initial
 [ ] 0002_add_index_runsql
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二个数据库变更也回滚了，索引被删除了。现在可以删除数据库变更文件了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ rm app/migrations/0002_add_index_runsql.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;应该尽量提供一个 reverse_sql。当一个原始 SQL 操作不需要回滚操作的时候，可以通过 migrations.RunSQL.noop 标记这个操作是可以回滚的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;migrations.RunSQL(
    sql=&#39;...&#39;,  # Your forward SQL here
    reverse_sql=migrations.RunSQL.noop,
),

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;understand-model-state-and-database-state&#34;&gt;Understand Model State and Database State&lt;/h1&gt;

&lt;p&gt;在上一步尝试通过手动执行 RunSQL 来创建索引的时候，即使数据库已经创建了索引，django 还是会生成对应的数据库变更。为了理解这是为什么，需要先理解 django 是如何决定生成一个新的数据库变更的。&lt;/p&gt;

&lt;h2 id=&#34;when-django-generates-a-new-migration&#34;&gt;When Django Generates a New Migration&lt;/h2&gt;

&lt;p&gt;Django 在生成和执行数据库变更的时候，同步数据库和模型之间的状态。例如，当给一个模型增加一个字段的时候，Django 会在数据库里面增加一列。当从模型删除一个字段的时候，Django 会从对应的表删除那个字段。&lt;/p&gt;

&lt;p&gt;为了同步数据库到模型的状态，Django 会维护模型对应的状态。为了同步模型到数据库的状态，Django 生成数据库变更。生成的数据库变更会翻译成对应的不同类型的数据库里面可执行的操作。当所有的数据库变更执行之后，预期上数据库和模型之间就应该是一致的状态了。&lt;/p&gt;

&lt;p&gt;为了得到数据库的状态，Django 会聚合之前的所有数据库变更。当聚合之后的状态和模型当前的状态不一致的时候，Django 会生成新的数据库变更。&lt;/p&gt;

&lt;p&gt;上一个例子里面，我们使用原始 SQL 创建索引。因为我们用的不是常见的操作，Django 这个时候并不知道我们已经创建了这个索引。&lt;/p&gt;

&lt;p&gt;当 Django 聚合所有的数据库变更，然后和模型当前的状态比较之后，发现少了一个索引。这就是为什么即使你手动创建了那个索引，Django 依然会认为缺少这个索引而产生对应的数据库变更。&lt;/p&gt;

&lt;h2 id=&#34;how-to-separate-database-and-state-in-migrations&#34;&gt;How to Separate Database and State in Migrations&lt;/h2&gt;

&lt;p&gt;因为 Django 不能用我们想要的方式创建索引，我们需要提供我们想要执行的 SQL 同时还需要告诉 Django 知道我们已经创建了。&lt;/p&gt;

&lt;p&gt;换句话说，你需要在数据库里面执行一些语句，同时提供给 Django 对应的数据库变更来同步它内部的状态。Django 提供了一个特殊的数据库变更操作叫做 &lt;a href=&#34;https://docs.djangoproject.com/en/2.1/ref/migration-operations/#separatedatabaseandstate&#34; title=&#34;SeparateDatabaseAndState&#34;&gt;SeparateDatabaseAndState&lt;/a&gt; ，这个操作比较少见，一般只是在现在这种情况下才会使用。&lt;/p&gt;

&lt;p&gt;修改一个数据库变更比从头写一个容易多了，所以我们先生成一个变更，然后再修改它：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ python manage.py makemigrations --name add_index_separate_database_and_state

Migrations for &#39;app&#39;:
  app/migrations/0002_add_index_separate_database_and_state.py
    - Alter field sold_at on sale
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是 Django 生成的变更，和之前的一样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;

# migrations/0002_add_index_separate_database_and_state.py

from django.db import migrations, models

class Migration(migrations.Migration):

    dependencies = [
        (&#39;app&#39;, &#39;0001_initial&#39;),
    ]

    operations = [
        migrations.AlterField(
            model_name=&#39;sale&#39;,
            name=&#39;sold_at&#39;,
            field=models.DateTimeField(
                auto_now_add=True,
                db_index=True,
            ),
        ),
    ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Django 给 sold_at 字段生成了一个 AlterField 操作。这个操作会创建索引并更新状态。我们希望保留这个操作，但是提供不同的命令在数据库执行。&lt;/p&gt;

&lt;p&gt;再说一次，可以通过 django 来生成这个命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ python manage.py sqlmigrate app 0002
BEGIN;
--
-- Alter field sold_at on sale
--
CREATE INDEX &amp;quot;app_sale_sold_at_b9438ae4&amp;quot; ON &amp;quot;app_sale&amp;quot; (&amp;quot;sold_at&amp;quot;);
COMMIT;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在适当的地方添加 CONCURRENTLY 关键字：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE INDEX CONCURRENTLY &amp;quot;app_sale_sold_at_b9438ae4&amp;quot;
ON &amp;quot;app_sale&amp;quot; (&amp;quot;sold_at&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来，编辑数据库变更文件，使用 SeparateDatabaseAndState 来执行修改后的 SQL：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;

# migrations/0002_add_index_separate_database_and_state.py

from django.db import migrations, models

class Migration(migrations.Migration):

    dependencies = [
        (&#39;app&#39;, &#39;0001_initial&#39;),
    ]

    operations = [
        migrations.SeparateDatabaseAndState(
            state_operations=[
                migrations.AlterField(
                    model_name=&#39;sale&#39;,
                    name=&#39;sold_at&#39;,
                    field=models.DateTimeField(
                        auto_now_add=True,
                        db_index=True,
                    ),
                ),
            ],

            database_operations=[
                migrations.RunSQL(sql=&amp;quot;&amp;quot;&amp;quot;
                    CREATE INDEX CONCURRENTLY &amp;quot;app_sale_sold_at_b9438ae4&amp;quot;
                    ON &amp;quot;app_sale&amp;quot; (&amp;quot;sold_at&amp;quot;);
                &amp;quot;&amp;quot;&amp;quot;, reverse_sql=&amp;quot;&amp;quot;&amp;quot;
                    DROP INDEX &amp;quot;app_sale_sold_at_b9438ae4&amp;quot;;
                &amp;quot;&amp;quot;&amp;quot;),
            ],
        ),

    ],
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
SeparateDatabaseAndState 操作接收两个列表参数：
&lt;li&gt;state_operations 是应用到模型内部状态变更上面的。这些操作不会影响数据库。&lt;/li&gt;
&lt;li&gt;database_operations 是应用的数据库的变更。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们保留了 django 产生的 state_operations 操作。这是我们使用 SeparateDatabaseAndState 的时候的通常的做法。注意字段上面增加了 db_index=True 。这个操作是让 django 知道那个字段上有一个索引。&lt;/p&gt;

&lt;p&gt;然后在 django 生成的 SQL 的基础上增加了 CONCURRENTLY 关键字。然后使用了 &lt;a href=&#34;https://docs.djangoproject.com/en/2.1/ref/migration-operations/#runsql&#34; title=&#34;RunSQL&#34;&gt;RunSQL&lt;/a&gt; 这个特殊动作执行了一个原始 SQL。&lt;/p&gt;

&lt;p&gt;执行这个数据库变更的时候，会有如下的输出：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ python manage.py migrate app
Operations to perform:
  Apply all migrations: app
Running migrations:
  Applying app.0002_add_index_separate_database_and_state...Traceback (most recent call last):
  File &amp;quot;/venv/lib/python3.7/site-packages/django/db/backends/utils.py&amp;quot;, line 83, in _execute
    return self.cursor.execute(sql)
psycopg2.InternalError: CREATE INDEX CONCURRENTLY cannot run inside a transaction block
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意上面这个输出报错了。&lt;/p&gt;

&lt;h1 id=&#34;non-atomic-migrations&#34;&gt;Non-Atomic Migrations&lt;/h1&gt;

&lt;p&gt;在 SQL 里面，CREATE, DROP, ALTER, 和 TRUNCATE 操作是数据库定义语句（DDL）。在支持在事务里面执行 DDL 的数据库，例如 &lt;a href=&#34;https://wiki.postgresql.org/wiki/Transactional_DDL_in_PostgreSQL:_A_Competitive_Analysis#Transactional_DDL&#34; title=&#34;PostgreSQL&#34;&gt;PostgreSQL&lt;/a&gt;，Django 默认会在事务里面执行数据库变更操作。然而，按照上面的错误，PostgreSQL 不能在事务里面执行异步索引创建。&lt;/p&gt;

&lt;p&gt;为了能在数据库变更里面异步创建索引，需要告诉 django 不要在事务里面执行这个变更。需要设置如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# migrations/0002_add_index_separate_database_and_state.py
from django.db import migrations, models

class Migration(migrations.Migration):
    atomic = False

    dependencies = [
        (&#39;app&#39;, &#39;0001_initial&#39;),
    ]

    operations = [
        migrations.SeparateDatabaseAndState(
            state_operations=[
                migrations.AlterField(
                    model_name=&#39;sale&#39;,
                    name=&#39;sold_at&#39;,
                    field=models.DateTimeField(
                        auto_now_add=True,
                        db_index=True,
                    ),
                ),
            ],

            database_operations=[
                migrations.RunSQL(sql=&amp;quot;&amp;quot;&amp;quot;
                    CREATE INDEX CONCURRENTLY &amp;quot;app_sale_sold_at_b9438ae4&amp;quot;
                    ON &amp;quot;app_sale&amp;quot; (&amp;quot;sold_at&amp;quot;);
                &amp;quot;&amp;quot;&amp;quot;,
                reverse_sql=&amp;quot;&amp;quot;&amp;quot;
                    DROP INDEX &amp;quot;app_sale_sold_at_b9438ae4&amp;quot;;
                &amp;quot;&amp;quot;&amp;quot;),
            ],
        ),

    ],
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后就可以执行了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ python manage.py migrate app
Operations to perform:
  Apply all migrations: app
Running migrations:
  Applying app.0002_add_index_separate_database_and_state... OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就执行了这个变更而没有任何停机时间。&lt;/p&gt;

&lt;ul&gt;
使用 SeparateDatabaseAndState 的时候还有一下需要考虑的问题：
&lt;li&gt;数据库操作必须和状态操作一致：数据库状态和模型的状态不一致可能会导致很多问题。好的做法是在 state_operations 使用 django 产生的变更，然后 database_operations 使用编辑之后的 django 通过 sqlmigrate 产生的 SQL。（其实就是上面例子里面的方式）&lt;/li&gt;
&lt;li&gt;非原子性的数据库操作在遇到错误的时候不能回滚：如果在执行数据库变更的时候遇到了错误，那你将不能回滚。这时候就必须整个回滚或者手动操作执行了。把尽量少的非原子性的操作放一起比较好。如果有其他的操作，可以把它们放到另一个单独的数据库变更里面。&lt;/li&gt;
&lt;li&gt;数据库变更也可能和数据库类型有关：django 会根据使用的后端数据库类型产生 SQL。可能可以支持其他类型的数据库，但是并不能保证一定可以。如果需要支持不同数据库类型，那需要根据需要修改一下这个方案。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;这篇文章主要是解决了一个大量数据的数据库里面，想要提高用户响应速度，但是不想增加停机时间的问题。&lt;/p&gt;

&lt;p&gt;（我感觉作者废话太多了，实在懒得翻译了。。。）&lt;/p&gt;

&lt;p&gt;By the end of the tutorial, you managed to generate and safely modify a Django migration to achieve this goal. You tackled different problems along the way and managed to overcome them using built-in tools provided by the migrations framework.&lt;/p&gt;

&lt;p&gt;In this tutorial, you learned the following:&lt;/p&gt;

&lt;p&gt;How Django migrations work internally using model and database state, and when new migrations are generated
How to execute custom SQL in migrations using the RunSQL action
What reversible migrations are, and how to make a RunSQL action reversible
What atomic migrations are, and how to change the default behavior according to your needs
How to safely execute complex migrations in Django
The separation between model and database state is an important concept. Once you understand it, and how to utilize it, you can overcome many limitations of the built-in migration operations. Some use cases that come to mind include adding an index that was already created in the database and providing vendor specific arguments to DDL commands.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Readings</title>
      <link>https://wdicc.com/readings/</link>
      <pubDate>Fri, 19 Apr 2019 15:38:57 +0800</pubDate>
      
      <guid>https://wdicc.com/readings/</guid>
      <description>&lt;h1 id=&#34;1984-英-乔治-奥威尔&#34;&gt;﻿1984 ([英] 乔治·奥威尔)&lt;/h1&gt;

&lt;p&gt;这书看完我觉得这根本就是一本恐怖小说，当里面的内容正在和将要发生的时候你就不会觉得里面的描述有点搞笑了。不过看到后面有译者的补充内容说和其他国家的朋友讨论的时候，大家都会有各种不同的带入感，觉得也挺有意思的。这可能是所谓的普世价值吧，大家都觉得不应该这样。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;思想罪可是件要不得的事情，老兄，”他庄重地说，“它很阴险。你甚至还不知道发生了什么事，它就抓住了你。你知道它怎样抓住我的吗?在睡梦里!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里是温斯顿一个朋友讲他怎么被抓的，因为说梦话说了一些不该说的，被女儿举报。。。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;谁能控制过去就控制未来;谁能控制现在就控制过去
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;拗口么，控制了现在就可以（通过修改历史）控制过去。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;不是!不光是要你们招供，也不光是要惩罚你们。你要我告诉你为什么把你们带到这里来吗?是为了给你们治病。是为了使你神志恢复健全!

温斯顿，你要知道，凡是我们带到这里来的人，没有一个不是治好走的。我们对你犯的那些愚蠢罪行并不感到兴趣。党对表面行为不感兴趣，我们关心的是思想。我们不单单要打败敌人，我们要改造他们。你懂得我的意思吗?“
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;犯了思想罪的人都病了，需要治。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;党越有力量，就越不能容忍;反对力量越弱，专制暴政就越严。果尔德施坦因及其异端邪说将永远存在。
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;1q84-村上春树&#34;&gt;1Q84 (村上春树)&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;姑且礼貌的问问。可是希望得到回答的哟。嘴不利索的话，点头或者摇头。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个书是看完上面的 1984 之后翻的，看了第二章感觉就有意思起来了，很会通过故事吸引人。不过这个书里面的隐喻实在好难懂啊，看别人的书评才能理解一些，可能作者厉害的地方就在这里吧。。。&lt;/p&gt;

&lt;h1 id=&#34;伟大的博弈-华尔街金融帝国的崛起-1653-2011-珍藏版-约翰-s-戈登&#34;&gt;伟大的博弈:华尔街金融帝国的崛起(1653～2011)(珍藏版) (约翰·S·戈登)&lt;/h1&gt;

&lt;p&gt;这本书几乎是从美国建国讲起，讲到后面华尔街兴起，以及美国的金融市场是怎么一步一步发展起来的，华尔街的起起落落，和看故事书一样。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;作为新兴工业经济基石的钢铁也彻底改变了华尔街的外观。许多建于19世纪50年代的陈旧的6层小办公楼被一一推倒，让位给“摩天大楼”（skyscraper）——这个词在1883年才被创造出来。钢铁建材的出现和电梯的发明使摩天大楼成为可能，而纽约狭小的城市面积更使得摩天大楼的大量出现不可避免。纽约古老街区里窄窄的街道从此开始熟识摩天大楼巨大的投影和楼宇之间漏出的些许阳光。这种趋势引起了市民和市府官员们的警觉，当40层的“衡平保险公司大厦”（Equitable Building）在雪松大街和青松大街之间的百老汇上开始建造时，它严严实实地占据了整个街区，这直接导致美国第一部城市规划条例的颁布。就像快餐一样，城市规划条例也发源于华尔街。事实上，美国文化中很多与金钱无关的传统都与华尔街有关。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一些美国的文化据说是发源于华尔街，比如快餐是因为股价上下波动很快大家忙到没时间吃饭，所以有了快餐。。。城市规划是因为华尔街发展太快不得不开始进行必要的规划。。。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;荷兰人早在导演和参与“郁金香泡沫”时练就的投机技术，很快就被运用到了北美新大陆。发生在这块处女地的第一次金融投机活动是针对当时原始的货币——贝壳串珠进行的投机，这次金融投机揭开了北美350年的金融史——同时也是350年的投机史的序幕。这些投机技术在以后的历史中被反复应用，投机者们沉溺其中，乐此不疲。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从郁金香泡沫开始讲投机，囤积贝壳让贝壳价值上涨获利。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;荷兰人发明了最早的操纵股市的技术，例如卖空（short-selling，指卖出自己并不拥有的股票，希望在股价下跌后购回以赚取差价）、“洗盘”（bear raid，指内部人合谋卖空股票，直到其他股票拥有者恐慌并全部卖出自己的股票导致股价下跌，内部人得以低价购回股票以平仓来获利）、对敲（syndicate，指一群合谋者在他们之间对倒股票来操纵股价），以及逼空股票（corner，也称杀空或坐庄某一只股票，或囤积某一种商品，指个人或集团秘密买断某种股票或商品的全部流通供应量，逼迫任何需要购买这种股票或商品的其他买家不得不在被操纵的价位上购买）。
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;（这种总是期望有人会愿意出价更高的想法，长期以来被称为投资的博傻理论）
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;。这时候菲利普斯开始买进贝壳串珠，并囤积起来。实际上，他把贝壳串珠装在桶里埋在地下，以减少贝壳串珠的流通量。几周之内，他就控制了串珠市场，成功地抬高了价格。到1666年，3颗白串珠就相当于1个斯图弗。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;控制市场上面的量，控制价格。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;最常见的铸币是西班牙的里亚尔银币（Spanish real），经常被切成2块、4块、8块来找零钱。这就是为什么直到今天，纽约证券交易所还是以一美元的1/8为最小单位来报价，而不是1/10。
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;到18世纪90年代，尽管费城的发展速度远远低于纽约，但它依然是那时美国的金融中心。美国的第一家银行——北美银行（Bank of North America）是在费城成立的；美国的第一家证券交易所——费城证券交易所（Philadelphia Stock Exchange）在1790年成立。在此后的10年内，费城仍然是美国的首都，而华盛顿那时尚在建设之中，因此，汉密尔顿的中央银行——美国银行（Bank of the United States[35]）也于1791年在费城成立。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;早期的时候，费城是金融中心，纽约还排不上号。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;·资本市场的繁荣催生了第一批专业的证券经纪人，他们需要一个专用的交易场所；为了防止在门口偷听价格“搭便车”的场外交易发生，也为了防止经纪人们无休止地杀低交易佣金，他们签订了著名的《梧桐树协议》——这一向被认为是纽约交易所的源头，而本质上是一个卡特尔——价格同盟。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;开始的时候证券交易是小部分人聚集起来做的一个事情，他们为了保证自己的佣金利益，搞了这个协议，很多年之后（似乎是19xx年）才放开佣金，那会都是固定佣金。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;·在这一时期，有限责任制度——现代企业制度的基石得以奠定，美国各州通过了《普通公司法》，带动了新一轮的经济增长，从1792年到1817年，联邦税收在25年内增长了9倍。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;公司法颁布之前企业都不能像人一样拥有自己的财产。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;18世纪末期，经纪人这个概念的含义要比今天宽泛得多。这个词早在14世纪就从法语引入到英语中，它的法语原意是：把一桶酒分装成一杯一杯或一瓶一瓶后再卖出的人。在17世纪之前，这个词一直特指零售商和批发商，此后，它就完全被用来特指自己不直接参与生产的中介人。到这个时期，“经纪人”的含义逐渐演变为：将买方和卖方撮合在一起，并对促成的交易收取佣金的人
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;broker 这个词在计算机领域也有，做代理，分发这类事情的，叫做 broker。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;美国银行股票（很快被简称为“BUS”）的交易在1791年春就已经开始了。这一年7月，该股票正式认购时，在一小时之内就全部卖光，随后股价一路攀升。这个新生国家的第一次大规模的股票公开发行（IPO）启动了它的第一轮牛市。
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;股票的含义才被特指为代表所有权的证券，而债券被特指为代表债权的证券
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;《梧桐树协议》。这被公认为是纽约证券交易所的最初起源，但本质上却是一个经纪人的卡特尔，纽约证券交易所的这一本质直到180多年后才得以改变。
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;”杰斐逊一向痛恨投机者，此时几乎掩饰不住自己的兴奋，他算了一下，投机者损失总值达到了500万美元，这相当于当时纽约的房地产总值。他的结论是，股市恐慌所带来的损失跟自然灾害摧毁纽约所带来的损失是一样的。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;股市恐慌带来的损失也会很大。带来失业，市场不景气，各种连锁反应。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;投机一直是一个颇受争议的名词，至少在华尔街以外的地方是这样。投机者经常被看成是资本主义市场发展进程中的寄生虫，他们并不创造财富，但却能从中谋利


投机有助于确保市场产生最公正的价格

另外，投机很像色情，给它下个定义或许很难，但明眼人却一眼就能辨别出来。正如20世纪初伟大的英国金融家欧内斯特·卡塞尔（Ernest Cassel）爵士所说：“当我年轻的时候，人们称我为赌徒；后来我的生意规模越来越大，我被称为一名投机者；而现在我被称为银行家。但其实我一直在做同样的工作。”
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有投机机会会带来交易量，这样会有博弈，所以有助于确保公平。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;一些债券以可转换债券的形式发行（意味着债券持有者可以根据需要把它们转换成股票），有一批可转换债券甚至允许持有人随心所欲地在债券和股票之间来回转换，这在华尔街的历史上是绝无仅有的，这种特性使它成为近乎完美的投机工具。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;股票上涨的时候，换成股票兑现，股票下跌的时候，换成债券又会保值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[91]格雷欣法则（Gresham’s Law），指使用者保留贵重的货币，而优先选择使用价值低的货币。托马斯· 格雷欣（Thomas Gresham, 1519~1579），英国金融家，皇家证券交易所（Royal Exchange）的创始人。—译者注
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也就是劣币驱逐良币。因为保值的东西不容易贬值，而不保值的东西最好尽快兑现，要不可能过几天就不值钱了。所以会保留良币，使用劣币，这样市场上就只能看到劣币了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1861年　美国南北战争爆发。
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;从私募走向公募：传统上，政府为战争进行融资，主要依靠征税和大量印钞，这是南北方政府同时能想到并做到的。而华尔街上年轻的银行家——库克为北方政府所做的是南方政府所没有想到的。他没有采用传统上私下向银行和经纪商出售债券的方式，即私募发行，而是革命性地通过华尔街向公众发售战争国债，即公募发行。他告诉普通美国人，购买这些战争债券不仅是一种爱国的表现，也是一笔很好的投资。到战争后期，库克出售国债的速度已经超过北方政府为战争花钱的速度。而与此同时，严重依赖印钞票支付战争费用的南方政府，面对相对于战前高达9000%的通货膨胀率无奈地接受了战败的结局。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;北方军有华尔街这些金融大鳄的点子和支持，很好的募集到了支持战争的钱，打赢了南方军。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1865年　南方邦联军投降，美国内战结束。不久，林肯遇刺。
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;1868年11月30日，两个交易所颁布了同样的监管条例，要求对所有在交易所拍卖的股票进行登记，并且，任何新股发行都必须提前30天通知交易所。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这之前，企业几乎可以随意增发股票，所以没人知道一个公司在市场上到底有多少股票。这个简直不敢想，居然这会才规定。。。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;对于研究华尔街的历史学家而言，道琼斯指数同样是无价的，因为它是现存最早的股票市场的连续平均指数，从1896年就开始有了记录。发明这个绝妙而又简单的办法的天才是查尔斯·道[130]，他也是《华尔街日报》（Wall Street Journal）的创办人之一。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;道琼工业指数的诞生。。。。。这个哥们居然还是华尔街日报的创办人。。。。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;意大利在15世纪文艺复兴时期出现了复式记账法（double-entry bookkeeping）


但是，由谁来作这个报告呢？公司内部的财务人员毕竟是为公司管理层工作，所以很难做到真正地独立。这时，独立会计师的人数迅速增加。1884年，在纽约、芝加哥和费城的商业电话簿上只能找到81个会计师，仅过了5年，这个数字就达到了322。1882年会计师及簿记师协会（Institute of Accountants and Bookkeepers）在纽约成立，并且开始向那些通过了严格考试的人员发放资格证书。1887年，美国公共会计师协会（American Association of Public Accountants）成立，它是现在美国会计行业管理机构的前身。1896年，纽约州通过立法奠定了这项职业的法律基础，并使用“注册会计师”这样一个称号来表示这些人是符合法律标准的会计师。纽约州的法律和“注册会计师”（Certified Public Accountant，CPA）这个名词马上也被其他州采用了。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;股票价格是会和一个公司运营到底怎么样有关系的，公司运营的不好，股票自然会跌，但是这之前公司记账都是自己记的，那简直想怎么记怎么记。。。这会开始有了第三方的记账机构。。。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;19世纪90年代　华尔街取得两大进步：股票市场平均指数和现代会计制度出现。
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;·再一次，依仗摩根巨大的影响力，摩根和华尔街的银行家们阻止了这场可能将美国经济拖入深渊的金融恐慌。美国这个当时世界上最强大的经济实体，在危机中不得不依靠摩根个人来扮演中央银行角色，这一事实促成了美联储在1913年成立。这一年，成为美国金融历史的分水岭。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;摩根牛逼到不行，各种救市，拯救美国经济。。。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;这种不安远不仅限于华尔街，那年秋天，西奥多·罗斯福在麦金利死后继任总统，他坚信并提倡政府对经济的干预，以防止某些强大的经济力量变成政治上的霸权。当1904年美国司法部宣布按照《谢尔曼反托拉斯法案》（Sherman Antitrust Act）起诉并要求拆分北方证券公司（Northern Securities Corporation）时，J·P·摩根被惊得目瞪口呆。北方证券公司是摩根处理E·H·哈里曼和詹姆斯·J·希尔关于北太平洋铁路公司的经济纠纷而成立的一家公司。摩根火速赶到了华盛顿，想搞明白为什么西奥多·罗斯福不能像绅士之间的交往那样事先告诉他，以便私下里达成一个双方满意的解决方案。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;反垄断。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;中央银行的职能是监控商业银行，管理货币供应，同时在金融市场恐慌或银行危机时期担当最后贷款人（lender of last resort）的角色。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;中央银行就是主持金融市场的，和。。救市的。。。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;“经济学”在本质上是研究市场中人的学问
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;股票是人心的体现，贪念，欲望。。。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1913年12月23日，国会立法批准设立美联储，这一年成为美国金融史上的分水岭。
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;人类社会有一条铁律：在没有外来压力时，任何组织的发展都会朝着有利于该组织精英的方向演进。这条规律既适用于津贴丰厚的公司管理层，也适用于被领袖人物控制的工会，既适用于美国国会，也适用于好莱坞。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以如果工人不罢工，那就只有可能被剥削的越来越严重，嗯，996。。。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;在华尔街200年的历史上，不论出现过什么样的阴谋诡计，仍然有两条游戏规则从来没有被亵渎过。第一条是“成交了就是成交了”（A deal is a deal）

第二条同样神圣的规则是，私人契约的隐私权不受侵犯
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个是平等交易的基石吧。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;·1933年，美国取消金本位制，颁布《证券法》和《格拉斯-斯蒂格尔法》；1934年，美国颁布《证券交易法》；同年，依据该法成立了美国证监会；1940年，美国颁布《投资公司法》和《投资顾问法》。至此，美国资本市场在自我演进超过百年之后第一次出现了关于证券发行、交易和投资基金的法律，也第一次建立了监管机构，这一系列制度建设形成了现代金融体系监管的基本框架，也为随后几十年美国金融市场的发展奠定了基础。
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;5月27日，罗斯福签署了《联邦证券法》（Federal Securities Act），这是美国历史上第一部规范证券交易的法律，它要求所有的新股发行都必须在美国证券交易委员会（Securities and Exchange Commission，即美国证监会）注册，而且必须披露特定的信息。6月5日，国会取消了美国的金本位制，
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进一步规范市场。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;尽管惠特尼百般阻挠，罗斯福总统还是提交了一项法案，于是，惠特尼和交易所决定由他们自己动手先来改革华尔街上最有问题的那些行为。
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;1934年2月13日，交易所委员会投票通过法令，禁止联手坐庄，同时也禁止专门经纪人将内幕信息透漏给他们的朋友，并禁止专门经纪人购买他们所做市股票的期权。
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;为了防止卖空投机和股市恐慌时打压市场，卖空单只有在股价上升时——也就是说卖空股票的价格高于上一个成交价时——才被认定有效。
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;为了防止今后单一金融风险再次扩散为金融系统风险，纽约证券交易所于1964年第一次建立了风险基金。就像19世纪交易所和经纪人委员会采取行动抑制过度的投机行为以及投资银行一致要求上市公司出具年度报告和独立的会计报表一样，华尔街的参与者们再一次意识到，他们有着超越各自利益的共同利益，需要大家共同维护。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只有规范的市场，才是健康的，持续发展的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;美里尔将这一切彻底改变了。他严格培训他的客户经理们——这些人现在被称做注册代理人（registered representative），让他们掌握经纪业务的基本知识，并且，美里尔在他们刚刚开始工作时就给他们支付固定工资，而不是让他们完全依靠佣金过活
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;专业的代理人出现，专业的事情有专业的人员做更加靠谱，这个是社会分工和规模化必须走的路。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;格雷厄姆被称为“现代证券分析之父”，他倡导的基本面研究和开创的证券分析方法在一定程度上改变了华尔街此前盛行的投机风气，并为现代资产管理业奠定了基础。其著作《证券分析》和《聪明的投资者》影响甚广。巴菲特早年曾向格雷厄姆学习投资。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;理性的分析证券市场的规律，分析股票的走向。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;纽约证券分析协会（New York Society of Security Analysts）于20世纪30年代成立
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;1960年，这个预言变成了现实，养老基金和工会拥有数以十亿计的资金，它们成为华尔街的大玩家。那一年，美国中部卡车司机联合工会（Teamsters）持有的股票价值为2350万美元，美国矿工联合工会（United Mine Workers Union）有1640万美元投资在华尔街。1961年，联邦政府预算总额只有不到1000亿美元，而所有非保险类养老基金持有的股票市值就有174亿美元之多。在那个时期，养老基金每年都有10亿美元的资金进入股市，有20亿美元进入债市。除此以外，随着千百万美国家庭开始有能力购买原先是奢侈品的人寿保险，这些人寿保险的承办主体——保险公司也越来越多地成为华尔街的主要投资者。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保险金的进入，让这个市场更大，也就更加需要稳定和健康的市场。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;道琼斯指数是按照价格加权而不是按照市值加权计算，这意味着在道琼斯平均指数的计算过程中，高价股票的影响大于低价股票，而股票市值的大小对指数的影响却没有被考虑进来（股票的市值=股票价格×股票总流通股）
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;1965年，自动报价机终于与一块电子显示屏相连接，使整个大厅的人都可以同步看到正在打印的记录单上的股价信息
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;《联邦证券法》就要求经纪人为客户寻找到股票的最好报价
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;纽约证券交易所的专门经纪人们通过交易所的管理委员在1955年制定了《394条例》（Rule 394），该条例禁止会员公司买卖交易所以外的股票，“除非是在交易所特别豁免的情况下”。换句话说，联邦法律要求经纪人们去寻找能给出最好价格的市场，而纽约证券交易所却禁止他们这样去做。
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;1975年5月1日，《梧桐树协议》签订183年之后，固定佣金制在华尔街上寿终正寝，几年之后，它也将从伦敦交易所消失
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;纳斯达克是“美国证券交易商自动报价系统”（National Association of Securities Dealers Automated Quotation System）
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;到20世纪80年代末期，美国事实上只剩下两个证券交易市场：一个是纽约证券交易所，主要交易挂牌证券，它们市值较大，并被广泛持有；另一个是纳斯达克市场，主要交易那些市值较小的、未在交易所挂牌的股票。当然，也有明显的例外，例如英特尔和微软这两家大公司都是在纳斯达克交易，而不是“主板”[202]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;以萨班尼斯和奥克利两位提案人命名的《萨班尼斯和奥克利法案》（Sarbanes-Oxyley Act）为财务会计制度带来了巨大的变化，其中包括禁止会计师事务所为同一家公司同时提供审计和咨询服务。此外，股票期权必须在授予员工之际便计入公司当期费用，而不能等到期权执行时再计入公司费用，以便能使投资者更清楚地了解到公司的价值。
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;·2001年11月，美国安然公司财务丑闻被接连曝光，安然公司股价一路由每股90美元下滑至每股30美分。2001年12月2日，在全球拥有3000多家子公司、名列《财富》杂志“美国500强”第七名、掌控着美国20%的电能和天然气交易、被誉为“华尔街宠儿”的安然公司申请破产保护。不久，其聘请的会计师事务所安达信——一个有90多年历史的世界级会计师事务所退出审计市场。
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Blogs Weechat Official Accounts and Freedom</title>
      <link>https://wdicc.com/blogs-weechat-official-accounts-and-freedom/</link>
      <pubDate>Thu, 28 Mar 2019 11:18:37 +0800</pubDate>
      
      <guid>https://wdicc.com/blogs-weechat-official-accounts-and-freedom/</guid>
      <description>&lt;p&gt;十几年前，还没有微博的时候，大家热衷于开 blog 写点自己想写的东西，出来了一大批 blog 平台，不管写多少内容有没有什么价值，很多人都会开一个自己的 blog。同时也有不少人自己搭建自己的 blog 平台，那会还有人卖空间专门搭 blog 用，提供一个虚拟主机，可以一键弄一个自己的 wordpress。&lt;/p&gt;

&lt;p&gt;我最早的时候的 blog 是自己搭建的，后来也用过 wordpress，也去新浪开过博客。现在看开 blog 其实满足了用户的两个诉求，一个是写东西表达自己的想法，一个是社交。单纯的表达自己的想法可能也是一种发泄输出吧，写下来会觉得有了输出，之后会觉得告一个段落。至于社交，一般是几个好友会互相关注对方的 blog，比如当时的 msn space，qq 空间这些会直接在 im 工具里面提醒你。对于感兴趣的人不管是朋友还是陌生人，可以留个言什么的互相交流。以前在各个平台开的博客现在有的是平台死了文章没有了，有的是自己都忘记用什么账号开的了，找不到了。倒是自己搭的平台因为自己持续的在把数据保留下来，现在还有一些历史数据，现在回看这些内容感觉也挺好玩挺温馨的。&lt;/p&gt;

&lt;p&gt;到了现在，blog 基本都死了，出现了微信公众号这个东西，我一直觉得微信公众号是一个反互联网的东西，他们想了很多办法来防止里面的内容被外部抓到，比如我自己发布的内容想在自己网站提供一个列表给大家看就不行，因为虽然提供了在 pc 浏览器看内容的方式，但是只能看单篇，想看其他的必须用手机扫了码之后在手机看，并没有提供 pc 的列表页。只能是发一篇把一篇文章地址加入到自己的列表里面。&lt;/p&gt;

&lt;p&gt;内容格式支持 html，编辑器不好用还催生了一批辅助工具，从这些工具复制源码之后，确实可以有效果，但是因为微信实际并不能编辑源码，有时候遇到复制的奇葩的代码，会发现无论如何都编辑不好。而且关键是微信官方对待公众号和对待聊天功能一样，并没有多少兴趣去把这个东西做到极致，也可能是因为他们从 qq 那边看到，功能怎么样和用户用不用其实并不是那么的强相关吧，并不是提供了用户所有想要的功能用户就会用，这样反而增加了产品的复杂度可能得不偿失。&lt;/p&gt;

&lt;p&gt;公众号还有一个问题是，他们天然倾向于满足用户的需求，用户需要低俗八卦那他就会想办法多制造这些内容，而且这些东西在那些人的圈子里面流窜，获得更多的用户。比如那些养生的东西，这能吃那不能吃的文章在中老年圈子里面就流传的很快。但是一篇反过来避谣的文章就流传不起来，因为这些人不会关注这样的公众号。造谣一时爽，避谣跑断腿。只是拿这样的一篇文章如何能说服对方呢？对方首先一个并没有看到多少人支持这个观点，另外一个可能会说好好我信你了，然后就完事了，也不会转发打自己的脸，不会觉得要对那些看了自己转发的文章的人负责。&lt;/p&gt;

&lt;p&gt;微博上面相对好一点，在原微博上可以直接可以看到不同观点，反对的微博也可能会再次出现在自己的时间线也同样可以看到针对这个微博大家的观点，这也是一个学习的过程，反思自己之前为什么会没有在第一时间看到其他提出来的问题呢，自己也会持续提升自己的判断辨别能力。但是微博上面又会放大参与者的情绪，导致一些极端的情况，这就另说了。&lt;/p&gt;

&lt;p&gt;今天还听了另外一个观点，可以一起聊聊。现在各种算法会依据你看的内容不停推荐类似的内容，比如你喜欢看猫，那就持续的推猫的内容，让你不停的看下去。最开始可能是今日头条开始这么做的吧，后面网易新闻也跟进了。我一直用的是网易新闻，期间试过看今日头条，发现里面内容质量不高之后就删掉了，直到某天网易新闻也开始做了类似的事情，新闻每次刷新都会给你推荐新的，导致没有看完的时候，就把网易新闻也删除了。换了即刻，现在发现即刻也可以乱推一些东西之后，取消关注了很多的频道，现在用的也不多了。&lt;/p&gt;

&lt;p&gt;你喜欢看什么，就尽量多的给你推什么，这个算法有问题么？其实挺美好的，这样不就不用你来回自己去找想看的内容了吗？但是这样其实也会有几个问题，一可能会让你接触不到其他你没接触到但是有可能喜欢的东西，二可能会让人的思路变得极端。每天都环绕在一个没有争议的环境里面，慢慢的可能会失去辨别能力，也很更加不容易接受不同的东西。&lt;/p&gt;

&lt;p&gt;说回那个观点，那个观点讲的就是比如看了一个宣扬极端观点的视频，他持续给你推荐这些视频的话，会不会容易把这个人变的很极端？按说是存在这种可能的，当然如果这个人自己确实对这个感兴趣那总也是会自己找这些信息看的，不过是这种推荐可能节约了他的时间。&lt;/p&gt;

&lt;p&gt;标题为啥还提到了自由呢？微信我感觉就是不自由的，把大家圈进来之后就只能在这里面玩，决不允许有出去的机会。并且也没有意愿提供一个自由的环境。群里发一个链接，还需要先经过微信的审核，如果他们不想让你打开你就打不开，比如淘宝的链接就打不开。话说这个居然没有反垄断法来管理也是有意思。微博上面发的内容相对自由一点，但是微博的审查也比较厉害，当然这个是也有国家层面的事情，不多说了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Co. founders</title>
      <link>https://wdicc.com/co-founders/</link>
      <pubDate>Wed, 13 Feb 2019 18:14:39 +0800</pubDate>
      
      <guid>https://wdicc.com/co-founders/</guid>
      <description>&lt;p&gt;和别人一起搞了一个公司，算是一个技术合伙人。目前参与技术团队的组建，产品团队的组建等。目前公司运行了大概 2 年不到，稍微总结一下。&lt;/p&gt;

&lt;h2 id=&#34;需要什么样子的合伙人&#34;&gt;需要什么样子的合伙人&lt;/h2&gt;

&lt;p&gt;开公司前应该需要先弄清楚自己需要什么样子的合伙人。一般来说都会找一个和自己能力互补的，比如自己搞技术的，找一个产品或者运营方向比较强的。这样大家分工协作，以最少的资金发挥最大效力。&lt;/p&gt;

&lt;p&gt;但是这里其实有一个问题，怎么评价对方的能力。因为是补充自己不专业的部分，那自己一般并没有能力仔细考核对方的能力，怎么办？&lt;/p&gt;

&lt;p&gt;国外公司招聘技术人员，会倾向于考核算法等基础能力，即使你工作年头再长，也不看你做的系统业务有多牛逼，只看你的基础技术能力如何，对一些底层协议了解情况等等。为什么呢？&lt;/p&gt;

&lt;p&gt;我感觉因为我们做的事情事情通常有很大的不确定性，技术是为业务服务的，业务方向随市场情况走。技术这块来说，算法协议这些东西都是不变的，了解了原理，那不管是用什么语言，为什么业务服务，都可以随机应变，很快可以适应。&lt;/p&gt;

&lt;p&gt;类似的，我们找合伙人实际上也不应该只考虑对方看着目前刚好符合需求，而更多的应该去看看这个人的过往业绩，是否在你不擅长的领域做了很多让你值得给出好评的成绩，同时也需要注意，是他做出来的，还是依赖公司的品牌做的。&lt;/p&gt;

&lt;p&gt;另外也需要看看对方的团队组建能力，毕竟不可能单打独斗打天下，那必定会涉及到招聘，如果对方目前的团队战斗能力明显不行，那你也不要抱很大希望对方将来可以组建出来强大的团队。考核团队可能也简单，看看对方的团队的人都来自哪里，擅长做什么就好。&lt;/p&gt;

&lt;ol&gt;
总结下来似乎 2 点：
&lt;li&gt;过往的业绩，擅长的业务方向，擅长的工作方式。&lt;/li&gt;
&lt;li&gt;团队组建能力。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;需要有亲自动手的决心&#34;&gt;需要有亲自动手的决心&lt;/h2&gt;

&lt;p&gt;合伙开公司，公司是自己的，当然这个是基于一定的股份比例来的，可能至少超过 5% 吧，具体多少看你，简单说就是一个让你觉得这个公司我需要想尽办法让他维持下去的比例。如果你找合伙人，也至少应该给到合伙人让他觉得公司是他自己的这样一个比例的股份。&lt;/p&gt;

&lt;p&gt;公司是自己的，那就需要有亲自动手的决心。基于别人的成果，有时候很容易做出来一些让自己觉得自己牛逼的成绩。比如在一个大公司里面，做一个产品很容易就可以获得几十万的流量，或者做一个系统的时候，有很多公司资源可以使用，让你相对轻松的搭建一个复杂系统。如果离开公司，自己有没有兴趣和能力从头做这些事情呢？必须要有，因为你不做就没人做了。&lt;/p&gt;

&lt;p&gt;创业一般都是搞一个不太成熟的领域，这里面很多事情都需要去摸索，想要快速发展，必须要亲自动手才能快速得到反馈，快速知道自己是否应该调整方向适应市场。如果让其他人做，那经过反馈，指导，反馈，指导这样的多次循环可能才会发现是需要我们调整方向，而不是办事的人有问题。&lt;/p&gt;

&lt;h2 id=&#34;实事求是-合伙人之间公开信息&#34;&gt;实事求是，合伙人之间公开信息&lt;/h2&gt;

&lt;p&gt;合伙人之间信息共享，发挥集体的智慧。毕竟找合伙人的目的是为了补充自己的短处，那么就应该多利用合伙人的能力，以发挥最大的效力，合伙人之间应该公开所有信息，以便让大家清楚目前整个公司的目标和问题，能出力的多出力。&lt;/p&gt;

&lt;p&gt;一定避免遇事只是自己发愁，还有各种刻意遮掩的情况，多发挥集体智慧。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Resume</title>
      <link>https://wdicc.com/resume-en/</link>
      <pubDate>Tue, 12 Feb 2019 15:14:28 +0800</pubDate>
      
      <guid>https://wdicc.com/resume-en/</guid>
      <description>&lt;p&gt;Already has worked about two decades, worked in many jobs, like SRE, data analyst, DBA, AD delivery system developer, mobile APP and website developer.&lt;/p&gt;

&lt;h2 id=&#34;education&#34;&gt;Education&lt;/h2&gt;

&lt;p&gt;*BeiHang University(AKA Beijing University of Aeronautics and Astronautics or BUAA)*
Graduate in 2002, bachelor degree&lt;/p&gt;

&lt;h2 id=&#34;experience&#34;&gt;Experience&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;BrilliantAero.com (2017 - present)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Co. founder, tech and product leader. Have builtup the developer team and product team, developed our iOS, Android APP, and the website.&lt;/p&gt;

&lt;p&gt;The main developing languages I used are JavaScript, Python, and React Native related technology.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Qunar.com (2010 - 2016)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This is the company that I have stayed for the longest time. Mainly doing the following work.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Data analyst: Build up a team to analyse data for Vacation BU, including log collection, ETL, and displays.&lt;/li&gt;
&lt;li&gt;PostgreSQL DBA: Build up a team to operation and maintenance around one hundred or so PostgreSQL database servers and setup the monitor system for the servers.&lt;/li&gt;
&lt;li&gt;Advertise delivery system: Developed and maintained the CPM and CPC AD delivery system, which page view is about 1 billion per day before I leave.&lt;/li&gt;
&lt;li&gt;Mobile APP and website for Vacation BU: Developed and maintained the vacation section in Qunar APP and the mobile website.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These systems are not only developing by me, we use lots of the popular programming languages including Lua and Python.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Taobao.com (2009 - 2010)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Software engineer. Analyzing Data for linezing.com which collecting data/logs from taobao.com use Hadoop and Hive, and some developing work for the user website.&lt;/p&gt;

&lt;p&gt;The main developing languages I used are SQL, Java, Shell, HTML, JavaScript.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Yahoo China (2007 - 2009)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;SRE of data strategy BU, operation and maintenance about 100 servers. During that time, I developed a nagios plugin that can be centralized managed, so we can easily customize our monitoring.&lt;/p&gt;

&lt;p&gt;The main developing languages I used are PHP, Perl, Shell.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>简历</title>
      <link>https://wdicc.com/resume/</link>
      <pubDate>Tue, 12 Feb 2019 15:09:22 +0800</pubDate>
      
      <guid>https://wdicc.com/resume/</guid>
      <description>&lt;p&gt;已经算是大龄程序员了，做过很多岗位，整理总结一下自己的工作经历，可以时不时回来回顾一下，适合自恋。 English version &lt;a href=&#34;https://wdicc.com/resume-en/&#34; title=&#34;here&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;学历&#34;&gt;学历&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;北京航空航天大学&lt;/strong&gt; 2002 年 &lt;code&gt;本科&lt;/code&gt; 毕业，应用物理与应用电子技术专业&lt;/p&gt;

&lt;h2 id=&#34;工作经历&#34;&gt;工作经历&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;新晨航空（2017 - 现在）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;公司合伙人，技术和产品负责人。组建团队，做了 APP 和网站。&lt;/p&gt;

&lt;p&gt;主要开发语言是 JavaScript，React Native 相关技术，Python。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;去哪儿网（2010 - 2016）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这是工作时间最长的公司了。主要是以下几个方面的事情。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;数据工作：带领团队建立了度假部门的统计体系，包括日志收集分析入库展示等工作。&lt;/li&gt;
&lt;li&gt;PostgreSQL DBA 团队：带领团队维护公司几百个 pg 实例，建立了相应的监控体系。&lt;/li&gt;
&lt;li&gt;广告系统：带领团队负责了公司的 CPM 广告系统，之后还开发了度假部门的 CPC 广告系统。日 pv 达十亿。&lt;/li&gt;
&lt;li&gt;度假无线团队：开发维护去哪儿 APP 里面度假模块（iOS, Android），还有 HTML5 版本的度假客户端。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;主要开发语言比较多了，基本主流的都用了，包括 Lua，Python 等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;淘宝网（2009 - 2010）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;开发工程师。做了一些基于 Hadoop 和 Hive 的统计，以及量子统计的 Web 后台界面的开发。&lt;/p&gt;

&lt;p&gt;主要开发语言是 SQL, Java, Shell, HTML, JavaScript。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Yahoo 中国（2007 - 2009）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;战略数据平台部的 AppOPS 职位(类似 SRE)，负责大概 100 台机器的运维。期间开发了一个基于 Nagios 的中心配置的监控插件，方便实现个性化的监控需求。&lt;/p&gt;

&lt;p&gt;主要开发语言是 PHP，Perl，Shell。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Zero to $1B: 8 Lessons Scaling a Startup</title>
      <link>https://wdicc.com/8-lessons-scaling-a-startup/</link>
      <pubDate>Tue, 22 Jan 2019 18:25:37 +0800</pubDate>
      
      <guid>https://wdicc.com/8-lessons-scaling-a-startup/</guid>
      <description>&lt;p&gt;原文是这里 &lt;a href=&#34;https://medium.com/@swaaanson/zero-to-1b-8-lessons-scaling-a-startup-f9a4b631de61&#34; title=&#34;Zero to $1B: 8 Lessons Scaling a Startup&#34;&gt;Zero to $1B: 8 Lessons Scaling a Startup&lt;/a&gt;，这里只是部分翻译 + 我自己的理解。&lt;/p&gt;

&lt;h2 id=&#34;lesson-1-要谦虚的同时-保持自信&#34;&gt;Lesson #1: 要谦虚的同时，保持自信&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;要相信你是最牛逼的，可以搞定一切问题。&lt;/li&gt;
&lt;li&gt;也要够谦虚知道可能有不足，幼稚的地方，要听取别人的意见建议。&lt;/li&gt;
&lt;li&gt;也要谦逊的知道你自己的技能不一定适合公司的各个阶段，还需要不断提升自己的能力。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;lesson-2-可能会需要同时创立不止一个公司-可能是一系列公司&#34;&gt;Lesson #2: 可能会需要同时创立不止一个公司，可能是一系列公司&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;把你自己的领导能力看成是产品，多征求用户（也就是员工）的意见，严肃对待批评，但是不要当作是针对你自己的，对新的战略做做 A/B 测试。&lt;/li&gt;
&lt;li&gt;雇佣一个教练（？）。&lt;/li&gt;
&lt;li&gt;不管规模多大，每 6 个月给团队做一个 360 度的评测。&lt;/li&gt;
&lt;li&gt;[http://paulgraham.com/identity.html][Keep your identity small]] 这个意译似乎是说：不要给自己贴过多的标签，这会让你更陷入很多的无意义的争论。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;lesson-3-你的快乐和你创业公司的成功的关联性可能是-0-64&#34;&gt;Lesson #3: 你的快乐和你创业公司的成功的关联性可能是 0.64&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;经常锻炼身体，保证充足的睡眠，开始做做冥想。&lt;/li&gt;
&lt;li&gt;避免自娱自乐。比如某个月收益不错，就开始用这个推算我们未来三年怎么怎么样，某个月行情不行，就奔溃的不行。别着急想那么远，多看看眼前的事情吧。&lt;/li&gt;
&lt;li&gt;开始募集资金的是，根据市场反馈及早做调整。我们 A 轮的时候，被 42 次拒绝之后，我们进行了重组，更改了我们的要价，然后就找到了一家对我们有信心的投资。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;lesson-4-好的公司胜在产品创新和商业模式创新上&#34;&gt;Lesson #4: 好的公司胜在产品创新和商业模式创新上&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;获取客户的模式是商业模式的竞争。&lt;/li&gt;
&lt;li&gt;早期的创始人需要多花点时间想想商业模式创新和获取客户的策略。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;lesson-5-企业文化是用来帮助你成功的一个自我实现的故事&#34;&gt;Lesson #5: 企业文化是用来帮助你成功的一个自我实现的故事&lt;/h2&gt;

&lt;ol&gt;
如果要设计企业文化，那有几步参考
&lt;li&gt;确定你们这个行业里面成功的公司具备的特征是啥。比如共享单车企业（需要速度）和做医疗的企业（需要严谨）就不一样。&lt;/li&gt;
&lt;li&gt;确定什么样子的企业文化会带来那些特征。&lt;/li&gt;
&lt;li&gt;持续基于那些企业文化招聘和管理你的团队。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;lesson-6-有一个不合理的动机是有帮助的&#34;&gt;Lesson #6: 有一个不合理的动机是有帮助的&lt;/h2&gt;

&lt;p&gt;这里作者讲了一个自己的事情，他当年在选择去斯坦福商学院还是创业的时候，想问问斯坦福那边是不是可以晚几年去，对方说你创业啥时候都可以，斯坦福可就这么一个机会。不过作者后面还是去创业了，现在牛逼的时候说每年都会拿出了那个信看看，激励自己。。。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;有一个不合理的动机有时候不止有帮助，可能还是必须的。&lt;/li&gt;
&lt;li&gt;招聘的时候，也招聘这样有有自我实现需求的（with chips on shoulder)。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;lesson-7-创业成功的一个秘密方法是对厌倦的事情的极高的忍耐力&#34;&gt;Lesson #7: 创业成功的一个秘密方法是对厌倦的事情的极高的忍耐力&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;创业公司最值钱的工作往往是最不性感的那部分（最无聊的）。&lt;/li&gt;
&lt;li&gt;好好处理好它们。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;lesson-8-公司规模扩大也需要你自己能处理更多事情-早一点顾一个-ea-吧&#34;&gt;Lesson #8: 公司规模扩大也需要你自己能处理更多事情（早一点顾一个 EA 吧）&lt;/h2&gt;

&lt;p&gt;不少创业者都对长时间工作很自豪。那挺2的。你应该自豪的是你带来的巨大的杠杆作用（通常也会带来长时间工作）。当我每周工作 100 小时的时候，我并没有感觉的满足，我知道 1 可能是我没有委托足够的事情出去，或者 2 我没有合适的人来给我委托。&lt;/p&gt;

&lt;p&gt;这个说的没错，但是感觉是作者在给自己的一个公司做宣传。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The Year in Sound</title>
      <link>https://wdicc.com/the-year-in-sound/</link>
      <pubDate>Sun, 13 Jan 2019 13:07:44 +0800</pubDate>
      
      <guid>https://wdicc.com/the-year-in-sound/</guid>
      <description>&lt;p&gt;自从发现 &lt;a href=&#34;https://www.nytimes.com/column/the-daily&#34; title=&#34;NYTimes 的 The Daily&#34;&gt;NYTimes 的 The Daily&lt;/a&gt; 之后，听的比较多，2018 年底，他们有一期 &lt;a href=&#34;https://www.nytimes.com/2018/12/24/podcasts/the-daily/2018-year-in-sound.html&#34; title=&#34;The Year in Sound&#34;&gt;The Year in Sound&lt;/a&gt; 对 2018 年的一个总结，听的时候觉得可以总结一下里面的事件。&lt;/p&gt;

&lt;ol&gt;
&lt;li value=&#34;6&#34;&gt;月份 Trump 和三胖在新加坡会面。前后还来回磨叽了几次。三胖同意解除核装置。后面三胖和南韩总统在边界还一起握手。&lt;/li&gt;
&lt;li&gt;Robert Mueller 调查俄罗斯影响 2016 竞选。&lt;/li&gt;
&lt;li&gt;fb 爆出来用户数据被一家公司 Cambridge Analytica 拿去可能影响了竞选，并且似乎 fb 自己知道这个事情。Mark Zuckerberg 被叫去听证会询问。后面 Sundar Pichai 因为给中国定制搜索引擎的事情也被叫去过。&lt;/li&gt;
&lt;li value=&#34;2&#34;&gt;月 14 号 Florida high school 17 人死于&lt;a href=&#34;https://en.wikipedia.org/wiki/Stoneman_Douglas_High_School_shooting&#34; title=&#34;枪击案&#34;&gt;枪击案&lt;/a&gt;。学生对控枪的&lt;a href=&#34;https://edition.cnn.com/2018/02/17/us/florida-student-emma-gonzalez-speech/index.html&#34; title=&#34;抗议&#34;&gt;抗议&lt;/a&gt;。&lt;/li&gt;
&lt;li value=&#34;3&#34;&gt;月 4 号，居住在英国的前 Russian spy 和她女儿被人&lt;a href=&#34;https://www.bbc.com/news/uk-43315636&#34; title=&#34;下毒&#34;&gt;下毒&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;移民政策的变更，分开孩子和大人，起诉大人，导致很多人孩子后面找不到了。后面把这个政策取消了。&lt;/li&gt;
&lt;li&gt;Brett Kavanaugh 接替  Anthony Kennedy 成为大法官。Kavanaugh 还被一个博士爆出来说在高中时期（40年前）被试图性侵，开了听证会。&lt;/li&gt;
&lt;li&gt;Trump 的律师 Micheal Cohen 被 Trump 开掉，以及后面反过来和 Mueller 配合指证 Trump。&lt;/li&gt;
&lt;li&gt;Trump 和普京会面。&lt;/li&gt;
&lt;li&gt;California 大火。&lt;/li&gt;
&lt;li&gt;美国记者 Jamal Khashoggi 在沙特阿拉伯驻土耳其伊斯坦布尔的使馆里面被肢解。Trump 表示相信沙特王子不是他干的。&lt;/li&gt;
&lt;li&gt;中美贸易战。&lt;/li&gt;
&lt;li&gt;中期选举，民主党占了 house(似乎是众议院) 的多数。Nancy Pelosi 当选为 house 发言人。 Trump 年底嚷嚷要建墙要资金，议院不同意，直接把政府 shutdown 了，截至发稿还没谈妥。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;还有一些应该没记录，可能会有遗漏。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Iptv2</title>
      <link>https://wdicc.com/iptv2/</link>
      <pubDate>Thu, 10 Jan 2019 10:20:56 +0800</pubDate>
      
      <guid>https://wdicc.com/iptv2/</guid>
      <description>&lt;p&gt;之前写过&lt;a href=&#34;https://wdicc.com/BJ-Chinaunicom-iptv/&#34; title=&#34;一篇关于 iptv 的帖子&#34;&gt;一篇关于 iptv 的帖子&lt;/a&gt;，里面用到了一个副路由，这样我家里其实就有两个路由器，这样用了比较长一段时间。&lt;/p&gt;

&lt;p&gt;最近联通给换了一个光猫，很容易就可以 hack 进管理界面，就又折腾了一下 iptv 的事情。&lt;/p&gt;

&lt;p&gt;iptv 和上网通道都是通过一根光纤进来的，通过不同的 vlan 区分数据。vlan 是二层的，收到这些数据之后如果有必要，可以通过 vlan id 来过滤出来，比如有的光猫会提供把 iptv 流量过滤到 4 口，其他上网流量过滤到光猫的其他口。我之前的猫就这样设置的，看 iptv 只能连接光猫的 4 口。如果光猫允许设置，那可以把 iptv 流量打上 tag 继续发到比如 1 口，这样 1 口就又有上网流量，又有 iptv 流量了，下一级路由就可以只通过这一条线来收两个流量了。&lt;/p&gt;

&lt;p&gt;iptv 那个通道除了提供了组播数据（这个是具体的视频数据的来源）之外，还提供了一个只提供了必要的服务的互联网，比如提供了频道列表，各频道的节目表等等。&lt;/p&gt;

&lt;p&gt;有的光猫可能会提供 pppoe 拨号功能和 wifi，不过一般没人用，因为性能差。所以一般我们会配置光猫做桥接，把数据透传下来，让下一级来拨号和提供 wifi。&lt;/p&gt;

&lt;p&gt;（下面部分限于我自己的理解很有可能说错，欢迎指正）&lt;/p&gt;

&lt;p&gt;iptv vlan 我看也提供了路由功能，也可以桥接透传。比如我之前的方式就是使用了光猫提供的路由功能，接了一个路由器，以光猫为上级路由器，然后会获取到一个内网的 ip。然后二级路由器上通过 udpxy 提供服务给内网用户用。&lt;/p&gt;

&lt;p&gt;那这样的话，似乎可以直接在我的主路由上找一个网卡和光猫 iptv 口接起来，然后跑一个 dhcp 获取一下 ip 不就可以省掉副路由了么？ &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; &lt;del&gt;不过我在 R6300v2 上尝试没成功&lt;/del&gt; &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。在新的软路由里面搞成功了。这里面也不需要跑 igmpproxy，我理解实际用的是上级光猫发过来的数据。&lt;/p&gt;

&lt;p&gt;然后 igmpproxy 是怎么回事呢，我理解比如 iptv 是接到了路由器而不是光猫的时候，那么就需要路由器把光猫的那些数据转发下去，这个时候光猫需要通过桥接方式把数据给过来，然后需要把数据发到下级路由，这个时候还不能直接让这个数据在 lan 里面乱跑，否则会影响我们的网速，通过 igmpproxy 可以把上级光猫给过来的组播数据转发到某个端口，然后下级设备比如你把 iptv 接到这个端口，就可以通过那个端口获取这些 iptv 的组播数据了。这样 iptv 就不用接到光猫了，接到你的路由器就可以了。&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;对于 udpxy，有一个 status 页面，里面会显示一些信息，里面有一个 Multicast Address 很重要，必须是上级光猫给的 ip 才行，也就是上面讲的那个 ip，这样才能获取到数据。如果线路配置有问题，那这里的 ip 会显示 169.xx 或者 0.0.xx 啥的，那一般是不行的。&lt;/p&gt;

&lt;p&gt;&lt;del&gt;我目前也没明白一点，我之前在 R6300v2 里面设置的时候，和光猫还是一条线，然后通过 udpxy 就可以看，不知道是怎么做到的。&lt;/del&gt; &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;h1 id=&#34;footnotes&#34;&gt;Footnotes&lt;/h1&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;这个我在 openwrt 里面通过了，openwrt 比梅林灵活，我从猫接了两条线给路由器，一条用来 pppoe 上网，一条获取一个内部 ip 用来通过 udpxy 转发看 iptv。 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li id=&#34;fn:2&#34;&gt;又试了一下，梅林 rom 下，在内部网络 -&gt; iptv 配置里面，LAN 端口都选择无，使用 DHCP 路由选择 Microsoft（其他的没试过，按说应该都可以，只要不是无），UDP 代理选一个端口，IGMP 停用，这样就会启动一个 dhcp 客户端获取到一个内网的 ip，udpxy 会转发那个 ip 获取到的数据。这样实际是和我说的接两条线的方式是一样的。 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li id=&#34;fn:3&#34;&gt;这里就是那个梅林 rom 里面的 iptv 配置里面关于 LAN 端口和 igmp 的配置部分的用途了，需要告诉 rom 路由器的哪个 lan 端口接了 iptv，以及要启用 igmp 转发。这里说的 iptv 是指给我们的那个盒子，这么结之后就和把 iptv 盒子接到光猫是一样的，路由器会把盒子的请求都转发给光猫。这样实际那个 iptv 盒子完全不知道是通过路由器访问的。 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:3&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li id=&#34;fn:2&#34;&gt;又试了一下，梅林 rom 下，在内部网络 -&gt; iptv 配置里面，LAN 端口都选择无，使用 DHCP 路由选择 Microsoft（其他的没试过，按说应该都可以，只要不是无），UDP 代理选一个端口，IGMP 停用，这样就会启动一个 dhcp 客户端获取到一个内网的 ip，udpxy 会转发那个 ip 获取到的数据。这样实际是和我说的接两条线的方式是一样的。 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Amap Work With Code Push</title>
      <link>https://wdicc.com/amap-work-with-code-push/</link>
      <pubDate>Sat, 05 Jan 2019 09:53:09 +0800</pubDate>
      
      <guid>https://wdicc.com/amap-work-with-code-push/</guid>
      <description>&lt;p&gt;我们 app 用了高德地图和 codepush，iOS 里面之前用的高德地图 sdk 的 5.x 版本，最近想升级到最新的 6.6.0 发现和 codepush 出现了 symbol 的冲突，主要是两个函数 &lt;code&gt;aes_decrypt_key128&lt;/code&gt; 和 &lt;code&gt;aes_encrypt_key128&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;高德地图是不开源的，万幸我们有 codepush 的源码，所以思路是只需要把 codepush 里面冲突的函数改个名字就好了。&lt;/p&gt;

&lt;p&gt;改代码很简单，主要是怎么和项目集成。我用的是 &lt;a href=&#34;https://github.com/ds300/patch-package#readme&#34; title=&#34;patch-package&#34;&gt;patch-package&lt;/a&gt; ，做法如下。&lt;/p&gt;

&lt;p&gt;给 &lt;code&gt;package.json&lt;/code&gt; 的 scripts 增加一个 &lt;code&gt;postinstall&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt; &amp;quot;scripts&amp;quot;: {
  &amp;quot;postinstall&amp;quot;: &amp;quot;patch-package&amp;quot;
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后就是改 &lt;code&gt;node_modules/react-native-code-push&lt;/code&gt; 下面的文件，改完之后，执行一下 &lt;code&gt;yarn patch-package react-native-code-push&lt;/code&gt; 会生成一个类似 &lt;code&gt;patches/react-native-code-push+5.5.1.patch&lt;/code&gt; 的文件，确认一下这个文件里面是不是包含了你修改的内容。&lt;/p&gt;

&lt;p&gt;这就可以了，以后执行 &lt;code&gt;yarn install&lt;/code&gt; 的时候会自动打这个 patch。&lt;/p&gt;

&lt;p&gt;这个方式比 fork 一份对方的代码好一点，有时候有些代码发到 npm 的是编译之后的版本，fork 之后也不好用，除非你也发布一个。用 patch 的方式会好一点，安装的还是对方发布的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Android Packaging</title>
      <link>https://wdicc.com/android-packaging/</link>
      <pubDate>Sun, 02 Dec 2018 16:52:34 +0800</pubDate>
      
      <guid>https://wdicc.com/android-packaging/</guid>
      <description>&lt;p&gt;国内市场因为 android 的发布渠道比较多，所以一般我们会想要追踪一下用户使用的包是从哪里下载安装的。&lt;/p&gt;

&lt;p&gt;Android 打包支持 buildTypes ，一般这个会用来区分不同的环境，比如 dev，beta，prod 等，不同环境可能会有一些不同的设置，比如 dev 会打开更多的日志输出什么的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    android{
        buildTypes {
            debug {
                ...
            }
            release {
                ...
            }
            beta {
                ...
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有一个支持是 productFlavors，一般用这个来区分不同的渠道，不同渠道也可以有一些不同的设置，类似上面的 buildTypes。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    android {  
        productFlavors {
            xiaomi {}
            baidu {}
            wandoujia {}
            x360 {}
        }

        productFlavors.all {
            flavor -&amp;gt; flavor.manifestPlaceholders = [CHANNEL_ID: name]
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配合 &lt;code&gt;AndroidManifext.xml&lt;/code&gt; 文件的配置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   &amp;lt;meta-data android:name=&amp;quot;CHANNEL_ID&amp;quot; android:value=&amp;quot;${CHANNEL_ID}&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在代码里面取到这个，然后设置渠道。&lt;/p&gt;

&lt;p&gt;这样就可以打渠道包了 &lt;code&gt;./gradlew assembleWandoujiaRelease&lt;/code&gt; 编译 &lt;code&gt;wandoujia&lt;/code&gt; 这个渠道的 &lt;code&gt;releases&lt;/code&gt; 包。这个方式有一个问题是，每一个渠道包都需要从头编译一次，一个渠道 10 分钟，那所有渠道下来，就可能需要一个小时了，关键是很多无用功。&lt;/p&gt;

&lt;p&gt;受不了这个，然后发现了美团的思路。有一个民间的方案 https://github.com/GavinCT/AndroidMultiChannelBuildTool 。&lt;/p&gt;

&lt;p&gt;这个方案的主要思路是 apk 只编译一次，编译好之后，通过在 apk 里面增加不同名字的文件的方式来区分不同的渠道。app 运行的时候，读这个文件名字，然后设置对应的渠道。&lt;/p&gt;

&lt;p&gt;对于 v1 签名的 apk，在 META-INF 下面增加空文件不需要重新签名，所以只需要再次 zip 压缩就可以。&lt;/p&gt;

&lt;p&gt;对于 v2 签名的 apk，需要重新签名，可以使用 &lt;code&gt;apksigner&lt;/code&gt; 这个程序，这个是 android sdk 带的。我的 mac 系统路径是 &lt;code&gt;~/Library/Android/sdk/build-tools/*/apksigner&lt;/code&gt; ，因为会安装多个 build-tools 版本，所以会有多个，用哪个都可以。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    cmd = [apksigner, &amp;quot;sign&amp;quot;, &amp;quot;--ks&amp;quot;, &amp;quot;your_key_store_path&amp;quot;, &amp;quot;--ks-pass&amp;quot;, &amp;quot;pass:your_pass&amp;quot;, &amp;quot;--ks-key-alias&amp;quot;, &amp;quot;your_alias&amp;quot;, apk]
    check_call(cmd)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就可以了。&lt;/p&gt;

&lt;p&gt;我看美团似乎弄了一个新的版本 https://github.com/Meituan-Dianping/walle 看着挺复杂的，没研究过。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>A* Search Algorithm</title>
      <link>https://wdicc.com/a-star-search-algorithm/</link>
      <pubDate>Sat, 24 Nov 2018 14:48:04 +0800</pubDate>
      
      <guid>https://wdicc.com/a-star-search-algorithm/</guid>
      <description>&lt;p&gt;前段时间我们设想了一个需求，想帮助用户规划一下从 A -&gt; B 的航线。对于路径规划从来没弄过，研究了一下，基本都在提这个 &lt;a href=&#34;https://en.wikipedia.org/wiki/A*_search_algorithm&#34; title=&#34;A 星寻路算法&#34;&gt;A 星寻路算法&lt;/a&gt;。&lt;/p&gt;

&lt;ol&gt;
先贴几个文章：
&lt;li&gt;简单的讲解的文章例如 https://www.jianshu.com/p/65282bd32391&lt;/li&gt;
&lt;li&gt;这个详细一点的 https://blog.csdn.net/DinnerHowe/article/details/79380317&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我写了一个简单的程序，这个程序没有做过任何的优化，只能说是解释了这个算法的逻辑而已，在终端里面可以可视化的把计算过程显示出来。效果可以看&lt;a href=&#34;https://gist.github.com/wd/69469977bf76d9091ca01714eae08f37&#34; title=&#34;这里&#34;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/python
import sys
import random


RED = &#39;\033[31m&#39;
GREEN = &#39;\033[32m&#39;
GRAY = &#39;\033[35m&#39;
NC = &#39;\033[0m&#39;

class Point(object):
    x = 0
    y = 0
    close = False
    open = False
    start = False
    end = False
    wall = False
    H = 99
    G = 99
    parent = None

    def __init__(self, **kwargs):
        if &#39;x&#39; in kwargs:
            self.x = kwargs[&#39;x&#39;]

        if &#39;y&#39; in kwargs:
            self.y = kwargs[&#39;y&#39;]

        self.key = &#39;{}-{}&#39;.format(self.x, self.y)

    def __str__(self):
        return &#39;{},H{:2},G{:2},F{:2},P{:3}&#39;.format(
                self.key,
                self.H if self.H != 99 else &#39;&#39;,
                self.G if self.G != 99 else &#39;&#39;,
                self.G + self.H if self.G != 99 else &#39;&#39;,
                self.parent.key if self.parent else &#39;&#39;)

    def  __lt__(self, other):
        return self.x &amp;lt; other.x if self.y == other.y else self.y &amp;lt; other.y


def get_area(width, height):
    area = {}
    for i in range(width):
        for j in range(height):
            point = Point(x=i, y=j)

            area[point.key] = point
    return area

def show_result(area_hash):
    prev_y = -1

    for point in sorted(area_hash.values()):
        if ( prev_y != point.y ):
            if (prev_y != -1):
                print(&#39;&#39;)
            prev_y = point.y

        if point.start:
            format = RED + &#39;S&#39; + NC
        elif point.end:
            format = RED + &#39;E&#39; + NC
        elif point.wall:
            format = GRAY + &#39;W&#39; + NC
        elif point.close:
            format = GREEN + &#39;0&#39; + NC
        else:
            format = &#39; &#39;
        print((format + &#39;({})  &#39;).format(point), end=&#39;&#39;)
    print(&#39;&#39;)

def set_preset(area, start, end, wall):
    area[start].start = True
    area[end].end = True
    for key in wall:
        area[key].wall = True
    return area

def is_valid_point(point, width, height):
    if point.wall or point.close:
        return False

    if point.x &amp;lt; 0 or point.x &amp;gt; width:
        return False

    if point.y &amp;lt; 0 or point.y &amp;gt; height:
        return False

    return True

def get_around(area, point, width, height):
    n = &#39;{}-{}&#39;.format(point.x, point.y - 1)
    s = &#39;{}-{}&#39;.format(point.x, point.y + 1)
    l = &#39;{}-{}&#39;.format(point.x - 1, point.y)
    r = &#39;{}-{}&#39;.format(point.x + 1, point.y)

    res = {}
    for key in [n, s, l, r]:
        if key in area and is_valid_point(area[key], width, height):
            area[key].parent = point
            area[key].G = area[key].G if area[key].G != 99 else (point.G if point.G != 99 else 0) + 1
            res[key] = area[key]

    return res

def get_H(point, end_point):
    return abs(point.x - end_point.x) + abs(point.y - end_point.y)

step = 0
opened = {}

def go(area, start, end, width, height):
    global step, opened
    start_point = area[start]
    end_point= area[end]
    start_point.close = True

    if start_point.key in opened:
        del opened[start_point.key]

    points = get_around(area, start_point, width, height)
    opened.update(points)

    rnd = random.choice(list(opened))
    next_point = area[rnd]
    for key, point in opened.items():
        point.H = get_H(point, end_point)

        if point.H + point.G &amp;lt;= next_point.H + next_point.G:
            next_point = point

    print(&#39;step {}: {}&#39;.format(step, next_point))
    step += 1
    if step &amp;gt;= 3:
        pass

    if next_point and next_point.key != end:
        go(area, next_point.key, end, width, height)

def get_result(area, start, end):
    print(&#39;{}{}{} &amp;lt;- &#39;.format(RED, area[end].key, NC), end=&#39;&#39;)
    parent = area[end].parent
    if(parent.key != start):
        get_result(area, start, parent.key)
    else:
        print(&#39;{}{}{}&#39;.format(RED, area[start].key, NC), end=&#39;&#39;)

def main():
    width = 10
    height = 10
    start = &#39;1-3&#39;
    end = &#39;8-4&#39;
    wall = [&#39;2-2&#39;, &#39;3-2&#39;, &#39;3-3&#39;, &#39;3-4&#39;, &#39;3-5&#39;, &#39;3-6&#39;, &#39;5-4&#39;, &#39;2-6&#39;, &#39;1-6&#39;]

    area = get_area(width, height)
    area = set_preset(area, start, end, wall)
    go(area, start, end, width,  height)
    show_result(area)
    get_result(area, start, end)

if __name__ == &#39;__main__&#39;:
    main()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个算法通过调整 G 和 H 的计算逻辑，可以平衡寻路速度和路径是否最短。另外，对于 open 列表的维护，也可以使用一些适合自己的数据结构来得到比较快速的查找。上面第二个帖子里面比较详细的列了一些改进算法的思路。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Phpbb Auth Plugin</title>
      <link>https://wdicc.com/phpbb-auth-plugin/</link>
      <pubDate>Sat, 17 Nov 2018 21:15:50 +0800</pubDate>
      
      <guid>https://wdicc.com/phpbb-auth-plugin/</guid>
      <description>&lt;p&gt;这几天我们这里需要搞一个论坛，我搜了一些，选了 phpbb，这个毕竟年头比较久远，也支持 PostgreSQL。&lt;/p&gt;

&lt;p&gt;我们自己本身有自己的会员逻辑，所以就需要把他的登陆和我们自己的结合，而 phpbb 也支持自己作 &lt;a href=&#34;https://wiki.phpbb.com/Authentication_plugins&#34; title=&#34;Auth Plugin&#34;&gt;Auth Plugin&lt;/a&gt;。&lt;/p&gt;

&lt;ol&gt;
涉及到的文件有几个
&lt;li&gt;includes/auth/auth_foo.php：这个是具体的 auth 逻辑代码的地方。&lt;/li&gt;
&lt;li&gt;config/default/container/services_auth.yml：这个是注册这个 auth 逻辑的地方。&lt;/li&gt;
&lt;li&gt;template 模板文件：这个我没涉及到，所以没去了解。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;service 文件的配置：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;    auth.provider.skyreq:
        class: phpbb\auth\provider\foo
        arguments:
            - &#39;@dbal.conn&#39;
            - &#39;@config&#39;
            - &#39;@passwords.manager&#39;
            - &#39;@request&#39;
            - &#39;@user&#39;
            - &#39;@service_container&#39;
            - &#39;%core.root_path%&#39;
            - &#39;%core.php_ext%&#39;
        tags:
            - { name: auth.provider }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面配置里面 arguments 指定的，是 auth_foo.php 的 constructor 接受的参数。可以需要什么配置什么，个数要对应。&lt;/p&gt;

&lt;p&gt;配置这个之后，只需要在 &lt;code&gt;auth_foo.php&lt;/code&gt; 里面实现具体的逻辑就可以了。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;init_method&lt;/code&gt; 这个方法是在后台用户选中这个 auth 方法的时候执行的，比如你如果有一些配置的话就可以在这里验证。如果需要用户录入配置的话，还需要配合 template 文件，好提供录入的界面。我这里没有这个需求。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;login_method&lt;/code&gt; 这个方法是在用户登陆的时候会调用。会传入用户名和密码两个参数。实现逻辑可以参考 auth_db 这个模块。phpbb 为了安全，对于管理员用户会有一个二次验证的过程，管理员的 session 过期时间也会短一些。所以我们必须要实现这个，否则一个管理员就无法访问后台了。我这里是完全复制的 auth_db 的逻辑，里面改动了一点增加了一个硬编码只允许几个我指定的用户登陆。然后验证也完全用的 phpbb 的密码逻辑。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;autologin_method&lt;/code&gt; 这个方法是在用户 session 创建的时候通过外部逻辑实现验证的时候调用。自己实现认证主要是在这里实现。我的需求是通过 cookie 验证，如果用户不存在，会直接新建一个用户，如果已经存在，会直接用那个用户登陆。这样一个用户在我的系统的其它页面登陆之后，访问 phpbb 就会自动登陆了。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;logout_method&lt;/code&gt; 登出的逻辑。我这没有需求，不希望用户从论坛登出。所以留空就可以了。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;validate_session_method&lt;/code&gt; session 验证逻辑，这个是验证一个用户的 session 是否有效。如果无效会触发自动登陆。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Fear, trust and JavaScript: When types and functional programming fail</title>
      <link>https://wdicc.com/fear-trust-and-javascript/</link>
      <pubDate>Thu, 01 Nov 2018 12:56:20 +0800</pubDate>
      
      <guid>https://wdicc.com/fear-trust-and-javascript/</guid>
      <description>&lt;p&gt;翻译自 &lt;a href=&#34;https://www.reaktor.com/blog/fear-trust-and-javascript/&#34; title=&#34;Fear, trust and JavaScript: When types and functional programming fail&#34;&gt;Fear, trust and JavaScript: When types and functional programming fail&lt;/a&gt; , 最早是 &lt;a href=&#34;https://news.ycombinator.com/item?id=18314628&#34; title=&#34;hacker news&#34;&gt;hacker news&lt;/a&gt; 看到的。&lt;/p&gt;

&lt;p&gt;只是翻译大意。&lt;/p&gt;

&lt;p&gt;作为开发人员，我们需要减少对代码执行失败的恐惧，增强对代码的信心。很多 javascript 开发人员从函数式编程语言和强类型语言里面借鉴思路来将信任交给工具和代码来减少恐惧。类似可选类型，函数转换，和只读化这些思想可以帮助写出更好的 javascript 代码。当把这些想法都加入到 javascript 里面，会有一些妥协，协作起来比较差，并且最终会导致将信任从开发人员交给代码和工具的想法失败。&lt;/p&gt;

&lt;p&gt;举例来看看 javascript 里面是如何在两种观点下面处理数据的：理解数据的结构和修改数据。&lt;/p&gt;

&lt;h1 id=&#34;fear-and-the-shape-of-data&#34;&gt;Fear and the shape of data&lt;/h1&gt;

&lt;p&gt;在类似 javascript 的动态语言里面，很难知道你数据的结构。默认的方式是依赖公约(convention)。相信其它程序员和其它系统按照协议给你正确的数据。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;fetchUser(id).then( user =&amp;gt; {
 // Got my user!
})

// Later
render(user.name) // He has a name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我一般管这种方式叫「假装这是你要的」。在高可信的环境下，这个会工作的挺好。&lt;/p&gt;

&lt;p&gt;但是恐惧会悄悄的到来。代码的复杂度会增加。代码会是不同开发人员基于不同的公约(convention)开发的。你收到的数据来自于不可控的上游以及不稳定的格式。会开始看到空指针错误。对代码的信任会崩塌，对数据格式的疑问会引起焦虑而不是信任。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;这个数据里面到底有什么值？&lt;/li&gt;
&lt;li&gt;我可以删除里面的数据而不产生影响吗？&lt;/li&gt;
&lt;li&gt;我可以把这个数据传入这个函数吗？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例如下面这个。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;fetchUser(id).then( user =&amp;gt; {
 // Got my user!
 if(!user || !user.name) {
   throw new Error(&#39;wat&#39;)
 }
})

// Later
if(user &amp;amp;&amp;amp; user.name) {
  render(user.name)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是防御性编程(defensive programming)。在你不再信任你的代码会在适当的时候提供你期望的数据的时候会这么写。漂亮的代码会因为这些检查变得乱七八糟的，失去可读性，代码变得脆弱和很难改变。恐惧会增加，会越来越难相信代码会工作的很好。&lt;/p&gt;

&lt;h2 id=&#34;optional-types-pretend-really-hard&#34;&gt;Optional types: Pretend really hard&lt;/h2&gt;

&lt;p&gt;有一种消除恐惧的方法是通过 &lt;a href=&#34;https://www.typescriptlang.org/&#34; title=&#34;TypeScript&#34;&gt;TypeScript&lt;/a&gt; 或者 &lt;a href=&#34;https://flow.org/&#34; title=&#34;Flow&#34;&gt;Flow&lt;/a&gt; 引入可选的类型检查。接收到一个 user 之后，声明这是 User 类型，这以后只当作 User 类型用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;interface User{
  id: number
  name: string
  email?: string
}

fetchUser(id).then((user: User) =&amp;gt; {
 // Got my User!
})

// Later
render(user.name) // Compiler says he has a name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样假装其实挺难的。你把你的信任转移到其它地方了。你依然相信其它系统会给你正确的数据结构。在代码里面，你信任你给那个数据赋予的类型，在你使用不当的时候，编译器会报错。代替相信开发人员知道数据的结构并且正确的使用它，你信任开发人员会写出正确的类型，信任编译器不会对这些类型撒谎。&lt;/p&gt;

&lt;p&gt;增加类型设定并没有解决潜在的问题，它会提升数据在代码里面的一致性，但是对于外来数据没有任何限制。&lt;/p&gt;

&lt;h2 id=&#34;validation-trust-but-validate&#34;&gt;Validation: Trust but validate&lt;/h2&gt;

&lt;p&gt;在一个互相不太信任的环境里面，你或者需要在各种地方做数据校验。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;fetchUser(id).then(user =&amp;gt;{
  const validationErrors = validate(user)
  if (validationErrors) {
    throw new Error(&#39;wat&#39;)
  }
 // got my User!
})

// Later
render(user.name) //He has a name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以手动做这些，不过这些验证可能是临时的（应该是说不太通用），费力的，并且容易出错的。或者，你可以使用 &lt;a href=&#34;http://json-schema.org/&#34; title=&#34;JSON schema&#34;&gt;JSON schema&lt;/a&gt; 定义和 &lt;a href=&#34;https://github.com/epoberezkin/ajv&#34; title=&#34;ajv&#34;&gt;ajv&lt;/a&gt; 或者其它工具来验证数据是不是符合 schema 定义。这么做可以让其它用户复用，例如生成文档，但是这个似乎不那么明确也容易出错，因为你需要手动写这样的定义。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
  &amp;quot;title&amp;quot;: &amp;quot;user&amp;quot;,
  &amp;quot;type&amp;quot;: &amp;quot;object&amp;quot;,
  &amp;quot;properties&amp;quot;: {
    &amp;quot;id&amp;quot;: {
      &amp;quot;type&amp;quot;: &amp;quot;integer&amp;quot;
    },
    &amp;quot;name&amp;quot;: {
      &amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;
    },
    &amp;quot;age&amp;quot;: {
      &amp;quot;type&amp;quot;: &amp;quot;integer&amp;quot;
    }
  },
  &amp;quot;required&amp;quot;: [&amp;quot;id&amp;quot;, &amp;quot;name&amp;quot;]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;optional-types-validation&#34;&gt;Optional types + validation&lt;/h2&gt;

&lt;p&gt;或者你也可以同时使用类型检查和数据验证。类型检查减少内部对数据的恐惧，数据校验建立对外来数据的信任。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;interface User{
  id: number
  name: string
  email?: string
}

fetchUser(id).then((user: User) =&amp;gt;{
  const validationErrors = validate(user)
  if (validationErrors) {
    throw new Error(&#39;wat I trusted you&#39;)
  }
 // got my User!
})

// Later
render(user.name) //He has a name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了避免同时写两套类型定义给数据验证和类型检查，你可以使用 Typescript 和 Flow 或者使用类似 &lt;a href=&#34;https://github.com/pelotom/runtypes&#34; title=&#34;runtypes&#34;&gt;runtypes&lt;/a&gt;(TS), &lt;a href=&#34;https://github.com/seanhess/runtime-types&#34; title=&#34;runtime-types&#34;&gt;runtime-types&lt;/a&gt;(Flow) 或者 &lt;a href=&#34;https://github.com/YousefED/typescript-json-schema&#34; title=&#34;typescript-json-schema&#34;&gt;typescript-json-schema&lt;/a&gt;(TS) 这样的库。经过这几步之后，你可能开始信任你的数据了。但是这里还有更深的问题，等一会会说。&lt;/p&gt;

&lt;h1 id=&#34;fear-and-changing-data&#34;&gt;Fear and changing data&lt;/h1&gt;

&lt;p&gt;那么当改变数据的时候呢？默认情况下，javascript 里面的数据可以随意改变。举个例子，这个函数接收一个文档，然后改变了一个字段的格式，增加了一个字段。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function formatDocument(doc, source) {
  if(doc.creationDate) {
    doc.creationDate = convertTimeToUtc(doc.creationDate)
  } else {
    doc.creationDate = null
  }
  doc.source = source
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是在这种风格下，数据流就很难掌控了，恐惧会开始出现。如果我们的数据在很多地方都用了呢？数据在我这里是什么值？如何才能相信数据在此时此刻是我期望的？这个例子比较无聊，但是问题在大量代码或者同步系统里面会变得更严重。&lt;/p&gt;

&lt;p&gt;你想要依赖类型检查，但是这些类型定义也救不了你。在 typescript 和 flow 里面，下面的函数有相同的类型定义。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function formatDocument(doc: Document, source: String) {
  if(doc.creationDate) {
    doc.creationDate = convertTimeToUtc(doc.creationDate)
  } else {
    doc.creationDate = null
  }
  doc.source = source
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function formatDocument(doc: Document, source: String) {
  if(doc.creationDate) {
    doc.creationDate = convertTimeToUtc(doc.creationDate)
  } else {
    doc.creationDate = null
  }
  doc.source = source
  child_process.exec(&amp;quot;sudo rm -rf /&amp;quot;)
  launchRocket()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中一个是你想要的，另一个会把城市炸飞。类型检查对这些无能为力。&lt;/p&gt;

&lt;h2 id=&#34;convention-pretend-immutability&#34;&gt;Convention: Pretend immutability&lt;/h2&gt;

&lt;p&gt;为了写更好的代码，你们团队决定使用只读风格来写代码。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function formatDocument(doc: Document, source: String) {
  return {
    creationDate: sanitizeDate(doc.creationDate),
    source: source,
    text: doc.text
  }
  // Not mutating data
  // Not deleting root dir
  // Not launching rocket
}

function sanitizeDate(date) {
  return date ? convertTimeToUtc(date) : null
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你赞同使用 const 而不是 var，使用复制修改而不是直接修改。使用赋值来表示修改。开始使用三目运算符(ternary operator) 来代替 if 语句。函数返回新的值而不是修改。使用 map，filter，reduce 以及其它函数式的方法产生新的数据，而不是直接修改。&lt;/p&gt;

&lt;p&gt;不可改变的数据约定在 javascript 世界里面会带来便利，在 javascript 生态里面工作的挺好。但是这个严重依赖于开发人员的自律和互相信任。你相信开发人员会按照协议例如避免直接修改数据或者在数据发生改变的时候明确的指出来。你可能需要更健壮一点的东西。&lt;/p&gt;

&lt;h2 id=&#34;libraries-pretend-really-hard&#34;&gt;Libraries: Pretend really hard&lt;/h2&gt;

&lt;p&gt;你可以通过使用数据转换和只读数据结构的辅助工具来把对开发人员的信任转移到工具上。可选的有例如 &lt;a href=&#34;http://ramdajs.com/&#34; title=&#34;Ramda&#34;&gt;Ramda&lt;/a&gt;，&lt;a href=&#34;https://github.com/calmm-js/partial.lenses&#34; title=&#34;partial.lenses&#34;&gt;partial.lenses&lt;/a&gt;，&lt;a href=&#34;https://github.com/gcanti/monocle-ts&#34; title=&#34;monocle-ts&#34;&gt;monocle-ts&lt;/a&gt; 以及其它的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import * as R from &#39;ramda&#39;
function formatDocument(doc, source) {
  const creationDate = sanitizeDate(creationDate)
  // Return a new copy of the data
  return R.merge(doc, {creationDate, source})
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些工具的一个基本原则是把这些数据当作不可变的。但是 &lt;a href=&#34;http://ramdajs.com/0.14/docs/#assoc&#34; title=&#34;Ramda 也只是浅拷贝&#34;&gt;Ramda 也只是浅拷贝&lt;/a&gt;，不过如果对于不可变数据的约定足够，那大家还是可以假装它是。你可能会得到一点性能影响，但是你会得到对代码的信任。如果我们普遍使用这类工具以及这样的约定，会让这个工作的很好。&lt;/p&gt;

&lt;p&gt;强制使用只读数据结构又想避免性能影响，可以试试看 &lt;a href=&#34;https://github.com/facebook/immutable-js&#34; title=&#34;Immutable.js&#34;&gt;Immutable.js&lt;/a&gt;， &lt;a href=&#34;https://github.com/rtfeldman/seamless-immutable&#34; title=&#34;seamless-immutable&#34;&gt;seamless-immutable&lt;/a&gt; 或者 &lt;a href=&#34;http://swannodette.github.io/mori/&#34; title=&#34;Mori&#34;&gt;Mori&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import * as I from &#39;Immutablejs&#39;
function formatDocument(doc, source) {
  const creationDate = sanitizeDate(creationDate)
  // Cant&#39;t mutate doc
  return doc.merge({creationDate, source})
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这么做使得数据本身是不可变的，只能通过暴露出来的只读途径去使用数据。但是只会应用到这些数据内部的数据结构。大量的其它 javascript 代码依赖于 javascript 的原生数据结构，你得在这些数据类型间来回转换，对于原生的数据类型不再信任了。&lt;/p&gt;

&lt;p&gt;这些方法都有自己的局限性，但是大部分都和类型检查冲突。&lt;/p&gt;

&lt;h1 id=&#34;trusting-javascript&#34;&gt;Trusting JavaScript&lt;/h1&gt;

&lt;p&gt;前面的例子引入了一些可以写出更高效的 javascript 代码的工具：类型检查，函数式转换，不可变数据结构。但是这些工具都有自己的局限性，很难一起配合。&lt;/p&gt;

&lt;h2 id=&#34;optional-types-give-a-false-sense-of-security&#34;&gt;Optional types give a false sense of security&lt;/h2&gt;

&lt;p&gt;对于 javascript 来说，类型检查设计之初就是可选的，并不是所有东西都被定义了类型，你也没法相信所有东西都有类型。Flow 不可靠，而 &lt;a href=&#34;https://www.typescriptlang.org/docs/handbook/type-compatibility.html&#34; title=&#34;typescript 故意不可靠&#34;&gt;typescript 故意不可靠&lt;/a&gt;，这意味着有些情况下类型是错误的但是编译器会忽略。&lt;/p&gt;

&lt;p&gt;并且 javascript 的类型检查有时候会撒谎。javascript 有些东西很难或者说不可能通过 typescript 或者 flow 定义类型。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Higher order functions&lt;/li&gt;
&lt;li&gt;Ramda 的 &lt;a href=&#34;http://ramdajs.com/0.14/docs/#call&#34; title=&#34;call&#34;&gt;call&lt;/a&gt;, &lt;a href=&#34;http://ramdajs.com/0.14/docs/#compose&#34; title=&#34;compose&#34;&gt;compose&lt;/a&gt;, &lt;a href=&#34;http://ramdajs.com/0.14/docs/#chain&#34; title=&#34;chain&#34;&gt;chain&lt;/a&gt;, &lt;a href=&#34;http://ramdajs.com/0.14/docs/#lift&#34; title=&#34;lift&#34;&gt;lift&lt;/a&gt;, and &lt;a href=&#34;http://ramdajs.com/0.14/docs/#lens&#34; title=&#34;lenses&#34;&gt;lenses&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;partial.lenses 的 &lt;a href=&#34;https://github.com/calmm-js/partial.lenses/issues/55&#34; title=&#34;functions&#34;&gt;functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Dynamic functions&lt;/li&gt;
&lt;li&gt;Ramda 的 &lt;a href=&#34;http://ramdajs.com/0.14/docs/#invert&#34; title=&#34;invert&#34;&gt;invert&lt;/a&gt;, &lt;a href=&#34;http://ramdajs.com/0.14/docs/#dissoc&#34; title=&#34;dissoc&#34;&gt;dissoc&lt;/a&gt;, &lt;a href=&#34;http://ramdajs.com/0.14/docs/#mergeWith&#34; title=&#34;mergeWith&#34;&gt;mergeWith&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Immutable.js 的&lt;a href=&#34;https://github.com/facebook/immutable-js/blob/master/type-definitions/Immutable.d.ts&#34; title=&#34;几乎所有内容&#34;&gt;几乎所有内容&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Monkey-patched anything&lt;/li&gt;
&lt;li&gt;AWS SDK 客户端 &lt;a href=&#34;https://docs.aws.amazon.com/sdk-for-javascript/v2/developer-guide/using-promises.html#w2ab1c17c15c14c17&#34; title=&#34;promises&#34;&gt;promises&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Bluebird &lt;a href=&#34;http://bluebirdjs.com/docs/api/promisification.html&#34; title=&#34;promisified APIs&#34;&gt;promisified APIs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Highly dynamic data structures&lt;/li&gt;
&lt;li&gt;ElasticSearch &lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-get&#34; title=&#34;schemas&#34;&gt;schemas&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;winston &lt;a href=&#34;https://github.com/winstonjs/winston#creating-your-own-logger&#34; title=&#34;custom loggers&#34;&gt;custom loggers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;想要把这些的类型都痛够 typescript 或者 flow 定义出来，得牺牲下面的原则：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;牺牲类型安全，也就使用类型检查的主要原因：使用 any 来定义他们，不对他们进行类型检查。&lt;/li&gt;
&lt;li&gt;牺牲便利性：让这些方法不那么通用，以便可以定义更加准确的类型。&lt;/li&gt;
&lt;li&gt;牺牲其它开发人员的时间：让使用这些函数的人提供正确的类型，例如 &lt;code&gt;Ramda.pipe&amp;lt;User, Array&amp;lt;string&amp;gt;, string, int&amp;gt;(..)&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这样你开始混合使用这些工具，把他们的类型定义混合进来。这样把信任从工具的开发人员转移到了开发人员的类型定义上。这些库部分会包含 any 类型，调用这些方法会悄悄的失去对类型的检查。使用 Flow 的时候，如果一个文件没有 &lt;code&gt;@flow&lt;/code&gt; 注解，会默默的关闭类型检查。&lt;/p&gt;

&lt;p&gt;你可以通过广泛的使用类型检查来避免这个问题，不允许使用 any 类型，设置检查工具对没有做类型检查的文件报错，以及其它的一些严格的设置。&lt;/p&gt;

&lt;p&gt;但是这很像是在堵住一艘正在漏水的船的洞一样。问题不仅在于你不相信系统里面的类型，而是你认为可以。你依赖类型检查来告诉你修改有问题，但是因为有时候会使用 any 类型，或者使用某个库，或者某些问题导致类型检查被禁用，而并不会告诉你。JavaScript 里面的类型和其它语言里面的类型不一样：他们不能以相同的方式被信任。&lt;/p&gt;

&lt;p&gt;最终，类型检查的有效性依赖于使用的团队的知识和信念。如果团队有比较高的信念和知识，他们就可以给更高的信任到类型检查上。但这取决于团队维持这个信任的的注意力和纪律性，恐惧会从许多微妙的途径蔓延开。&lt;/p&gt;

&lt;h2 id=&#34;functional-programming-types-javascript-pick-two&#34;&gt;Functional programming. Types. JavaScript. Pick two&lt;/h2&gt;

&lt;p&gt;类型检查和基础的函数式编程方法例如 maps，filters，reducers 等可以在 javascript 里面用的还可以。但是当你想要更深入一点的时候就会遇到问题。两个例子：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/facebook/immutable-js&#34; title=&#34;Immutable.js&#34;&gt;Immutable.js&lt;/a&gt; 是一个给 javascript 用的持久的，只读数据结构类型。提供了常用的 javascript 数据结构，不依赖于就地修改数据。包括了内置的用于 &lt;a href=&#34;https://github.com/facebook/immutable-js/blob/master/type-definitions/Immutable.d.ts&#34; title=&#34;typescript&#34;&gt;typescript&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/facebook/immutable-js/blob/master/type-definitions/immutable.js.flow&#34; title=&#34;flow&#34;&gt;flow&lt;/a&gt; 的类型定义（可以点过去看看）。里面有数不清的 any 类型，禁用了对这些值的类型检查。这样依赖用户通过其它类型检查提供正确的类型的数据。基本上，你每次用这个库时，要么选择不使用类型检查，要不就需要额外的工作保证类型是正确的。这阻碍了函数式编程的使用。&lt;/p&gt;

&lt;p&gt;Ramda 是另一个给 jvascript 使用的函数式编程工具。一些类型定义可以在&lt;a href=&#34;https://github.com/types/npm-ramda#status&#34; title=&#34;这里&#34;&gt;这里&lt;/a&gt;找到，以及这个评论：&lt;/p&gt;

&lt;p&gt;“注意：很多 Ramda 里面的函数还不是很好定义类型，问题主要集中在偏函数应用(Partial Application)，柯里化(curring) 和 代码组合(composition) 上，尤其在表达通用类型上。是的，这些可能是你最初使用 Ramda 的原因，这些问题导致 Ramda 很难给 typescript 写类型定义。一些关于 TS 的链接在下面可以找到”&lt;/p&gt;

&lt;p&gt;尽管有像 &lt;a href=&#34;https://github.com/gcanti&#34; title=&#34;Giulio Canti&#34;&gt;Giulio Canti&lt;/a&gt; 这样令人印象深刻的工作，每次你选择高级一点的函数式编程概念的时候，例如不可变数据结构，函数组合，科里化，你基本上需要选择抛弃类型检查或者更多的代码来保证类型检查工作正常。这回阻碍函数式编程。&lt;/p&gt;

&lt;h2 id=&#34;why-we-can-t-have-nice-things-in-javascript&#34;&gt;Why we can’t have nice things in JavaScript&lt;/h2&gt;

&lt;p&gt;不可变数据结构在广泛被使用的时候工作的会挺好。但是 javascript 生态设计是基于可变数据结构的，&lt;a href=&#34;http://tagide.com/blog/research/constraints&#34; title=&#34;你不可能通过一个工具库来强制不可变&#34;&gt;你不可能通过一个工具库来强制不可变&lt;/a&gt;，javascript 的类型检查也不足以处理作为库工具使用的不可变数据结构。&lt;/p&gt;

&lt;p&gt;类型检查在被广泛使用的时候工作的挺好。但是 javascript 里面的类型检查在设计时就是可选的，为了兼容 javascript 做的一些妥协。&lt;/p&gt;

&lt;p&gt;类型检查，不可变数据结构，以及函数式编程都互相支持，就像他们在其它语言里面一样。类型检查可以用来加强不可变数据，即使内部的数据结构是可变的或者类型在运行时不存在。类型检查可以帮助开发人员可以在使用函数组合或者使用 lenses 转换数据的时候能更好对接。能知道支持类型的时候函数转换会更加简单一点。知道数据是不可变的时候，函数转换会更加有效。&lt;/p&gt;

&lt;h1 id=&#34;learning-to-code-with-fear&#34;&gt;Learning to code with fear&lt;/h1&gt;

&lt;p&gt;怎么伴随着恐惧编程？写更好的 javascript。一开始就假设对代码不信任，学习更多的技巧来编写功能化的 javascript 来避免琐碎的部分。有必要的话引入类型检查。使用不可变数据，不过只在有需要的时候或者想要强制约定的时候使用。只在有意义的时候使用类型检查，在功能性数据处理或者不可变类型可以提供更多好处的时候抛弃他们。当不使用类型检查的时候，多使用组合函数或者 lenses(透镜？) 。&lt;/p&gt;

&lt;p&gt;或者改变游戏使用 &lt;a href=&#34;http://www.purescript.org/&#34; title=&#34;Purescript&#34;&gt;Purescript&lt;/a&gt;。或者 &lt;a href=&#34;https://bucklescript.github.io/&#34; title=&#34;ReasonML&#34;&gt;ReasonML&lt;/a&gt;, &lt;a href=&#34;http://elm-lang.org/&#34; title=&#34;Elm&#34;&gt;Elm&lt;/a&gt;, 甚至 &lt;a href=&#34;https://clojurescript.org/&#34; title=&#34;ClojureScript&#34;&gt;ClojureScript&lt;/a&gt;。这些现在就可用。如果有需要，这些可以在 javascript 生态系统使用。这些从代码层面提供更高的信任，提供可以互相配合且工作的很好的不可变数据结构，函数式编程，以及类型系统。&lt;/p&gt;

&lt;p&gt;使用其中的任何一个语言都不能解决你的所有问题。这会引入他们自己的一下问题。但是可能会给你更高层面的对代码的信任，以及增加或者减少信任更好的工具。&lt;a href=&#34;https://www.reaktor.com/blog/fear-trust-and-purescript&#34; title=&#34;我的下一篇文章，会探讨下如何在 purescript 里面把这些思想结合起来。&#34;&gt;我的下一篇文章，会探讨下如何在 purescript 里面把这些思想结合起来。&lt;/a&gt;（这个是这个哥们的另一篇文章，标题叫 Fear, trust and PureScript: Building on trust with types and functional programming，力挺 PureScript）。&lt;/p&gt;

&lt;p&gt;但是在 javascript 里面，恐惧永远都伴随着你。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Typescript and Jest</title>
      <link>https://wdicc.com/typescript-and-jest/</link>
      <pubDate>Thu, 01 Nov 2018 11:59:29 +0800</pubDate>
      
      <guid>https://wdicc.com/typescript-and-jest/</guid>
      <description>&lt;p&gt;最近在折腾 typescript，把很多项目改成了 ts 的。有一个老项目，改的过程中感觉各种不踏实，打算还是先写点测试用例，就折腾了一下 jest。各种坑。。。&lt;/p&gt;

&lt;p&gt;首先需要加一个 &lt;code&gt;tsconfig.json&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
  &amp;quot;compilerOptions&amp;quot;: {
    &amp;quot;target&amp;quot;: &amp;quot;es2015&amp;quot;,
    &amp;quot;module&amp;quot;: &amp;quot;es2015&amp;quot;,
    &amp;quot;lib&amp;quot;: [
      &amp;quot;es2015&amp;quot;
    ],
    &amp;quot;outDir&amp;quot;: &amp;quot;./lib&amp;quot;,
    &amp;quot;declaration&amp;quot;: true,

    &amp;quot;noEmit&amp;quot;: true,
    &amp;quot;moduleResolution&amp;quot;: &amp;quot;node&amp;quot;,
    &amp;quot;esModuleInterop&amp;quot;: true,
    &amp;quot;allowSyntheticDefaultImports&amp;quot;: true,

    /* Strict Type-checking */
    &amp;quot;strict&amp;quot;: true,
    &amp;quot;strictNullChecks&amp;quot;: true,
    &amp;quot;noImplicitAny&amp;quot;: true,
    &amp;quot;noImplicitThis&amp;quot;: true,
    &amp;quot;alwaysStrict&amp;quot;: true,

    /* Additional Checks */
    &amp;quot;noUnusedLocals&amp;quot;: true,                /* Report errors on unused locals. */
    &amp;quot;noUnusedParameters&amp;quot;: true,            /* Report errors on unused parameters. */
    &amp;quot;noImplicitReturns&amp;quot;: true,             /* Report error when not all code paths in function return a value. */
    &amp;quot;noFallthroughCasesInSwitch&amp;quot;: true,    /* Report errors for fallthrough cases in switch statement. */
  },
  &amp;quot;include&amp;quot;: [
     &amp;quot;*.ts&amp;quot;
  ],
  &amp;quot;exclude&amp;quot;: [
    &amp;quot;node_modules&amp;quot;,
    &amp;quot;__tests__&amp;quot;
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后安装一个 &lt;code&gt;typescript&lt;/code&gt; 就可以通过 &lt;code&gt;yarn tsc&lt;/code&gt; 命令编译了，生成的 js 在 &lt;code&gt;lib&lt;/code&gt; 下面。&lt;/p&gt;

&lt;p&gt;测试如果是用 js 写，那么直接装 &lt;code&gt;jest&lt;/code&gt; 就可以了。但是我们既然项目都改成 ts 了，那么还是希望用 ts 写。那就需要用到 &lt;code&gt;ts-jest&lt;/code&gt; 。这货的配置可以写到 &lt;code&gt;package.json&lt;/code&gt; 里面。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
 &amp;quot;name&amp;quot;: &#39;test-projct&#39;,
 &amp;quot;version&amp;quot;: &amp;quot;0.0.1&amp;quot;,
 ........
 &amp;quot;jest&amp;quot;: {
    &amp;quot;preset&amp;quot;: &amp;quot;ts-jest&amp;quot;,
    &amp;quot;testEnvironment&amp;quot;: &amp;quot;node&amp;quot;,
    &amp;quot;testMatch&amp;quot;: [ &amp;quot;**/__tests__/*-test.ts&amp;quot; ],
    &amp;quot;globals&amp;quot;: {
      &amp;quot;ts-jest&amp;quot;: {
        &amp;quot;babelConfig&amp;quot;: true,
        &amp;quot;isolatedModules&amp;quot;: true
      }
    }
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;isolatedModules&lt;/code&gt; 表示说测试的时候先不做 type 检查。我这情况是，要改那些文件比较大一时都弄不好，可能 type 只改了部分，但是这个时候改到某个方法的时候，需要先加测试，以免改前改后不一致，所以这个时候只能忽略掉 type 检查了。&lt;/p&gt;

&lt;p&gt;这样配置之后，就可以用 ts 写 test 了。test 文件放到 &lt;code&gt;__tests__&lt;/code&gt; 目录里面，用 &lt;code&gt;*-test.ts&lt;/code&gt; 命名。这样这目录也可以放一些非测试用文件了，比如测试用例用到的一些 mock 文件之类。&lt;/p&gt;

&lt;p&gt;这样看着一切美好。直到我遇到了一个问题，我的那些需要测试的方法，有些是私有的，又不想因为这个改成 public 的，那么是不是有办法可以测试？这样就找到了 &lt;code&gt;rewire&lt;/code&gt; ，这个可以把你的模块的内容随意替换组合，方便你做 mock。我要做的也覆盖了。这样完美了。&lt;/p&gt;

&lt;p&gt;但是发现，rewire 不支持 typescript。在 ts 文件里面 rewire 一个模块之后，并没有多出来那些 &lt;code&gt;__get__&lt;/code&gt; 和 &lt;code&gt;__set__&lt;/code&gt; 方法。没仔细去研究代码，找到了 &lt;code&gt;babel-plugin-rewire&lt;/code&gt; ，给 &lt;code&gt;package.json&lt;/code&gt; 增加配置如下。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;  &amp;quot;babel&amp;quot;: {
    &amp;quot;presets&amp;quot;: [
      &amp;quot;env&amp;quot;
    ],
    &amp;quot;env&amp;quot;: {
      &amp;quot;test&amp;quot;: {
        &amp;quot;plugins&amp;quot;: [
          &amp;quot;babel-plugin-rewire&amp;quot;
        ]
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;发现还是不行，并没有什么效果。查了之后发现，是因为 ts-test 根本不会去调用 babel 的缘故，所以上面的那个 &lt;code&gt;babelConfig&lt;/code&gt; 就是这个用途，让 ts-test 去使用 babel。&lt;/p&gt;

&lt;p&gt;目前还有一个问题是怎么让这个 package 在别人安装使用的时候自动编译为 js，这样让 js 用户也可以用。尝试过在 &lt;code&gt;package.json&lt;/code&gt; 里面增加 build 发现不行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt; &amp;quot;scripts&amp;quot;: {
    &amp;quot;build&amp;quot;: &amp;quot;tsc&amp;quot;,
    &amp;quot;postinstall&amp;quot;: &amp;quot;[ -f ../../node_modules/.bin/tsc ] &amp;amp;&amp;amp; ../../node_modules/.bin/tsc || echo &#39;no typescript found, skip build&#39;&amp;quot;,
    &amp;quot;test&amp;quot;: &amp;quot;jest&amp;quot;
  },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装这个模块之后在 &lt;code&gt;./node_modules/test-module/&lt;/code&gt; 下面执行 &lt;code&gt;tsc&lt;/code&gt; 并不会产出 &lt;code&gt;lib&lt;/code&gt; 目录的编译文件。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Upgrade to React 16.3</title>
      <link>https://wdicc.com/upgrade-to-react-16.3/</link>
      <pubDate>Mon, 22 Oct 2018 16:21:30 +0800</pubDate>
      
      <guid>https://wdicc.com/upgrade-to-react-16.3/</guid>
      <description>&lt;p&gt;随着 React native 升级，React 也升级到了 16.5 了。原来的改成新的生命周期了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class ExampleComponent extends React.Component {
  static getDerivedStateFromProps(nextProps, prevState) {
    // Called after a component is instantiated or before it receives new props.
    // Return an object to update state in response to prop changes.
    // Return null to indicate no change to state.
  }

  UNSAFE_componentWillMount() {
    // New name for componentWillMount()
    // Indicates that this method can be unsafe for async rendering.
    // Prefer componentDidMount() instead.
  }

  UNSAFE_componentWillUpdate(nextProps, nextState) {
    // New name for componentWillUpdate()
    // Indicates that this method can be unsafe for async rendering.
    // Prefer componentDidUpdate() instead.
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    // New name for componentWillReceiveProps()
    // Indicates that this method can be unsafe for async rendering.
    // Prefer static getDerivedStateFromProps() instead.
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;React 在后面的版本里面，这几个方法都会被加上 &lt;code&gt;UNSAFE_&lt;/code&gt; ，直到被移除。&lt;/p&gt;

&lt;p&gt;我们在 &lt;code&gt;componentWillReceiveProps&lt;/code&gt; 里面主要是做了一个事情是根据后端反的数据来更新界面内容。因为我们用了 redux + saga，所以需要在这里做这个事情，如果是通过回调来更新数据的话，就不用这么麻烦了，直接在回调里面设置 state 就可以了。&lt;/p&gt;

&lt;p&gt;因为在 &lt;code&gt;getDerivedStateFromProps&lt;/code&gt; 里面不让接触现在的 &lt;code&gt;this.props&lt;/code&gt; ，所以也不能简单的把原来 &lt;code&gt;componentWillReceiveProps&lt;/code&gt; 的代码直接复制过来用。解决思路下面的链接都提到了很多，我自己总结有那几个。&lt;/p&gt;

&lt;h1 id=&#34;和-prevstate-做比较&#34;&gt;和 prevState 做比较&lt;/h1&gt;

&lt;p&gt;比如想象一个页面有两个按钮，一个点了之后会 setState 为 &lt;code&gt;test1&lt;/code&gt; ，另一个按钮点了之后，会通过网络请求更新 store，然后更新 props 为 &lt;code&gt;test2&lt;/code&gt; ，那这个时候只需要和当前的 state 做比较就可以决定是不是要设置新的 state 了。&lt;/p&gt;

&lt;h1 id=&#34;把-preprops-保存到-state-然后和-prevstate-做比较&#34;&gt;把 preProps 保存到 state 然后和 prevState 做比较&lt;/h1&gt;

&lt;p&gt;这么做基本就和原来使用 &lt;code&gt;componentWillReceiveProps&lt;/code&gt; 基本一样了。没什么好说的了。&lt;/p&gt;

&lt;h1 id=&#34;在-render-里面综合-state-和-props-的值&#34;&gt;在 render 里面综合 state 和 props 的值&lt;/h1&gt;

&lt;p&gt;比如有时候页面显示的是用户录入和 props 的数据综合的，那可以在 render 里面做这个合并的工作。&lt;/p&gt;

&lt;h1 id=&#34;参考链接&#34;&gt;参考链接&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/reactjs/rfcs/blob/master/text/0006-static-lifecycle-methods.md#common-problems&#34; title=&#34;React 关于新的生命周期的 rfc&#34;&gt;React 关于新的生命周期的 rfc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://reactjs.org/docs/react-component.html#unsafe_componentwillreceiveprops&#34; title=&#34;关于使用场景比较多升级的时候处理比较麻烦的 componentWillReceiveProps 方法&#34;&gt;关于使用场景比较多升级的时候处理比较麻烦的 componentWillReceiveProps 方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/reactjs/reactjs.org/issues/721&#34; title=&#34;关于 componentWillReceiveProps 方法和 getDerivedStateFromProps 的讨论&#34;&gt;关于 componentWillReceiveProps 方法和 getDerivedStateFromProps 的讨论&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/33925435&#34; title=&#34;关于新的生命周期国内人的中文解释&#34;&gt;关于新的生命周期国内人的中文解释&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/fi3ework/blog/issues/37&#34; title=&#34;另一篇国人的解释&#34;&gt;另一篇国人的解释&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html&#34; title=&#34;React 官方关于 getDerivedStateFromProps 使用的一些建议&#34;&gt;React 官方关于 getDerivedStateFromProps 使用的一些建议&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/reactjs/rfcs/pull/40&#34; title=&#34;关于为啥不在 getDerivedStateFromProps 里面加一个 prevProps 的讨论&#34;&gt;关于为啥不在 getDerivedStateFromProps 里面加一个 prevProps 的讨论&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Cleanup Your Disk Space</title>
      <link>https://wdicc.com/cleanup-your-disk-space/</link>
      <pubDate>Fri, 12 Oct 2018 12:26:47 +0800</pubDate>
      
      <guid>https://wdicc.com/cleanup-your-disk-space/</guid>
      <description>&lt;p&gt;200 多 G 的空间，说没就没。搞个开发真不容易。&lt;/p&gt;

&lt;p&gt;清理 yarn npm 开发的 cache，这些有需要的会再次下载&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yarn cache clean
npm cache clean
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;清理 gradle android 开发的 cache，这些有需要的话 android-studio 会在生成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rm -rf ~/.gradle/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;清理 xcode ios 开发的东西，这些清理掉了需要用的话 xcode 会再生成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rm -rf ~/Library/Developer/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;清理 brew 安装的软件的旧版本，这个执行之后 python 可能会不正常，执行一下 &lt;code&gt;pyenv rehash&lt;/code&gt; 之类的命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew cleanup
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>R.I.P Maomao</title>
      <link>https://wdicc.com/r.i.p-maomao/</link>
      <pubDate>Fri, 28 Sep 2018 10:33:30 +0800</pubDate>
      
      <guid>https://wdicc.com/r.i.p-maomao/</guid>
      <description>&lt;p&gt;毛毛应该是 2004 年上半年&lt;a href=&#34;https://wdicc.com/about-mao/&#34; title=&#34;我从一个人家里抱回来的&#34;&gt;我从一个人家里抱回来的&lt;/a&gt;，到现在 14 岁多一点。&lt;a href=&#34;https://wdicc.com/diabetic-cat-maomao/&#34; title=&#34;从 2013.12.29 发现得了糖尿病&#34;&gt;从 2013.12.29 发现得了糖尿病&lt;/a&gt;，到现在是 4 年多一点，等于是大概 10 岁左右的时候得的。&lt;/p&gt;

&lt;p&gt;前面 10 年是无忧无虑欢乐的 10 年，猫基本什么都不用管，只有刚开始第一次长假出去玩的时候，拜托过朋友给中间来看看。后面出去玩基本就把两只猫都扔家里了，给他们弄足够的水和吃的，最长出去玩的时间得有 10 天，回来猫只是会比较粘人，其它基本还好。&lt;/p&gt;

&lt;p&gt;自从毛毛病了之后，就和养了一个孩子一样，必须每天早晚 2 针胰岛素。参考上面的文章，通过自己学习，掌握了采血，通过稀释来配胰岛素等。所以开始还需要定期配好稀释好的胰岛素，一次大概配置 20 针左右，放到冰箱，然后每天 2 针，10 天左右就需要重新配置。配药的时候，需要注意量和不能有空气，每次和老婆就像吸毒人员一样，小心翼翼的配好。直到后面加了糖猫猫的群，发现了 bd 针，才开始不在自己稀释配药了。&lt;/p&gt;

&lt;p&gt;毛毛病了之后，我们基本就很难出远门了，因为必须要回来打针。所以出去几次远门都拜托朋友、cc 妈妈等过来给定期打针。直到今年，才开始尝试给带着猫回家，去了一趟我们家，一趟 cc 家，整体猫虽然很害怕，不过也还好，没出什么问题。&lt;/p&gt;

&lt;p&gt;这次本来打算带着他们去沈阳的，结果没想到毛毛出事了。都是我的问题，我知道猫可以活 10 到 20 年，我曾经无处次想过猫死的时候的情形，没想到昨天就这么来了。昨天一晚没有睡，我早上感觉浑身乏力，以为是饿的，去吃了早点才发现不是这个原因。下定决心给他安乐的是我，我可能太薄情了，看着他抽搐受不了。毛毛病了这几年，我们也还断断续续的去了很多次医院，也有几次病危，但是都挺过来了。&lt;/p&gt;

&lt;p&gt;糖尿病猫做无碳水疗法需要喂高蛋白的猫粮，我们家没有条件给妞妞和毛毛分开喂食，只能一起吃。前段时间妞妞身体也不舒服过一次，去医院做 b 超，说是他的有一个肾萎缩的很厉害，建议我们喂老年猫粮，少喂高蛋白的。我也很发愁怎么搞。我和老婆两个北漂，父母多不在这里不能帮忙。&lt;/p&gt;

&lt;p&gt;现在只剩妞妞一个了，打算还是带着他去沈阳，还有乌龟一起。要不一只猫在家估计很孤单也会有问题，妞妞是一个特别粘人的猫。妞妞比毛毛大一岁，今年 15 岁多一点，希望能健康活着。&lt;/p&gt;

&lt;p&gt;毛毛病了之后，我就发现经过了童年成年到中年，也到了要开始有生离死别的时候了。当你喜爱的人一个一个都离开你的时候，为了什么活着？我和老婆没有孩子，当父母都百年之后我真不知道我会不会去选择提前结束。快乐的前半生即将或者已经过去了，后面怎么面对？&lt;/p&gt;

&lt;p&gt;安息吧毛毛，我们爱你。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Typescript for React Native</title>
      <link>https://wdicc.com/typescript-for-react-native/</link>
      <pubDate>Sun, 16 Sep 2018 16:36:17 +0800</pubDate>
      
      <guid>https://wdicc.com/typescript-for-react-native/</guid>
      <description>&lt;p&gt;前几天研究 settimeout 的问题的时候，发现 &lt;a href=&#34;https://github.com/ocetnik/react-native-background-timer&#34; title=&#34;react-native-background-timer&#34;&gt;react-native-background-timer&lt;/a&gt; 自己没有 typescript 的 type 文件，但是有人给写了一个 &lt;a href=&#34;https://www.npmjs.com/package/@types/react-native-background-timer&#34; title=&#34;@types/react-native-background-timer&#34;&gt;@types/react-native-background-timer&lt;/a&gt;，这个包算偏门了，都有人写了 type 文件，我感觉是时候试试看 typescript 了。&lt;/p&gt;

&lt;p&gt;搜了一下，发现没有多少在 rn 里面使用 ts 的，有一些关于 react 的，又很奇怪，大都基于 webpack 的。后来找到一篇&lt;a href=&#34;https://facebook.github.io/react-native/blog/2018/05/07/using-typescript-with-react-native&#34; title=&#34;官方的 blog 上面的&#34;&gt;官方的 blog 上面的&lt;/a&gt;，然后结合自己的研究，找到了思路。我是基于已有项目来做的，那个 blog 是基于新项目，大同小异。&lt;/p&gt;

&lt;p&gt;首先装几个包，这几个包里面， &lt;code&gt;=typescript&lt;/code&gt; 提供 typescript 的编译器， &lt;code&gt;react-native-typescript-transformer&lt;/code&gt; 提供了从 ts 代码到 js 代码的转换支持， @types 的两个包提供了 react 和 react-native 的 type 文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ yarn add -D typescript react-native-typescript-transformer @types/react @types/react-native
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在项目的根目录还需要准几个文件。 tsconfig.json，你的目录里面可能已经有一个 &lt;code&gt;jsconfig.json&lt;/code&gt; 了，那个是给 eslint 用的。tsconfig.json 同时给 typescript 和 tslint 使用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
  &amp;quot;compilerOptions&amp;quot;: {
    &amp;quot;target&amp;quot;: &amp;quot;es2015&amp;quot;,
    &amp;quot;module&amp;quot;: &amp;quot;es2015&amp;quot;,
    &amp;quot;lib&amp;quot;: [
      &amp;quot;es2015&amp;quot;
    ],
    &amp;quot;jsx&amp;quot;: &amp;quot;react&amp;quot;,
    &amp;quot;noEmit&amp;quot;: true,
    &amp;quot;moduleResolution&amp;quot;: &amp;quot;node&amp;quot;,
    &amp;quot;strict&amp;quot;: true,
    &amp;quot;esModuleInterop&amp;quot;: true,
    &amp;quot;types&amp;quot;: [
       &amp;quot;react&amp;quot;,
       &amp;quot;react-native&amp;quot;
     ],
    &amp;quot;allowSyntheticDefaultImports&amp;quot;: true
  },
  &amp;quot;include&amp;quot;: [
     &amp;quot;./app/**/*&amp;quot;
  ],
  &amp;quot;exclude&amp;quot;: [
    &amp;quot;node_modules&amp;quot;
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里面的 include/exclude 按照需要调整，注意里面没有 output，我们并不需要 typescript 输出 js 文件。（当然，也可以用输出 js 文件的方式来做这个事情，但是这样就不太好自动化了，细节不说了）&lt;/p&gt;

&lt;p&gt;然后还需要一个 rn-cli.config.js，这个是给 &lt;code&gt;react-native-typescript-transformer&lt;/code&gt; 用的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;module.exports = {
  getTransformModulePath() {
    return require.resolve(&#39;react-native-typescript-transformer&#39;);
  },
  getSourceExts() {
    return [&#39;ts&#39;, &#39;tsx&#39;];
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后就可以写一些 &lt;code&gt;.ts&lt;/code&gt; 文件了。 &lt;code&gt;.ts&lt;/code&gt; 文件表示只有 js 代码， &lt;code&gt;.tsx&lt;/code&gt; 文件表示里面有 react 代码。写完之后可以执行一下 &lt;code&gt;yarn tsc&lt;/code&gt; 看看，是否有错误。没有错误的话，也可以在模拟器里面看看自己的 ts 代码是不是确实可以执行。&lt;/p&gt;

&lt;p&gt;你的代码可以在模拟器里面执行，主要是下面这段代码的作用。 &lt;code&gt;ts.transpileModule&lt;/code&gt; 会把 ts 代码转换成 js 代码，最终执行的是 js 代码。这里有一个需要注意的地方就是这里不管 ts 的语法错误，也就是你比如定义了一个 type 是 string 类型的变量，你给他做了 number 类型的赋值，这个在 js 里面是可以的，ts 是不允许的，但是这里并不会看到错误。执行 &lt;code&gt;yarn tsc&lt;/code&gt; 可以看到错误提示。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;module.exports.transform = function(src, filename, options) {
  if (typeof src === &#39;object&#39;) {
    // handle RN &amp;gt;= 0.46
    ;({ src, filename, options } = src)
  }

  if (filename.endsWith(&#39;.ts&#39;) || filename.endsWith(&#39;.tsx&#39;)) {
    const tsCompileResult = ts.transpileModule(src, {
      compilerOptions,
      fileName: filename,
      reportDiagnostics: true,
    })

    const errors = tsCompileResult.diagnostics.filter(
      ({ category }) =&amp;gt; category === ts.DiagnosticCategory.Error
    )
.....
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
所以保证代码符合 typescript 有下面几个方法：
&lt;li&gt;使用支持 typescript 的编辑器，依靠编辑器的提示。vs code 配合 tslint 可以做到这个。&lt;/li&gt;
&lt;li&gt;提交代码之前执行 &lt;code&gt;yarn tsc&lt;/code&gt; 验证代码没问题之后再提交。&lt;/li&gt;
&lt;li&gt;在 git 的 commit-hook 里面增加一个 hook 自动执行 &lt;code&gt;yarn tsc&lt;/code&gt; 检查。git 也可以在 server 端做这个检查。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了保证这个，我在 git 的 commit-hook 里面增加了一个 hook。放到 &lt;code&gt;.git/hooks/pre-commit&lt;/code&gt; 就可以。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/sh

has_ts_file=`git diff --cached --name-status | awk &#39;$1 != &amp;quot;D&amp;quot; { print $2 }&#39; | grep &#39;.ts$&#39; |wc -l`

exec 1&amp;gt;&amp;amp;2

if [ &amp;quot;$has_ts_file&amp;quot; -ge &#39;1&#39; ];then
    yarn tsc
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是 git 的 hooks 文件并不是 repo 的一部份，如何保证大家都是一样的配置呢？有一个 npm 包可以做这个事情。。 &lt;code&gt;yarn add -D pre-commit&lt;/code&gt; ，然后在 package.json 里面增加一些配置。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;    &amp;quot;scripts&amp;quot;: {
        &amp;quot;start&amp;quot;: &amp;quot;node node_modules/react-native/local-cli/cli.js start&amp;quot;,
        &amp;quot;test&amp;quot;: &amp;quot;jest&amp;quot;,
        &amp;quot;lint&amp;quot;: &amp;quot;node_modules/.bin/eslint app&amp;quot;,
        &amp;quot;version&amp;quot;: &amp;quot;./version-ios.sh&amp;quot;,
        &amp;quot;precommit&amp;quot;: &amp;quot;./pre-commit&amp;quot;
    },
    &amp;quot;pre-commit&amp;quot;: [
        &amp;quot;precommit&amp;quot;
    ],
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;scripts 里面的 precommit 和 pre-commit 是新加的。那个 pre-commit 就是上面的那个脚本，放到项目目录一起管理就可以。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Background Task in React Native</title>
      <link>https://wdicc.com/background-task-in-react-native/</link>
      <pubDate>Sat, 08 Sep 2018 16:06:18 +0800</pubDate>
      
      <guid>https://wdicc.com/background-task-in-react-native/</guid>
      <description>&lt;p&gt;react-native 支持 &lt;code&gt;setTimeout&lt;/code&gt; 和 &lt;code&gt;setInterval&lt;/code&gt; 这些 js 的方法来设置 timer 执行一些任务。但是对于长时间执行的任务，比如你想每 1 分钟都执行一下网络请求看看是不是有新的数据，这个时候会有一个黄条警告和你说不要这么做。&lt;/p&gt;

&lt;p&gt;我们有类似需求，就找到了 &lt;a href=&#34;https://github.com/ocetnik/react-native-background-timer&#34; title=&#34;react-native-background-timer&#34;&gt;react-native-background-timer&lt;/a&gt; 这个包。这个用起来和 js 的 setTimeout 的方法一样，可以一直运行。&lt;/p&gt;

&lt;p&gt;我们另外还使用了 websocket 来和服务器保持数据同步。这样就必须要保证有网络问题的时候，可以自动重连保证链接。我们找到了 &lt;a href=&#34;https://github.com/pladaria/reconnecting-websocket&#34; title=&#34;reconnecting-websocket&#34;&gt;reconnecting-websocket&lt;/a&gt; 这个包，他提供了自动重连功能。这个包是基于 js 写的，没有任何的 native 代码。我们用的过程中发现时不时会出现断开的情况，因为并不能稳定复现，我们一开始也没有太多时间研究这个问题，所以这个 bug 几乎是持续了几个月。另外，也主要是因为我们还有 pc 设备，也用了 websocket，但是那边表现就很稳定，所以基本可以确定是 android 的问题。&lt;/p&gt;

&lt;p&gt;我们试过自己手动断网，和手动重启服务器的方式断开 websocket，然后发现他都会重连。出现 bug 的时候，都是比如放了一个晚上，第二天来了之后，发现断开了。或者有时候似乎又不会断，总之是不很好的稳定可以复现。&lt;/p&gt;

&lt;p&gt;一开始怀疑是 android 进入省电模式之后，应用会出问题，把设备一直接着电源之后，似乎发现好像好了，但是实际上还是会出现断开的情况。后来给 app 增加了 &lt;code&gt;REQUEST_IGNORE_BATTERY_OPTIMIZATIONS&lt;/code&gt; 权限，试图解决，发现也不行。&lt;/p&gt;

&lt;p&gt;最近一个月总算有时间看看了，仔细研究了一下。给 app 增加了更多的 log，记录一下 websocket 的链接和断开的情况。发现一个情况，似乎整整 24h 的时候，会出现一个断开。断开之后有时候会连不上，有时候可以。因为是整整 24h，所以这个断开基本上可以肯定是 server 那边问题，但是断开不能重连依然是用户端这边的问题。&lt;/p&gt;

&lt;p&gt;后来我们找到了 24h 断开的原因，我们 websocket server 用的是 channel redis，&lt;a href=&#34;https://github.com/django/channels_redis/blob/master/channels_redis/core.py#L149&#34; title=&#34;里面默认是 24h 会断开&#34;&gt;里面默认是 24h 会断开&lt;/a&gt;。这个案子破了，定期倒是没问题，现在就是为啥不会重连的问题了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt; def __init__(
        self,
        hosts=None,
        prefix=&amp;quot;asgi:&amp;quot;,
        expiry=60,
        group_expiry=86400,
        capacity=100,
        channel_capacity=None,
        symmetric_encryption_keys=None,
    ):
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过分析 websocket 的日志，发现断开之后，执行重连的时候，reconnect-websocket 避免过度重连，会增加一个延时，调用 &lt;a href=&#34;https://github.com/pladaria/reconnecting-websocket/blob/master/reconnecting-websocket.ts#L326&#34; title=&#34;this._wait()&#34;&gt;this._wait()&lt;/a&gt;，问题就出在了这里，我们发现这个 promise 会卡住不能 resolve，这里面调用的就是 &lt;code&gt;setTimeout&lt;/code&gt; 。结合一开始说的，比较怀疑 rn 自己的 setTimeout 有问题，就试了一下使用 react-native-background-timer 来实现。改了之后运行了几天发现问题解决了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;    private _wait(): Promise&amp;lt;void&amp;gt; {
        return new Promise(resolve =&amp;gt; {
            setTimeout(resolve, this._getNextDelay());
        });
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;继续看看为啥 rn 自己的 timer 有问题。&lt;/p&gt;

&lt;p&gt;找到了 &lt;a href=&#34;https://github.com/facebook/react-native/blob/master/Libraries/Core/Timers/JSTimers.js&#34; title=&#34;JSTimers.js&#34;&gt;JSTimers.js&lt;/a&gt;，这里面通过调用 &lt;code&gt;Timing.createTimer&lt;/code&gt; 来创建 timer 的。Timing.createTimer 这个 native 模块的代码在&lt;a href=&#34;https://github.com/facebook/react-native/blob/master/ReactAndroid/src/main/java/com/facebook/react/modules/core/Timing.java#L324&#34; title=&#34;这里&#34;&gt;这里&lt;/a&gt;。这代码里面用到的包不熟悉，看了半天觉得看不明白，但是看到了这些。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;  @Override
  public void onHostPause() {
    isPaused.set(true);
    clearFrameCallback();
    maybeIdleCallback();
  }

  @Override
  public void onHostResume() {
    isPaused.set(false);
    // TODO(5195192) Investigate possible problems related to restarting all tasks at the same
    // moment
    setChoreographerCallback();
    maybeSetChoreographerIdleCallback();
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那个 &lt;code&gt;onHostPause&lt;/code&gt; 很可疑，我们知道 android 黑屏的时候，是会调用 app 的 onPause 的。继续找这个类实现了 &lt;a href=&#34;https://github.com/facebook/react-native/blob/master/ReactAndroid/src/main/java/com/facebook/react/bridge/LifecycleEventListener.java&#34; title=&#34;LifecycleEventListener&#34;&gt;LifecycleEventListener&lt;/a&gt; 这个接口，里面注释写和 active 切换有关系，实际就是和 onPause 这些 activity 的生命周期挂钩的。&lt;/p&gt;

&lt;p&gt;app 放到后台之后，会调用 onHostPause，然后 timer 就都不执行了，所以那个 promise 一直不能 resolve，然后 reconnect-websocket 就不会连接。&lt;/p&gt;

&lt;p&gt;RN 提供了 &lt;a href=&#34;https://facebook.github.io/react-native/docs/headless-js-android.html&#34; title=&#34;Headless JS&#34;&gt;Headless JS&lt;/a&gt; 来执行后台任务。我们就是改造了一下 reconnect-websocket 用 react-native-background-timer 就解决问题了。有需要可以用这个 https://github.com/wd/reconnecting-websocket 。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>React Native Deeplink</title>
      <link>https://wdicc.com/react-native-deeplink/</link>
      <pubDate>Mon, 03 Sep 2018 18:00:56 +0800</pubDate>
      
      <guid>https://wdicc.com/react-native-deeplink/</guid>
      <description>&lt;p&gt;App 一般都支持类似 &lt;code&gt;coolflight://list&lt;/code&gt; 这样的链接，可以直接打开 app 并打开列表，这个就是 deeplink。&lt;/p&gt;

&lt;p&gt;这个需要对 native 代码做一些修改，可以参考&lt;a href=&#34;https://reactnavigation.org/docs/en/deep-linking.html&#34; title=&#34;这里&#34;&gt;这里&lt;/a&gt;的修改，ios 和 android 都有写。这里有一个需要注意的是，对于 android 有一个配置是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;data android:scheme=&amp;quot;mychat&amp;quot; android:host=&amp;quot;mychat&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个里面配置 host 的话，后面使用的时候就需要类似 &lt;code&gt;mychat://mychat/list&lt;/code&gt; 这样的方式了，就是多了一层 mychat。这样也会导致 ios 和 android 的链接不统一，我查了&lt;a href=&#34;https://developer.android.com/training/app-links/deep-linking&#34; title=&#34;文档&#34;&gt;文档&lt;/a&gt;也没有查到没有设置 host 会有什么问题，我就去掉了，去掉之后，ios 和 android 的链接就统一了。都是 &lt;code&gt;mychat://list&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;另外 android 还有一个需要注意的地方是，activity 的 launchmod 需要设置为 &lt;code&gt;singleTask&lt;/code&gt; 要不会导致每次通过 deeplink 打开 app 都会新建一个，导致你有多个 js 在后台跑。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;activity
  android:name=&amp;quot;.MainActivity&amp;quot;
  android:launchMode=&amp;quot;singleTask&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 js 里面可以使用 &lt;code&gt;Linking.openURL(url).catch(err =&amp;gt; console.error(&#39;An error occurred&#39;, err))&lt;/code&gt; 打开一个 deeplink ，可以是别的 app 的，也可以是自己的。&lt;/p&gt;

&lt;p&gt;然后就是在 js 里面处理对应的 deeplink 了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;componentDidMount() {
  Linking.getInitialURL().then((url) =&amp;gt; {
    if (url) {
      console.log(&#39;Initial url is: &#39; + url);
    }
  }).catch(err =&amp;gt; console.error(&#39;An error occurred&#39;, err));

  Linking.addEventListener(&#39;url&#39;, this._handleOpenURL);
}

componentWillUnmount() {
  Linking.removeEventListener(&#39;url&#39;, this._handleOpenURL);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 &lt;code&gt;componentDidMount&lt;/code&gt; 里面，通过 &lt;code&gt;Linking.getInitialURL()&lt;/code&gt; 可以得到 app 冷启动的时候拿到的 link。通过 &lt;code&gt;Linking.addEventListener(&#39;url&#39;, callback)&lt;/code&gt; 可以拿到热启动 app 拿到的 link，分别处理或者统一处理都可以，看业务需求。&lt;/p&gt;

&lt;p&gt;我们用的是 React Navigation，他支持可以直接给 screen 设置 path，然后和 deeplink 匹配跳转。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const SimpleApp = createStackNavigator({
  Home: { screen: HomeScreen },
  Chat: {
    screen: ChatScreen,
    path: &#39;chat/:user&#39;,
  },
});


const prefix = &#39;mychat://&#39;; // 这里我们上面提到的统一了，所以不用区分 ios 和 android
const MainApp = () =&amp;gt; &amp;lt;SimpleApp uriPrefix={prefix} /&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样只需要定义一个 &lt;code&gt;uriPrefix&lt;/code&gt; 就可以了。&lt;/p&gt;

&lt;p&gt;我们为了把 navigation 和 redux 结合，自定义了 navigation 的 &lt;code&gt;navigation&lt;/code&gt; 属性，就不允许这么弄了。需要自己处理。&lt;/p&gt;

&lt;p&gt;主要思路是通过 &lt;code&gt;SimpleApp.router.getActionForPathAndParams(path, params)&lt;/code&gt; 得到 action，然后 dipatch 这个 action 就可以了。&lt;/p&gt;

&lt;p&gt;那个 &lt;code&gt;chat/:user&lt;/code&gt; 可以匹配到 &lt;code&gt;mychat://chat/Jim&lt;/code&gt; 这样的 deeplink，然后那个 &lt;code&gt;user: Jim&lt;/code&gt; 会以 param 的方式给到 screen，通过 param.user 可以访问到。&lt;/p&gt;

&lt;p&gt;path 的格式支持的是这个 &lt;a href=&#34;https://github.com/pillarjs/path-to-regexp&#34; title=&#34;path-to-regexp&#34;&gt;path-to-regexp&lt;/a&gt; 支持的格式，可以自定义表达式，具体可以参考那个文档。&lt;/p&gt;

&lt;p&gt;path 支持使用 &lt;code&gt;?&lt;/code&gt; 来表示一个字段是可选的，例如 &lt;code&gt;mychat://chat/:user?&lt;/code&gt; 表示会匹配到 &lt;code&gt;mychat://chat&lt;/code&gt; 和 &lt;code&gt;mychat://chat/Jim&lt;/code&gt; 。 &lt;code&gt;mychat://chat/:user?/:msg?&lt;/code&gt; 这样的，可以匹配 &lt;code&gt;mychat://chat&lt;/code&gt; &lt;code&gt;mychat://chat/Jim&lt;/code&gt; &lt;code&gt;mychat://chat/Jim/hey&lt;/code&gt; 但是不能匹配 &lt;code&gt;mychat://chat//hey&lt;/code&gt; 。默认匹配的是 &lt;code&gt;([^\\/]+)&lt;/code&gt; 可以通过自定义表达式支持。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;  path: &#39;chat/:user([^\\/]*)?/:msg?&#39;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>React Mobx</title>
      <link>https://wdicc.com/react-mobx/</link>
      <pubDate>Sun, 02 Sep 2018 19:18:16 +0800</pubDate>
      
      <guid>https://wdicc.com/react-mobx/</guid>
      <description>&lt;p&gt;我们之前用的是 redux 来做的统一 store，最近一个新项目有同学用了 mobx，就了解了一下，刚开始看的时候，感觉比 redux 好啊？&lt;/p&gt;

&lt;p&gt;mobx 的逻辑是自动收集 store 属性被哪些 dom 使用，然后在属性被改变的时候，自动更新 dom。这样的模式显然比 redux 的 action，reducer，selector 那一套简单多了。&lt;/p&gt;

&lt;p&gt;给对应的组件加上 &lt;code&gt;@observer&lt;/code&gt; 装饰器之后，store 改变就会自动重现渲染组件。store 可以用下面的模式给到组件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const store = new TodoList();
&amp;lt;TodoListView todoList={store} /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以用 &lt;code&gt;@inject&lt;/code&gt; 装饰器&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;@inject(store =&amp;gt; store)
@observer
class TodoListView {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后都通过 &lt;code&gt;this.props&lt;/code&gt; 引用。&lt;/p&gt;

&lt;p&gt;一切都很美好，直到我看到了&lt;a href=&#34;https://mobx.js.org/best/react.html&#34; title=&#34;这个&#34;&gt;这个&lt;/a&gt;，这里列了一些 mobx 的坑。比如有讲到，mobx 为了能监控到对 store 的依赖和修改，其实是把 store 属性做了修改，所以 store 有一个属性是一个 Map，那么实际得到的是一个和 ES6 Map api 类似的一个对象，但是并不是原生的 Map。比如有一个属性是 Object，你给加了一个 key，例如 store.object[&#39;a&#39;] = &#39;test&#39;，那么这个修改并不能被监视，具体看那个文档吧。&lt;/p&gt;

&lt;p&gt;写 Javascript 基本就是从一个小坑爬出来掉到一个大坑里面。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Android Custom</title>
      <link>https://wdicc.com/android-custom/</link>
      <pubDate>Sun, 02 Sep 2018 08:00:16 +0800</pubDate>
      
      <guid>https://wdicc.com/android-custom/</guid>
      <description>&lt;p&gt;我们给用户的设备，有 android pad 和 pc。pc 系统我之前基于 porteus 定制了一个，勉强可以用。apad 的系统一直没搞好。&lt;/p&gt;

&lt;p&gt;Android 系统必须要解锁之后才可以定制系统，否则没有 root 权限，system 分区的数据不能修改。&lt;/p&gt;

&lt;ul&gt;
Android 系统有四个重要的分区。
&lt;li&gt;&lt;code&gt;boot&lt;/code&gt; ，和 linux 的类似，里面有 kernel 和 ramdisk，ramdisk 应该是在启动之后会成为 / 分区&lt;/li&gt;
&lt;li&gt;&lt;code&gt;recovery&lt;/code&gt; ，恢复分区，如果想对系统分区做什么操作，可以使用这里的程序引导系统，这个时候允许你进行一些操作。默认的 recovery 只能 wipe 和刷系统。自定义的 recovery 比较厉害，可以支持备份啊啥的一堆事情，比如 twrp 还有图形界面。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;system&lt;/code&gt; ，系统分区，系统程序都在这里，包括系统自带的一些 app 等等。正常情况对这个分区是不能修改的，系统分区都是只读的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;data&lt;/code&gt; ，数据分区，这个分区是给用户使用的。用户安装的一下 app 以及一些数据都在这里。wipe 的时候就是会清空这个分区的数据。大家熟悉的 sdcard 那个分区，其实数据也是在这里的。data 分区里面 app 只能读取自己的数据，无法访问别的 app 的。但是放在 /sdcard 分区的数据，大家都可以访问（当然，还得有 sdcard 的权限）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;前三个分区都可以定制。首先需要解锁 bootloader，这个各个定制版都可能有区别，比如华为我记得还需要去他们网站获取一个解锁码，获取的时候会提示你解锁之后就不给保了。原生的 android 都是去开发者选项里面打开，然后在启动的时候进 bootloader，执行 &lt;code&gt;fastboot oem unlock-go&lt;/code&gt; 。解锁的时候会自动 reset 系统，注意先备份数据。&lt;/p&gt;

&lt;p&gt;解锁之后，就可以刷自己的 recovery 了。刷之前建议先备份一下 &lt;code&gt;boot&lt;/code&gt; &lt;code&gt;recovery&lt;/code&gt; &lt;code&gt;system&lt;/code&gt; 分区，以方便自己回头可以刷回来。我用的是 twrp，其它的好像现在也么看到。这个得找和你的手机匹配的才行。具体方法是执行 fastboot boot twrpxxxxx.img 临时使用 twrp 启动，然后用通过 &lt;code&gt;adb shell&lt;/code&gt; 登录 shell，之后用 &lt;code&gt;dd if=/dev/block/mmcblk0pXX of=/sdcard/xxx.img&lt;/code&gt; 来备份，之后用 &lt;code&gt;adb pull /sdcard/xxx.img&lt;/code&gt; 下载到本地。具体各个分区的那个 XX 是什么，可以用 &lt;code&gt;fdisk -l&lt;/code&gt; 看。&lt;/p&gt;

&lt;p&gt;这里有一个需要注意的是，我发现我这使用临时启动到 twrp 的方式还是不能修改 system 分区，必须是把 twrp 刷入 recovery 之后才可以。就是这个导致我一直没有搞好 apad 的系统，我开始一直是用临时启动到 recovery 的方式来做的，对 system 做修改就是死机。&lt;/p&gt;

&lt;p&gt;现在比较新的系统都有一个 dm-verify ，想修改 system 分区就需要关闭这个，否则任何修改都会导致系统不能启动。我在 &lt;a href=&#34;https://forum.xda-developers.com/android/software/universal-dm-verity-forceencrypt-t3817389&#34; title=&#34;xda 找到一个&#34;&gt;xda 找到一个&lt;/a&gt; 可以直接在 recovery 里面通过 sideload 刷就可以。&lt;/p&gt;

&lt;p&gt;关闭 dm-verify 之后就可以修改系统了。我还有一个需求是想系统启动之后，通过 iptables 对系统使用的网络做一些限制。想要在系统启动之后做一些事情，比较简单的就是修改 system 分区的那些 xxx.rc 加入自己的东西。我试了之后发现虽然程序可以执行，但是这种方式的程序，并不能直接操作 iptables 命令（执行不报错，但是无实际效果）。查了说大概是 kernel 级别的限制，这样难不成就去定制 kernel 了？&lt;/p&gt;

&lt;p&gt;Android 系统的 root 实际应该就是对系统 kernel 打了一个补丁，放了一个后门，允许通过 su 命令来获取 root 权限，这里获取的 root 权限可是货真价实的，可以执行 iptables 命令。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://forum.xda-developers.com/apps/magisk&#34; title=&#34;Magisk&#34;&gt;Magisk&lt;/a&gt; 可以给系统 root。recovery 里面通过 sideload 刷入之后，系统会多出来一个 app，有程序想用 su 的话，这个 app 会弹一个提示问是不是允许。magisk 应该是给 kernel 打了补丁，关闭了 dm-verify（所以用 magisk 的话，就可以不用上面那个了），然后启动的时候，会 mount 一个 su.img 提供 su 命令，会启动一个 su 的 daemon。这个可以通过看 ramdisk 里面的内容可以看到。magisk 还会在你的 /data 分区装一个 app，一起配合使用。但是要注意一点，我们 wipe 系统之后，这个 app 也会被删除。但是前面说的那些 su.img 之类都是在 boot 分区的，那些都还有，一个没有 app 配合的 su 也可以用，就是所有程序都直接使用，没有限制了。所以如果是你自己用，那最最好是和 boot 一起刷，或者就是自己安装一个 app。&lt;/p&gt;

&lt;p&gt;对于 system 的修改，拿到 root 权限就可以了。但是对于 boot 分区，只能拿到一个 boot.img，想要修改，还需要使用一些工具把里面的内容解出来，以及之后再打包。我找到一个&lt;a href=&#34;https://forum.xda-developers.com/showthread.php?t=2319018&#34; title=&#34;工具&#34;&gt;工具&lt;/a&gt; 。&lt;/p&gt;

&lt;p&gt;android 系统启动的时候会读取一些 xxx.rc，这些 rc 类似 linux 下面那些，但是不像 linux 那些都是脚本，是有一个自己的格式的内容。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;on property:sys.boot_completed=1
    start wd-post-boot

service wd-post-boot /system/bin/sh /wd.post_boot.sh
    class late_start
    user root
    disabled
    oneshot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比如我上面这个，定义了一个 service &lt;code&gt;wd-post-boot&lt;/code&gt; ，然后让他在 &lt;code&gt;sys.boot_completed&lt;/code&gt; 这个 prop 值为 1 的时候执行一次。还有很多其它的方法，可以找 android 的文档看，我说的不能执行 iptables 就是这里的脚本里面不能执行。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Boot Linux Through PXE</title>
      <link>https://wdicc.com/boot-linux-through-pxe/</link>
      <pubDate>Mon, 02 Jul 2018 16:47:31 +0800</pubDate>
      
      <guid>https://wdicc.com/boot-linux-through-pxe/</guid>
      <description>&lt;p&gt;测试 porteus 的时候，每次都是做好 iso 之后写到一个 u 盘，然后用 u 盘启动看看效果，发现有点蛋疼，这浪费时间不说，我的 u 盘寿命估计也得少一截。就研究了一下 pxe 启动，这样每次改完之后通过 pxe 直接读取我改了之后的 iso 引导 linux 就好了。&lt;/p&gt;

&lt;p&gt;我这看 pxe 启动主要需要做两个事情，一个是 dhcp 的时候广播 tftp 的信息，一个是通过 nfs 共享给那个系统需要读取的文件。nfs 共享也可以改用 http 等其他服务。&lt;/p&gt;

&lt;h2 id=&#34;dnsmasq&#34;&gt;dnsmasq&lt;/h2&gt;

&lt;p&gt;广播 tftp 的信息，可以通过 dnsmasq 来做。dhcp 部分就不贴了，只贴 tftp 相关的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tftp-root=/srv/pxe/boot
dhcp-boot=/pxelinux.0
enable-tftp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;网卡启动的时候会获取 &lt;code&gt;/pxelinux.0&lt;/code&gt; 然后获取 &lt;code&gt;/pxelinux.cfg/default&lt;/code&gt; （这个实际上有一个判断顺序，方便给不同的机器不同的配置）。然后根据这里面的配置，获取内核信息。然后加载内核。&lt;/p&gt;

&lt;h2 id=&#34;nfs&#34;&gt;nfs&lt;/h2&gt;

&lt;p&gt;加载内核之后还需要系统文件，这个时候貌似有几个选择，比如通过 http 发送。我这用的是 nfs。想要通过 nfs 发送，内核得能支持 nfs mount。各 linux 的做法貌似不太一样。&lt;/p&gt;

&lt;p&gt;配置 nfs 的目录，在 &lt;code&gt;/etc/exports&lt;/code&gt; 里面加入类似这样的信息。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/srv/pxe/porteus *(ro,fsid=0,no_subtree_check)
/srv/pxe/storage *(rw,fsid=1,no_root_squash,no_subtree_check)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后 &lt;code&gt;exportfs -rv&lt;/code&gt; ，这样 nfs 设置好了。&lt;/p&gt;

&lt;p&gt;我这 export 的目录和上面 tftp-root 的目录不一样，有的发行版可能会按照 tftp-root 的设置来读取，这个还得区分发行版看。&lt;/p&gt;

&lt;h2 id=&#34;其他&#34;&gt;其他&lt;/h2&gt;

&lt;p&gt;上面的例子只是写了一个大高，是实际使用相差很大。比如如何得到 &lt;code&gt;pxelinux.0&lt;/code&gt; ，如何让内核支持 nfs，以及在内核启动的时候加载 nfs 并使用 nfs 的数据启动，这些都和发行版有关系，还需要单看。&lt;/p&gt;

&lt;ul&gt;
参考
&lt;li&gt;&lt;a href=&#34;https://www.syslinux.org/wiki/index.php?title=PXELINUX&#34; title=&#34;PXELINUX&#34;&gt;PXELINUX&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Install Porteus to HD</title>
      <link>https://wdicc.com/install-porteus-to-hd/</link>
      <pubDate>Mon, 02 Jul 2018 16:23:54 +0800</pubDate>
      
      <guid>https://wdicc.com/install-porteus-to-hd/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://porteus.org/&#34; title=&#34;Porteus&#34;&gt;Porteus&lt;/a&gt; 是一个很好玩的系统，他基于 aufs 弄出来的一个「只读」系统，说是只读，实际上他也可以把修改保存到一个硬盘目录，然后启动的时候自动加载这些修改，这样就修改都还在。但是如果把这个目录删除，那么修改就都没有了，这就是所谓的只读。&lt;/p&gt;

&lt;p&gt;我开始的需求是需要搞一个 linux，然后给用户使用，并且希望用户只能用浏览器，不能使用其他东西，因为我们提供的服务就是一个网页。不能使用其他东西是为了避免使用的时候导致系统奔溃什么的，还得派人花时间去维护。然后看到有人推荐 &lt;a href=&#34;http://porteus-kiosk.org/index.html&#34; title=&#34;Kiosk&#34;&gt;Kiosk&lt;/a&gt;，看了一下感觉这个东西太完美了，就是我想要的东西。然后就开始研究这个系统。研究的过程中发现了他是基于 Porteus 的，就开始看 porteus。&lt;/p&gt;

&lt;p&gt;Kiosk 确实也不错，但是我使用的时候想要定制支持中文输入法，打印机等设备，然后发现他阉割加定制的太多了，导致我看了几天居然还没有找到他的入口在哪里，尝试想搞定输入法，费了很多劲。kiosk 使用的是 openbox + tint2 ，后面看了 porteus 之后，他支持 mate，kde 这些桌面，并且也直接就支持 scim，所以打算还是基于这个定制比较简单一点。&lt;/p&gt;

&lt;p&gt;具体定制就不多说了，主要是定制好 iso 之后，怎么安装到硬盘。&lt;/p&gt;

&lt;p&gt;其实也相当简单，只需要把 u 盘上面的内容复制到一个硬盘分区，然后安装一个 bootloader 就可以了。&lt;/p&gt;

&lt;p&gt;安装 bootloader 的时候由于对这个东西不是特别熟悉，以及这么多年不搞 linux 之后又出来很多新的概念，所以走了一些弯路，一番&lt;a href=&#34;https://wdicc.com/grub2-and-uefi/&#34; title=&#34;学习&#34;&gt;学习&lt;/a&gt;之后，发现简单的很。可以参考&lt;a href=&#34;https://wdicc.com/grub2-and-uefi/#grub&#34; title=&#34;这里&#34;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;然后就是需要弄一个 &lt;code&gt;grub.cfg&lt;/code&gt; 就可以了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set timeout=1
set superusers=root
password_pbkdf2 root grub.pbkdf2.sha512.10000.xxxxxxxx
password guest guest

if [ x&amp;quot;$default&amp;quot; = xsaved ];then
 load_env;
 set default=&amp;quot;$saved_entry&amp;quot;;
fi

insmod vbe
insmod efi_gop
insmod efi_uga

insmod font
insmod part_gpt

search --label --no-floppy --set kgzx KGZX
set prefix=($kgzx)/boot/grub

if loadfont $prefix/fonts/unicode.pf2
then
    insmod gfxterm
    set gfxmode=auto
    set gfxpayload=keep
    terminal_output gfxterm
    insmod png
    background_image $prefix/grub.png
fi

menuentry &#39;我的系统&#39; --unrestricted {
  set root=&amp;quot;($kgzx)&amp;quot;
  linux /boot/syslinux/vmlinuz changes=/mnt/sda4/
  initrd /boot/syslinux/initrd.xz
  boot
}

menuentry &#39;Cleanup&#39; --users &amp;quot;guest&amp;quot; {
  set root=&amp;quot;($kgzx)&amp;quot;
  linux   /boot/syslinux/vmlinuz 3 restore=1
  initrd /boot/syslinux/initrd.xz
  boot
}

menuentry &#39;Backup&#39; --users &amp;quot;root&amp;quot; {
  search --file --set root /efi/Microsoft/Boot/bootmgfw.efi
  chainloader /efi/Microsoft/Boot/bootmgfw.efi
  boot
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果只是使用 mbr 方式，也可以用 grub-legacy 也就是 0.97 那个版本，安装操作类似的，grub.cfg 不一样，那个是叫做 &lt;code&gt;menu.lst&lt;/code&gt; 。然后那个版本不支持 uefi boot 和中文菜单。好像也不支持菜单设置密码？没啥特别的建议还是 grub2 吧。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Compile Kernel Module</title>
      <link>https://wdicc.com/compile-kernel-module/</link>
      <pubDate>Mon, 02 Jul 2018 16:13:56 +0800</pubDate>
      
      <guid>https://wdicc.com/compile-kernel-module/</guid>
      <description>&lt;p&gt;使用 porteus 的时候，发现网卡不支持，找了一下发现有内核驱动可以用，那就需要编译一下内核的模块。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.porteus.org/component/content/article/20-tutorials/development/91-compilation-and-usage-of-custom-porteus-kernel.html&#34; title=&#34;这里&#34;&gt;这里&lt;/a&gt;有一个帖子写了如何编译内核，主要步骤是先给内核打 aufs 的补丁，然后就是正常的 make config &amp;&amp; make &amp;&amp; make modules_install 了。&lt;/p&gt;

&lt;p&gt;我这只是编译一个网卡驱动，操作步骤大概如下，把内核解压放到 /mnt/sda1/kernel 下面，然后把网卡驱动代码放到 /mnt/sda1/kernel/linux-4.16.3/drivers/net/wireless/rtl8821ce 下面。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# cd /mnt/sda1/kernel/linux-4.16.3/
# modprobe configs &amp;amp;&amp;amp; zcat /proc/config.gz &amp;gt; .config
# make oldconfig
# make prepare
# make modules_prepare
# export srctree=/mnt/sda1/kernel/linux-4.16.3
# ln -s /mnt/sda1/kernel/linux-4.16.3 /usr/src/linux
# cd drivers/net/wireless/rtl8821ce
# make
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在这个目录下面会产生一个 rtl8821ce.ko 的文件。&lt;/p&gt;

&lt;p&gt;如果是遇到自己用的内核有一个模块没编译，那可以用下面的方式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# after make modules_prepare
# make modules SUBDIRS=drivers/firmware/efi/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样会在 drivers/firmware/efi/ 目录下面产生一个 xx.ko 之类的文件。&lt;/p&gt;

&lt;p&gt;把上面产生的 ko 文件放到你的 linux 的对应目录就可以使用 modprob 加载了，例如 &lt;code&gt;/lib/modules/4.16.3-porteus/kernel/drivers/net/wireless/8821ce.ko&lt;/code&gt; 。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Geodesy</title>
      <link>https://wdicc.com/geodesy/</link>
      <pubDate>Sun, 01 Jul 2018 08:10:05 +0800</pubDate>
      
      <guid>https://wdicc.com/geodesy/</guid>
      <description>&lt;p&gt;坐标点之间的距离角度计算不能简单的用平面几何来算，得按照球面计算，PostgreSQL 提供了 gis 数据的计算支持，各种图形关系判断，距离计算等等。但是我们有时候也需要在 js 里面计算，开始的时候尝试自己按照公式写来着，写了一些发现太蛋疼了，因为只是单纯的看公式，缺少空间概念，算的对不对啥的都不知道。后来发现了这个 &lt;a href=&#34;https://github.com/chrisveness/geodesy&#34; title=&#34;js 库&#34;&gt;js 库&lt;/a&gt;，简直太贴心了。&lt;/p&gt;

&lt;ol&gt;
提供了我用过的几个功能
&lt;li&gt;度数表示转换，小数点形式到度分秒形式的互转。在 utm.js 里面。&lt;/li&gt;
&lt;li&gt;计算线的真北角。point1.bearingTo(point2)，真北角计算是和线的方向有关系的。&lt;/li&gt;
&lt;li&gt;和当前点夹角是 x，距离是 y 的点，point1.destinationPoint(y, x)。&lt;/li&gt;
&lt;li&gt;两点之间的距离，point1.distanceTo(point2)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;然后顺便记录一些东西。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 两条线的夹角的一半，普通角度
let angle = (360 + 180 + bearing1 - bearing2) % 360 // 360 保证只有正的
let halfAngle = angle &amp;gt; 180 ? (360 - angle)/2 : angle/2 // 只要锐角

// 计算两条线夹角中线的真北角
// left,right bearing 需要是真北角
let rightBearing = 90 + (bearing1 + bearing2)/2
let leftBearing = 180 + rightBearing

// Math.sin 之类的方法使用的应该是小数形式的度数表示
let angleToDecimal = halfAngle*Math.PI/180
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>UEFI Bootable Usb</title>
      <link>https://wdicc.com/uefi-bootable-usb/</link>
      <pubDate>Sat, 30 Jun 2018 07:30:58 +0800</pubDate>
      
      <guid>https://wdicc.com/uefi-bootable-usb/</guid>
      <description>&lt;h1 id=&#34;uefi-shell&#34;&gt;UEFI shell&lt;/h1&gt;

&lt;p&gt;UEFI firmware 应该会读取设备里面的分区，找到 ESP 然后再读里面的内容。我看到最简单的方式是把 u 盘格式化成 fat 然后建一个目录 &lt;code&gt;/boot/efi&lt;/code&gt; 然后下载一个 &lt;a href=&#34;https://wiki.archlinux.org/index.php/Unified_Extensible_Firmware_Interface#UEFI_Shell&#34; title=&#34;uefi shell&#34;&gt;uefi shell&lt;/a&gt; 把 .efi 文件放到这个目录 &lt;code&gt;/boot/efi/shellx64.efi&lt;/code&gt; ，然后启动的时候就多了一个 uefi 菜单了，选择之后可以进入一个 uefi shell。&lt;/p&gt;

&lt;p&gt;uefi shell 里面有几个命令可以用。&lt;/p&gt;

&lt;h2 id=&#34;map&#34;&gt;map&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;map&lt;/code&gt; 可以列出来当前机器的磁盘情况，找到你的 esp 分区。&lt;/p&gt;

&lt;h2 id=&#34;ls&#34;&gt;ls&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;ls&lt;/code&gt; 可以列出来磁盘目录里面的内容，比如 &lt;code&gt;ls fs0:\boot&lt;/code&gt; ，注意磁盘和目录之间用 &lt;code&gt;:&lt;/code&gt; ，目录层级之间用 &lt;code&gt;\&lt;/code&gt; 。&lt;/p&gt;

&lt;h2 id=&#34;bcfg&#34;&gt;bcfg&lt;/h2&gt;

&lt;p&gt;可以通过 &lt;code&gt;bcfg boot dump -v&lt;/code&gt; 列出来当前所有的 efi 菜单，注意每个项目都有一个序号，后面会用到。&lt;/p&gt;

&lt;p&gt;比如我想自己加一个菜单进去，那就找到最后那个的序号，然后执行 &lt;code&gt;bcfg add 8 fs0:\boot\grub\grubx64.efi GRUB&lt;/code&gt; (fat 系统不区分大小写)，指向我自己通过 &lt;code&gt;grub-install --efi-directory=/mnt/sda1/&lt;/code&gt; 放到 esp 分区的 grub 的 efi ，这样启动的时候就多了一个 GRUB 的选项，通过这个选项就可以进入 linux，然后使用更方便的 efibootmgr 来编辑这个菜单了。&lt;/p&gt;

&lt;ul&gt;
参考:
&lt;li&gt;&lt;a href=&#34;https://wiki.archlinux.org/index.php/EFISTUB#UEFI_Shell&#34; title=&#34;UEFI Shell&#34;&gt;UEFI Shell&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;自己制作-iso&#34;&gt;自己制作 iso&lt;/h1&gt;

&lt;p&gt;通过 &lt;a href=&#34;https://www.syslinux.org/wiki/index.php?title=Isohybrid#UEFI&#34; title=&#34;isohybrid&#34;&gt;isohybrid&lt;/a&gt; 可以把一个 iso 做成支持 uefi 的格式，然后通过 dd 写入 u 盘之后，这个 u 盘就支持 uefi 启动了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkisofs \
 -o output.iso \
 -c boot/syslinux/isolinux.boot \
 -b boot/syslinux/isolinux.bin \
  -no-emul-boot -boot-load-size 4 -boot-info-table \
 -eltorito-alt-boot \
 -eltorito-platform 0xEF -eltorito-boot isolinux/efiboot.img \
  -no-emul-boot \
 CD_ROOT
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;efiboot.img 实际是一个 iso 格式的磁盘 img，可以通过下面的方式产生&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ dd if=/dev/zero of=./efiboot.img bs=1M count=4
$ mount efiboot.img ./mnt
$ cp -r EFI /mnt
$ umount /mnt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;EFI/boot 目录是 efi 启动你自己定义的内容，然后执行 &lt;code&gt;isohybrid --uefi output.iso&lt;/code&gt; 。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Grub2 and UEFI</title>
      <link>https://wdicc.com/grub2-and-uefi/</link>
      <pubDate>Fri, 29 Jun 2018 20:03:54 +0800</pubDate>
      
      <guid>https://wdicc.com/grub2-and-uefi/</guid>
      <description>&lt;p&gt;这几天搞 Linux 又学习了一些新的东西。&lt;/p&gt;

&lt;p&gt;以前都是把 grub 装到 MBR，然后通过 grub 可以 chainloader 启动 windows。现在发现我装了之后并不能启动我的 windows 10 了，就只好研究了一下。&lt;/p&gt;

&lt;h2 id=&#34;gpt-分区&#34;&gt;GPT 分区&lt;/h2&gt;

&lt;p&gt;以前都是 MBR(Master Boot Record) 形式的分区，主分区 4 个，如果想要建更多，需要建扩展分区，然后再在扩展分区里面建立逻辑分区。现在发现有了 GPT(GUID Partition Table) 分区。这个方式呢，比 MBR 方式有好处，支持更多分区，支持大于 2.2TB 容量的磁盘。&lt;/p&gt;

&lt;p&gt;我看我的 windows 10 机器预装就是用的这个分区格式。&lt;/p&gt;

&lt;h2 id=&#34;uefi-系统&#34;&gt;UEFI 系统&lt;/h2&gt;

&lt;p&gt;UEFI(Unified Extensible Firmware Interface) 是基于 BIOS 的 MBR 启动方式不同的东西，是基于单独的 EFI System Partition(ESP) 里面的数据启动的。里面的程序都需要和 UEFI firmware 的 bitness 一致，x86_64 啥的。&lt;/p&gt;

&lt;p&gt;所以我的 windows 10 在 ESP 分区里面已经放了一个自己的起动器。Linux 启动之后，可以查看 &lt;code&gt;/sys/firmware/efi&lt;/code&gt; 看看是不是有，有的话表示 kernel 支持 efi，且和 firmware 的 bitness 一致。&lt;/p&gt;

&lt;p&gt;ESP 分区是 fat16/fat32 格式的，不像 mbr 在固定位置，到底是哪个分区是呢？是通过通过分区的 boot flag 这个标志来识别的。&lt;/p&gt;

&lt;h2 id=&#34;efibootmgr&#34;&gt;efibootmgr&lt;/h2&gt;

&lt;p&gt;Linux 下面可以使用 efibootmgr 管理 efi 菜单，当然得 kernel 支持，主要看 &lt;code&gt;/sys/firmware/efi&lt;/code&gt; 目录吧。具体内核参数可以看&lt;a href=&#34;https://wiki.archlinux.org/index.php/Unified_Extensible_Firmware_Interface#Linux_kernel_config_options_for_UEFI&#34; title=&#34;这个&#34;&gt;这个&lt;/a&gt;。我看着应该是只有通过 efi 启动的系统，才能读取 efi firmware 的信息。否则就算有内核模块也不能读取。&lt;/p&gt;

&lt;p&gt;我还发现我这的机器上面通过 efibootmgr 删除了 windows 的行之后，启动的时候按 F12 出来的启动选项里面还有 windwos，会自动加回来，不知道是主板的保护还是哪里的问题，bios 里面没找到可以关闭这个功能的地方。&lt;/p&gt;

&lt;h2 id=&#34;grub&#34;&gt;Grub&lt;/h2&gt;

&lt;p&gt;grub 支持安装到 MBR 也支持安装到 ESP 分区。不过只是把内容放到那个分区，最后给 efi 加启动的菜单，还需要 efibootmgr，就是需要相应的内核支持。&lt;/p&gt;

&lt;p&gt;类似这样，就是通过 uefi 启动了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# grub-install --target=x86_64-efi --efi-directory=/mnt/sda1 --bootloader-id=GRUB --boot-directory=/mnt/sda4/boot /dev/sda
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以装到 MBR，就是通过传统的 bios 启动。可能需要加 &lt;code&gt;--force&lt;/code&gt; ，我遇到的情况会提示 gpt 分区的 boot flag 没有，我这直接不理他加 force 就可以。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# grub-install --boot-directory=/mnt/sda4/boot /dev/sda
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;grub 实际上是放到第一个分区前面的一部分空间里面的，传统的 MBR 方式分区软件一般会预留 31kb 从第 63 个扇区开始分区。对于 GPT 分区，因为会有一个 ESP 分区，grub 也可以直接利用这个，装到这个分区，ESP 分区会有一个 bootable flag，因为这等于是单独给 grub 用的分区，所以 grub 也不客气会直接覆盖里面的东西，用自己的文件系统格式，一般系统都不支持，这样也可以防止你自己或者被其他软件误操作。所以要注意，如果你打算用 efi 模式启动，那通过第一个方式用 &lt;code&gt;--efi-directory&lt;/code&gt; 把 grub 装到这个分区，或者就还是用 mbr 方式好了。参考&lt;a href=&#34;https://www.gnu.org/software/grub/manual/grub/html_node/BIOS-installation.html#BIOS-installation&#34; title=&#34;这个&#34;&gt;这个&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;加载-windows&#34;&gt;加载 windows&lt;/h2&gt;

&lt;p&gt;我看可以通过 chainloader 加载 windows，也有 ntldr 加载，不太清楚具体区别。chainloader 是通过读取指定设备的块来的，比如 chainloader +1 读第一个块。或者 chainloader /EFI/Microsoft/Boot/bootmgfw.efi。&lt;/p&gt;

&lt;p&gt;UEFI 模式安装的 windows 可以参考&lt;a href=&#34;https://wiki.archlinux.org/index.php/GRUB#Windows_installed_in_UEFI.2FGPT_Mode_menu_entry&#34; title=&#34;这里&#34;&gt;这里&lt;/a&gt;，传统 MBR 方式的，参考&lt;a href=&#34;https://wiki.archlinux.org/index.php/GRUB#Windows_installed_in_BIOS.2FMBR_mode&#34; title=&#34;这里&#34;&gt;这里&lt;/a&gt;，这个用的是 ntldr 的方式，估计用 chainloader +1 应该也可以。&lt;/p&gt;

&lt;h2 id=&#34;怎么通过-uefi-启动-grub&#34;&gt;怎么通过 uefi 启动 grub&lt;/h2&gt;

&lt;p&gt;想要使用 efibootmgr 编辑 efi 的菜单，就得通过 efi 模式启动到一个 linux。那一种方式是找一个支持 efi 启动的 live cd。另外一种是使用一个 &lt;a href=&#34;https://wiki.archlinux.org/index.php/Unified_Extensible_Firmware_Interface#UEFI_Shell&#34; title=&#34;uefi shell&#34;&gt;uefi shell&lt;/a&gt;，可以参考&lt;a href=&#34;https://wdicc.com/uefi-bootable-usb/&#34; title=&#34;这里&#34;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;设备名称是变的怎么办&#34;&gt;设备名称是变的怎么办&lt;/h2&gt;

&lt;p&gt;我发现我这插了 u 盘之后，u 盘就成了 hd0 了，这样写在 grub.cfg 里面的 &lt;code&gt;set root=&amp;quot;(hd0,1)&amp;quot;&lt;/code&gt; 这样的代码就有问题了。grub2 提供了一个 &lt;a href=&#34;https://www.gnu.org/software/grub/manual/grub/grub.html#search&#34; title=&#34;search&#34;&gt;search&lt;/a&gt; 命令来查找你想要的东西，然后把结果设置到一个变量。&lt;/p&gt;

&lt;p&gt;文档里面写了 &lt;code&gt;search.file&lt;/code&gt; 是 &lt;code&gt;search --file&lt;/code&gt; 的 alias，但实际上还有坑在这里。区别的地方看下面&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;search.file /efi/Microsoft/Boot/bootmgfw.efi root
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;search --file /efi/Microsoft/Boot/bootmgfw.efi --set root
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看到区别了吧，那个 root 相当于是自己定义的变量（实际上 grub2 会隐含的用到 root 变量，所以也不能完全说是自己定义的）。我在这个坑上面花了一些时间。&lt;/p&gt;

&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.rodsbooks.com/efi-bootloaders/index.html&#34; title=&#34;Managing EFI Boot Loaders for Linux&#34;&gt;Managing EFI Boot Loaders for Linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.rodsbooks.com/efi-bootloaders/grub2.html&#34; title=&#34;Managing EFI Boot Loaders for Linux: Using GRUB 2&#34;&gt;Managing EFI Boot Loaders for Linux: Using GRUB 2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.gnu.org/software/grub/manual/grub/html_node/Installing-GRUB-using-grub_002dinstall.html&#34; title=&#34;4.1 Installing GRUB using grub-install&#34;&gt;4.1 Installing GRUB using grub-install&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Redux Selector</title>
      <link>https://wdicc.com/redux-selector/</link>
      <pubDate>Sun, 13 May 2018 10:43:28 +0800</pubDate>
      
      <guid>https://wdicc.com/redux-selector/</guid>
      <description>&lt;p&gt;redux 应用可以通过 selector 来做 state -&gt; props 的映射工作。selector 本身有缓存效果，所以可以一定意义上加速。我用的是这个 &lt;a href=&#34;https://github.com/reduxjs/reselect&#34; title=&#34;https://github.com/reduxjs/reselect&#34;&gt;https://github.com/reduxjs/reselect&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;selector 主要是一个纯函数，给同样的输入，得到同样的输出，只处理数据，没有其他附加影响。这样就可以缓存中间结果了。&lt;/p&gt;

&lt;p&gt;新建 selector 有两个方法，一个是直接定义函数，例如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const s1 = (state) =&amp;gt; {
    // 经过计算
    return state.user
}
const s2 = state =&amp;gt; state.data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外一个方法是通过 &lt;code&gt;createSelector&lt;/code&gt; 函数来创建，例如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const s3 = createSelector(s1, s2, (s1, s2) =&amp;gt;{
    // 经过计算
    return xx
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际上 selector 都是一些函数，具体用的是侯会执行这些函数，第一个方法创建的还好理解，第二个方法里面，会传什么参数呢？输入是什么呢？&lt;/p&gt;

&lt;p&gt;实际上，第二个方法定义的 selector 执行的时候类似这样。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const res = s3(s1(state), s2(state))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输入是里面 selector 的输入，然后不停嵌套到最初的数据。这样一个 selector 使用的方法就广泛了。比如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const s1_res = s1(state) // 从其他地方或者逻辑获取到这个值

const res = s3(s1_res, s2(state)) // 直接用来作为 s3 的输入
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>
