<!doctype html><html lang=en><head><title>Best Practice for React-Native and Redux &ndash; wd and cc</title>
<meta name=description content="Good good study, day day up!"><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=UTF-8><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.4/css/academicons.min.css integrity="sha512-IW0nhlW5MgNydsXJO40En2EoCkTTjZhI3yuODrZIc8cQ4h1XcF53PsqDHa09NqnkXuIe0Oiyyj171BqZFwISBw==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://wdicc.com/css/palettes/base16-dark.css><link rel=stylesheet href=https://wdicc.com/css/risotto.css><link rel=stylesheet href=https://wdicc.com/css/custom.css><link rel=icon href=https://wdicc.com/favicon.ico></head><body><div class=page><header class=page__header><nav class="page__nav main-nav"><ul><h1 class=page__logo><a href=https://wdicc.com/ class=page__logo-inner>wd and cc</a></h1><li class=main-nav__item><a class=nav-main-item href=https://wdicc.com/posts/ title>Posts</a></li><li class=main-nav__item><a class=nav-main-item href="https://www.google.com.hk/search?sitesearch=https%3A%2F%2Fwdicc.com%2F&amp;q=" title>Search</a></li><li class=main-nav__item><a class=nav-main-item href=https://wdicc.com/atom.xml title>subscribe</a></li></ul></nav></header><section class=page__body><header class=content__header><h1>Best Practice for React-Native and Redux</h1></header><div class=content__body><p>从 6 月到现在，在 RN 上面摸爬滚打了一段时间了，目前总算找到了一个适合我们自我感觉还可以的开发模式。</p><p>一开始，我们使用的是传统的 React 的模式，然后一个 app 页面一个文件，通过 StackNavigator 组合到一起。这么做在我们的第一个 app 里面没觉得有什么问题，每个页面维护自己的数据，页面之间需要数据共享或者通讯的时候（比如从 list 到详情页面的时候，详情里面有一个改变状态的按钮，状态改变之后希望 list 的状态也跟着变化，这样用户返回之后能看到正确的数据）有 2 个方式。</p><ul><li>通过 DeviceEventEmitter。
需要数据的页面订阅，然后在其他页面 emit event 之后前面的页面就可以收到。这个时候可以只通知改变的数据的字段，前一个页面直接去修改，这样可以避免重新刷新页面。也可以发一个简单的通知让其他页面去自己获取数据。</li><li>通过 navigator 提供的 params 属性。
StatckNavigator 提供了一个 params 属性。就是 <code class=verbatim>this.props.navigation.state.params</code> ，可以通过 setParams 来改变，或者通过类似 <code class=verbatim>this.props.navigation.navigate('Login', {goBackToHome: true})</code> 的方式给，那个 <code class=verbatim>goBackToHome</code> 将来就会在 params 里面。</li></ul><p>直到我们开始做第二个 app。</p><p>第二个 app 是一个单页面 app，登录之后就只有一个页面了，有一个大地图，有左侧 sidebar，sidebar 里面的按钮点击还会出其他页面。这个肯定不能按照我们前面的思路来做了，我们按照组件，拆分了不同的文件，然后组合起来。这个时候更加会需要页面之间的通讯，并且这个时候可选项只有第一个了 <code class=verbatim>DeviceEventEmitter</code> ，因为都没有 navigate 什么事情。</p><p>这个时候就发现一个问题，event 太多了，开始有点混乱了。emit event 之后，慢慢会发现不知道哪里有订阅，不好管理。这个 app 做完之后，就仔细研究了一下 redux。</p><p>其实写第一个 app 的时候就知道 redux，但是很多概念看的云里雾里的，当时在 react 还没有吃透的情况下，根本没有能力把 redux 搞好。所以当时放弃了 redux。</p><p>了解 redux 之后，感觉这个东西是我们的药。统一的 state 管理，这不就不用考虑状态传递了么？所以一门心思开始研究 redux。刚好我们第一个 app 需要全新改版，我们就借机把我们的第一个 app 也重构到了 redux 实现。整体过程还是蛮舒服的，自己也总结了几条我们自己的使用的思路。</p><div id=outline-container-headline-1 class=outline-4><h4 id=headline-1>目录结构安排</h4><div id=outline-text-headline-1 class=outline-text-4><p>先大概看看我们 app 的目录结构。我们把所有的 js 文件都放到了 app 目录下面。</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>app
</span></span><span style=display:flex><span>ios
</span></span><span style=display:flex><span>android
</span></span><span style=display:flex><span>index.js</span></span></code></pre></div></div><p>然后 app 目录下面，分了 <code class=verbatim>actions</code> ， <code class=verbatim>reducers</code> ， <code class=verbatim>sagas</code> ， <code class=verbatim>selector</code> 几个目录。</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>actions
</span></span><span style=display:flex><span>images
</span></span><span style=display:flex><span>index.js
</span></span><span style=display:flex><span>reducers
</span></span><span style=display:flex><span>sagas
</span></span><span style=display:flex><span>screens
</span></span><span style=display:flex><span>selectors
</span></span><span style=display:flex><span>utility</span></span></code></pre></div></div><ul><li>actions 里面放的是 mapDispatchToProps 这个逻辑对应的东西。</li><li>reducers 里面放的是 reducers。</li><li>sagas 里面放的是所有网络请求相关的 actions 的处理逻辑。</li><li>seelctor 里面放的是 mapStateToProps 这个逻辑对应的东西。</li></ul><p>每个目录里面也都有一个自己的 index.js 把本目录里面的内容组合起来。通过最外面的 index.js 把这几个目录的逻辑组合起来。</p></div></div><div id=outline-container-headline-2 class=outline-4><h4 id=headline-2>给页面设计一个基类</h4><div id=outline-text-headline-2 class=outline-text-4><p>这样会比较方便你去做一些所有页面都需要做的事情。</p></div></div><div id=outline-container-headline-3 class=outline-4><h4 id=headline-3>一个 app 一个统一的 store</h4><div id=outline-text-headline-3 class=outline-text-4><p>我们 app 还不大，所以这么设计也还好，如果页面比较复杂，我看也有组件使用自己的 store 的例子，这个还没有经验。这么做唯一一个问题就是，那个 store 里面的数据一直都在，多少会占用一些内存。不过我是觉得没啥了，其实这点内存占用不算啥。</p></div></div><div id=outline-container-headline-4 class=outline-4><h4 id=headline-4>store 设计和页面无关</h4><div id=outline-text-headline-4 class=outline-text-4><p>Store 参考了一个文章统一设计，和页面无关。比如我们设计了 user, orders, orderDetail 这些 state，数据所有页面共享。否则如果按照页面来划分的话，某些页面之间如果有用到共享数据就要么多复制一份，那有点浪费了，要么就是会有点乱。</p></div></div><div id=outline-container-headline-5 class=outline-4><h4 id=headline-5>每个页面都使用自己的 props</h4><div id=outline-text-headline-5 class=outline-text-4><p>不在页面间交叉使用 props ，这样不会乱。并且因为我们是一个统一的 store，所以其实每次 props 变化，所有页面都会 render。这个我使用下面的一个思路来解决了。</p></div></div><div id=outline-container-headline-6 class=outline-4><h4 id=headline-6>shouldComponentUpdate</h4><div id=outline-text-headline-6 class=outline-text-4><p>这个就是在页面的基类里面，通过比较判断本页面的 props 是否有变化来解决前面那个 render 问题。</p></div></div><div id=outline-container-headline-7 class=outline-4><h4 id=headline-7>使用 reselect</h4><div id=outline-text-headline-7 class=outline-text-4><p>因为只要 state 发生变化 redux 就会调用 mapStateToProps 来计算 props，这个计算有一些消耗，毕竟一般也就其中一个页面的 props 需要计算。我们用这个 reselect 解决这个问题，一个页面的 props 需要的 state 没变化的时候，reselect 就可以把 cache 的数据直接返回就好了。</p></div></div><div id=outline-container-headline-8 class=outline-4><h4 id=headline-8>适当使用页面的 state</h4><div id=outline-text-headline-8 class=outline-text-4><p>redux 的理念是所有页面的 state 都放到了 store 里面，你不需要做 setState 动作了。但是实际上有些时候适当使用 state 会让你的开发更加方便。比如表单验证，用户输入数据之后点击提交 ，如果通过发送 action 改变 state 然后再通过 selector 返回页面，那就有点太费劲了。而直接通过 setState 设定页面 state，然后在提交表单的时候读出来做验证就简单多了。</p><p>有时候页面的一些 state 是和 props 有关系的，这个时候可以使用 <code class=verbatim>componentWillReceiveProps(nextProps)</code> 来判定，然后和 state 同步。</p></div></div><div id=outline-container-headline-9 class=outline-4><h4 id=headline-9>Android 的返回按钮处理</h4><div id=outline-text-headline-9 class=outline-text-4><p>android 有一个实体的返回按钮，StackNavigator 给出的<a href=https://reactnavigation.org/docs/guides/redux#Handling-the-Hardware-Back-Button-in-Android>方案</a>是监听一个 <code class=verbatim>hardwareBackPress</code> 事件，然后 <code class=verbatim>dispatch(NavigationActions.back())</code> ，但是有一个问题是，有时候我们返回的时候还需要做一些自己的动作。比如清理 store 的数据，或者判断一下往哪里返什么的，比如用户刚提交了订单之后，给了一个按钮可以看订单详情，这个时候从详情返回就希望直接到首页，不要又返回新建订单的页面。</p><p>我们通过下面的思路做的</p><div class="src src-javascript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span>    <span style=color:#a6e22e>onBackPress</span> <span style=color:#f92672>=</span> () =&gt; {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> { <span style=color:#a6e22e>dispatch</span>, <span style=color:#a6e22e>nav</span> } <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>props</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>nav</span>.<span style=color:#a6e22e>index</span> <span style=color:#f92672>===</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> {<span style=color:#a6e22e>routes</span>} <span style=color:#f92672>=</span> <span style=color:#a6e22e>nav</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> {<span style=color:#a6e22e>params</span>} <span style=color:#f92672>=</span> <span style=color:#a6e22e>routes</span>[<span style=color:#a6e22e>routes</span>.<span style=color:#a6e22e>length</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(<span style=color:#a6e22e>params</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>params</span>.<span style=color:#a6e22e>goBack</span>) {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>params</span>.<span style=color:#a6e22e>goBack</span>();
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>dispatch</span>(<span style=color:#a6e22e>NavigationActions</span>.<span style=color:#a6e22e>back</span>());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    };</span></span></code></pre></div></div><p>然后在页面的基类里面</p><div class="src src-javascript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span>    <span style=color:#a6e22e>constructor</span>(<span style=color:#a6e22e>props</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span>(<span style=color:#a6e22e>props</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>goBack</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>props</span>.<span style=color:#a6e22e>navigation</span>.<span style=color:#a6e22e>setParams</span>({ <span style=color:#a6e22e>goBack</span><span style=color:#f92672>:</span> ()=&gt;<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>goBack</span>() })
</span></span><span style=display:flex><span>    }</span></span></code></pre></div></div><p>然后页面里面如果有自己的特殊逻辑，那就实现一个 <code class=verbatim>goBack</code> 方法就好了。</p></div></div><div id=outline-container-headline-10 class=outline-4><h4 id=headline-10>表单的弹出页面，不一定需要使用 store</h4><div id=outline-text-headline-10 class=outline-text-4><p>比如一个下单页面，需要填联系人信息，这个时候我们一般会到一个联系人的页面来选择联系人。这个时候在这个页面选择的联系人，如何传递给上一个页面呢？有两个类型的方法。</p><p>第一个方法自然就是 redux 的方法，在选择页面点确定的时候，触发 action 通过 reducer 设置这个页面的 store，然后通过 selector 修改上一个页面的 props，这样就达到了传递的目的。</p><p>第二个方法是在新页面打开的时候，通过 navigater 传一个 callback 过去，那边选择好的时候，调用这个回调方法把数据传回来。</p><p>第一个方法贴合 redux 的做法，但是存在一个问题，如果这个新的选择页面在多个地方出现，那么就需要有一个区分，当前这个选择是给哪个地方服务的(因为必须得在 redux 的 store 里面做好区分，否则两个页面总是相同的状态)。另外还有一个数据清理的问题，否则下次在别的页面打开这个页面，会有上次的数据残留。</p><p>第二个方法土一点，但是没有上面的问题。不过要注意的是，如果新的页面有网络请求，那这个时候还需要和 saga thunk 这些关联，那么就总是会走到 redux 的 store，所以这个方法就不适用了。</p></div></div><div id=outline-container-headline-11 class=outline-4><h4 id=headline-11>参考文章</h4><div id=outline-text-headline-11 class=outline-text-4><ul><li><a href=https://wdicc.com/11-mistakes-during-use-react-native/>11-mistakes-during-use-react-native</a></li></ul></div></div></div><footer class=content__footer></footer></section><section class=page__aside><div class=aside__about><div class=aside__about><img class=about__logo src=https://wdicc.com/favicon.ico alt=Logo><h1 class=about__title>Happy every day!</h1><p class=about__description>Good good study, day day up!</p></div><ul class=aside__social-links><li><a href=https://github.com/wd rel=me aria-label=GitHub title=GitHub><i class="fa-brands fa-github" aria-hidden=true></i></a>&nbsp;</li></ul></div><hr><div class=aside__content><p>2017-11-26</p><hr>On this page:<nav id=TableOfContents><ul><li><a href=#headline-1>目录结构安排</a></li><li><a href=#headline-2>给页面设计一个基类</a></li><li><a href=#headline-3>一个 app 一个统一的 store</a></li><li><a href=#headline-4>store 设计和页面无关</a></li><li><a href=#headline-5>每个页面都使用自己的 props</a></li><li><a href=#headline-6>shouldComponentUpdate</a></li><li><a href=#headline-7>使用 reselect</a></li><li><a href=#headline-8>适当使用页面的 state</a></li><li><a href=#headline-9>Android 的返回按钮处理</a></li><li><a href=#headline-10>表单的弹出页面，不一定需要使用 store</a></li><li><a href=#headline-11>参考文章</a></li></ul></nav></div></section><footer class=page__footer><p><br><span class=active>$ echo $LANG<br><b>zh_CN</b></span><br></p><br><br><p class=copyright>wd © 2025</p><p class=advertisement>Powered by <a href=https://gohugo.io/>hugo</a> and <a href=https://github.com/joeroe/risotto>risotto</a>.</p></footer></div></body></html>