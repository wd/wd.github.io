<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, viewport-fit=cover, initial-scale=1">
    <title>PING命令中TTL的具体含义zz | wd and cc</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    <header>

  
  
  <nav>
    <ul>
      
      
      <li class="pull-left ">
        <a href="https://wdicc.com/">/home/wd and cc</a>
      </li>
      
      
      <li class="pull-left ">
        <a href="/tags/">~/tags</a>
      </li>
      
      
      <li class="pull-left ">
        <a href="/resume/">~/resume</a>
      </li>
      
      
      <li class="pull-left ">
        <a href="https://www.google.com.hk/search?sitesearch=https%3A%2F%2Fwdicc.com%2F&amp;q=">~/search</a>
      </li>
      

      
      
      <li class="pull-right">
        <a href="/atom.xml">~/subscribe</a>
      </li>
      

    </ul>
  </nav>
</header>

  </head>

  <body>
    <br/>

<div class="article-meta">
<h1><span class="title">PING命令中TTL的具体含义zz</span></h1>

<h2 class="date">2006/08/30</h2>
<p class="terms">
  
  
  
  
  Tags: <a href="/tags/linux">linux</a> <a href="/tags/other">other</a> <a href="/tags/ping">ping</a> 
  
  
</p>
</div>












<main>
<br />
以我公司2台机器为例<br />
看如下命令<br />
D:Documents and Settingshx&gt;ping 61.152.93.131<br />

Pinging 61.152.93.131 with 32 bytes of data:<br />

Reply from 61.152.93.131: bytes=32 time=21ms TTL=118<br />
Reply from 61.152.93.131: bytes=32 time=19ms TTL=118<br />
Reply from 61.152.93.131: bytes=32 time=18ms TTL=118<br />
Reply from 61.152.93.131: bytes=32 time=22ms TTL=118<br />

Ping statistics for 61.152.93.131:<br />
Packets: Sent = 4， Received = 4， Lost = 0 (0% loss<br />
Approximate round trip times in milli-seconds:<br />
Minimum = 18ms， Maximum = 22ms， Average = 20ms<br />

D:Documents and Settingshx&gt;ping 61.152.104.40<br />

Pinging 61.152.104.40 with 32 bytes of data:<br />

Reply from 61.152.104.40: bytes=32 time=28ms TTL=54<br />
Reply from 61.152.104.40: bytes=32 time=18ms TTL=54<br />
Reply from 61.152.104.40: bytes=32 time=18ms TTL=54<br />
Reply from 61.152.104.40: bytes=32 time=13ms TTL=54<br />

Ping statistics for 61.152.104.40:<br />
Packets: Sent = 4， Received = 4， Lost = 0 (0% loss<br />
Approximate round trip times in milli-seconds:<br />
Minimum = 13ms， Maximum = 28ms， Average = 19ms<br />
第一台TTL为118，则基本可以判断这是一台Windows机器，从我的机器到这台机器经过了10个节点，因为128-118=10。而第二台应该是台Linux，理由一样64-54=10。<br />
了解了上面的东西，可能有人会有一些疑问，例如以下：<br />

1，不是说包可能走很多路径吗，为什么我看到的4个包TTL都是一样的，没有出现不同？<br />

这是由于包经过的路径是经过了一些最优选择算法来定下来的，在网络拓扑稳定一段时间后，包的路由路径也会相对稳定在一个最短路径上。具体怎么算出来的要去研究路由算法了，不在讨论之列。<br />

2，对于上面例子第二台机器，为什么不认为它是经过了74个节点的Windows机器？因为128-74=54。<br />

对于这个问题，我们要引入另外一个很好的ICMP协议工具。不过首先要声明的是，一个包经过74个节点这个有些恐怖，这样的路径还是不用为好。<br />

要介绍的这个工具是tracert（*nix下为traceroute），让我们来看对上面的第二台机器用这个命令的结果<br />
D:Documents and Settingshx&gt;tracert 61.152.104.40<br />

Tracing route to 61.152.104.40 over a maximum of 30 hops<br />

1 13 ms 16 ms 9 ms 10.120.32.1<br />
2 9 ms 9 ms 11 ms 219.233.244.105<br />
3 12 ms 10 ms 10 ms 219.233.238.173<br />
4 15 ms 15 ms 17 ms 219.233.238.13<br />
5 14 ms 19 ms 19 ms 202.96.222.73<br />
6 14 ms 17 ms 13 ms 202.96.222.121<br />
7 14 ms 15 ms 14 ms 61.152.81.86<br />
8 15 ms 14 ms 13 ms 61.152.87.162<br />
9 16 ms 16 ms 28 ms 61.152.99.26<br />
10 12 ms 13 ms 18 ms 61.152.99.94<br />
11 14 ms 18 ms 16 ms 61.152.104.40<br />

Trace complete.<br />

从这个命令的结果能够看到从我的机器到服务器所走的路由，确实是11个节点（上面说10个好像是我犯了忘了算0的错误了，应该是64-54+1，嘿嘿），而不是128的TTL经过了70多个节点。<br />
既然已经说到这里了，不妨顺便说说关于这两个ICMP命令的高级一点的东西。<br />
首先是ping命令，其实ping有这样一个参数，可以无视操作系统默认TTL值而使用自己定义的值来发送ICMP Request包。<br />
例如还是用那台Linux机器，用以下命令：<br />
D:Documents and Settingshx&gt;ping 61.152.104.40 -i 11<br />

Pinging 61.152.104.40 with 32 bytes of data:<br />

Reply from 61.152.104.40: bytes=32 time=10ms TTL=54<br />
Reply from 61.152.104.40: bytes=32 time=13ms TTL=54<br />
Reply from 61.152.104.40: bytes=32 time=10ms TTL=54<br />
Reply from 61.152.104.40: bytes=32 time=13ms TTL=54<br />

Ping statistics for 61.152.104.40:<br />
Packets: Sent = 4， Received = 4， Lost = 0 (0% loss)，<br />
Approximate round trip times in milli-seconds:<br />
Minimum = 10ms， Maximum = 13ms， Average = 11ms<br />

D:Documents and Settingshx&gt;<br />
这个命令我们定义了发包的TTL为11，而前面我们知道，我到这台服务器是要经过11个节点的，所以这个输出和以前没什么不同。现在再用这个试试看：<br />
D:Documents and Settingshx&gt;ping 61.152.104.40 -i 10<br />

Pinging 61.152.104.40 with 32 bytes of data:<br />

Reply from 61.152.99.94: TTL expired in transit.<br />
Reply from 61.152.99.94: TTL expired in transit.<br />
Reply from 61.152.99.94: TTL expired in transit.<br />
Reply from 61.152.99.94: TTL expired in transit.<br />

Ping statistics for 61.152.104.40:<br />
Packets: Sent = 4， Received = 4， Lost = 0 (0% loss)，<br />
Approximate round trip times in milli-seconds:<br />
Minimum = 0ms， Maximum = 0ms， Average = 0ms<br />

D:Documents and Settingshx&gt;<br />

可 以看到，结果不一样了，我定义了TTL为10来发包，结果是TTL expired in transit.就是说在到达服务器之前这个包的生命周期就结束了。注意看这句话前面的ip，这个ip恰好是我们前面tracert结果到服务器之前的最 后1个ip，包的TTL就是在这里减少到0了，根据我们前面的讨论，当TTL减为0时设备会丢弃包并发送一个TTL过期的ICMP反馈给源地址，这里的结 果就是最好的证明。<br />
通过这里再次又证明了从我机器到服务器是经过了11个节点而不是70多个，呵呵。<br />
最后再巩固一下知识，有人可能觉得tracer这个命令很神奇，可以发现一个包所经过的路由路径。其实这个命令的原理就在我们上面的讨论中。<br />

想象一下，如果我给目的服务器发送一个TTL为1的包，结果会怎样？<br />
根据前面的讨论，在包港出发的第一个节点，TTL就会减少为0，这时这个节点就会回应TTL失效的反馈，这个回应包含了设备本身的ip地址，这样我们就得到了路由路径的第一个节点的地址。<br />
因此，我们继续发送TTL=2的包，也就受到第二个节点的TTL失效回应<br />

依次类推，我们一个一个的发现，当最终返回的结果不是TTL失效而是ICMP Response的时候，我们的tracert也就结束了，就是这么简单。<br />

顺便补一句ping命令还有个-n的参数指定要发包的数量，指定了这个数字就会按照你的要求来发包了而不是默认的4个包。如果使用-t参数的话，命令会一直发包直到你强行中止它。<br />
</span></div><br />
<!-- 分割 --><br />

</main>


<section id="comment">
    <h2 class="title">Comments</h2>
    <div id="disqus_thread" aria-live="polite">
        <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>
</section>


    
     <script type="text/javascript">
        var disqus_config = function () {
            this.page.url = '';
            this.page.identifier = '';
        };

        (function() {
          var d = document, s = d.createElement('script');
          s.src = '//wdicc.disqus.com/embed.js';
          s.setAttribute('data-timestamp', +new Date());
          (d.head || d.body).appendChild(s);
        })();
     </script>
    





    <footer style="clear:both">
      
      <hr/>
      Theme from <a href="https://github.com/wd/hugo-classic">hugo-classic</a> fork from <a href="https://github.com/goodroot/hugo-classic">Github</a>
      
    </footer>
  </body>
</html>

